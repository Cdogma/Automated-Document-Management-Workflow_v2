# MaehrDocs Code Übersicht

# Generiert am 2025-05-05 20:39:47 durch Start_extract_code.py

# Fortsetzung Teil 3 - Datei 1341 bis 1417 von 1417



# ================================================================================
# Datei: venv\Lib\site-packages\pymupdf\mupdf.py
# ================================================================================

# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _mupdf
else:
    import _mupdf

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


def cdata(ptr, nelements=1):
    return _mupdf.cdata(ptr, nelements)

def memmove(data, indata):
    return _mupdf.memmove(data, indata)
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _mupdf.delete_SwigPyIterator

    def value(self):
        return _mupdf.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _mupdf.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _mupdf.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _mupdf.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _mupdf.SwigPyIterator_equal(self, x)

    def copy(self):
        return _mupdf.SwigPyIterator_copy(self)

    def next(self):
        return _mupdf.SwigPyIterator_next(self)

    def __next__(self):
        return _mupdf.SwigPyIterator___next__(self)

    def previous(self):
        return _mupdf.SwigPyIterator_previous(self)

    def advance(self, n):
        return _mupdf.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _mupdf.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _mupdf.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _mupdf.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _mupdf.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _mupdf.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _mupdf.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _mupdf:
_mupdf.SwigPyIterator_swigregister(SwigPyIterator)
class uchar_array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _mupdf.uchar_array_swiginit(self, _mupdf.new_uchar_array(nelements))
    __swig_destroy__ = _mupdf.delete_uchar_array

    def __getitem__(self, index):
        return _mupdf.uchar_array___getitem__(self, index)

    def __setitem__(self, index, value):
        return _mupdf.uchar_array___setitem__(self, index, value)

    def cast(self):
        return _mupdf.uchar_array_cast(self)

    @staticmethod
    def frompointer(t):
        return _mupdf.uchar_array_frompointer(t)

# Register uchar_array in _mupdf:
_mupdf.uchar_array_swigregister(uchar_array)
class vectoruc(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectoruc_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectoruc___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectoruc___bool__(self)

    def __len__(self):
        return _mupdf.vectoruc___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectoruc___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectoruc___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectoruc___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectoruc___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectoruc___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectoruc___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectoruc_pop(self)

    def append(self, x):
        return _mupdf.vectoruc_append(self, x)

    def empty(self):
        return _mupdf.vectoruc_empty(self)

    def size(self):
        return _mupdf.vectoruc_size(self)

    def swap(self, v):
        return _mupdf.vectoruc_swap(self, v)

    def begin(self):
        return _mupdf.vectoruc_begin(self)

    def end(self):
        return _mupdf.vectoruc_end(self)

    def rbegin(self):
        return _mupdf.vectoruc_rbegin(self)

    def rend(self):
        return _mupdf.vectoruc_rend(self)

    def clear(self):
        return _mupdf.vectoruc_clear(self)

    def get_allocator(self):
        return _mupdf.vectoruc_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectoruc_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectoruc_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectoruc_swiginit(self, _mupdf.new_vectoruc(*args))

    def push_back(self, x):
        return _mupdf.vectoruc_push_back(self, x)

    def front(self):
        return _mupdf.vectoruc_front(self)

    def back(self):
        return _mupdf.vectoruc_back(self)

    def assign(self, n, x):
        return _mupdf.vectoruc_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectoruc_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectoruc_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectoruc_reserve(self, n)

    def capacity(self):
        return _mupdf.vectoruc_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectoruc

# Register vectoruc in _mupdf:
_mupdf.vectoruc_swigregister(vectoruc)
class vectori(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectori_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectori___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectori___bool__(self)

    def __len__(self):
        return _mupdf.vectori___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectori___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectori___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectori___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectori___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectori___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectori___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectori_pop(self)

    def append(self, x):
        return _mupdf.vectori_append(self, x)

    def empty(self):
        return _mupdf.vectori_empty(self)

    def size(self):
        return _mupdf.vectori_size(self)

    def swap(self, v):
        return _mupdf.vectori_swap(self, v)

    def begin(self):
        return _mupdf.vectori_begin(self)

    def end(self):
        return _mupdf.vectori_end(self)

    def rbegin(self):
        return _mupdf.vectori_rbegin(self)

    def rend(self):
        return _mupdf.vectori_rend(self)

    def clear(self):
        return _mupdf.vectori_clear(self)

    def get_allocator(self):
        return _mupdf.vectori_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectori_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectori_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectori_swiginit(self, _mupdf.new_vectori(*args))

    def push_back(self, x):
        return _mupdf.vectori_push_back(self, x)

    def front(self):
        return _mupdf.vectori_front(self)

    def back(self):
        return _mupdf.vectori_back(self)

    def assign(self, n, x):
        return _mupdf.vectori_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectori_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectori_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectori_reserve(self, n)

    def capacity(self):
        return _mupdf.vectori_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectori

# Register vectori in _mupdf:
_mupdf.vectori_swigregister(vectori)
class vectorf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectorf___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectorf___bool__(self)

    def __len__(self):
        return _mupdf.vectorf___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectorf___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectorf___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectorf___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectorf___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectorf___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectorf___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectorf_pop(self)

    def append(self, x):
        return _mupdf.vectorf_append(self, x)

    def empty(self):
        return _mupdf.vectorf_empty(self)

    def size(self):
        return _mupdf.vectorf_size(self)

    def swap(self, v):
        return _mupdf.vectorf_swap(self, v)

    def begin(self):
        return _mupdf.vectorf_begin(self)

    def end(self):
        return _mupdf.vectorf_end(self)

    def rbegin(self):
        return _mupdf.vectorf_rbegin(self)

    def rend(self):
        return _mupdf.vectorf_rend(self)

    def clear(self):
        return _mupdf.vectorf_clear(self)

    def get_allocator(self):
        return _mupdf.vectorf_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectorf_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectorf_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectorf_swiginit(self, _mupdf.new_vectorf(*args))

    def push_back(self, x):
        return _mupdf.vectorf_push_back(self, x)

    def front(self):
        return _mupdf.vectorf_front(self)

    def back(self):
        return _mupdf.vectorf_back(self)

    def assign(self, n, x):
        return _mupdf.vectorf_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectorf_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectorf_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectorf_reserve(self, n)

    def capacity(self):
        return _mupdf.vectorf_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectorf

# Register vectorf in _mupdf:
_mupdf.vectorf_swigregister(vectorf)
class vectord(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectord___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectord___bool__(self)

    def __len__(self):
        return _mupdf.vectord___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectord___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectord___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectord___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectord___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectord___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectord___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectord_pop(self)

    def append(self, x):
        return _mupdf.vectord_append(self, x)

    def empty(self):
        return _mupdf.vectord_empty(self)

    def size(self):
        return _mupdf.vectord_size(self)

    def swap(self, v):
        return _mupdf.vectord_swap(self, v)

    def begin(self):
        return _mupdf.vectord_begin(self)

    def end(self):
        return _mupdf.vectord_end(self)

    def rbegin(self):
        return _mupdf.vectord_rbegin(self)

    def rend(self):
        return _mupdf.vectord_rend(self)

    def clear(self):
        return _mupdf.vectord_clear(self)

    def get_allocator(self):
        return _mupdf.vectord_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectord_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectord_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectord_swiginit(self, _mupdf.new_vectord(*args))

    def push_back(self, x):
        return _mupdf.vectord_push_back(self, x)

    def front(self):
        return _mupdf.vectord_front(self)

    def back(self):
        return _mupdf.vectord_back(self)

    def assign(self, n, x):
        return _mupdf.vectord_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectord_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectord_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectord_reserve(self, n)

    def capacity(self):
        return _mupdf.vectord_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectord

# Register vectord in _mupdf:
_mupdf.vectord_swigregister(vectord)
class vectors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectors___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectors___bool__(self)

    def __len__(self):
        return _mupdf.vectors___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectors___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectors___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectors___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectors___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectors___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectors___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectors_pop(self)

    def append(self, x):
        return _mupdf.vectors_append(self, x)

    def empty(self):
        return _mupdf.vectors_empty(self)

    def size(self):
        return _mupdf.vectors_size(self)

    def swap(self, v):
        return _mupdf.vectors_swap(self, v)

    def begin(self):
        return _mupdf.vectors_begin(self)

    def end(self):
        return _mupdf.vectors_end(self)

    def rbegin(self):
        return _mupdf.vectors_rbegin(self)

    def rend(self):
        return _mupdf.vectors_rend(self)

    def clear(self):
        return _mupdf.vectors_clear(self)

    def get_allocator(self):
        return _mupdf.vectors_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectors_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectors_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectors_swiginit(self, _mupdf.new_vectors(*args))

    def push_back(self, x):
        return _mupdf.vectors_push_back(self, x)

    def front(self):
        return _mupdf.vectors_front(self)

    def back(self):
        return _mupdf.vectors_back(self)

    def assign(self, n, x):
        return _mupdf.vectors_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectors_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectors_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectors_reserve(self, n)

    def capacity(self):
        return _mupdf.vectors_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectors

# Register vectors in _mupdf:
_mupdf.vectors_swigregister(vectors)
class map_string_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.map_string_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.map_string_int___nonzero__(self)

    def __bool__(self):
        return _mupdf.map_string_int___bool__(self)

    def __len__(self):
        return _mupdf.map_string_int___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _mupdf.map_string_int___getitem__(self, key)

    def __delitem__(self, key):
        return _mupdf.map_string_int___delitem__(self, key)

    def has_key(self, key):
        return _mupdf.map_string_int_has_key(self, key)

    def keys(self):
        return _mupdf.map_string_int_keys(self)

    def values(self):
        return _mupdf.map_string_int_values(self)

    def items(self):
        return _mupdf.map_string_int_items(self)

    def __contains__(self, key):
        return _mupdf.map_string_int___contains__(self, key)

    def key_iterator(self):
        return _mupdf.map_string_int_key_iterator(self)

    def value_iterator(self):
        return _mupdf.map_string_int_value_iterator(self)

    def __setitem__(self, *args):
        return _mupdf.map_string_int___setitem__(self, *args)

    def asdict(self):
        return _mupdf.map_string_int_asdict(self)

    def __init__(self, *args):
        _mupdf.map_string_int_swiginit(self, _mupdf.new_map_string_int(*args))

    def empty(self):
        return _mupdf.map_string_int_empty(self)

    def size(self):
        return _mupdf.map_string_int_size(self)

    def swap(self, v):
        return _mupdf.map_string_int_swap(self, v)

    def begin(self):
        return _mupdf.map_string_int_begin(self)

    def end(self):
        return _mupdf.map_string_int_end(self)

    def rbegin(self):
        return _mupdf.map_string_int_rbegin(self)

    def rend(self):
        return _mupdf.map_string_int_rend(self)

    def clear(self):
        return _mupdf.map_string_int_clear(self)

    def get_allocator(self):
        return _mupdf.map_string_int_get_allocator(self)

    def count(self, x):
        return _mupdf.map_string_int_count(self, x)

    def erase(self, *args):
        return _mupdf.map_string_int_erase(self, *args)

    def find(self, x):
        return _mupdf.map_string_int_find(self, x)

    def lower_bound(self, x):
        return _mupdf.map_string_int_lower_bound(self, x)

    def upper_bound(self, x):
        return _mupdf.map_string_int_upper_bound(self, x)
    __swig_destroy__ = _mupdf.delete_map_string_int

# Register map_string_int in _mupdf:
_mupdf.map_string_int_swigregister(map_string_int)
class vectorq(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectorq_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectorq___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectorq___bool__(self)

    def __len__(self):
        return _mupdf.vectorq___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectorq___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectorq___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectorq___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectorq___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectorq___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectorq___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectorq_pop(self)

    def append(self, x):
        return _mupdf.vectorq_append(self, x)

    def empty(self):
        return _mupdf.vectorq_empty(self)

    def size(self):
        return _mupdf.vectorq_size(self)

    def swap(self, v):
        return _mupdf.vectorq_swap(self, v)

    def begin(self):
        return _mupdf.vectorq_begin(self)

    def end(self):
        return _mupdf.vectorq_end(self)

    def rbegin(self):
        return _mupdf.vectorq_rbegin(self)

    def rend(self):
        return _mupdf.vectorq_rend(self)

    def clear(self):
        return _mupdf.vectorq_clear(self)

    def get_allocator(self):
        return _mupdf.vectorq_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectorq_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectorq_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectorq_swiginit(self, _mupdf.new_vectorq(*args))

    def push_back(self, x):
        return _mupdf.vectorq_push_back(self, x)

    def front(self):
        return _mupdf.vectorq_front(self)

    def back(self):
        return _mupdf.vectorq_back(self)

    def assign(self, n, x):
        return _mupdf.vectorq_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectorq_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectorq_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectorq_reserve(self, n)

    def capacity(self):
        return _mupdf.vectorq_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectorq

# Register vectorq in _mupdf:
_mupdf.vectorq_swigregister(vectorq)
class vector_search_page2_hit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vector_search_page2_hit_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vector_search_page2_hit___nonzero__(self)

    def __bool__(self):
        return _mupdf.vector_search_page2_hit___bool__(self)

    def __len__(self):
        return _mupdf.vector_search_page2_hit___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vector_search_page2_hit___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vector_search_page2_hit___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vector_search_page2_hit___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vector_search_page2_hit___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vector_search_page2_hit___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vector_search_page2_hit___setitem__(self, *args)

    def pop(self):
        return _mupdf.vector_search_page2_hit_pop(self)

    def append(self, x):
        return _mupdf.vector_search_page2_hit_append(self, x)

    def empty(self):
        return _mupdf.vector_search_page2_hit_empty(self)

    def size(self):
        return _mupdf.vector_search_page2_hit_size(self)

    def swap(self, v):
        return _mupdf.vector_search_page2_hit_swap(self, v)

    def begin(self):
        return _mupdf.vector_search_page2_hit_begin(self)

    def end(self):
        return _mupdf.vector_search_page2_hit_end(self)

    def rbegin(self):
        return _mupdf.vector_search_page2_hit_rbegin(self)

    def rend(self):
        return _mupdf.vector_search_page2_hit_rend(self)

    def clear(self):
        return _mupdf.vector_search_page2_hit_clear(self)

    def get_allocator(self):
        return _mupdf.vector_search_page2_hit_get_allocator(self)

    def pop_back(self):
        return _mupdf.vector_search_page2_hit_pop_back(self)

    def erase(self, *args):
        return _mupdf.vector_search_page2_hit_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vector_search_page2_hit_swiginit(self, _mupdf.new_vector_search_page2_hit(*args))

    def push_back(self, x):
        return _mupdf.vector_search_page2_hit_push_back(self, x)

    def front(self):
        return _mupdf.vector_search_page2_hit_front(self)

    def back(self):
        return _mupdf.vector_search_page2_hit_back(self)

    def assign(self, n, x):
        return _mupdf.vector_search_page2_hit_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vector_search_page2_hit_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vector_search_page2_hit_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vector_search_page2_hit_reserve(self, n)

    def capacity(self):
        return _mupdf.vector_search_page2_hit_capacity(self)
    __swig_destroy__ = _mupdf.delete_vector_search_page2_hit

# Register vector_search_page2_hit in _mupdf:
_mupdf.vector_search_page2_hit_swigregister(vector_search_page2_hit)
class vector_fz_font_ucs_gid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vector_fz_font_ucs_gid_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vector_fz_font_ucs_gid___nonzero__(self)

    def __bool__(self):
        return _mupdf.vector_fz_font_ucs_gid___bool__(self)

    def __len__(self):
        return _mupdf.vector_fz_font_ucs_gid___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vector_fz_font_ucs_gid___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vector_fz_font_ucs_gid___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vector_fz_font_ucs_gid___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vector_fz_font_ucs_gid___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vector_fz_font_ucs_gid___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vector_fz_font_ucs_gid___setitem__(self, *args)

    def pop(self):
        return _mupdf.vector_fz_font_ucs_gid_pop(self)

    def append(self, x):
        return _mupdf.vector_fz_font_ucs_gid_append(self, x)

    def empty(self):
        return _mupdf.vector_fz_font_ucs_gid_empty(self)

    def size(self):
        return _mupdf.vector_fz_font_ucs_gid_size(self)

    def swap(self, v):
        return _mupdf.vector_fz_font_ucs_gid_swap(self, v)

    def begin(self):
        return _mupdf.vector_fz_font_ucs_gid_begin(self)

    def end(self):
        return _mupdf.vector_fz_font_ucs_gid_end(self)

    def rbegin(self):
        return _mupdf.vector_fz_font_ucs_gid_rbegin(self)

    def rend(self):
        return _mupdf.vector_fz_font_ucs_gid_rend(self)

    def clear(self):
        return _mupdf.vector_fz_font_ucs_gid_clear(self)

    def get_allocator(self):
        return _mupdf.vector_fz_font_ucs_gid_get_allocator(self)

    def pop_back(self):
        return _mupdf.vector_fz_font_ucs_gid_pop_back(self)

    def erase(self, *args):
        return _mupdf.vector_fz_font_ucs_gid_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vector_fz_font_ucs_gid_swiginit(self, _mupdf.new_vector_fz_font_ucs_gid(*args))

    def push_back(self, x):
        return _mupdf.vector_fz_font_ucs_gid_push_back(self, x)

    def front(self):
        return _mupdf.vector_fz_font_ucs_gid_front(self)

    def back(self):
        return _mupdf.vector_fz_font_ucs_gid_back(self)

    def assign(self, n, x):
        return _mupdf.vector_fz_font_ucs_gid_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vector_fz_font_ucs_gid_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vector_fz_font_ucs_gid_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vector_fz_font_ucs_gid_reserve(self, n)

    def capacity(self):
        return _mupdf.vector_fz_font_ucs_gid_capacity(self)
    __swig_destroy__ = _mupdf.delete_vector_fz_font_ucs_gid

# Register vector_fz_font_ucs_gid in _mupdf:
_mupdf.vector_fz_font_ucs_gid_swigregister(vector_fz_font_ucs_gid)
class vector_fz_point(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vector_fz_point_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vector_fz_point___nonzero__(self)

    def __bool__(self):
        return _mupdf.vector_fz_point___bool__(self)

    def __len__(self):
        return _mupdf.vector_fz_point___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vector_fz_point___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vector_fz_point___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vector_fz_point___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vector_fz_point___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vector_fz_point___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vector_fz_point___setitem__(self, *args)

    def pop(self):
        return _mupdf.vector_fz_point_pop(self)

    def append(self, x):
        return _mupdf.vector_fz_point_append(self, x)

    def empty(self):
        return _mupdf.vector_fz_point_empty(self)

    def size(self):
        return _mupdf.vector_fz_point_size(self)

    def swap(self, v):
        return _mupdf.vector_fz_point_swap(self, v)

    def begin(self):
        return _mupdf.vector_fz_point_begin(self)

    def end(self):
        return _mupdf.vector_fz_point_end(self)

    def rbegin(self):
        return _mupdf.vector_fz_point_rbegin(self)

    def rend(self):
        return _mupdf.vector_fz_point_rend(self)

    def clear(self):
        return _mupdf.vector_fz_point_clear(self)

    def get_allocator(self):
        return _mupdf.vector_fz_point_get_allocator(self)

    def pop_back(self):
        return _mupdf.vector_fz_point_pop_back(self)

    def erase(self, *args):
        return _mupdf.vector_fz_point_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vector_fz_point_swiginit(self, _mupdf.new_vector_fz_point(*args))

    def push_back(self, x):
        return _mupdf.vector_fz_point_push_back(self, x)

    def front(self):
        return _mupdf.vector_fz_point_front(self)

    def back(self):
        return _mupdf.vector_fz_point_back(self)

    def assign(self, n, x):
        return _mupdf.vector_fz_point_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vector_fz_point_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vector_fz_point_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vector_fz_point_reserve(self, n)

    def capacity(self):
        return _mupdf.vector_fz_point_capacity(self)
    __swig_destroy__ = _mupdf.delete_vector_fz_point

# Register vector_fz_point in _mupdf:
_mupdf.vector_fz_point_swigregister(vector_fz_point)

def new_bytes(nelements):
    return _mupdf.new_bytes(nelements)

def delete_bytes(ary):
    return _mupdf.delete_bytes(ary)

def bytes_getitem(ary, index):
    return _mupdf.bytes_getitem(ary, index)

def bytes_setitem(ary, index, value):
    return _mupdf.bytes_setitem(ary, index, value)

def new_floats(nelements):
    return _mupdf.new_floats(nelements)

def delete_floats(ary):
    return _mupdf.delete_floats(ary)

def floats_getitem(ary, index):
    return _mupdf.floats_getitem(ary, index)

def floats_setitem(ary, index, value):
    return _mupdf.floats_setitem(ary, index, value)

def internal_set_error_classes(classes):
    return _mupdf.internal_set_error_classes(classes)
FZ_VERSION = _mupdf.FZ_VERSION
r"""This file was auto-generated by mupdfwrap.py."""
FZ_VERSION_MAJOR = _mupdf.FZ_VERSION_MAJOR
FZ_VERSION_MINOR = _mupdf.FZ_VERSION_MINOR
FZ_VERSION_PATCH = _mupdf.FZ_VERSION_PATCH
TOFU_CJK_EXT = _mupdf.TOFU_CJK_EXT
FZ_ENABLE_SPOT_RENDERING = _mupdf.FZ_ENABLE_SPOT_RENDERING
r"""
    Enable the following for spot (and hence overprint/overprint
    simulation) capable rendering. This forces FZ_PLOTTERS_N on.

    Choose which plotters we need.
    By default we build all the plotters in. To avoid building
    plotters in that aren't needed, define the unwanted
    FZ_PLOTTERS_... define to 0.

    Choose which document agents to include.
    By default all are enabled. To avoid building unwanted
    ones, define FZ_ENABLE_... to 0.

    Some of those document agents rely on the HTML
    engine. This will be enabled if required based upon
    those engines, but can be enabled independently of
    them so that other features (such as the fz_story
    mechanism or PDF Annotation rich content) can work.

    Choose which document writers to include.
    By default all are enabled. To avoid building unwanted
    ones, define FZ_ENABLE_..._OUTPUT to 0.

    Choose whether to enable ICC color profiles.

    Choose whether to enable JPEG2000 decoding.
    By default, it is enabled, but due to frequent security
    issues with the third party libraries we support disabling
    it with this flag.

    Choose whether to enable JavaScript.
    By default JavaScript is enabled both for mutool and PDF
    interactivity.

    Choose which fonts to include.
    By default we include the base 14 PDF fonts,
    DroidSansFallback from Android for CJK, and
    Charis SIL from SIL for epub/html.
    Enable the following defines to AVOID including
    unwanted fonts.
    """
FZ_PLOTTERS_N = _mupdf.FZ_PLOTTERS_N
FZ_PLOTTERS_G = _mupdf.FZ_PLOTTERS_G
FZ_PLOTTERS_RGB = _mupdf.FZ_PLOTTERS_RGB
FZ_PLOTTERS_CMYK = _mupdf.FZ_PLOTTERS_CMYK
FZ_ENABLE_PDF = _mupdf.FZ_ENABLE_PDF
FZ_ENABLE_XPS = _mupdf.FZ_ENABLE_XPS
FZ_ENABLE_SVG = _mupdf.FZ_ENABLE_SVG
FZ_ENABLE_CBZ = _mupdf.FZ_ENABLE_CBZ
FZ_ENABLE_IMG = _mupdf.FZ_ENABLE_IMG
FZ_ENABLE_HTML = _mupdf.FZ_ENABLE_HTML
FZ_ENABLE_EPUB = _mupdf.FZ_ENABLE_EPUB
FZ_ENABLE_FB2 = _mupdf.FZ_ENABLE_FB2
FZ_ENABLE_MOBI = _mupdf.FZ_ENABLE_MOBI
FZ_ENABLE_TXT = _mupdf.FZ_ENABLE_TXT
FZ_ENABLE_OFFICE = _mupdf.FZ_ENABLE_OFFICE
FZ_ENABLE_OCR_OUTPUT = _mupdf.FZ_ENABLE_OCR_OUTPUT
FZ_ENABLE_ODT_OUTPUT = _mupdf.FZ_ENABLE_ODT_OUTPUT
FZ_ENABLE_DOCX_OUTPUT = _mupdf.FZ_ENABLE_DOCX_OUTPUT
FZ_ENABLE_JPX = _mupdf.FZ_ENABLE_JPX
FZ_ENABLE_JS = _mupdf.FZ_ENABLE_JS
FZ_ENABLE_ICC = _mupdf.FZ_ENABLE_ICC
FZ_ENABLE_HTML_ENGINE = _mupdf.FZ_ENABLE_HTML_ENGINE
MEMENTO_PREFILL = _mupdf.MEMENTO_PREFILL
MEMENTO_POSTFILL = _mupdf.MEMENTO_POSTFILL
MEMENTO_ALLOCFILL = _mupdf.MEMENTO_ALLOCFILL
MEMENTO_FREEFILL = _mupdf.MEMENTO_FREEFILL

def Memento_checkBlock(arg1):
    return _mupdf.Memento_checkBlock(arg1)

def Memento_checkAllMemory():
    return _mupdf.Memento_checkAllMemory()

def Memento_check():
    return _mupdf.Memento_check()

def Memento_setParanoia(arg1):
    return _mupdf.Memento_setParanoia(arg1)

def Memento_paranoidAt(arg1):
    return _mupdf.Memento_paranoidAt(arg1)

def Memento_breakAt(arg1):
    return _mupdf.Memento_breakAt(arg1)

def Memento_breakOnFree(a):
    return _mupdf.Memento_breakOnFree(a)

def Memento_breakOnRealloc(a):
    return _mupdf.Memento_breakOnRealloc(a)

def Memento_getBlockNum(arg1):
    return _mupdf.Memento_getBlockNum(arg1)

def Memento_find(a):
    return _mupdf.Memento_find(a)

def Memento_breakpoint():
    return _mupdf.Memento_breakpoint()

def Memento_failAt(arg1):
    return _mupdf.Memento_failAt(arg1)

def Memento_failThisEvent():
    return _mupdf.Memento_failThisEvent()

def Memento_listBlocks():
    return _mupdf.Memento_listBlocks()

def Memento_listNewBlocks():
    return _mupdf.Memento_listNewBlocks()

def Memento_listLargeBlocks():
    return _mupdf.Memento_listLargeBlocks()

def Memento_listPhasedBlocks():
    return _mupdf.Memento_listPhasedBlocks()

def Memento_setMax(arg1):
    return _mupdf.Memento_setMax(arg1)

def Memento_stats():
    return _mupdf.Memento_stats()

def Memento_label(arg1, arg2):
    return _mupdf.Memento_label(arg1, arg2)

def Memento_tick():
    return _mupdf.Memento_tick()

def Memento_setVerbose(arg1):
    return _mupdf.Memento_setVerbose(arg1)

def Memento_addBacktraceLimitFnname(fnname):
    return _mupdf.Memento_addBacktraceLimitFnname(fnname)

def Memento_setAtexitFin(atexitfin):
    return _mupdf.Memento_setAtexitFin(atexitfin)

def Memento_setIgnoreNewDelete(ignore):
    return _mupdf.Memento_setIgnoreNewDelete(ignore)

def Memento_malloc(s):
    return _mupdf.Memento_malloc(s)

def Memento_realloc(arg1, s):
    return _mupdf.Memento_realloc(arg1, s)

def Memento_free(arg1):
    return _mupdf.Memento_free(arg1)

def Memento_calloc(arg1, arg2):
    return _mupdf.Memento_calloc(arg1, arg2)

def Memento_strdup(arg1):
    return _mupdf.Memento_strdup(arg1)

def Memento_info(addr):
    return _mupdf.Memento_info(addr)

def Memento_listBlockInfo():
    return _mupdf.Memento_listBlockInfo()

def Memento_blockInfo(blk):
    return _mupdf.Memento_blockInfo(blk)

def Memento_takeByteRef(blk):
    return _mupdf.Memento_takeByteRef(blk)

def Memento_dropByteRef(blk):
    return _mupdf.Memento_dropByteRef(blk)

def Memento_takeShortRef(blk):
    return _mupdf.Memento_takeShortRef(blk)

def Memento_dropShortRef(blk):
    return _mupdf.Memento_dropShortRef(blk)

def Memento_takeIntRef(blk):
    return _mupdf.Memento_takeIntRef(blk)

def Memento_dropIntRef(blk):
    return _mupdf.Memento_dropIntRef(blk)

def Memento_takeRef(blk):
    return _mupdf.Memento_takeRef(blk)

def Memento_dropRef(blk):
    return _mupdf.Memento_dropRef(blk)

def Memento_adjustRef(blk, adjust):
    return _mupdf.Memento_adjustRef(blk, adjust)

def Memento_reference(blk):
    return _mupdf.Memento_reference(blk)

def Memento_checkPointerOrNull(blk):
    return _mupdf.Memento_checkPointerOrNull(blk)

def Memento_checkBytePointerOrNull(blk):
    return _mupdf.Memento_checkBytePointerOrNull(blk)

def Memento_checkShortPointerOrNull(blk):
    return _mupdf.Memento_checkShortPointerOrNull(blk)

def Memento_checkIntPointerOrNull(blk):
    return _mupdf.Memento_checkIntPointerOrNull(blk)

def Memento_startLeaking():
    return _mupdf.Memento_startLeaking()

def Memento_stopLeaking():
    return _mupdf.Memento_stopLeaking()

def Memento_sequence():
    return _mupdf.Memento_sequence()

def Memento_squeezing():
    return _mupdf.Memento_squeezing()

def Memento_fin():
    return _mupdf.Memento_fin()

def Memento_bt():
    return _mupdf.Memento_bt()
PATH_MAX = _mupdf.PATH_MAX
FZ_PI = _mupdf.FZ_PI
FZ_RADIAN = _mupdf.FZ_RADIAN
FZ_DEGREE = _mupdf.FZ_DEGREE
FZ_SQRT2 = _mupdf.FZ_SQRT2
FZ_LN2 = _mupdf.FZ_LN2
ARCH_HAS_NEON = _mupdf.ARCH_HAS_NEON
r"""Spot architectures where we have optimisations."""
ARCH_HAS_SSE = _mupdf.ARCH_HAS_SSE
HAVE_SIGSETJMP = _mupdf.HAVE_SIGSETJMP
r"""Some differences in libc can be smoothed over"""
EOF = _mupdf.EOF
SEEK_SET = _mupdf.SEEK_SET
SEEK_CUR = _mupdf.SEEK_CUR
SEEK_END = _mupdf.SEEK_END
M_PI = _mupdf.M_PI
class fz_point(object):
    r"""fz_point is a point in a two-dimensional space."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_point_x_get, _mupdf.fz_point_x_set)
    y = property(_mupdf.fz_point_y_get, _mupdf.fz_point_y_set)

    def __init__(self):
        _mupdf.fz_point_swiginit(self, _mupdf.new_fz_point())
    __swig_destroy__ = _mupdf.delete_fz_point

# Register fz_point in _mupdf:
_mupdf.fz_point_swigregister(fz_point)
class fz_rect(object):
    r"""
    fz_rect is a rectangle represented by two diagonally opposite
    corners at arbitrary coordinates.

    Rectangles are always axis-aligned with the X- and Y- axes. We
    wish to distinguish rectangles in 3 categories; infinite, finite,
    and invalid. Zero area rectangles are a sub-category of finite
    ones.

    For all valid rectangles, x0 <= x1 and y0 <= y1 in all cases.
    Infinite rectangles have x0 = y0 = FZ_MIN_INF_RECT,
    x1 = y1 = FZ_MAX_INF_RECT. For any non infinite valid rectangle,
    the area is defined as (x1 - x0) * (y1 - y0).

    To check for empty or infinite rectangles use fz_is_empty_rect
    and fz_is_infinite_rect. To check for valid rectangles use
    fz_is_valid_rect.

    We choose this representation, so that we can easily distinguish
    the difference between intersecting 2 valid rectangles and
    getting an invalid one, as opposed to getting a zero area one
    (which nonetheless has valid bounds within the plane).

    x0, y0: The top left corner.

    x1, y1: The bottom right corner.

    We choose FZ_{MIN,MAX}_INF_RECT to be the largest 32bit signed
    integer values that survive roundtripping to floats.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x0 = property(_mupdf.fz_rect_x0_get, _mupdf.fz_rect_x0_set)
    y0 = property(_mupdf.fz_rect_y0_get, _mupdf.fz_rect_y0_set)
    x1 = property(_mupdf.fz_rect_x1_get, _mupdf.fz_rect_x1_set)
    y1 = property(_mupdf.fz_rect_y1_get, _mupdf.fz_rect_y1_set)

    def __init__(self):
        _mupdf.fz_rect_swiginit(self, _mupdf.new_fz_rect())
    __swig_destroy__ = _mupdf.delete_fz_rect

# Register fz_rect in _mupdf:
_mupdf.fz_rect_swigregister(fz_rect)
class fz_irect(object):
    r"""
    fz_irect is a rectangle using integers instead of floats.

    It's used in the draw device and for pixmap dimensions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x0 = property(_mupdf.fz_irect_x0_get, _mupdf.fz_irect_x0_set)
    y0 = property(_mupdf.fz_irect_y0_get, _mupdf.fz_irect_y0_set)
    x1 = property(_mupdf.fz_irect_x1_get, _mupdf.fz_irect_x1_set)
    y1 = property(_mupdf.fz_irect_y1_get, _mupdf.fz_irect_y1_set)

    def __init__(self):
        _mupdf.fz_irect_swiginit(self, _mupdf.new_fz_irect())
    __swig_destroy__ = _mupdf.delete_fz_irect

# Register fz_irect in _mupdf:
_mupdf.fz_irect_swigregister(fz_irect)
class fz_matrix(object):
    r"""
    	fz_matrix is a row-major 3x3 matrix used for representing
    	transformations of coordinates throughout MuPDF.

    	Since all points reside in a two-dimensional space, one vector
    	is always a constant unit vector; hence only some elements may
    	vary in a matrix. Below is how the elements map between
    	different representations.

    a b 0
    	| c d 0 | normally represented as [ a b c d e f ].
    	\ e f 1 /
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    a = property(_mupdf.fz_matrix_a_get, _mupdf.fz_matrix_a_set)
    b = property(_mupdf.fz_matrix_b_get, _mupdf.fz_matrix_b_set)
    c = property(_mupdf.fz_matrix_c_get, _mupdf.fz_matrix_c_set)
    d = property(_mupdf.fz_matrix_d_get, _mupdf.fz_matrix_d_set)
    e = property(_mupdf.fz_matrix_e_get, _mupdf.fz_matrix_e_set)
    f = property(_mupdf.fz_matrix_f_get, _mupdf.fz_matrix_f_set)

    def __init__(self):
        _mupdf.fz_matrix_swiginit(self, _mupdf.new_fz_matrix())
    __swig_destroy__ = _mupdf.delete_fz_matrix

# Register fz_matrix in _mupdf:
_mupdf.fz_matrix_swigregister(fz_matrix)
cvar = _mupdf.cvar
fz_unit_rect = cvar.fz_unit_rect
fz_empty_rect = cvar.fz_empty_rect
fz_empty_irect = cvar.fz_empty_irect
fz_infinite_rect = cvar.fz_infinite_rect
fz_infinite_irect = cvar.fz_infinite_irect

class fz_quad(object):
    r"""
    A representation for a region defined by 4 points.

    The significant difference between quads and rects is that
    the edges of quads are not axis aligned.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ul = property(_mupdf.fz_quad_ul_get, _mupdf.fz_quad_ul_set)
    ur = property(_mupdf.fz_quad_ur_get, _mupdf.fz_quad_ur_set)
    ll = property(_mupdf.fz_quad_ll_get, _mupdf.fz_quad_ll_set)
    lr = property(_mupdf.fz_quad_lr_get, _mupdf.fz_quad_lr_set)

    def __init__(self):
        _mupdf.fz_quad_swiginit(self, _mupdf.new_fz_quad())
    __swig_destroy__ = _mupdf.delete_fz_quad

# Register fz_quad in _mupdf:
_mupdf.fz_quad_swigregister(fz_quad)
fz_identity = cvar.fz_identity

FZ_VERBOSE_EXCEPTIONS = _mupdf.FZ_VERBOSE_EXCEPTIONS
class fz_alloc_context(object):
    r"""Allocator structure; holds callbacks and private data pointer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.fz_alloc_context_user_get, _mupdf.fz_alloc_context_user_set)
    malloc = property(_mupdf.fz_alloc_context_malloc_get, _mupdf.fz_alloc_context_malloc_set)
    realloc = property(_mupdf.fz_alloc_context_realloc_get, _mupdf.fz_alloc_context_realloc_set)
    free = property(_mupdf.fz_alloc_context_free_get, _mupdf.fz_alloc_context_free_set)

    def __init__(self):
        _mupdf.fz_alloc_context_swiginit(self, _mupdf.new_fz_alloc_context())
    __swig_destroy__ = _mupdf.delete_fz_alloc_context

# Register fz_alloc_context in _mupdf:
_mupdf.fz_alloc_context_swigregister(fz_alloc_context)
fz_invalid_quad = cvar.fz_invalid_quad
fz_infinite_quad = cvar.fz_infinite_quad

FZ_ERROR_NONE = _mupdf.FZ_ERROR_NONE
FZ_ERROR_GENERIC = _mupdf.FZ_ERROR_GENERIC
FZ_ERROR_SYSTEM = _mupdf.FZ_ERROR_SYSTEM
FZ_ERROR_LIBRARY = _mupdf.FZ_ERROR_LIBRARY
FZ_ERROR_ARGUMENT = _mupdf.FZ_ERROR_ARGUMENT
FZ_ERROR_LIMIT = _mupdf.FZ_ERROR_LIMIT
FZ_ERROR_UNSUPPORTED = _mupdf.FZ_ERROR_UNSUPPORTED
FZ_ERROR_FORMAT = _mupdf.FZ_ERROR_FORMAT
FZ_ERROR_SYNTAX = _mupdf.FZ_ERROR_SYNTAX
FZ_ERROR_TRYLATER = _mupdf.FZ_ERROR_TRYLATER
FZ_ERROR_ABORT = _mupdf.FZ_ERROR_ABORT
FZ_ERROR_REPAIRED = _mupdf.FZ_ERROR_REPAIRED
class fz_locks_context(object):
    r"""
    Locking functions

    MuPDF is kept deliberately free of any knowledge of particular
    threading systems. As such, in order for safe multi-threaded
    operation, we rely on callbacks to client provided functions.

    A client is expected to provide FZ_LOCK_MAX number of mutexes,
    and a function to lock/unlock each of them. These may be
    recursive mutexes, but do not have to be.

    If a client does not intend to use multiple threads, then it
    may pass NULL instead of a lock structure.

    In order to avoid deadlocks, we have one simple rule
    internally as to how we use locks: We can never take lock n
    when we already hold any lock i, where 0 <= i <= n. In order
    to verify this, we have some debugging code, that can be
    enabled by defining FITZ_DEBUG_LOCKING.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.fz_locks_context_user_get, _mupdf.fz_locks_context_user_set)
    lock = property(_mupdf.fz_locks_context_lock_get, _mupdf.fz_locks_context_lock_set)
    unlock = property(_mupdf.fz_locks_context_unlock_get, _mupdf.fz_locks_context_unlock_set)

    def __init__(self):
        _mupdf.fz_locks_context_swiginit(self, _mupdf.new_fz_locks_context())
    __swig_destroy__ = _mupdf.delete_fz_locks_context

# Register fz_locks_context in _mupdf:
_mupdf.fz_locks_context_swigregister(fz_locks_context)
FZ_LOCK_ALLOC = _mupdf.FZ_LOCK_ALLOC
FZ_LOCK_FREETYPE = _mupdf.FZ_LOCK_FREETYPE
FZ_LOCK_GLYPHCACHE = _mupdf.FZ_LOCK_GLYPHCACHE
FZ_LOCK_MAX = _mupdf.FZ_LOCK_MAX
FZ_STORE_UNLIMITED = _mupdf.FZ_STORE_UNLIMITED
FZ_STORE_DEFAULT = _mupdf.FZ_STORE_DEFAULT
class fz_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_string_refs_get, _mupdf.fz_string_refs_set)
    str = property(_mupdf.fz_string_str_get, _mupdf.fz_string_str_set)

    def __init__(self):
        _mupdf.fz_string_swiginit(self, _mupdf.new_fz_string())
    __swig_destroy__ = _mupdf.delete_fz_string

# Register fz_string in _mupdf:
_mupdf.fz_string_swigregister(fz_string)
FZ_JMPBUF_ALIGN = _mupdf.FZ_JMPBUF_ALIGN
class fz_error_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    top = property(_mupdf.fz_error_context_top_get, _mupdf.fz_error_context_top_set)
    stack = property(_mupdf.fz_error_context_stack_get, _mupdf.fz_error_context_stack_set)
    padding = property(_mupdf.fz_error_context_padding_get, _mupdf.fz_error_context_padding_set)
    stack_base = property(_mupdf.fz_error_context_stack_base_get, _mupdf.fz_error_context_stack_base_set)
    errcode = property(_mupdf.fz_error_context_errcode_get, _mupdf.fz_error_context_errcode_set)
    errnum = property(_mupdf.fz_error_context_errnum_get, _mupdf.fz_error_context_errnum_set)
    print_user = property(_mupdf.fz_error_context_print_user_get, _mupdf.fz_error_context_print_user_set)
    _print = property(_mupdf.fz_error_context__print_get, _mupdf.fz_error_context__print_set)
    message = property(_mupdf.fz_error_context_message_get, _mupdf.fz_error_context_message_set)

    def __init__(self):
        _mupdf.fz_error_context_swiginit(self, _mupdf.new_fz_error_context())
    __swig_destroy__ = _mupdf.delete_fz_error_context

# Register fz_error_context in _mupdf:
_mupdf.fz_error_context_swigregister(fz_error_context)
class fz_warn_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    print_user = property(_mupdf.fz_warn_context_print_user_get, _mupdf.fz_warn_context_print_user_set)
    _print = property(_mupdf.fz_warn_context__print_get, _mupdf.fz_warn_context__print_set)
    count = property(_mupdf.fz_warn_context_count_get, _mupdf.fz_warn_context_count_set)
    message = property(_mupdf.fz_warn_context_message_get, _mupdf.fz_warn_context_message_set)

    def __init__(self):
        _mupdf.fz_warn_context_swiginit(self, _mupdf.new_fz_warn_context())
    __swig_destroy__ = _mupdf.delete_fz_warn_context

# Register fz_warn_context in _mupdf:
_mupdf.fz_warn_context_swigregister(fz_warn_context)
class fz_aa_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hscale = property(_mupdf.fz_aa_context_hscale_get, _mupdf.fz_aa_context_hscale_set)
    vscale = property(_mupdf.fz_aa_context_vscale_get, _mupdf.fz_aa_context_vscale_set)
    scale = property(_mupdf.fz_aa_context_scale_get, _mupdf.fz_aa_context_scale_set)
    bits = property(_mupdf.fz_aa_context_bits_get, _mupdf.fz_aa_context_bits_set)
    text_bits = property(_mupdf.fz_aa_context_text_bits_get, _mupdf.fz_aa_context_text_bits_set)
    min_line_width = property(_mupdf.fz_aa_context_min_line_width_get, _mupdf.fz_aa_context_min_line_width_set)

    def __init__(self):
        _mupdf.fz_aa_context_swiginit(self, _mupdf.new_fz_aa_context())
    __swig_destroy__ = _mupdf.delete_fz_aa_context

# Register fz_aa_context in _mupdf:
_mupdf.fz_aa_context_swigregister(fz_aa_context)
class fz_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.fz_context_user_get, _mupdf.fz_context_user_set)
    alloc = property(_mupdf.fz_context_alloc_get, _mupdf.fz_context_alloc_set)
    locks = property(_mupdf.fz_context_locks_get, _mupdf.fz_context_locks_set)
    error = property(_mupdf.fz_context_error_get, _mupdf.fz_context_error_set)
    warn = property(_mupdf.fz_context_warn_get, _mupdf.fz_context_warn_set)
    aa = property(_mupdf.fz_context_aa_get, _mupdf.fz_context_aa_set)
    seed48 = property(_mupdf.fz_context_seed48_get, _mupdf.fz_context_seed48_set)
    icc_enabled = property(_mupdf.fz_context_icc_enabled_get, _mupdf.fz_context_icc_enabled_set)
    throw_on_repair = property(_mupdf.fz_context_throw_on_repair_get, _mupdf.fz_context_throw_on_repair_set)
    handler = property(_mupdf.fz_context_handler_get, _mupdf.fz_context_handler_set)
    archive = property(_mupdf.fz_context_archive_get, _mupdf.fz_context_archive_set)
    style = property(_mupdf.fz_context_style_get, _mupdf.fz_context_style_set)
    tuning = property(_mupdf.fz_context_tuning_get, _mupdf.fz_context_tuning_set)
    stddbg = property(_mupdf.fz_context_stddbg_get, _mupdf.fz_context_stddbg_set)
    font = property(_mupdf.fz_context_font_get, _mupdf.fz_context_font_set)
    colorspace = property(_mupdf.fz_context_colorspace_get, _mupdf.fz_context_colorspace_set)
    store = property(_mupdf.fz_context_store_get, _mupdf.fz_context_store_set)
    glyph_cache = property(_mupdf.fz_context_glyph_cache_get, _mupdf.fz_context_glyph_cache_set)

    def __init__(self):
        _mupdf.fz_context_swiginit(self, _mupdf.new_fz_context())
    __swig_destroy__ = _mupdf.delete_fz_context

# Register fz_context in _mupdf:
_mupdf.fz_context_swigregister(fz_context)
class fz_buffer(object):
    r"""
    fz_buffer is a wrapper around a dynamically allocated array of
    bytes.

    Buffers have a capacity (the number of bytes storage immediately
    available) and a current size.

    The contents of the structure are considered implementation
    details and are subject to change. Users should use the accessor
    functions in preference.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_buffer_refs_get, _mupdf.fz_buffer_refs_set)
    data = property(_mupdf.fz_buffer_data_get, _mupdf.fz_buffer_data_set)
    cap = property(_mupdf.fz_buffer_cap_get, _mupdf.fz_buffer_cap_set)
    len = property(_mupdf.fz_buffer_len_get, _mupdf.fz_buffer_len_set)
    unused_bits = property(_mupdf.fz_buffer_unused_bits_get, _mupdf.fz_buffer_unused_bits_set)
    shared = property(_mupdf.fz_buffer_shared_get, _mupdf.fz_buffer_shared_set)

    def __init__(self):
        _mupdf.fz_buffer_swiginit(self, _mupdf.new_fz_buffer())
    __swig_destroy__ = _mupdf.delete_fz_buffer

# Register fz_buffer in _mupdf:
_mupdf.fz_buffer_swigregister(fz_buffer)
FZ_REPLACEMENT_CHARACTER = _mupdf.FZ_REPLACEMENT_CHARACTER
FZ_UTFMAX = _mupdf.FZ_UTFMAX
class fz_stream(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_stream_refs_get, _mupdf.fz_stream_refs_set)
    error = property(_mupdf.fz_stream_error_get, _mupdf.fz_stream_error_set)
    eof = property(_mupdf.fz_stream_eof_get, _mupdf.fz_stream_eof_set)
    progressive = property(_mupdf.fz_stream_progressive_get, _mupdf.fz_stream_progressive_set)
    pos = property(_mupdf.fz_stream_pos_get, _mupdf.fz_stream_pos_set)
    avail = property(_mupdf.fz_stream_avail_get, _mupdf.fz_stream_avail_set)
    bits = property(_mupdf.fz_stream_bits_get, _mupdf.fz_stream_bits_set)
    rp = property(_mupdf.fz_stream_rp_get, _mupdf.fz_stream_rp_set)
    wp = property(_mupdf.fz_stream_wp_get, _mupdf.fz_stream_wp_set)
    state = property(_mupdf.fz_stream_state_get, _mupdf.fz_stream_state_set)
    next = property(_mupdf.fz_stream_next_get, _mupdf.fz_stream_next_set)
    drop = property(_mupdf.fz_stream_drop_get, _mupdf.fz_stream_drop_set)
    seek = property(_mupdf.fz_stream_seek_get, _mupdf.fz_stream_seek_set)

    def __init__(self):
        _mupdf.fz_stream_swiginit(self, _mupdf.new_fz_stream())
    __swig_destroy__ = _mupdf.delete_fz_stream

# Register fz_stream in _mupdf:
_mupdf.fz_stream_swigregister(fz_stream)
class fz_output(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    state = property(_mupdf.fz_output_state_get, _mupdf.fz_output_state_set)
    write = property(_mupdf.fz_output_write_get, _mupdf.fz_output_write_set)
    seek = property(_mupdf.fz_output_seek_get, _mupdf.fz_output_seek_set)
    tell = property(_mupdf.fz_output_tell_get, _mupdf.fz_output_tell_set)
    close = property(_mupdf.fz_output_close_get, _mupdf.fz_output_close_set)
    drop = property(_mupdf.fz_output_drop_get, _mupdf.fz_output_drop_set)
    reset = property(_mupdf.fz_output_reset_get, _mupdf.fz_output_reset_set)
    as_stream = property(_mupdf.fz_output_as_stream_get, _mupdf.fz_output_as_stream_set)
    truncate = property(_mupdf.fz_output_truncate_get, _mupdf.fz_output_truncate_set)
    closed = property(_mupdf.fz_output_closed_get, _mupdf.fz_output_closed_set)
    bp = property(_mupdf.fz_output_bp_get, _mupdf.fz_output_bp_set)
    wp = property(_mupdf.fz_output_wp_get, _mupdf.fz_output_wp_set)
    ep = property(_mupdf.fz_output_ep_get, _mupdf.fz_output_ep_set)
    buffered = property(_mupdf.fz_output_buffered_get, _mupdf.fz_output_buffered_set)
    bits = property(_mupdf.fz_output_bits_get, _mupdf.fz_output_bits_set)

    def __init__(self):
        _mupdf.fz_output_swiginit(self, _mupdf.new_fz_output())
    __swig_destroy__ = _mupdf.delete_fz_output

# Register fz_output in _mupdf:
_mupdf.fz_output_swigregister(fz_output)
class fz_md5(object):
    r"""
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lo = property(_mupdf.fz_md5_lo_get, _mupdf.fz_md5_lo_set)
    hi = property(_mupdf.fz_md5_hi_get, _mupdf.fz_md5_hi_set)
    a = property(_mupdf.fz_md5_a_get, _mupdf.fz_md5_a_set)
    b = property(_mupdf.fz_md5_b_get, _mupdf.fz_md5_b_set)
    c = property(_mupdf.fz_md5_c_get, _mupdf.fz_md5_c_set)
    d = property(_mupdf.fz_md5_d_get, _mupdf.fz_md5_d_set)
    buffer = property(_mupdf.fz_md5_buffer_get, _mupdf.fz_md5_buffer_set)

    def __init__(self):
        _mupdf.fz_md5_swiginit(self, _mupdf.new_fz_md5())
    __swig_destroy__ = _mupdf.delete_fz_md5

# Register fz_md5 in _mupdf:
_mupdf.fz_md5_swigregister(fz_md5)
class fz_sha256(object):
    r"""
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    state = property(_mupdf.fz_sha256_state_get, _mupdf.fz_sha256_state_set)
    count = property(_mupdf.fz_sha256_count_get, _mupdf.fz_sha256_count_set)

    def __init__(self):
        _mupdf.fz_sha256_swiginit(self, _mupdf.new_fz_sha256())
    __swig_destroy__ = _mupdf.delete_fz_sha256

# Register fz_sha256 in _mupdf:
_mupdf.fz_sha256_swigregister(fz_sha256)
class fz_sha512(object):
    r"""
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    state = property(_mupdf.fz_sha512_state_get, _mupdf.fz_sha512_state_set)
    count = property(_mupdf.fz_sha512_count_get, _mupdf.fz_sha512_count_set)

    def __init__(self):
        _mupdf.fz_sha512_swiginit(self, _mupdf.new_fz_sha512())
    __swig_destroy__ = _mupdf.delete_fz_sha512

# Register fz_sha512 in _mupdf:
_mupdf.fz_sha512_swigregister(fz_sha512)
class fz_arc4(object):
    r"""
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_arc4_x_get, _mupdf.fz_arc4_x_set)
    y = property(_mupdf.fz_arc4_y_get, _mupdf.fz_arc4_y_set)
    state = property(_mupdf.fz_arc4_state_get, _mupdf.fz_arc4_state_set)

    def __init__(self):
        _mupdf.fz_arc4_swiginit(self, _mupdf.new_fz_arc4())
    __swig_destroy__ = _mupdf.delete_fz_arc4

# Register fz_arc4 in _mupdf:
_mupdf.fz_arc4_swigregister(fz_arc4)
class fz_aes(object):
    r"""
    Structure definitions are public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nr = property(_mupdf.fz_aes_nr_get, _mupdf.fz_aes_nr_set)
    rk = property(_mupdf.fz_aes_rk_get, _mupdf.fz_aes_rk_set)
    buf = property(_mupdf.fz_aes_buf_get, _mupdf.fz_aes_buf_set)

    def __init__(self):
        _mupdf.fz_aes_swiginit(self, _mupdf.new_fz_aes())
    __swig_destroy__ = _mupdf.delete_fz_aes

# Register fz_aes in _mupdf:
_mupdf.fz_aes_swigregister(fz_aes)
FZ_AES_DECRYPT = _mupdf.FZ_AES_DECRYPT
FZ_AES_ENCRYPT = _mupdf.FZ_AES_ENCRYPT
class fz_getopt_long_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    option = property(_mupdf.fz_getopt_long_options_option_get, _mupdf.fz_getopt_long_options_option_set)
    flag = property(_mupdf.fz_getopt_long_options_flag_get, _mupdf.fz_getopt_long_options_flag_set)
    opaque = property(_mupdf.fz_getopt_long_options_opaque_get, _mupdf.fz_getopt_long_options_opaque_set)

    def __init__(self):
        _mupdf.fz_getopt_long_options_swiginit(self, _mupdf.new_fz_getopt_long_options())
    __swig_destroy__ = _mupdf.delete_fz_getopt_long_options

# Register fz_getopt_long_options in _mupdf:
_mupdf.fz_getopt_long_options_swigregister(fz_getopt_long_options)
FZ_HASH_TABLE_KEY_LENGTH = _mupdf.FZ_HASH_TABLE_KEY_LENGTH
FZ_BIDI_LTR = _mupdf.FZ_BIDI_LTR
FZ_BIDI_RTL = _mupdf.FZ_BIDI_RTL
FZ_BIDI_NEUTRAL = _mupdf.FZ_BIDI_NEUTRAL
FZ_BIDI_CLASSIFY_WHITE_SPACE = _mupdf.FZ_BIDI_CLASSIFY_WHITE_SPACE
FZ_BIDI_REPLACE_TAB = _mupdf.FZ_BIDI_REPLACE_TAB
class fz_archive_handler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    recognize = property(_mupdf.fz_archive_handler_recognize_get, _mupdf.fz_archive_handler_recognize_set)
    open = property(_mupdf.fz_archive_handler_open_get, _mupdf.fz_archive_handler_open_set)

    def __init__(self):
        _mupdf.fz_archive_handler_swiginit(self, _mupdf.new_fz_archive_handler())
    __swig_destroy__ = _mupdf.delete_fz_archive_handler

# Register fz_archive_handler in _mupdf:
_mupdf.fz_archive_handler_swigregister(fz_archive_handler)
class fz_archive(object):
    r"""Implementation details: Subject to change."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_archive_refs_get, _mupdf.fz_archive_refs_set)
    file = property(_mupdf.fz_archive_file_get, _mupdf.fz_archive_file_set)
    format = property(_mupdf.fz_archive_format_get, _mupdf.fz_archive_format_set)
    drop_archive = property(_mupdf.fz_archive_drop_archive_get, _mupdf.fz_archive_drop_archive_set)
    count_entries = property(_mupdf.fz_archive_count_entries_get, _mupdf.fz_archive_count_entries_set)
    list_entry = property(_mupdf.fz_archive_list_entry_get, _mupdf.fz_archive_list_entry_set)
    has_entry = property(_mupdf.fz_archive_has_entry_get, _mupdf.fz_archive_has_entry_set)
    read_entry = property(_mupdf.fz_archive_read_entry_get, _mupdf.fz_archive_read_entry_set)
    open_entry = property(_mupdf.fz_archive_open_entry_get, _mupdf.fz_archive_open_entry_set)

    def __init__(self):
        _mupdf.fz_archive_swiginit(self, _mupdf.new_fz_archive())
    __swig_destroy__ = _mupdf.delete_fz_archive

# Register fz_archive in _mupdf:
_mupdf.fz_archive_swigregister(fz_archive)
fz_libarchive_archive_handler = cvar.fz_libarchive_archive_handler

class fz_storable(object):
    r"""
    Any storable object should include an fz_storable structure
    at the start (by convention at least) of their structure.
    (Unless it starts with an fz_key_storable, see below).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_storable_refs_get, _mupdf.fz_storable_refs_set)
    drop = property(_mupdf.fz_storable_drop_get, _mupdf.fz_storable_drop_set)
    droppable = property(_mupdf.fz_storable_droppable_get, _mupdf.fz_storable_droppable_set)

    def __init__(self):
        _mupdf.fz_storable_swiginit(self, _mupdf.new_fz_storable())
    __swig_destroy__ = _mupdf.delete_fz_storable

# Register fz_storable in _mupdf:
_mupdf.fz_storable_swigregister(fz_storable)
class fz_key_storable(object):
    r"""
    Any storable object that can appear in the key of another
    storable object should include an fz_key_storable structure
    at the start (by convention at least) of their structure.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.fz_key_storable_storable_get, _mupdf.fz_key_storable_storable_set)
    store_key_refs = property(_mupdf.fz_key_storable_store_key_refs_get, _mupdf.fz_key_storable_store_key_refs_set)

    def __init__(self):
        _mupdf.fz_key_storable_swiginit(self, _mupdf.new_fz_key_storable())
    __swig_destroy__ = _mupdf.delete_fz_key_storable

# Register fz_key_storable in _mupdf:
_mupdf.fz_key_storable_swigregister(fz_key_storable)
class fz_store_hash(object):
    r"""
    The store can be seen as a dictionary that maps keys to
    fz_storable values. In order to allow keys of different types to
    be stored, we have a structure full of functions for each key
    'type'; this fz_store_type pointer is stored with each key, and
    tells the store how to perform certain operations (like taking/
    dropping a reference, comparing two keys, outputting details for
    debugging etc).

    The store uses a hash table internally for speed where possible.
    In order for this to work, we need a mechanism for turning a
    generic 'key' into 'a hashable string'. For this purpose the
    type structure contains a make_hash_key function pointer that
    maps from a void * to a fz_store_hash structure. If
    make_hash_key function returns 0, then the key is determined not
    to be hashable, and the value is not stored in the hash table.

    Some objects can be used both as values within the store, and as
    a component of keys within the store. We refer to these objects
    as "key storable" objects. In this case, we need to take
    additional care to ensure that we do not end up keeping an item
    within the store, purely because its value is referred to by
    another key in the store.

    An example of this are fz_images in PDF files. Each fz_image is
    placed into the	store to enable it to be easily reused. When the
    image is rendered, a pixmap is generated from the image, and the
    pixmap is placed into the store so it can be reused on
    subsequent renders. The image forms part of the key for the
    pixmap.

    When we close the pdf document (and any associated pages/display
    lists etc), we drop the images from the store. This may leave us
    in the position of the images having non-zero reference counts
    purely because they are used as part of the keys for the
    pixmaps.

    We therefore use special reference counting functions to keep
    track of these "key storable" items, and hence store the number
    of references to these items that are used in keys.

    When the number of references to an object == the number of
    references to an object from keys in the store, we know that we
    can remove all the items which have that object as part of the
    key. This is done by running a pass over the store, 'reaping'
    those items.

    Reap passes are slower than we would like as they touch every
    item in the store. We therefore provide a way to 'batch' such
    reap passes together, using fz_defer_reap_start/
    fz_defer_reap_end to bracket a region in which many may be
    triggered.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.fz_store_hash_drop_get, _mupdf.fz_store_hash_drop_set)

    def __init__(self):
        _mupdf.fz_store_hash_swiginit(self, _mupdf.new_fz_store_hash())
    __swig_destroy__ = _mupdf.delete_fz_store_hash

# Register fz_store_hash in _mupdf:
_mupdf.fz_store_hash_swigregister(fz_store_hash)
class fz_store_type(object):
    r"""
    Every type of object to be placed into the store defines an
    fz_store_type. This contains the pointers to functions to
    make hashes, manipulate keys, and check for needing reaping.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_mupdf.fz_store_type_name_get, _mupdf.fz_store_type_name_set)
    make_hash_key = property(_mupdf.fz_store_type_make_hash_key_get, _mupdf.fz_store_type_make_hash_key_set)
    keep_key = property(_mupdf.fz_store_type_keep_key_get, _mupdf.fz_store_type_keep_key_set)
    drop_key = property(_mupdf.fz_store_type_drop_key_get, _mupdf.fz_store_type_drop_key_set)
    cmp_key = property(_mupdf.fz_store_type_cmp_key_get, _mupdf.fz_store_type_cmp_key_set)
    format_key = property(_mupdf.fz_store_type_format_key_get, _mupdf.fz_store_type_format_key_set)
    needs_reap = property(_mupdf.fz_store_type_needs_reap_get, _mupdf.fz_store_type_needs_reap_set)

    def __init__(self):
        _mupdf.fz_store_type_swiginit(self, _mupdf.new_fz_store_type())
    __swig_destroy__ = _mupdf.delete_fz_store_type

# Register fz_store_type in _mupdf:
_mupdf.fz_store_type_swigregister(fz_store_type)
FZ_RI_PERCEPTUAL = _mupdf.FZ_RI_PERCEPTUAL
FZ_RI_RELATIVE_COLORIMETRIC = _mupdf.FZ_RI_RELATIVE_COLORIMETRIC
FZ_RI_SATURATION = _mupdf.FZ_RI_SATURATION
FZ_RI_ABSOLUTE_COLORIMETRIC = _mupdf.FZ_RI_ABSOLUTE_COLORIMETRIC
class fz_color_params(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ri = property(_mupdf.fz_color_params_ri_get, _mupdf.fz_color_params_ri_set)
    bp = property(_mupdf.fz_color_params_bp_get, _mupdf.fz_color_params_bp_set)
    op = property(_mupdf.fz_color_params_op_get, _mupdf.fz_color_params_op_set)
    opm = property(_mupdf.fz_color_params_opm_get, _mupdf.fz_color_params_opm_set)

    def __init__(self):
        _mupdf.fz_color_params_swiginit(self, _mupdf.new_fz_color_params())
    __swig_destroy__ = _mupdf.delete_fz_color_params

# Register fz_color_params in _mupdf:
_mupdf.fz_color_params_swigregister(fz_color_params)
FZ_MAX_COLORS = _mupdf.FZ_MAX_COLORS
FZ_COLORSPACE_IS_DEVICE = _mupdf.FZ_COLORSPACE_IS_DEVICE
FZ_COLORSPACE_IS_ICC = _mupdf.FZ_COLORSPACE_IS_ICC
FZ_COLORSPACE_HAS_CMYK = _mupdf.FZ_COLORSPACE_HAS_CMYK
FZ_COLORSPACE_HAS_SPOTS = _mupdf.FZ_COLORSPACE_HAS_SPOTS
FZ_COLORSPACE_HAS_CMYK_AND_SPOTS = _mupdf.FZ_COLORSPACE_HAS_CMYK_AND_SPOTS
class fz_default_colorspaces(object):
    r"""Structure to hold default colorspaces."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_default_colorspaces_refs_get, _mupdf.fz_default_colorspaces_refs_set)
    gray = property(_mupdf.fz_default_colorspaces_gray_get, _mupdf.fz_default_colorspaces_gray_set)
    rgb = property(_mupdf.fz_default_colorspaces_rgb_get, _mupdf.fz_default_colorspaces_rgb_set)
    cmyk = property(_mupdf.fz_default_colorspaces_cmyk_get, _mupdf.fz_default_colorspaces_cmyk_set)
    oi = property(_mupdf.fz_default_colorspaces_oi_get, _mupdf.fz_default_colorspaces_oi_set)

    def __init__(self):
        _mupdf.fz_default_colorspaces_swiginit(self, _mupdf.new_fz_default_colorspaces())
    __swig_destroy__ = _mupdf.delete_fz_default_colorspaces

# Register fz_default_colorspaces in _mupdf:
_mupdf.fz_default_colorspaces_swigregister(fz_default_colorspaces)
fz_default_color_params = cvar.fz_default_color_params

class fz_colorspace(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    key_storable = property(_mupdf.fz_colorspace_key_storable_get, _mupdf.fz_colorspace_key_storable_set)
    type = property(_mupdf.fz_colorspace_type_get, _mupdf.fz_colorspace_type_set)
    flags = property(_mupdf.fz_colorspace_flags_get, _mupdf.fz_colorspace_flags_set)
    n = property(_mupdf.fz_colorspace_n_get, _mupdf.fz_colorspace_n_set)
    name = property(_mupdf.fz_colorspace_name_get, _mupdf.fz_colorspace_name_set)

    def __init__(self):
        _mupdf.fz_colorspace_swiginit(self, _mupdf.new_fz_colorspace())
    __swig_destroy__ = _mupdf.delete_fz_colorspace

# Register fz_colorspace in _mupdf:
_mupdf.fz_colorspace_swigregister(fz_colorspace)
FZ_MAX_SEPARATIONS = _mupdf.FZ_MAX_SEPARATIONS
FZ_SEPARATION_COMPOSITE = _mupdf.FZ_SEPARATION_COMPOSITE
FZ_SEPARATION_SPOT = _mupdf.FZ_SEPARATION_SPOT
FZ_SEPARATION_DISABLED = _mupdf.FZ_SEPARATION_DISABLED
class fz_pixmap(object):
    r"""
    Pixmaps represent a set of pixels for a 2 dimensional region of
    a plane. Each pixel has n components per pixel. The components
    are in the order process-components, spot-colors, alpha, where
    there can be 0 of any of those types. The data is in
    premultiplied alpha when rendering, but non-premultiplied for
    colorspace conversions and rescaling.

    x, y: The minimum x and y coord of the region in pixels.

    w, h: The width and height of the region in pixels.

    n: The number of color components in the image.
    	n = num composite colors + num spots + num alphas

    s: The number of spot channels in the image.

    alpha: 0 for no alpha, 1 for alpha present.

    flags: flag bits.
    	Bit 0: If set, draw the image with linear interpolation.
    	Bit 1: If set, free the samples buffer when the pixmap
    	is destroyed.

    stride: The byte offset from the data for any given pixel
    to the data for the same pixel on the row below.

    seps: NULL, or a pointer to a separations structure. If NULL,
    s should be 0.

    xres, yres: Image resolution in dpi. Default is 96 dpi.

    colorspace: Pointer to a colorspace object describing the
    colorspace the pixmap is in. If NULL, the image is a mask.

    samples: Pointer to the first byte of the pixmap sample data.
    This is typically a simple block of memory w * h * n bytes of
    memory in which the components are stored linearly, but with the
    use of appropriate stride values, scanlines can be stored in
    different orders, and have different amounts of padding. The
    first n bytes are components 0 to n-1 for the pixel at (x,y).
    Each successive n bytes gives another pixel in scanline order
    as we move across the line. The start of each scanline is offset
    the start of the previous one by stride bytes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.fz_pixmap_storable_get, _mupdf.fz_pixmap_storable_set)
    x = property(_mupdf.fz_pixmap_x_get, _mupdf.fz_pixmap_x_set)
    y = property(_mupdf.fz_pixmap_y_get, _mupdf.fz_pixmap_y_set)
    w = property(_mupdf.fz_pixmap_w_get, _mupdf.fz_pixmap_w_set)
    h = property(_mupdf.fz_pixmap_h_get, _mupdf.fz_pixmap_h_set)
    n = property(_mupdf.fz_pixmap_n_get, _mupdf.fz_pixmap_n_set)
    s = property(_mupdf.fz_pixmap_s_get, _mupdf.fz_pixmap_s_set)
    alpha = property(_mupdf.fz_pixmap_alpha_get, _mupdf.fz_pixmap_alpha_set)
    flags = property(_mupdf.fz_pixmap_flags_get, _mupdf.fz_pixmap_flags_set)
    stride = property(_mupdf.fz_pixmap_stride_get, _mupdf.fz_pixmap_stride_set)
    seps = property(_mupdf.fz_pixmap_seps_get, _mupdf.fz_pixmap_seps_set)
    xres = property(_mupdf.fz_pixmap_xres_get, _mupdf.fz_pixmap_xres_set)
    yres = property(_mupdf.fz_pixmap_yres_get, _mupdf.fz_pixmap_yres_set)
    colorspace = property(_mupdf.fz_pixmap_colorspace_get, _mupdf.fz_pixmap_colorspace_set)
    samples = property(_mupdf.fz_pixmap_samples_get, _mupdf.fz_pixmap_samples_set)
    underlying = property(_mupdf.fz_pixmap_underlying_get, _mupdf.fz_pixmap_underlying_set)

    def __init__(self):
        _mupdf.fz_pixmap_swiginit(self, _mupdf.new_fz_pixmap())
    __swig_destroy__ = _mupdf.delete_fz_pixmap

# Register fz_pixmap in _mupdf:
_mupdf.fz_pixmap_swigregister(fz_pixmap)
FZ_PIXMAP_FLAG_INTERPOLATE = _mupdf.FZ_PIXMAP_FLAG_INTERPOLATE
FZ_PIXMAP_FLAG_FREE_SAMPLES = _mupdf.FZ_PIXMAP_FLAG_FREE_SAMPLES
FZ_DEFLATE_NONE = _mupdf.FZ_DEFLATE_NONE
FZ_DEFLATE_BEST_SPEED = _mupdf.FZ_DEFLATE_BEST_SPEED
FZ_DEFLATE_BEST = _mupdf.FZ_DEFLATE_BEST
FZ_DEFLATE_DEFAULT = _mupdf.FZ_DEFLATE_DEFAULT
class fz_range(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    offset = property(_mupdf.fz_range_offset_get, _mupdf.fz_range_offset_set)
    length = property(_mupdf.fz_range_length_get, _mupdf.fz_range_length_set)

    def __init__(self):
        _mupdf.fz_range_swiginit(self, _mupdf.new_fz_range())
    __swig_destroy__ = _mupdf.delete_fz_range

# Register fz_range in _mupdf:
_mupdf.fz_range_swigregister(fz_range)
class fz_compression_params(object):
    r"""
    Compression parameters used for buffers of compressed data;
    typically for the source data for images.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.fz_compression_params_type_get, _mupdf.fz_compression_params_type_set)

    def __init__(self):
        _mupdf.fz_compression_params_swiginit(self, _mupdf.new_fz_compression_params())
    __swig_destroy__ = _mupdf.delete_fz_compression_params

# Register fz_compression_params in _mupdf:
_mupdf.fz_compression_params_swigregister(fz_compression_params)
class fz_compressed_buffer(object):
    r"""
    Buffers of compressed data; typically for the source data
    for images.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_compressed_buffer_refs_get, _mupdf.fz_compressed_buffer_refs_set)
    params = property(_mupdf.fz_compressed_buffer_params_get, _mupdf.fz_compressed_buffer_params_set)
    buffer = property(_mupdf.fz_compressed_buffer_buffer_get, _mupdf.fz_compressed_buffer_buffer_set)

    def __init__(self):
        _mupdf.fz_compressed_buffer_swiginit(self, _mupdf.new_fz_compressed_buffer())
    __swig_destroy__ = _mupdf.delete_fz_compressed_buffer

# Register fz_compressed_buffer in _mupdf:
_mupdf.fz_compressed_buffer_swigregister(fz_compressed_buffer)
FZ_IMAGE_UNKNOWN = _mupdf.FZ_IMAGE_UNKNOWN
FZ_IMAGE_RAW = _mupdf.FZ_IMAGE_RAW
FZ_IMAGE_FAX = _mupdf.FZ_IMAGE_FAX
FZ_IMAGE_FLATE = _mupdf.FZ_IMAGE_FLATE
FZ_IMAGE_LZW = _mupdf.FZ_IMAGE_LZW
FZ_IMAGE_RLD = _mupdf.FZ_IMAGE_RLD
FZ_IMAGE_BMP = _mupdf.FZ_IMAGE_BMP
FZ_IMAGE_GIF = _mupdf.FZ_IMAGE_GIF
FZ_IMAGE_JBIG2 = _mupdf.FZ_IMAGE_JBIG2
FZ_IMAGE_JPEG = _mupdf.FZ_IMAGE_JPEG
FZ_IMAGE_JPX = _mupdf.FZ_IMAGE_JPX
FZ_IMAGE_JXR = _mupdf.FZ_IMAGE_JXR
FZ_IMAGE_PNG = _mupdf.FZ_IMAGE_PNG
FZ_IMAGE_PNM = _mupdf.FZ_IMAGE_PNM
FZ_IMAGE_TIFF = _mupdf.FZ_IMAGE_TIFF
FZ_IMAGE_PSD = _mupdf.FZ_IMAGE_PSD
class fz_bitmap(object):
    r"""
    Bitmaps have 1 bit per component. Only used for creating
    halftoned versions of contone buffers, and saving out. Samples
    are stored msb first, akin to pbms.

    The internals of this struct are considered implementation
    details and subject to change. Where possible, accessor
    functions should be used in preference.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_bitmap_refs_get, _mupdf.fz_bitmap_refs_set)
    w = property(_mupdf.fz_bitmap_w_get, _mupdf.fz_bitmap_w_set)
    h = property(_mupdf.fz_bitmap_h_get, _mupdf.fz_bitmap_h_set)
    stride = property(_mupdf.fz_bitmap_stride_get, _mupdf.fz_bitmap_stride_set)
    n = property(_mupdf.fz_bitmap_n_get, _mupdf.fz_bitmap_n_set)
    xres = property(_mupdf.fz_bitmap_xres_get, _mupdf.fz_bitmap_xres_set)
    yres = property(_mupdf.fz_bitmap_yres_get, _mupdf.fz_bitmap_yres_set)
    samples = property(_mupdf.fz_bitmap_samples_get, _mupdf.fz_bitmap_samples_set)

    def __init__(self):
        _mupdf.fz_bitmap_swiginit(self, _mupdf.new_fz_bitmap())
    __swig_destroy__ = _mupdf.delete_fz_bitmap

# Register fz_bitmap in _mupdf:
_mupdf.fz_bitmap_swigregister(fz_bitmap)
class fz_image(object):
    r"""
    Structure is public to allow other structures to
    be derived from it. Do not access members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    key_storable = property(_mupdf.fz_image_key_storable_get, _mupdf.fz_image_key_storable_set)
    w = property(_mupdf.fz_image_w_get, _mupdf.fz_image_w_set)
    h = property(_mupdf.fz_image_h_get, _mupdf.fz_image_h_set)
    n = property(_mupdf.fz_image_n_get, _mupdf.fz_image_n_set)
    bpc = property(_mupdf.fz_image_bpc_get, _mupdf.fz_image_bpc_set)
    imagemask = property(_mupdf.fz_image_imagemask_get, _mupdf.fz_image_imagemask_set)
    interpolate = property(_mupdf.fz_image_interpolate_get, _mupdf.fz_image_interpolate_set)
    use_colorkey = property(_mupdf.fz_image_use_colorkey_get, _mupdf.fz_image_use_colorkey_set)
    use_decode = property(_mupdf.fz_image_use_decode_get, _mupdf.fz_image_use_decode_set)
    decoded = property(_mupdf.fz_image_decoded_get, _mupdf.fz_image_decoded_set)
    scalable = property(_mupdf.fz_image_scalable_get, _mupdf.fz_image_scalable_set)
    orientation = property(_mupdf.fz_image_orientation_get, _mupdf.fz_image_orientation_set)
    mask = property(_mupdf.fz_image_mask_get, _mupdf.fz_image_mask_set)
    xres = property(_mupdf.fz_image_xres_get, _mupdf.fz_image_xres_set)
    yres = property(_mupdf.fz_image_yres_get, _mupdf.fz_image_yres_set)
    colorspace = property(_mupdf.fz_image_colorspace_get, _mupdf.fz_image_colorspace_set)
    drop_image = property(_mupdf.fz_image_drop_image_get, _mupdf.fz_image_drop_image_set)
    get_pixmap = property(_mupdf.fz_image_get_pixmap_get, _mupdf.fz_image_get_pixmap_set)
    get_size = property(_mupdf.fz_image_get_size_get, _mupdf.fz_image_get_size_set)
    colorkey = property(_mupdf.fz_image_colorkey_get, _mupdf.fz_image_colorkey_set)
    decode = property(_mupdf.fz_image_decode_get, _mupdf.fz_image_decode_set)

    def __init__(self):
        _mupdf.fz_image_swiginit(self, _mupdf.new_fz_image())
    __swig_destroy__ = _mupdf.delete_fz_image

# Register fz_image in _mupdf:
_mupdf.fz_image_swigregister(fz_image)
FZ_FUNCTION_BASED = _mupdf.FZ_FUNCTION_BASED
FZ_LINEAR = _mupdf.FZ_LINEAR
FZ_RADIAL = _mupdf.FZ_RADIAL
FZ_MESH_TYPE4 = _mupdf.FZ_MESH_TYPE4
FZ_MESH_TYPE5 = _mupdf.FZ_MESH_TYPE5
FZ_MESH_TYPE6 = _mupdf.FZ_MESH_TYPE6
FZ_MESH_TYPE7 = _mupdf.FZ_MESH_TYPE7
class fz_shade(object):
    r"""
    Structure is public to allow derived classes. Do not
    access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.fz_shade_storable_get, _mupdf.fz_shade_storable_set)
    bbox = property(_mupdf.fz_shade_bbox_get, _mupdf.fz_shade_bbox_set)
    colorspace = property(_mupdf.fz_shade_colorspace_get, _mupdf.fz_shade_colorspace_set)
    matrix = property(_mupdf.fz_shade_matrix_get, _mupdf.fz_shade_matrix_set)
    use_background = property(_mupdf.fz_shade_use_background_get, _mupdf.fz_shade_use_background_set)
    background = property(_mupdf.fz_shade_background_get, _mupdf.fz_shade_background_set)
    function_stride = property(_mupdf.fz_shade_function_stride_get, _mupdf.fz_shade_function_stride_set)
    function = property(_mupdf.fz_shade_function_get, _mupdf.fz_shade_function_set)
    type = property(_mupdf.fz_shade_type_get, _mupdf.fz_shade_type_set)
    buffer = property(_mupdf.fz_shade_buffer_get, _mupdf.fz_shade_buffer_set)

    def __init__(self):
        _mupdf.fz_shade_swiginit(self, _mupdf.new_fz_shade())
    __swig_destroy__ = _mupdf.delete_fz_shade

# Register fz_shade in _mupdf:
_mupdf.fz_shade_swigregister(fz_shade)
class fz_vertex(object):
    r"""Handy routine for processing mesh based shades"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    p = property(_mupdf.fz_vertex_p_get, _mupdf.fz_vertex_p_set)
    c = property(_mupdf.fz_vertex_c_get, _mupdf.fz_vertex_c_set)

    def __init__(self):
        _mupdf.fz_vertex_swiginit(self, _mupdf.new_fz_vertex())
    __swig_destroy__ = _mupdf.delete_fz_vertex

# Register fz_vertex in _mupdf:
_mupdf.fz_vertex_swigregister(fz_vertex)
class fz_text_decoder(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    decode_bound = property(_mupdf.fz_text_decoder_decode_bound_get, _mupdf.fz_text_decoder_decode_bound_set)
    decode_size = property(_mupdf.fz_text_decoder_decode_size_get, _mupdf.fz_text_decoder_decode_size_set)
    decode = property(_mupdf.fz_text_decoder_decode_get, _mupdf.fz_text_decoder_decode_set)
    table1 = property(_mupdf.fz_text_decoder_table1_get, _mupdf.fz_text_decoder_table1_set)
    table2 = property(_mupdf.fz_text_decoder_table2_get, _mupdf.fz_text_decoder_table2_set)

    def __init__(self):
        _mupdf.fz_text_decoder_swiginit(self, _mupdf.new_fz_text_decoder())
    __swig_destroy__ = _mupdf.delete_fz_text_decoder

# Register fz_text_decoder in _mupdf:
_mupdf.fz_text_decoder_swigregister(fz_text_decoder)
fz_unicode_from_iso8859_1 = cvar.fz_unicode_from_iso8859_1
fz_unicode_from_iso8859_7 = cvar.fz_unicode_from_iso8859_7
fz_unicode_from_koi8u = cvar.fz_unicode_from_koi8u
fz_unicode_from_pdf_doc_encoding = cvar.fz_unicode_from_pdf_doc_encoding
fz_unicode_from_windows_1250 = cvar.fz_unicode_from_windows_1250
fz_unicode_from_windows_1251 = cvar.fz_unicode_from_windows_1251
fz_unicode_from_windows_1252 = cvar.fz_unicode_from_windows_1252

FZ_ADOBE_CNS = _mupdf.FZ_ADOBE_CNS
FZ_ADOBE_GB = _mupdf.FZ_ADOBE_GB
FZ_ADOBE_JAPAN = _mupdf.FZ_ADOBE_JAPAN
FZ_ADOBE_KOREA = _mupdf.FZ_ADOBE_KOREA
class fz_font_flags_t(object):
    r"""
    Every fz_font carries a set of flags
    within it, in a fz_font_flags_t structure.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_mono = property(_mupdf.fz_font_flags_t_is_mono_get, _mupdf.fz_font_flags_t_is_mono_set)
    is_serif = property(_mupdf.fz_font_flags_t_is_serif_get, _mupdf.fz_font_flags_t_is_serif_set)
    is_bold = property(_mupdf.fz_font_flags_t_is_bold_get, _mupdf.fz_font_flags_t_is_bold_set)
    is_italic = property(_mupdf.fz_font_flags_t_is_italic_get, _mupdf.fz_font_flags_t_is_italic_set)
    ft_substitute = property(_mupdf.fz_font_flags_t_ft_substitute_get, _mupdf.fz_font_flags_t_ft_substitute_set)
    ft_stretch = property(_mupdf.fz_font_flags_t_ft_stretch_get, _mupdf.fz_font_flags_t_ft_stretch_set)
    fake_bold = property(_mupdf.fz_font_flags_t_fake_bold_get, _mupdf.fz_font_flags_t_fake_bold_set)
    fake_italic = property(_mupdf.fz_font_flags_t_fake_italic_get, _mupdf.fz_font_flags_t_fake_italic_set)
    has_opentype = property(_mupdf.fz_font_flags_t_has_opentype_get, _mupdf.fz_font_flags_t_has_opentype_set)
    invalid_bbox = property(_mupdf.fz_font_flags_t_invalid_bbox_get, _mupdf.fz_font_flags_t_invalid_bbox_set)
    cjk = property(_mupdf.fz_font_flags_t_cjk_get, _mupdf.fz_font_flags_t_cjk_set)
    cjk_lang = property(_mupdf.fz_font_flags_t_cjk_lang_get, _mupdf.fz_font_flags_t_cjk_lang_set)
    embed = property(_mupdf.fz_font_flags_t_embed_get, _mupdf.fz_font_flags_t_embed_set)
    never_embed = property(_mupdf.fz_font_flags_t_never_embed_get, _mupdf.fz_font_flags_t_never_embed_set)

    def __init__(self):
        _mupdf.fz_font_flags_t_swiginit(self, _mupdf.new_fz_font_flags_t())
    __swig_destroy__ = _mupdf.delete_fz_font_flags_t

# Register fz_font_flags_t in _mupdf:
_mupdf.fz_font_flags_t_swigregister(fz_font_flags_t)
class fz_shaper_data_t(object):
    r"""
    In order to shape a given font, we need to
    declare it to a shaper library (harfbuzz, by default, but others
    are possible). To avoid redeclaring it every time we need to
    shape, we hold a shaper handle and the destructor for it within
    the font itself. The handle is initialised by the caller when
    first required and the destructor is called when the fz_font is
    destroyed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    shaper_handle = property(_mupdf.fz_shaper_data_t_shaper_handle_get, _mupdf.fz_shaper_data_t_shaper_handle_set)
    destroy = property(_mupdf.fz_shaper_data_t_destroy_get, _mupdf.fz_shaper_data_t_destroy_set)

    def __init__(self):
        _mupdf.fz_shaper_data_t_swiginit(self, _mupdf.new_fz_shaper_data_t())
    __swig_destroy__ = _mupdf.delete_fz_shaper_data_t

# Register fz_shaper_data_t in _mupdf:
_mupdf.fz_shaper_data_t_swigregister(fz_shaper_data_t)
class fz_font(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_font_refs_get, _mupdf.fz_font_refs_set)
    name = property(_mupdf.fz_font_name_get, _mupdf.fz_font_name_set)
    buffer = property(_mupdf.fz_font_buffer_get, _mupdf.fz_font_buffer_set)
    flags = property(_mupdf.fz_font_flags_get, _mupdf.fz_font_flags_set)
    ft_face = property(_mupdf.fz_font_ft_face_get, _mupdf.fz_font_ft_face_set)
    shaper_data = property(_mupdf.fz_font_shaper_data_get, _mupdf.fz_font_shaper_data_set)
    t3matrix = property(_mupdf.fz_font_t3matrix_get, _mupdf.fz_font_t3matrix_set)
    t3resources = property(_mupdf.fz_font_t3resources_get, _mupdf.fz_font_t3resources_set)
    t3procs = property(_mupdf.fz_font_t3procs_get, _mupdf.fz_font_t3procs_set)
    t3lists = property(_mupdf.fz_font_t3lists_get, _mupdf.fz_font_t3lists_set)
    t3widths = property(_mupdf.fz_font_t3widths_get, _mupdf.fz_font_t3widths_set)
    t3flags = property(_mupdf.fz_font_t3flags_get, _mupdf.fz_font_t3flags_set)
    t3doc = property(_mupdf.fz_font_t3doc_get, _mupdf.fz_font_t3doc_set)
    t3run = property(_mupdf.fz_font_t3run_get, _mupdf.fz_font_t3run_set)
    t3freeres = property(_mupdf.fz_font_t3freeres_get, _mupdf.fz_font_t3freeres_set)
    bbox = property(_mupdf.fz_font_bbox_get, _mupdf.fz_font_bbox_set)
    ascender = property(_mupdf.fz_font_ascender_get, _mupdf.fz_font_ascender_set)
    descender = property(_mupdf.fz_font_descender_get, _mupdf.fz_font_descender_set)
    glyph_count = property(_mupdf.fz_font_glyph_count_get, _mupdf.fz_font_glyph_count_set)
    bbox_table = property(_mupdf.fz_font_bbox_table_get, _mupdf.fz_font_bbox_table_set)
    use_glyph_bbox = property(_mupdf.fz_font_use_glyph_bbox_get, _mupdf.fz_font_use_glyph_bbox_set)
    width_count = property(_mupdf.fz_font_width_count_get, _mupdf.fz_font_width_count_set)
    width_default = property(_mupdf.fz_font_width_default_get, _mupdf.fz_font_width_default_set)
    width_table = property(_mupdf.fz_font_width_table_get, _mupdf.fz_font_width_table_set)
    advance_cache = property(_mupdf.fz_font_advance_cache_get, _mupdf.fz_font_advance_cache_set)
    encoding_cache = property(_mupdf.fz_font_encoding_cache_get, _mupdf.fz_font_encoding_cache_set)
    has_digest = property(_mupdf.fz_font_has_digest_get, _mupdf.fz_font_has_digest_set)
    digest = property(_mupdf.fz_font_digest_get, _mupdf.fz_font_digest_set)
    subfont = property(_mupdf.fz_font_subfont_get, _mupdf.fz_font_subfont_set)

    def __init__(self):
        _mupdf.fz_font_swiginit(self, _mupdf.new_fz_font())
    __swig_destroy__ = _mupdf.delete_fz_font

# Register fz_font in _mupdf:
_mupdf.fz_font_swigregister(fz_font)
FZ_LINECAP_BUTT = _mupdf.FZ_LINECAP_BUTT
FZ_LINECAP_ROUND = _mupdf.FZ_LINECAP_ROUND
FZ_LINECAP_SQUARE = _mupdf.FZ_LINECAP_SQUARE
FZ_LINECAP_TRIANGLE = _mupdf.FZ_LINECAP_TRIANGLE
FZ_LINEJOIN_MITER = _mupdf.FZ_LINEJOIN_MITER
FZ_LINEJOIN_ROUND = _mupdf.FZ_LINEJOIN_ROUND
FZ_LINEJOIN_BEVEL = _mupdf.FZ_LINEJOIN_BEVEL
FZ_LINEJOIN_MITER_XPS = _mupdf.FZ_LINEJOIN_MITER_XPS
class fz_stroke_state(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_stroke_state_refs_get, _mupdf.fz_stroke_state_refs_set)
    start_cap = property(_mupdf.fz_stroke_state_start_cap_get, _mupdf.fz_stroke_state_start_cap_set)
    dash_cap = property(_mupdf.fz_stroke_state_dash_cap_get, _mupdf.fz_stroke_state_dash_cap_set)
    end_cap = property(_mupdf.fz_stroke_state_end_cap_get, _mupdf.fz_stroke_state_end_cap_set)
    linejoin = property(_mupdf.fz_stroke_state_linejoin_get, _mupdf.fz_stroke_state_linejoin_set)
    linewidth = property(_mupdf.fz_stroke_state_linewidth_get, _mupdf.fz_stroke_state_linewidth_set)
    miterlimit = property(_mupdf.fz_stroke_state_miterlimit_get, _mupdf.fz_stroke_state_miterlimit_set)
    dash_phase = property(_mupdf.fz_stroke_state_dash_phase_get, _mupdf.fz_stroke_state_dash_phase_set)
    dash_len = property(_mupdf.fz_stroke_state_dash_len_get, _mupdf.fz_stroke_state_dash_len_set)
    dash_list = property(_mupdf.fz_stroke_state_dash_list_get, _mupdf.fz_stroke_state_dash_list_set)

    def __init__(self):
        _mupdf.fz_stroke_state_swiginit(self, _mupdf.new_fz_stroke_state())
    __swig_destroy__ = _mupdf.delete_fz_stroke_state

# Register fz_stroke_state in _mupdf:
_mupdf.fz_stroke_state_swigregister(fz_stroke_state)
class fz_path_walker(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    moveto = property(_mupdf.fz_path_walker_moveto_get, _mupdf.fz_path_walker_moveto_set)
    lineto = property(_mupdf.fz_path_walker_lineto_get, _mupdf.fz_path_walker_lineto_set)
    curveto = property(_mupdf.fz_path_walker_curveto_get, _mupdf.fz_path_walker_curveto_set)
    closepath = property(_mupdf.fz_path_walker_closepath_get, _mupdf.fz_path_walker_closepath_set)
    quadto = property(_mupdf.fz_path_walker_quadto_get, _mupdf.fz_path_walker_quadto_set)
    curvetov = property(_mupdf.fz_path_walker_curvetov_get, _mupdf.fz_path_walker_curvetov_set)
    curvetoy = property(_mupdf.fz_path_walker_curvetoy_get, _mupdf.fz_path_walker_curvetoy_set)
    rectto = property(_mupdf.fz_path_walker_rectto_get, _mupdf.fz_path_walker_rectto_set)

    def __init__(self):
        _mupdf.fz_path_walker_swiginit(self, _mupdf.new_fz_path_walker())
    __swig_destroy__ = _mupdf.delete_fz_path_walker

# Register fz_path_walker in _mupdf:
_mupdf.fz_path_walker_swigregister(fz_path_walker)
class fz_text_item(object):
    r"""
    Text buffer.

    The trm field contains the a, b, c and d coefficients.
    The e and f coefficients come from the individual elements,
    together they form the transform matrix for the glyph.

    Glyphs are referenced by glyph ID.
    The Unicode text equivalent is kept in a separate array
    with indexes into the glyph array.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_text_item_x_get, _mupdf.fz_text_item_x_set)
    y = property(_mupdf.fz_text_item_y_get, _mupdf.fz_text_item_y_set)
    adv = property(_mupdf.fz_text_item_adv_get, _mupdf.fz_text_item_adv_set)
    gid = property(_mupdf.fz_text_item_gid_get, _mupdf.fz_text_item_gid_set)
    ucs = property(_mupdf.fz_text_item_ucs_get, _mupdf.fz_text_item_ucs_set)
    cid = property(_mupdf.fz_text_item_cid_get, _mupdf.fz_text_item_cid_set)

    def __init__(self):
        _mupdf.fz_text_item_swiginit(self, _mupdf.new_fz_text_item())
    __swig_destroy__ = _mupdf.delete_fz_text_item

# Register fz_text_item in _mupdf:
_mupdf.fz_text_item_swigregister(fz_text_item)
fz_default_stroke_state = cvar.fz_default_stroke_state

FZ_LANG_UNSET = _mupdf.FZ_LANG_UNSET
FZ_LANG_ur = _mupdf.FZ_LANG_ur
FZ_LANG_urd = _mupdf.FZ_LANG_urd
FZ_LANG_ko = _mupdf.FZ_LANG_ko
FZ_LANG_ja = _mupdf.FZ_LANG_ja
FZ_LANG_zh = _mupdf.FZ_LANG_zh
FZ_LANG_zh_Hans = _mupdf.FZ_LANG_zh_Hans
FZ_LANG_zh_Hant = _mupdf.FZ_LANG_zh_Hant
class fz_text_span(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    font = property(_mupdf.fz_text_span_font_get, _mupdf.fz_text_span_font_set)
    trm = property(_mupdf.fz_text_span_trm_get, _mupdf.fz_text_span_trm_set)
    wmode = property(_mupdf.fz_text_span_wmode_get, _mupdf.fz_text_span_wmode_set)
    bidi_level = property(_mupdf.fz_text_span_bidi_level_get, _mupdf.fz_text_span_bidi_level_set)
    markup_dir = property(_mupdf.fz_text_span_markup_dir_get, _mupdf.fz_text_span_markup_dir_set)
    language = property(_mupdf.fz_text_span_language_get, _mupdf.fz_text_span_language_set)
    len = property(_mupdf.fz_text_span_len_get, _mupdf.fz_text_span_len_set)
    cap = property(_mupdf.fz_text_span_cap_get, _mupdf.fz_text_span_cap_set)
    items = property(_mupdf.fz_text_span_items_get, _mupdf.fz_text_span_items_set)
    next = property(_mupdf.fz_text_span_next_get, _mupdf.fz_text_span_next_set)

    def __init__(self):
        _mupdf.fz_text_span_swiginit(self, _mupdf.new_fz_text_span())
    __swig_destroy__ = _mupdf.delete_fz_text_span

# Register fz_text_span in _mupdf:
_mupdf.fz_text_span_swigregister(fz_text_span)
class fz_text(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_text_refs_get, _mupdf.fz_text_refs_set)
    head = property(_mupdf.fz_text_head_get, _mupdf.fz_text_head_set)
    tail = property(_mupdf.fz_text_tail_get, _mupdf.fz_text_tail_set)

    def __init__(self):
        _mupdf.fz_text_swiginit(self, _mupdf.new_fz_text())
    __swig_destroy__ = _mupdf.delete_fz_text

# Register fz_text in _mupdf:
_mupdf.fz_text_swigregister(fz_text)
FZ_DEVFLAG_MASK = _mupdf.FZ_DEVFLAG_MASK
FZ_DEVFLAG_COLOR = _mupdf.FZ_DEVFLAG_COLOR
FZ_DEVFLAG_UNCACHEABLE = _mupdf.FZ_DEVFLAG_UNCACHEABLE
FZ_DEVFLAG_FILLCOLOR_UNDEFINED = _mupdf.FZ_DEVFLAG_FILLCOLOR_UNDEFINED
FZ_DEVFLAG_STROKECOLOR_UNDEFINED = _mupdf.FZ_DEVFLAG_STROKECOLOR_UNDEFINED
FZ_DEVFLAG_STARTCAP_UNDEFINED = _mupdf.FZ_DEVFLAG_STARTCAP_UNDEFINED
FZ_DEVFLAG_DASHCAP_UNDEFINED = _mupdf.FZ_DEVFLAG_DASHCAP_UNDEFINED
FZ_DEVFLAG_ENDCAP_UNDEFINED = _mupdf.FZ_DEVFLAG_ENDCAP_UNDEFINED
FZ_DEVFLAG_LINEJOIN_UNDEFINED = _mupdf.FZ_DEVFLAG_LINEJOIN_UNDEFINED
FZ_DEVFLAG_MITERLIMIT_UNDEFINED = _mupdf.FZ_DEVFLAG_MITERLIMIT_UNDEFINED
FZ_DEVFLAG_LINEWIDTH_UNDEFINED = _mupdf.FZ_DEVFLAG_LINEWIDTH_UNDEFINED
FZ_DEVFLAG_BBOX_DEFINED = _mupdf.FZ_DEVFLAG_BBOX_DEFINED
FZ_DEVFLAG_GRIDFIT_AS_TILED = _mupdf.FZ_DEVFLAG_GRIDFIT_AS_TILED
FZ_BLEND_NORMAL = _mupdf.FZ_BLEND_NORMAL
FZ_BLEND_MULTIPLY = _mupdf.FZ_BLEND_MULTIPLY
FZ_BLEND_SCREEN = _mupdf.FZ_BLEND_SCREEN
FZ_BLEND_OVERLAY = _mupdf.FZ_BLEND_OVERLAY
FZ_BLEND_DARKEN = _mupdf.FZ_BLEND_DARKEN
FZ_BLEND_LIGHTEN = _mupdf.FZ_BLEND_LIGHTEN
FZ_BLEND_COLOR_DODGE = _mupdf.FZ_BLEND_COLOR_DODGE
FZ_BLEND_COLOR_BURN = _mupdf.FZ_BLEND_COLOR_BURN
FZ_BLEND_HARD_LIGHT = _mupdf.FZ_BLEND_HARD_LIGHT
FZ_BLEND_SOFT_LIGHT = _mupdf.FZ_BLEND_SOFT_LIGHT
FZ_BLEND_DIFFERENCE = _mupdf.FZ_BLEND_DIFFERENCE
FZ_BLEND_EXCLUSION = _mupdf.FZ_BLEND_EXCLUSION
FZ_BLEND_HUE = _mupdf.FZ_BLEND_HUE
FZ_BLEND_SATURATION = _mupdf.FZ_BLEND_SATURATION
FZ_BLEND_COLOR = _mupdf.FZ_BLEND_COLOR
FZ_BLEND_LUMINOSITY = _mupdf.FZ_BLEND_LUMINOSITY
FZ_BLEND_MODEMASK = _mupdf.FZ_BLEND_MODEMASK
FZ_BLEND_ISOLATED = _mupdf.FZ_BLEND_ISOLATED
FZ_BLEND_KNOCKOUT = _mupdf.FZ_BLEND_KNOCKOUT
FZ_FUNCTION_MAX_N = _mupdf.FZ_FUNCTION_MAX_N
FZ_FUNCTION_MAX_M = _mupdf.FZ_FUNCTION_MAX_M
class fz_function(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.fz_function_storable_get, _mupdf.fz_function_storable_set)
    size = property(_mupdf.fz_function_size_get, _mupdf.fz_function_size_set)
    m = property(_mupdf.fz_function_m_get, _mupdf.fz_function_m_set)
    n = property(_mupdf.fz_function_n_get, _mupdf.fz_function_n_set)
    eval = property(_mupdf.fz_function_eval_get, _mupdf.fz_function_eval_set)

    def __init__(self):
        _mupdf.fz_function_swiginit(self, _mupdf.new_fz_function())
    __swig_destroy__ = _mupdf.delete_fz_function

# Register fz_function in _mupdf:
_mupdf.fz_function_swigregister(fz_function)
class fz_device_container_stack(object):
    r"""
    The device structure is public to allow devices to be
    implemented outside of fitz.

    Device methods should always be called using e.g.
    fz_fill_path(ctx, dev, ...) rather than
    dev->fill_path(ctx, dev, ...)

    Devices can keep track of containers (clips/masks/groups/tiles)
    as they go to save callers having to do it.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    scissor = property(_mupdf.fz_device_container_stack_scissor_get, _mupdf.fz_device_container_stack_scissor_set)
    type = property(_mupdf.fz_device_container_stack_type_get, _mupdf.fz_device_container_stack_type_set)
    user = property(_mupdf.fz_device_container_stack_user_get, _mupdf.fz_device_container_stack_user_set)

    def __init__(self):
        _mupdf.fz_device_container_stack_swiginit(self, _mupdf.new_fz_device_container_stack())
    __swig_destroy__ = _mupdf.delete_fz_device_container_stack

# Register fz_device_container_stack in _mupdf:
_mupdf.fz_device_container_stack_swigregister(fz_device_container_stack)
fz_device_container_stack_is_clip = _mupdf.fz_device_container_stack_is_clip
fz_device_container_stack_is_mask = _mupdf.fz_device_container_stack_is_mask
fz_device_container_stack_is_group = _mupdf.fz_device_container_stack_is_group
fz_device_container_stack_is_tile = _mupdf.fz_device_container_stack_is_tile
FZ_STRUCTURE_INVALID = _mupdf.FZ_STRUCTURE_INVALID
FZ_STRUCTURE_DOCUMENT = _mupdf.FZ_STRUCTURE_DOCUMENT
FZ_STRUCTURE_PART = _mupdf.FZ_STRUCTURE_PART
FZ_STRUCTURE_ART = _mupdf.FZ_STRUCTURE_ART
FZ_STRUCTURE_SECT = _mupdf.FZ_STRUCTURE_SECT
FZ_STRUCTURE_DIV = _mupdf.FZ_STRUCTURE_DIV
FZ_STRUCTURE_BLOCKQUOTE = _mupdf.FZ_STRUCTURE_BLOCKQUOTE
FZ_STRUCTURE_CAPTION = _mupdf.FZ_STRUCTURE_CAPTION
FZ_STRUCTURE_TOC = _mupdf.FZ_STRUCTURE_TOC
FZ_STRUCTURE_TOCI = _mupdf.FZ_STRUCTURE_TOCI
FZ_STRUCTURE_INDEX = _mupdf.FZ_STRUCTURE_INDEX
FZ_STRUCTURE_NONSTRUCT = _mupdf.FZ_STRUCTURE_NONSTRUCT
FZ_STRUCTURE_PRIVATE = _mupdf.FZ_STRUCTURE_PRIVATE
FZ_STRUCTURE_DOCUMENTFRAGMENT = _mupdf.FZ_STRUCTURE_DOCUMENTFRAGMENT
FZ_STRUCTURE_ASIDE = _mupdf.FZ_STRUCTURE_ASIDE
FZ_STRUCTURE_TITLE = _mupdf.FZ_STRUCTURE_TITLE
FZ_STRUCTURE_FENOTE = _mupdf.FZ_STRUCTURE_FENOTE
FZ_STRUCTURE_SUB = _mupdf.FZ_STRUCTURE_SUB
FZ_STRUCTURE_P = _mupdf.FZ_STRUCTURE_P
FZ_STRUCTURE_H = _mupdf.FZ_STRUCTURE_H
FZ_STRUCTURE_H1 = _mupdf.FZ_STRUCTURE_H1
FZ_STRUCTURE_H2 = _mupdf.FZ_STRUCTURE_H2
FZ_STRUCTURE_H3 = _mupdf.FZ_STRUCTURE_H3
FZ_STRUCTURE_H4 = _mupdf.FZ_STRUCTURE_H4
FZ_STRUCTURE_H5 = _mupdf.FZ_STRUCTURE_H5
FZ_STRUCTURE_H6 = _mupdf.FZ_STRUCTURE_H6
FZ_STRUCTURE_LIST = _mupdf.FZ_STRUCTURE_LIST
FZ_STRUCTURE_LISTITEM = _mupdf.FZ_STRUCTURE_LISTITEM
FZ_STRUCTURE_LABEL = _mupdf.FZ_STRUCTURE_LABEL
FZ_STRUCTURE_LISTBODY = _mupdf.FZ_STRUCTURE_LISTBODY
FZ_STRUCTURE_TABLE = _mupdf.FZ_STRUCTURE_TABLE
FZ_STRUCTURE_TR = _mupdf.FZ_STRUCTURE_TR
FZ_STRUCTURE_TH = _mupdf.FZ_STRUCTURE_TH
FZ_STRUCTURE_TD = _mupdf.FZ_STRUCTURE_TD
FZ_STRUCTURE_THEAD = _mupdf.FZ_STRUCTURE_THEAD
FZ_STRUCTURE_TBODY = _mupdf.FZ_STRUCTURE_TBODY
FZ_STRUCTURE_TFOOT = _mupdf.FZ_STRUCTURE_TFOOT
FZ_STRUCTURE_SPAN = _mupdf.FZ_STRUCTURE_SPAN
FZ_STRUCTURE_QUOTE = _mupdf.FZ_STRUCTURE_QUOTE
FZ_STRUCTURE_NOTE = _mupdf.FZ_STRUCTURE_NOTE
FZ_STRUCTURE_REFERENCE = _mupdf.FZ_STRUCTURE_REFERENCE
FZ_STRUCTURE_BIBENTRY = _mupdf.FZ_STRUCTURE_BIBENTRY
FZ_STRUCTURE_CODE = _mupdf.FZ_STRUCTURE_CODE
FZ_STRUCTURE_LINK = _mupdf.FZ_STRUCTURE_LINK
FZ_STRUCTURE_ANNOT = _mupdf.FZ_STRUCTURE_ANNOT
FZ_STRUCTURE_EM = _mupdf.FZ_STRUCTURE_EM
FZ_STRUCTURE_STRONG = _mupdf.FZ_STRUCTURE_STRONG
FZ_STRUCTURE_RUBY = _mupdf.FZ_STRUCTURE_RUBY
FZ_STRUCTURE_RB = _mupdf.FZ_STRUCTURE_RB
FZ_STRUCTURE_RT = _mupdf.FZ_STRUCTURE_RT
FZ_STRUCTURE_RP = _mupdf.FZ_STRUCTURE_RP
FZ_STRUCTURE_WARICHU = _mupdf.FZ_STRUCTURE_WARICHU
FZ_STRUCTURE_WT = _mupdf.FZ_STRUCTURE_WT
FZ_STRUCTURE_WP = _mupdf.FZ_STRUCTURE_WP
FZ_STRUCTURE_FIGURE = _mupdf.FZ_STRUCTURE_FIGURE
FZ_STRUCTURE_FORMULA = _mupdf.FZ_STRUCTURE_FORMULA
FZ_STRUCTURE_FORM = _mupdf.FZ_STRUCTURE_FORM
FZ_STRUCTURE_ARTIFACT = _mupdf.FZ_STRUCTURE_ARTIFACT
FZ_METATEXT_ACTUALTEXT = _mupdf.FZ_METATEXT_ACTUALTEXT
FZ_METATEXT_ALT = _mupdf.FZ_METATEXT_ALT
FZ_METATEXT_ABBREVIATION = _mupdf.FZ_METATEXT_ABBREVIATION
FZ_METATEXT_TITLE = _mupdf.FZ_METATEXT_TITLE
class fz_device(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_device_refs_get, _mupdf.fz_device_refs_set)
    hints = property(_mupdf.fz_device_hints_get, _mupdf.fz_device_hints_set)
    flags = property(_mupdf.fz_device_flags_get, _mupdf.fz_device_flags_set)
    close_device = property(_mupdf.fz_device_close_device_get, _mupdf.fz_device_close_device_set)
    drop_device = property(_mupdf.fz_device_drop_device_get, _mupdf.fz_device_drop_device_set)
    fill_path = property(_mupdf.fz_device_fill_path_get, _mupdf.fz_device_fill_path_set)
    stroke_path = property(_mupdf.fz_device_stroke_path_get, _mupdf.fz_device_stroke_path_set)
    clip_path = property(_mupdf.fz_device_clip_path_get, _mupdf.fz_device_clip_path_set)
    clip_stroke_path = property(_mupdf.fz_device_clip_stroke_path_get, _mupdf.fz_device_clip_stroke_path_set)
    fill_text = property(_mupdf.fz_device_fill_text_get, _mupdf.fz_device_fill_text_set)
    stroke_text = property(_mupdf.fz_device_stroke_text_get, _mupdf.fz_device_stroke_text_set)
    clip_text = property(_mupdf.fz_device_clip_text_get, _mupdf.fz_device_clip_text_set)
    clip_stroke_text = property(_mupdf.fz_device_clip_stroke_text_get, _mupdf.fz_device_clip_stroke_text_set)
    ignore_text = property(_mupdf.fz_device_ignore_text_get, _mupdf.fz_device_ignore_text_set)
    fill_shade = property(_mupdf.fz_device_fill_shade_get, _mupdf.fz_device_fill_shade_set)
    fill_image = property(_mupdf.fz_device_fill_image_get, _mupdf.fz_device_fill_image_set)
    fill_image_mask = property(_mupdf.fz_device_fill_image_mask_get, _mupdf.fz_device_fill_image_mask_set)
    clip_image_mask = property(_mupdf.fz_device_clip_image_mask_get, _mupdf.fz_device_clip_image_mask_set)
    pop_clip = property(_mupdf.fz_device_pop_clip_get, _mupdf.fz_device_pop_clip_set)
    begin_mask = property(_mupdf.fz_device_begin_mask_get, _mupdf.fz_device_begin_mask_set)
    end_mask = property(_mupdf.fz_device_end_mask_get, _mupdf.fz_device_end_mask_set)
    begin_group = property(_mupdf.fz_device_begin_group_get, _mupdf.fz_device_begin_group_set)
    end_group = property(_mupdf.fz_device_end_group_get, _mupdf.fz_device_end_group_set)
    begin_tile = property(_mupdf.fz_device_begin_tile_get, _mupdf.fz_device_begin_tile_set)
    end_tile = property(_mupdf.fz_device_end_tile_get, _mupdf.fz_device_end_tile_set)
    render_flags = property(_mupdf.fz_device_render_flags_get, _mupdf.fz_device_render_flags_set)
    set_default_colorspaces = property(_mupdf.fz_device_set_default_colorspaces_get, _mupdf.fz_device_set_default_colorspaces_set)
    begin_layer = property(_mupdf.fz_device_begin_layer_get, _mupdf.fz_device_begin_layer_set)
    end_layer = property(_mupdf.fz_device_end_layer_get, _mupdf.fz_device_end_layer_set)
    begin_structure = property(_mupdf.fz_device_begin_structure_get, _mupdf.fz_device_begin_structure_set)
    end_structure = property(_mupdf.fz_device_end_structure_get, _mupdf.fz_device_end_structure_set)
    begin_metatext = property(_mupdf.fz_device_begin_metatext_get, _mupdf.fz_device_begin_metatext_set)
    end_metatext = property(_mupdf.fz_device_end_metatext_get, _mupdf.fz_device_end_metatext_set)
    d1_rect = property(_mupdf.fz_device_d1_rect_get, _mupdf.fz_device_d1_rect_set)
    container_len = property(_mupdf.fz_device_container_len_get, _mupdf.fz_device_container_len_set)
    container_cap = property(_mupdf.fz_device_container_cap_get, _mupdf.fz_device_container_cap_set)
    container = property(_mupdf.fz_device_container_get, _mupdf.fz_device_container_set)

    def __init__(self):
        _mupdf.fz_device_swiginit(self, _mupdf.new_fz_device())
    __swig_destroy__ = _mupdf.delete_fz_device

# Register fz_device in _mupdf:
_mupdf.fz_device_swigregister(fz_device)
FZ_DONT_INTERPOLATE_IMAGES = _mupdf.FZ_DONT_INTERPOLATE_IMAGES
FZ_NO_CACHE = _mupdf.FZ_NO_CACHE
FZ_DONT_DECODE_IMAGES = _mupdf.FZ_DONT_DECODE_IMAGES
class fz_cookie(object):
    r"""
    Cookie support - simple communication channel between app/library.

    Provide two-way communication between application and library.
    Intended for multi-threaded applications where one thread is
    rendering pages and another thread wants to read progress
    feedback or abort a job that takes a long time to finish. The
    communication is unsynchronized without locking.

    abort: The application should set this field to 0 before
    calling fz_run_page to render a page. At any point when the
    page is being rendered the application my set this field to 1
    which will cause the rendering to finish soon. This field is
    checked periodically when the page is rendered, but exactly
    when is not known, therefore there is no upper bound on
    exactly when the rendering will abort. If the application
    did not provide a set of locks to fz_new_context, it must also
    await the completion of fz_run_page before issuing another
    call to fz_run_page. Note that once the application has set
    this field to 1 after it called fz_run_page it may not change
    the value again.

    progress: Communicates rendering progress back to the
    application and is read only. Increments as a page is being
    rendered. The value starts out at 0 and is limited to less
    than or equal to progress_max, unless progress_max is -1.

    progress_max: Communicates the known upper bound of rendering
    back to the application and is read only. The maximum value
    that the progress field may take. If there is no known upper
    bound on how long the rendering may take this value is -1 and
    progress is not limited. Note that the value of progress_max
    may change from -1 to a positive value once an upper bound is
    known, so take this into consideration when comparing the
    value of progress to that of progress_max.

    errors: count of errors during current rendering.

    incomplete: Initially should be set to 0. Will be set to
    non-zero if a TRYLATER error is thrown during rendering.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    abort = property(_mupdf.fz_cookie_abort_get, _mupdf.fz_cookie_abort_set)
    progress = property(_mupdf.fz_cookie_progress_get, _mupdf.fz_cookie_progress_set)
    progress_max = property(_mupdf.fz_cookie_progress_max_get, _mupdf.fz_cookie_progress_max_set)
    errors = property(_mupdf.fz_cookie_errors_get, _mupdf.fz_cookie_errors_set)
    incomplete = property(_mupdf.fz_cookie_incomplete_get, _mupdf.fz_cookie_incomplete_set)

    def __init__(self):
        _mupdf.fz_cookie_swiginit(self, _mupdf.new_fz_cookie())
    __swig_destroy__ = _mupdf.delete_fz_cookie

# Register fz_cookie in _mupdf:
_mupdf.fz_cookie_swigregister(fz_cookie)
FZ_TEST_OPT_IMAGES = _mupdf.FZ_TEST_OPT_IMAGES
FZ_TEST_OPT_SHADINGS = _mupdf.FZ_TEST_OPT_SHADINGS
class fz_draw_options(object):
    r"""
    struct fz_draw_options: Options for creating a pixmap and draw
    device.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rotate = property(_mupdf.fz_draw_options_rotate_get, _mupdf.fz_draw_options_rotate_set)
    x_resolution = property(_mupdf.fz_draw_options_x_resolution_get, _mupdf.fz_draw_options_x_resolution_set)
    y_resolution = property(_mupdf.fz_draw_options_y_resolution_get, _mupdf.fz_draw_options_y_resolution_set)
    width = property(_mupdf.fz_draw_options_width_get, _mupdf.fz_draw_options_width_set)
    height = property(_mupdf.fz_draw_options_height_get, _mupdf.fz_draw_options_height_set)
    colorspace = property(_mupdf.fz_draw_options_colorspace_get, _mupdf.fz_draw_options_colorspace_set)
    alpha = property(_mupdf.fz_draw_options_alpha_get, _mupdf.fz_draw_options_alpha_set)
    graphics = property(_mupdf.fz_draw_options_graphics_get, _mupdf.fz_draw_options_graphics_set)
    text = property(_mupdf.fz_draw_options_text_get, _mupdf.fz_draw_options_text_set)

    def __init__(self):
        _mupdf.fz_draw_options_swiginit(self, _mupdf.new_fz_draw_options())
    __swig_destroy__ = _mupdf.delete_fz_draw_options

# Register fz_draw_options in _mupdf:
_mupdf.fz_draw_options_swigregister(fz_draw_options)
class fz_location(object):
    r"""
    Locations within the document are referred to in terms of
    chapter and page, rather than just a page number. For some
    documents (such as epub documents with large numbers of pages
    broken into many chapters) this can make navigation much faster
    as only the required chapter needs to be decoded at a time.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    chapter = property(_mupdf.fz_location_chapter_get, _mupdf.fz_location_chapter_set)
    page = property(_mupdf.fz_location_page_get, _mupdf.fz_location_page_set)

    def __init__(self):
        _mupdf.fz_location_swiginit(self, _mupdf.new_fz_location())
    __swig_destroy__ = _mupdf.delete_fz_location

# Register fz_location in _mupdf:
_mupdf.fz_location_swigregister(fz_location)
class fz_layout_char(object):
    r"""Simple text layout (for use with annotation editing primarily)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_layout_char_x_get, _mupdf.fz_layout_char_x_set)
    advance = property(_mupdf.fz_layout_char_advance_get, _mupdf.fz_layout_char_advance_set)
    p = property(_mupdf.fz_layout_char_p_get, _mupdf.fz_layout_char_p_set)
    next = property(_mupdf.fz_layout_char_next_get, _mupdf.fz_layout_char_next_set)

    def __init__(self):
        _mupdf.fz_layout_char_swiginit(self, _mupdf.new_fz_layout_char())
    __swig_destroy__ = _mupdf.delete_fz_layout_char

# Register fz_layout_char in _mupdf:
_mupdf.fz_layout_char_swigregister(fz_layout_char)
class fz_layout_line(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_layout_line_x_get, _mupdf.fz_layout_line_x_set)
    y = property(_mupdf.fz_layout_line_y_get, _mupdf.fz_layout_line_y_set)
    font_size = property(_mupdf.fz_layout_line_font_size_get, _mupdf.fz_layout_line_font_size_set)
    p = property(_mupdf.fz_layout_line_p_get, _mupdf.fz_layout_line_p_set)
    text = property(_mupdf.fz_layout_line_text_get, _mupdf.fz_layout_line_text_set)
    next = property(_mupdf.fz_layout_line_next_get, _mupdf.fz_layout_line_next_set)

    def __init__(self):
        _mupdf.fz_layout_line_swiginit(self, _mupdf.new_fz_layout_line())
    __swig_destroy__ = _mupdf.delete_fz_layout_line

# Register fz_layout_line in _mupdf:
_mupdf.fz_layout_line_swigregister(fz_layout_line)
class fz_layout_block(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pool = property(_mupdf.fz_layout_block_pool_get, _mupdf.fz_layout_block_pool_set)
    matrix = property(_mupdf.fz_layout_block_matrix_get, _mupdf.fz_layout_block_matrix_set)
    inv_matrix = property(_mupdf.fz_layout_block_inv_matrix_get, _mupdf.fz_layout_block_inv_matrix_set)
    head = property(_mupdf.fz_layout_block_head_get, _mupdf.fz_layout_block_head_set)
    tailp = property(_mupdf.fz_layout_block_tailp_get, _mupdf.fz_layout_block_tailp_set)
    text_tailp = property(_mupdf.fz_layout_block_text_tailp_get, _mupdf.fz_layout_block_text_tailp_set)

    def __init__(self):
        _mupdf.fz_layout_block_swiginit(self, _mupdf.new_fz_layout_block())
    __swig_destroy__ = _mupdf.delete_fz_layout_block

# Register fz_layout_block in _mupdf:
_mupdf.fz_layout_block_swigregister(fz_layout_block)
FZ_STEXT_PRESERVE_LIGATURES = _mupdf.FZ_STEXT_PRESERVE_LIGATURES
FZ_STEXT_PRESERVE_WHITESPACE = _mupdf.FZ_STEXT_PRESERVE_WHITESPACE
FZ_STEXT_PRESERVE_IMAGES = _mupdf.FZ_STEXT_PRESERVE_IMAGES
FZ_STEXT_INHIBIT_SPACES = _mupdf.FZ_STEXT_INHIBIT_SPACES
FZ_STEXT_DEHYPHENATE = _mupdf.FZ_STEXT_DEHYPHENATE
FZ_STEXT_PRESERVE_SPANS = _mupdf.FZ_STEXT_PRESERVE_SPANS
FZ_STEXT_CLIP = _mupdf.FZ_STEXT_CLIP
FZ_STEXT_USE_CID_FOR_UNKNOWN_UNICODE = _mupdf.FZ_STEXT_USE_CID_FOR_UNKNOWN_UNICODE
FZ_STEXT_COLLECT_STRUCTURE = _mupdf.FZ_STEXT_COLLECT_STRUCTURE
FZ_STEXT_ACCURATE_BBOXES = _mupdf.FZ_STEXT_ACCURATE_BBOXES
FZ_STEXT_COLLECT_VECTORS = _mupdf.FZ_STEXT_COLLECT_VECTORS
FZ_STEXT_IGNORE_ACTUALTEXT = _mupdf.FZ_STEXT_IGNORE_ACTUALTEXT
FZ_STEXT_SEGMENT = _mupdf.FZ_STEXT_SEGMENT
FZ_STEXT_MEDIABOX_CLIP = _mupdf.FZ_STEXT_MEDIABOX_CLIP
class fz_stext_page(object):
    r"""
    A note on stext's handling of structure.

    A PDF document can contain a structure tree. This gives the
    structure of a document in its entirety as a tree. e.g.

    Tree			MCID	INDEX
    -------------------------------------
    DOC			0	0
     TOC			1	0
      TOC_ITEM		2	0
      TOC_ITEM		3	1
      TOC_ITEM		4	2
      ...
     STORY			100	1
      SECTION		101	0
       HEADING		102	0
       SUBSECTION		103	1
        PARAGRAPH		104	0
        PARAGRAPH		105	1
        PARAGRAPH		106	2
       SUBSECTION		107	2
        PARAGRAPH		108	0
        PARAGRAPH		109	1
        PARAGRAPH		110	2
       ...
      SECTION		200	1
        ...

    Each different section of the tree is identified as part of an
    MCID by a number (this is a slight simplification, but makes the
    explanation easier).

    The PDF document contains markings that say "Entering MCID 0"
    and "Leaving MCID 0". Any content within that region is therefore
    identified as appearing in that particular structural region.

    This means that content can be sent in the document in a different
    order to which it appears 'logically' in the tree.

    MuPDF converts this tree form into a nested series of calls to
    begin_structure and end_structure.

    For instance, if the document started out with MCID 100, then
    we'd send:
    	begin_structure("DOC")
    	begin_structure("STORY")

    The problem with this is that if we send:
    	begin_structure("DOC")
    	begin_structure("STORY")
    	begin_structure("SECTION")
    	begin_structure("SUBSECTION")

    or
    	begin_structure("DOC")
    	begin_structure("STORY")
    	begin_structure("SECTION")
    	begin_structure("HEADING")

    How do I know what order the SECTION and HEADING should appear in?
    Are they even in the same STORY? Or the same DOC?

    Accordingly, every begin_structure is accompanied not only with the
    node type, but with an index. The index is the number of this node
    within this level of the tree. Hence:

    	begin_structure("DOC", 0)
    	begin_structure("STORY", 0)
    	begin_structure("SECTION", 0)
    	begin_structure("HEADING", 0)
    and
    	begin_structure("DOC", 0)
    	begin_structure("STORY", 0)
    	begin_structure("SECTION", 0)
    	begin_structure("SUBSECTION", 1)

    are now unambiguous in their describing of the tree.

    MuPDF automatically sends the minimal end_structure/begin_structure
    pairs to move us between nodes in the tree.

    In order to accomodate this information within the structured text
    data structures an additional block type is used. Previously a
    "page" was just a list of blocks, either text or images. e.g.

    [BLOCK:TEXT] <-> [BLOCK:IMG] <-> [BLOCK:TEXT] <-> [BLOCK:TEXT] ...

    We now introduce a new type of block, STRUCT, that turns this into
    a tree:

    [BLOCK:TEXT] <-> [BLOCK:STRUCT(IDX=0)] <-> [BLOCK:TEXT] <-> ...
                          /|
    [STRUCT:TYPE=DOC] <----
        |
    [BLOCK:TEXT] <-> [BLOCK:STRUCT(IDX=0)] <-> [BLOCK:TEXT] <-> ...
                          /|
    [STRUCT:TYPE=STORY] <--
        |
       ...

    Rather than doing a simple linear traversal of the list to extract
    the logical data, a caller now has to do a depth-first traversal.

    A text page is a list of blocks, together with an overall
    bounding box.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pool = property(_mupdf.fz_stext_page_pool_get, _mupdf.fz_stext_page_pool_set)
    mediabox = property(_mupdf.fz_stext_page_mediabox_get, _mupdf.fz_stext_page_mediabox_set)
    first_block = property(_mupdf.fz_stext_page_first_block_get, _mupdf.fz_stext_page_first_block_set)
    last_block = property(_mupdf.fz_stext_page_last_block_get, _mupdf.fz_stext_page_last_block_set)
    last_struct = property(_mupdf.fz_stext_page_last_struct_get, _mupdf.fz_stext_page_last_struct_set)

    def __init__(self):
        _mupdf.fz_stext_page_swiginit(self, _mupdf.new_fz_stext_page())
    __swig_destroy__ = _mupdf.delete_fz_stext_page

# Register fz_stext_page in _mupdf:
_mupdf.fz_stext_page_swigregister(fz_stext_page)
FZ_STEXT_BLOCK_TEXT = _mupdf.FZ_STEXT_BLOCK_TEXT
FZ_STEXT_BLOCK_IMAGE = _mupdf.FZ_STEXT_BLOCK_IMAGE
FZ_STEXT_BLOCK_STRUCT = _mupdf.FZ_STEXT_BLOCK_STRUCT
FZ_STEXT_BLOCK_VECTOR = _mupdf.FZ_STEXT_BLOCK_VECTOR
FZ_STEXT_BLOCK_GRID = _mupdf.FZ_STEXT_BLOCK_GRID
class fz_stext_block(object):
    r"""
    A text block is a list of lines of text (typically a paragraph),
    or an image.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.fz_stext_block_type_get, _mupdf.fz_stext_block_type_set)
    bbox = property(_mupdf.fz_stext_block_bbox_get, _mupdf.fz_stext_block_bbox_set)
    prev = property(_mupdf.fz_stext_block_prev_get, _mupdf.fz_stext_block_prev_set)
    next = property(_mupdf.fz_stext_block_next_get, _mupdf.fz_stext_block_next_set)

    def __init__(self):
        _mupdf.fz_stext_block_swiginit(self, _mupdf.new_fz_stext_block())
    __swig_destroy__ = _mupdf.delete_fz_stext_block

# Register fz_stext_block in _mupdf:
_mupdf.fz_stext_block_swigregister(fz_stext_block)
class fz_stext_line(object):
    r"""A text line is a list of characters that share a common baseline."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    wmode = property(_mupdf.fz_stext_line_wmode_get, _mupdf.fz_stext_line_wmode_set)
    dir = property(_mupdf.fz_stext_line_dir_get, _mupdf.fz_stext_line_dir_set)
    bbox = property(_mupdf.fz_stext_line_bbox_get, _mupdf.fz_stext_line_bbox_set)
    first_char = property(_mupdf.fz_stext_line_first_char_get, _mupdf.fz_stext_line_first_char_set)
    last_char = property(_mupdf.fz_stext_line_last_char_get, _mupdf.fz_stext_line_last_char_set)
    prev = property(_mupdf.fz_stext_line_prev_get, _mupdf.fz_stext_line_prev_set)
    next = property(_mupdf.fz_stext_line_next_get, _mupdf.fz_stext_line_next_set)

    def __init__(self):
        _mupdf.fz_stext_line_swiginit(self, _mupdf.new_fz_stext_line())
    __swig_destroy__ = _mupdf.delete_fz_stext_line

# Register fz_stext_line in _mupdf:
_mupdf.fz_stext_line_swigregister(fz_stext_line)
class fz_stext_char(object):
    r"""
    A text char is a unicode character, the style in which is
    appears, and the point at which it is positioned.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    c = property(_mupdf.fz_stext_char_c_get, _mupdf.fz_stext_char_c_set)
    bidi = property(_mupdf.fz_stext_char_bidi_get, _mupdf.fz_stext_char_bidi_set)
    flags = property(_mupdf.fz_stext_char_flags_get, _mupdf.fz_stext_char_flags_set)
    argb = property(_mupdf.fz_stext_char_argb_get, _mupdf.fz_stext_char_argb_set)
    origin = property(_mupdf.fz_stext_char_origin_get, _mupdf.fz_stext_char_origin_set)
    quad = property(_mupdf.fz_stext_char_quad_get, _mupdf.fz_stext_char_quad_set)
    size = property(_mupdf.fz_stext_char_size_get, _mupdf.fz_stext_char_size_set)
    font = property(_mupdf.fz_stext_char_font_get, _mupdf.fz_stext_char_font_set)
    next = property(_mupdf.fz_stext_char_next_get, _mupdf.fz_stext_char_next_set)

    def __init__(self):
        _mupdf.fz_stext_char_swiginit(self, _mupdf.new_fz_stext_char())
    __swig_destroy__ = _mupdf.delete_fz_stext_char

# Register fz_stext_char in _mupdf:
_mupdf.fz_stext_char_swigregister(fz_stext_char)
FZ_STEXT_STRIKEOUT = _mupdf.FZ_STEXT_STRIKEOUT
FZ_STEXT_UNDERLINE = _mupdf.FZ_STEXT_UNDERLINE
FZ_STEXT_SYNTHETIC = _mupdf.FZ_STEXT_SYNTHETIC
FZ_STEXT_FILLED = _mupdf.FZ_STEXT_FILLED
FZ_STEXT_STROKED = _mupdf.FZ_STEXT_STROKED
FZ_STEXT_CLIPPED = _mupdf.FZ_STEXT_CLIPPED
class fz_stext_struct(object):
    r"""
    When we are collecting the structure information from
    PDF structure trees/tags, we end up with a tree of
    nodes. The structure should be walked in depth-first
    traversal order to extract the content.

    An fz_stext_struct pointer can be NULL to indicate that
    we know there is a child there within the complete tree,
    but we don't know what it is yet.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    up = property(_mupdf.fz_stext_struct_up_get, _mupdf.fz_stext_struct_up_set)
    parent = property(_mupdf.fz_stext_struct_parent_get, _mupdf.fz_stext_struct_parent_set)
    first_block = property(_mupdf.fz_stext_struct_first_block_get, _mupdf.fz_stext_struct_first_block_set)
    last_block = property(_mupdf.fz_stext_struct_last_block_get, _mupdf.fz_stext_struct_last_block_set)
    standard = property(_mupdf.fz_stext_struct_standard_get, _mupdf.fz_stext_struct_standard_set)
    raw = property(_mupdf.fz_stext_struct_raw_get, _mupdf.fz_stext_struct_raw_set)

    def __init__(self):
        _mupdf.fz_stext_struct_swiginit(self, _mupdf.new_fz_stext_struct())
    __swig_destroy__ = _mupdf.delete_fz_stext_struct

# Register fz_stext_struct in _mupdf:
_mupdf.fz_stext_struct_swigregister(fz_stext_struct)
class fz_stext_grid_positions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.fz_stext_grid_positions_len_get, _mupdf.fz_stext_grid_positions_len_set)
    max_uncertainty = property(_mupdf.fz_stext_grid_positions_max_uncertainty_get, _mupdf.fz_stext_grid_positions_max_uncertainty_set)

    def __init__(self):
        _mupdf.fz_stext_grid_positions_swiginit(self, _mupdf.new_fz_stext_grid_positions())
    __swig_destroy__ = _mupdf.delete_fz_stext_grid_positions

# Register fz_stext_grid_positions in _mupdf:
_mupdf.fz_stext_grid_positions_swigregister(fz_stext_grid_positions)
FZ_SELECT_CHARS = _mupdf.FZ_SELECT_CHARS
FZ_SELECT_WORDS = _mupdf.FZ_SELECT_WORDS
FZ_SELECT_LINES = _mupdf.FZ_SELECT_LINES
class fz_stext_options(object):
    r"""Options for creating structured text."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flags = property(_mupdf.fz_stext_options_flags_get, _mupdf.fz_stext_options_flags_set)
    scale = property(_mupdf.fz_stext_options_scale_get, _mupdf.fz_stext_options_scale_set)

    def __init__(self):
        _mupdf.fz_stext_options_swiginit(self, _mupdf.new_fz_stext_options())
    __swig_destroy__ = _mupdf.delete_fz_stext_options

# Register fz_stext_options in _mupdf:
_mupdf.fz_stext_options_swigregister(fz_stext_options)
FZ_TRANSITION_NONE = _mupdf.FZ_TRANSITION_NONE
FZ_TRANSITION_SPLIT = _mupdf.FZ_TRANSITION_SPLIT
FZ_TRANSITION_BLINDS = _mupdf.FZ_TRANSITION_BLINDS
FZ_TRANSITION_BOX = _mupdf.FZ_TRANSITION_BOX
FZ_TRANSITION_WIPE = _mupdf.FZ_TRANSITION_WIPE
FZ_TRANSITION_DISSOLVE = _mupdf.FZ_TRANSITION_DISSOLVE
FZ_TRANSITION_GLITTER = _mupdf.FZ_TRANSITION_GLITTER
FZ_TRANSITION_FLY = _mupdf.FZ_TRANSITION_FLY
FZ_TRANSITION_PUSH = _mupdf.FZ_TRANSITION_PUSH
FZ_TRANSITION_COVER = _mupdf.FZ_TRANSITION_COVER
FZ_TRANSITION_UNCOVER = _mupdf.FZ_TRANSITION_UNCOVER
FZ_TRANSITION_FADE = _mupdf.FZ_TRANSITION_FADE
class fz_transition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.fz_transition_type_get, _mupdf.fz_transition_type_set)
    duration = property(_mupdf.fz_transition_duration_get, _mupdf.fz_transition_duration_set)
    vertical = property(_mupdf.fz_transition_vertical_get, _mupdf.fz_transition_vertical_set)
    outwards = property(_mupdf.fz_transition_outwards_get, _mupdf.fz_transition_outwards_set)
    direction = property(_mupdf.fz_transition_direction_get, _mupdf.fz_transition_direction_set)
    state0 = property(_mupdf.fz_transition_state0_get, _mupdf.fz_transition_state0_set)
    state1 = property(_mupdf.fz_transition_state1_get, _mupdf.fz_transition_state1_set)

    def __init__(self):
        _mupdf.fz_transition_swiginit(self, _mupdf.new_fz_transition())
    __swig_destroy__ = _mupdf.delete_fz_transition

# Register fz_transition in _mupdf:
_mupdf.fz_transition_swigregister(fz_transition)
class fz_link(object):
    r"""
    fz_link is a list of interactive links on a page.

    There is no relation between the order of the links in the
    list and the order they appear on the page. The list of links
    for a given page can be obtained from fz_load_links.

    A link is reference counted. Dropping a reference to a link is
    done by calling fz_drop_link.

    rect: The hot zone. The area that can be clicked in
    untransformed coordinates.

    uri: Link destinations come in two forms: internal and external.
    Internal links refer to other pages in the same document.
    External links are URLs to other documents.

    next: A pointer to the next link on the same page.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_link_refs_get, _mupdf.fz_link_refs_set)
    next = property(_mupdf.fz_link_next_get, _mupdf.fz_link_next_set)
    rect = property(_mupdf.fz_link_rect_get, _mupdf.fz_link_rect_set)
    uri = property(_mupdf.fz_link_uri_get, _mupdf.fz_link_uri_set)
    set_rect_fn = property(_mupdf.fz_link_set_rect_fn_get, _mupdf.fz_link_set_rect_fn_set)
    set_uri_fn = property(_mupdf.fz_link_set_uri_fn_get, _mupdf.fz_link_set_uri_fn_set)
    drop = property(_mupdf.fz_link_drop_get, _mupdf.fz_link_drop_set)

    def __init__(self):
        _mupdf.fz_link_swiginit(self, _mupdf.new_fz_link())
    __swig_destroy__ = _mupdf.delete_fz_link

# Register fz_link in _mupdf:
_mupdf.fz_link_swigregister(fz_link)
FZ_LINK_DEST_FIT = _mupdf.FZ_LINK_DEST_FIT
FZ_LINK_DEST_FIT_B = _mupdf.FZ_LINK_DEST_FIT_B
FZ_LINK_DEST_FIT_H = _mupdf.FZ_LINK_DEST_FIT_H
FZ_LINK_DEST_FIT_BH = _mupdf.FZ_LINK_DEST_FIT_BH
FZ_LINK_DEST_FIT_V = _mupdf.FZ_LINK_DEST_FIT_V
FZ_LINK_DEST_FIT_BV = _mupdf.FZ_LINK_DEST_FIT_BV
FZ_LINK_DEST_FIT_R = _mupdf.FZ_LINK_DEST_FIT_R
FZ_LINK_DEST_XYZ = _mupdf.FZ_LINK_DEST_XYZ
class fz_link_dest(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    loc = property(_mupdf.fz_link_dest_loc_get, _mupdf.fz_link_dest_loc_set)
    type = property(_mupdf.fz_link_dest_type_get, _mupdf.fz_link_dest_type_set)
    x = property(_mupdf.fz_link_dest_x_get, _mupdf.fz_link_dest_x_set)
    y = property(_mupdf.fz_link_dest_y_get, _mupdf.fz_link_dest_y_set)
    w = property(_mupdf.fz_link_dest_w_get, _mupdf.fz_link_dest_w_set)
    h = property(_mupdf.fz_link_dest_h_get, _mupdf.fz_link_dest_h_set)
    zoom = property(_mupdf.fz_link_dest_zoom_get, _mupdf.fz_link_dest_zoom_set)

    def __init__(self):
        _mupdf.fz_link_dest_swiginit(self, _mupdf.new_fz_link_dest())
    __swig_destroy__ = _mupdf.delete_fz_link_dest

# Register fz_link_dest in _mupdf:
_mupdf.fz_link_dest_swigregister(fz_link_dest)
class fz_outline_item(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    title = property(_mupdf.fz_outline_item_title_get, _mupdf.fz_outline_item_title_set)
    uri = property(_mupdf.fz_outline_item_uri_get, _mupdf.fz_outline_item_uri_set)
    is_open = property(_mupdf.fz_outline_item_is_open_get, _mupdf.fz_outline_item_is_open_set)

    def __init__(self):
        _mupdf.fz_outline_item_swiginit(self, _mupdf.new_fz_outline_item())
    __swig_destroy__ = _mupdf.delete_fz_outline_item

# Register fz_outline_item in _mupdf:
_mupdf.fz_outline_item_swigregister(fz_outline_item)
class fz_outline(object):
    r"""
    Structure based API
    fz_outline is a tree of the outline of a document (also known
    as table of contents).

    title: Title of outline item using UTF-8 encoding. May be NULL
    if the outline item has no text string.

    uri: Destination in the document to be displayed when this
    outline item is activated. May be an internal or external
    link, or NULL if the outline item does not have a destination.

    page: The page number of an internal link, or -1 for external
    links or links with no destination.

    next: The next outline item at the same level as this outline
    item. May be NULL if no more outline items exist at this level.

    down: The outline items immediate children in the hierarchy.
    May be NULL if no children exist.

    is_open: If zero, the outline element is closed in the UI. If
    1, it should be open, showing any child elements. All other
    values reserved.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_outline_refs_get, _mupdf.fz_outline_refs_set)
    title = property(_mupdf.fz_outline_title_get, _mupdf.fz_outline_title_set)
    uri = property(_mupdf.fz_outline_uri_get, _mupdf.fz_outline_uri_set)
    page = property(_mupdf.fz_outline_page_get, _mupdf.fz_outline_page_set)
    x = property(_mupdf.fz_outline_x_get, _mupdf.fz_outline_x_set)
    y = property(_mupdf.fz_outline_y_get, _mupdf.fz_outline_y_set)
    next = property(_mupdf.fz_outline_next_get, _mupdf.fz_outline_next_set)
    down = property(_mupdf.fz_outline_down_get, _mupdf.fz_outline_down_set)
    is_open = property(_mupdf.fz_outline_is_open_get, _mupdf.fz_outline_is_open_set)

    def __init__(self):
        _mupdf.fz_outline_swiginit(self, _mupdf.new_fz_outline())
    __swig_destroy__ = _mupdf.delete_fz_outline

# Register fz_outline in _mupdf:
_mupdf.fz_outline_swigregister(fz_outline)
class fz_outline_iterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.fz_outline_iterator_drop_get, _mupdf.fz_outline_iterator_drop_set)
    item = property(_mupdf.fz_outline_iterator_item_get, _mupdf.fz_outline_iterator_item_set)
    next = property(_mupdf.fz_outline_iterator_next_get, _mupdf.fz_outline_iterator_next_set)
    prev = property(_mupdf.fz_outline_iterator_prev_get, _mupdf.fz_outline_iterator_prev_set)
    up = property(_mupdf.fz_outline_iterator_up_get, _mupdf.fz_outline_iterator_up_set)
    down = property(_mupdf.fz_outline_iterator_down_get, _mupdf.fz_outline_iterator_down_set)
    insert = property(_mupdf.fz_outline_iterator_insert_get, _mupdf.fz_outline_iterator_insert_set)
    update = property(_mupdf.fz_outline_iterator_update_get, _mupdf.fz_outline_iterator_update_set)
    _del = property(_mupdf.fz_outline_iterator__del_get, _mupdf.fz_outline_iterator__del_set)
    doc = property(_mupdf.fz_outline_iterator_doc_get, _mupdf.fz_outline_iterator_doc_set)

    def __init__(self):
        _mupdf.fz_outline_iterator_swiginit(self, _mupdf.new_fz_outline_iterator())
    __swig_destroy__ = _mupdf.delete_fz_outline_iterator

# Register fz_outline_iterator in _mupdf:
_mupdf.fz_outline_iterator_swigregister(fz_outline_iterator)
FZ_MEDIA_BOX = _mupdf.FZ_MEDIA_BOX
FZ_CROP_BOX = _mupdf.FZ_CROP_BOX
FZ_BLEED_BOX = _mupdf.FZ_BLEED_BOX
FZ_TRIM_BOX = _mupdf.FZ_TRIM_BOX
FZ_ART_BOX = _mupdf.FZ_ART_BOX
FZ_UNKNOWN_BOX = _mupdf.FZ_UNKNOWN_BOX
FZ_LAYOUT_KINDLE_W = _mupdf.FZ_LAYOUT_KINDLE_W
FZ_LAYOUT_KINDLE_H = _mupdf.FZ_LAYOUT_KINDLE_H
FZ_LAYOUT_KINDLE_EM = _mupdf.FZ_LAYOUT_KINDLE_EM
FZ_LAYOUT_US_POCKET_W = _mupdf.FZ_LAYOUT_US_POCKET_W
FZ_LAYOUT_US_POCKET_H = _mupdf.FZ_LAYOUT_US_POCKET_H
FZ_LAYOUT_US_POCKET_EM = _mupdf.FZ_LAYOUT_US_POCKET_EM
FZ_LAYOUT_US_TRADE_W = _mupdf.FZ_LAYOUT_US_TRADE_W
FZ_LAYOUT_US_TRADE_H = _mupdf.FZ_LAYOUT_US_TRADE_H
FZ_LAYOUT_US_TRADE_EM = _mupdf.FZ_LAYOUT_US_TRADE_EM
FZ_LAYOUT_UK_A_FORMAT_W = _mupdf.FZ_LAYOUT_UK_A_FORMAT_W
FZ_LAYOUT_UK_A_FORMAT_H = _mupdf.FZ_LAYOUT_UK_A_FORMAT_H
FZ_LAYOUT_UK_A_FORMAT_EM = _mupdf.FZ_LAYOUT_UK_A_FORMAT_EM
FZ_LAYOUT_UK_B_FORMAT_W = _mupdf.FZ_LAYOUT_UK_B_FORMAT_W
FZ_LAYOUT_UK_B_FORMAT_H = _mupdf.FZ_LAYOUT_UK_B_FORMAT_H
FZ_LAYOUT_UK_B_FORMAT_EM = _mupdf.FZ_LAYOUT_UK_B_FORMAT_EM
FZ_LAYOUT_UK_C_FORMAT_W = _mupdf.FZ_LAYOUT_UK_C_FORMAT_W
FZ_LAYOUT_UK_C_FORMAT_H = _mupdf.FZ_LAYOUT_UK_C_FORMAT_H
FZ_LAYOUT_UK_C_FORMAT_EM = _mupdf.FZ_LAYOUT_UK_C_FORMAT_EM
FZ_LAYOUT_A5_W = _mupdf.FZ_LAYOUT_A5_W
FZ_LAYOUT_A5_H = _mupdf.FZ_LAYOUT_A5_H
FZ_LAYOUT_A5_EM = _mupdf.FZ_LAYOUT_A5_EM
FZ_DEFAULT_LAYOUT_W = _mupdf.FZ_DEFAULT_LAYOUT_W
FZ_DEFAULT_LAYOUT_H = _mupdf.FZ_DEFAULT_LAYOUT_H
FZ_DEFAULT_LAYOUT_EM = _mupdf.FZ_DEFAULT_LAYOUT_EM
FZ_PERMISSION_PRINT = _mupdf.FZ_PERMISSION_PRINT
FZ_PERMISSION_COPY = _mupdf.FZ_PERMISSION_COPY
FZ_PERMISSION_EDIT = _mupdf.FZ_PERMISSION_EDIT
FZ_PERMISSION_ANNOTATE = _mupdf.FZ_PERMISSION_ANNOTATE
FZ_PERMISSION_FORM = _mupdf.FZ_PERMISSION_FORM
FZ_PERMISSION_ACCESSIBILITY = _mupdf.FZ_PERMISSION_ACCESSIBILITY
FZ_PERMISSION_ASSEMBLE = _mupdf.FZ_PERMISSION_ASSEMBLE
FZ_PERMISSION_PRINT_HQ = _mupdf.FZ_PERMISSION_PRINT_HQ
FZ_META_FORMAT = _mupdf.FZ_META_FORMAT
FZ_META_ENCRYPTION = _mupdf.FZ_META_ENCRYPTION
FZ_META_INFO = _mupdf.FZ_META_INFO
FZ_META_INFO_TITLE = _mupdf.FZ_META_INFO_TITLE
FZ_META_INFO_AUTHOR = _mupdf.FZ_META_INFO_AUTHOR
FZ_META_INFO_SUBJECT = _mupdf.FZ_META_INFO_SUBJECT
FZ_META_INFO_KEYWORDS = _mupdf.FZ_META_INFO_KEYWORDS
FZ_META_INFO_CREATOR = _mupdf.FZ_META_INFO_CREATOR
FZ_META_INFO_PRODUCER = _mupdf.FZ_META_INFO_PRODUCER
FZ_META_INFO_CREATIONDATE = _mupdf.FZ_META_INFO_CREATIONDATE
FZ_META_INFO_MODIFICATIONDATE = _mupdf.FZ_META_INFO_MODIFICATIONDATE
class fz_page(object):
    r"""
    Structure definition is public so other classes can
    derive from it. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_page_refs_get, _mupdf.fz_page_refs_set)
    doc = property(_mupdf.fz_page_doc_get, _mupdf.fz_page_doc_set)
    chapter = property(_mupdf.fz_page_chapter_get, _mupdf.fz_page_chapter_set)
    number = property(_mupdf.fz_page_number_get, _mupdf.fz_page_number_set)
    incomplete = property(_mupdf.fz_page_incomplete_get, _mupdf.fz_page_incomplete_set)
    in_doc = property(_mupdf.fz_page_in_doc_get, _mupdf.fz_page_in_doc_set)
    drop_page = property(_mupdf.fz_page_drop_page_get, _mupdf.fz_page_drop_page_set)
    bound_page = property(_mupdf.fz_page_bound_page_get, _mupdf.fz_page_bound_page_set)
    run_page_contents = property(_mupdf.fz_page_run_page_contents_get, _mupdf.fz_page_run_page_contents_set)
    run_page_annots = property(_mupdf.fz_page_run_page_annots_get, _mupdf.fz_page_run_page_annots_set)
    run_page_widgets = property(_mupdf.fz_page_run_page_widgets_get, _mupdf.fz_page_run_page_widgets_set)
    load_links = property(_mupdf.fz_page_load_links_get, _mupdf.fz_page_load_links_set)
    page_presentation = property(_mupdf.fz_page_page_presentation_get, _mupdf.fz_page_page_presentation_set)
    control_separation = property(_mupdf.fz_page_control_separation_get, _mupdf.fz_page_control_separation_set)
    separation_disabled = property(_mupdf.fz_page_separation_disabled_get, _mupdf.fz_page_separation_disabled_set)
    separations = property(_mupdf.fz_page_separations_get, _mupdf.fz_page_separations_set)
    overprint = property(_mupdf.fz_page_overprint_get, _mupdf.fz_page_overprint_set)
    create_link = property(_mupdf.fz_page_create_link_get, _mupdf.fz_page_create_link_set)
    delete_link = property(_mupdf.fz_page_delete_link_get, _mupdf.fz_page_delete_link_set)
    prev = property(_mupdf.fz_page_prev_get, _mupdf.fz_page_prev_set)
    next = property(_mupdf.fz_page_next_get, _mupdf.fz_page_next_set)

    def __init__(self):
        _mupdf.fz_page_swiginit(self, _mupdf.new_fz_page())
    __swig_destroy__ = _mupdf.delete_fz_page

# Register fz_page in _mupdf:
_mupdf.fz_page_swigregister(fz_page)
class fz_document(object):
    r"""
    Structure definition is public so other classes can
    derive from it. Callers should not access the members
    directly, though implementations will need initialize
    functions directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_document_refs_get, _mupdf.fz_document_refs_set)
    drop_document = property(_mupdf.fz_document_drop_document_get, _mupdf.fz_document_drop_document_set)
    needs_password = property(_mupdf.fz_document_needs_password_get, _mupdf.fz_document_needs_password_set)
    authenticate_password = property(_mupdf.fz_document_authenticate_password_get, _mupdf.fz_document_authenticate_password_set)
    has_permission = property(_mupdf.fz_document_has_permission_get, _mupdf.fz_document_has_permission_set)
    load_outline = property(_mupdf.fz_document_load_outline_get, _mupdf.fz_document_load_outline_set)
    outline_iterator = property(_mupdf.fz_document_outline_iterator_get, _mupdf.fz_document_outline_iterator_set)
    layout = property(_mupdf.fz_document_layout_get, _mupdf.fz_document_layout_set)
    make_bookmark = property(_mupdf.fz_document_make_bookmark_get, _mupdf.fz_document_make_bookmark_set)
    lookup_bookmark = property(_mupdf.fz_document_lookup_bookmark_get, _mupdf.fz_document_lookup_bookmark_set)
    resolve_link_dest = property(_mupdf.fz_document_resolve_link_dest_get, _mupdf.fz_document_resolve_link_dest_set)
    format_link_uri = property(_mupdf.fz_document_format_link_uri_get, _mupdf.fz_document_format_link_uri_set)
    count_chapters = property(_mupdf.fz_document_count_chapters_get, _mupdf.fz_document_count_chapters_set)
    count_pages = property(_mupdf.fz_document_count_pages_get, _mupdf.fz_document_count_pages_set)
    load_page = property(_mupdf.fz_document_load_page_get, _mupdf.fz_document_load_page_set)
    page_label = property(_mupdf.fz_document_page_label_get, _mupdf.fz_document_page_label_set)
    lookup_metadata = property(_mupdf.fz_document_lookup_metadata_get, _mupdf.fz_document_lookup_metadata_set)
    set_metadata = property(_mupdf.fz_document_set_metadata_get, _mupdf.fz_document_set_metadata_set)
    get_output_intent = property(_mupdf.fz_document_get_output_intent_get, _mupdf.fz_document_get_output_intent_set)
    output_accelerator = property(_mupdf.fz_document_output_accelerator_get, _mupdf.fz_document_output_accelerator_set)
    run_structure = property(_mupdf.fz_document_run_structure_get, _mupdf.fz_document_run_structure_set)
    as_pdf = property(_mupdf.fz_document_as_pdf_get, _mupdf.fz_document_as_pdf_set)
    did_layout = property(_mupdf.fz_document_did_layout_get, _mupdf.fz_document_did_layout_set)
    is_reflowable = property(_mupdf.fz_document_is_reflowable_get, _mupdf.fz_document_is_reflowable_set)
    open = property(_mupdf.fz_document_open_get, _mupdf.fz_document_open_set)

    def __init__(self):
        _mupdf.fz_document_swiginit(self, _mupdf.new_fz_document())
    __swig_destroy__ = _mupdf.delete_fz_document

# Register fz_document in _mupdf:
_mupdf.fz_document_swigregister(fz_document)
class fz_document_handler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    recognize = property(_mupdf.fz_document_handler_recognize_get, _mupdf.fz_document_handler_recognize_set)
    open = property(_mupdf.fz_document_handler_open_get, _mupdf.fz_document_handler_open_set)
    extensions = property(_mupdf.fz_document_handler_extensions_get, _mupdf.fz_document_handler_extensions_set)
    mimetypes = property(_mupdf.fz_document_handler_mimetypes_get, _mupdf.fz_document_handler_mimetypes_set)
    recognize_content = property(_mupdf.fz_document_handler_recognize_content_get, _mupdf.fz_document_handler_recognize_content_set)
    wants_dir = property(_mupdf.fz_document_handler_wants_dir_get, _mupdf.fz_document_handler_wants_dir_set)
    wants_file = property(_mupdf.fz_document_handler_wants_file_get, _mupdf.fz_document_handler_wants_file_set)
    fin = property(_mupdf.fz_document_handler_fin_get, _mupdf.fz_document_handler_fin_set)

    def __init__(self):
        _mupdf.fz_document_handler_swiginit(self, _mupdf.new_fz_document_handler())
    __swig_destroy__ = _mupdf.delete_fz_document_handler

# Register fz_document_handler in _mupdf:
_mupdf.fz_document_handler_swigregister(fz_document_handler)
class fz_document_writer(object):
    r"""
    Structure is public to allow other structures to
    be derived from it. Do not access members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    begin_page = property(_mupdf.fz_document_writer_begin_page_get, _mupdf.fz_document_writer_begin_page_set)
    end_page = property(_mupdf.fz_document_writer_end_page_get, _mupdf.fz_document_writer_end_page_set)
    close_writer = property(_mupdf.fz_document_writer_close_writer_get, _mupdf.fz_document_writer_close_writer_set)
    drop_writer = property(_mupdf.fz_document_writer_drop_writer_get, _mupdf.fz_document_writer_drop_writer_set)
    dev = property(_mupdf.fz_document_writer_dev_get, _mupdf.fz_document_writer_dev_set)

    def __init__(self):
        _mupdf.fz_document_writer_swiginit(self, _mupdf.new_fz_document_writer())
    __swig_destroy__ = _mupdf.delete_fz_document_writer

# Register fz_document_writer in _mupdf:
_mupdf.fz_document_writer_swigregister(fz_document_writer)
class fz_band_writer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.fz_band_writer_drop_get, _mupdf.fz_band_writer_drop_set)
    close = property(_mupdf.fz_band_writer_close_get, _mupdf.fz_band_writer_close_set)
    header = property(_mupdf.fz_band_writer_header_get, _mupdf.fz_band_writer_header_set)
    band = property(_mupdf.fz_band_writer_band_get, _mupdf.fz_band_writer_band_set)
    trailer = property(_mupdf.fz_band_writer_trailer_get, _mupdf.fz_band_writer_trailer_set)
    out = property(_mupdf.fz_band_writer_out_get, _mupdf.fz_band_writer_out_set)
    w = property(_mupdf.fz_band_writer_w_get, _mupdf.fz_band_writer_w_set)
    h = property(_mupdf.fz_band_writer_h_get, _mupdf.fz_band_writer_h_set)
    n = property(_mupdf.fz_band_writer_n_get, _mupdf.fz_band_writer_n_set)
    s = property(_mupdf.fz_band_writer_s_get, _mupdf.fz_band_writer_s_set)
    alpha = property(_mupdf.fz_band_writer_alpha_get, _mupdf.fz_band_writer_alpha_set)
    xres = property(_mupdf.fz_band_writer_xres_get, _mupdf.fz_band_writer_xres_set)
    yres = property(_mupdf.fz_band_writer_yres_get, _mupdf.fz_band_writer_yres_set)
    pagenum = property(_mupdf.fz_band_writer_pagenum_get, _mupdf.fz_band_writer_pagenum_set)
    line = property(_mupdf.fz_band_writer_line_get, _mupdf.fz_band_writer_line_set)
    seps = property(_mupdf.fz_band_writer_seps_get, _mupdf.fz_band_writer_seps_set)

    def __init__(self):
        _mupdf.fz_band_writer_swiginit(self, _mupdf.new_fz_band_writer())
    __swig_destroy__ = _mupdf.delete_fz_band_writer

# Register fz_band_writer in _mupdf:
_mupdf.fz_band_writer_swigregister(fz_band_writer)
class fz_pcl_options(object):
    r"""PCL output"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    features = property(_mupdf.fz_pcl_options_features_get, _mupdf.fz_pcl_options_features_set)
    odd_page_init = property(_mupdf.fz_pcl_options_odd_page_init_get, _mupdf.fz_pcl_options_odd_page_init_set)
    even_page_init = property(_mupdf.fz_pcl_options_even_page_init_get, _mupdf.fz_pcl_options_even_page_init_set)
    tumble = property(_mupdf.fz_pcl_options_tumble_get, _mupdf.fz_pcl_options_tumble_set)
    duplex_set = property(_mupdf.fz_pcl_options_duplex_set_get, _mupdf.fz_pcl_options_duplex_set_set)
    duplex = property(_mupdf.fz_pcl_options_duplex_get, _mupdf.fz_pcl_options_duplex_set)
    paper_size = property(_mupdf.fz_pcl_options_paper_size_get, _mupdf.fz_pcl_options_paper_size_set)
    manual_feed_set = property(_mupdf.fz_pcl_options_manual_feed_set_get, _mupdf.fz_pcl_options_manual_feed_set_set)
    manual_feed = property(_mupdf.fz_pcl_options_manual_feed_get, _mupdf.fz_pcl_options_manual_feed_set)
    media_position_set = property(_mupdf.fz_pcl_options_media_position_set_get, _mupdf.fz_pcl_options_media_position_set_set)
    media_position = property(_mupdf.fz_pcl_options_media_position_get, _mupdf.fz_pcl_options_media_position_set)
    orientation = property(_mupdf.fz_pcl_options_orientation_get, _mupdf.fz_pcl_options_orientation_set)
    page_count = property(_mupdf.fz_pcl_options_page_count_get, _mupdf.fz_pcl_options_page_count_set)

    def __init__(self):
        _mupdf.fz_pcl_options_swiginit(self, _mupdf.new_fz_pcl_options())
    __swig_destroy__ = _mupdf.delete_fz_pcl_options

# Register fz_pcl_options in _mupdf:
_mupdf.fz_pcl_options_swigregister(fz_pcl_options)
class fz_pclm_options(object):
    r"""PCLm output"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compress = property(_mupdf.fz_pclm_options_compress_get, _mupdf.fz_pclm_options_compress_set)
    strip_height = property(_mupdf.fz_pclm_options_strip_height_get, _mupdf.fz_pclm_options_strip_height_set)
    page_count = property(_mupdf.fz_pclm_options_page_count_get, _mupdf.fz_pclm_options_page_count_set)

    def __init__(self):
        _mupdf.fz_pclm_options_swiginit(self, _mupdf.new_fz_pclm_options())
    __swig_destroy__ = _mupdf.delete_fz_pclm_options

# Register fz_pclm_options in _mupdf:
_mupdf.fz_pclm_options_swigregister(fz_pclm_options)
class fz_pdfocr_options(object):
    r"""PDFOCR output"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compress = property(_mupdf.fz_pdfocr_options_compress_get, _mupdf.fz_pdfocr_options_compress_set)
    strip_height = property(_mupdf.fz_pdfocr_options_strip_height_get, _mupdf.fz_pdfocr_options_strip_height_set)
    language = property(_mupdf.fz_pdfocr_options_language_get, _mupdf.fz_pdfocr_options_language_set)
    datadir = property(_mupdf.fz_pdfocr_options_datadir_get, _mupdf.fz_pdfocr_options_datadir_set)
    skew_correct = property(_mupdf.fz_pdfocr_options_skew_correct_get, _mupdf.fz_pdfocr_options_skew_correct_set)
    skew_angle = property(_mupdf.fz_pdfocr_options_skew_angle_get, _mupdf.fz_pdfocr_options_skew_angle_set)
    skew_border = property(_mupdf.fz_pdfocr_options_skew_border_get, _mupdf.fz_pdfocr_options_skew_border_set)
    page_count = property(_mupdf.fz_pdfocr_options_page_count_get, _mupdf.fz_pdfocr_options_page_count_set)

    def __init__(self):
        _mupdf.fz_pdfocr_options_swiginit(self, _mupdf.new_fz_pdfocr_options())
    __swig_destroy__ = _mupdf.delete_fz_pdfocr_options

# Register fz_pdfocr_options in _mupdf:
_mupdf.fz_pdfocr_options_swigregister(fz_pdfocr_options)
class fz_pwg_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    media_class = property(_mupdf.fz_pwg_options_media_class_get, _mupdf.fz_pwg_options_media_class_set)
    media_color = property(_mupdf.fz_pwg_options_media_color_get, _mupdf.fz_pwg_options_media_color_set)
    media_type = property(_mupdf.fz_pwg_options_media_type_get, _mupdf.fz_pwg_options_media_type_set)
    output_type = property(_mupdf.fz_pwg_options_output_type_get, _mupdf.fz_pwg_options_output_type_set)
    advance_distance = property(_mupdf.fz_pwg_options_advance_distance_get, _mupdf.fz_pwg_options_advance_distance_set)
    advance_media = property(_mupdf.fz_pwg_options_advance_media_get, _mupdf.fz_pwg_options_advance_media_set)
    collate = property(_mupdf.fz_pwg_options_collate_get, _mupdf.fz_pwg_options_collate_set)
    cut_media = property(_mupdf.fz_pwg_options_cut_media_get, _mupdf.fz_pwg_options_cut_media_set)
    duplex = property(_mupdf.fz_pwg_options_duplex_get, _mupdf.fz_pwg_options_duplex_set)
    insert_sheet = property(_mupdf.fz_pwg_options_insert_sheet_get, _mupdf.fz_pwg_options_insert_sheet_set)
    jog = property(_mupdf.fz_pwg_options_jog_get, _mupdf.fz_pwg_options_jog_set)
    leading_edge = property(_mupdf.fz_pwg_options_leading_edge_get, _mupdf.fz_pwg_options_leading_edge_set)
    manual_feed = property(_mupdf.fz_pwg_options_manual_feed_get, _mupdf.fz_pwg_options_manual_feed_set)
    media_position = property(_mupdf.fz_pwg_options_media_position_get, _mupdf.fz_pwg_options_media_position_set)
    media_weight = property(_mupdf.fz_pwg_options_media_weight_get, _mupdf.fz_pwg_options_media_weight_set)
    mirror_print = property(_mupdf.fz_pwg_options_mirror_print_get, _mupdf.fz_pwg_options_mirror_print_set)
    negative_print = property(_mupdf.fz_pwg_options_negative_print_get, _mupdf.fz_pwg_options_negative_print_set)
    num_copies = property(_mupdf.fz_pwg_options_num_copies_get, _mupdf.fz_pwg_options_num_copies_set)
    orientation = property(_mupdf.fz_pwg_options_orientation_get, _mupdf.fz_pwg_options_orientation_set)
    output_face_up = property(_mupdf.fz_pwg_options_output_face_up_get, _mupdf.fz_pwg_options_output_face_up_set)
    PageSize = property(_mupdf.fz_pwg_options_PageSize_get, _mupdf.fz_pwg_options_PageSize_set)
    separations = property(_mupdf.fz_pwg_options_separations_get, _mupdf.fz_pwg_options_separations_set)
    tray_switch = property(_mupdf.fz_pwg_options_tray_switch_get, _mupdf.fz_pwg_options_tray_switch_set)
    tumble = property(_mupdf.fz_pwg_options_tumble_get, _mupdf.fz_pwg_options_tumble_set)
    media_type_num = property(_mupdf.fz_pwg_options_media_type_num_get, _mupdf.fz_pwg_options_media_type_num_set)
    compression = property(_mupdf.fz_pwg_options_compression_get, _mupdf.fz_pwg_options_compression_set)
    row_count = property(_mupdf.fz_pwg_options_row_count_get, _mupdf.fz_pwg_options_row_count_set)
    row_feed = property(_mupdf.fz_pwg_options_row_feed_get, _mupdf.fz_pwg_options_row_feed_set)
    row_step = property(_mupdf.fz_pwg_options_row_step_get, _mupdf.fz_pwg_options_row_step_set)
    rendering_intent = property(_mupdf.fz_pwg_options_rendering_intent_get, _mupdf.fz_pwg_options_rendering_intent_set)
    page_size_name = property(_mupdf.fz_pwg_options_page_size_name_get, _mupdf.fz_pwg_options_page_size_name_set)

    def __init__(self):
        _mupdf.fz_pwg_options_swiginit(self, _mupdf.new_fz_pwg_options())
    __swig_destroy__ = _mupdf.delete_fz_pwg_options

# Register fz_pwg_options in _mupdf:
_mupdf.fz_pwg_options_swigregister(fz_pwg_options)
FZ_SVG_TEXT_AS_PATH = _mupdf.FZ_SVG_TEXT_AS_PATH
FZ_SVG_TEXT_AS_TEXT = _mupdf.FZ_SVG_TEXT_AS_TEXT
FZ_PLACE_STORY_FLAG_NO_OVERFLOW = _mupdf.FZ_PLACE_STORY_FLAG_NO_OVERFLOW
FZ_PLACE_STORY_RETURN_ALL_FITTED = _mupdf.FZ_PLACE_STORY_RETURN_ALL_FITTED
FZ_PLACE_STORY_RETURN_OVERFLOW_WIDTH = _mupdf.FZ_PLACE_STORY_RETURN_OVERFLOW_WIDTH
class fz_story_element_position(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    depth = property(_mupdf.fz_story_element_position_depth_get, _mupdf.fz_story_element_position_depth_set)
    heading = property(_mupdf.fz_story_element_position_heading_get, _mupdf.fz_story_element_position_heading_set)
    id = property(_mupdf.fz_story_element_position_id_get, _mupdf.fz_story_element_position_id_set)
    href = property(_mupdf.fz_story_element_position_href_get, _mupdf.fz_story_element_position_href_set)
    rect = property(_mupdf.fz_story_element_position_rect_get, _mupdf.fz_story_element_position_rect_set)
    text = property(_mupdf.fz_story_element_position_text_get, _mupdf.fz_story_element_position_text_set)
    open_close = property(_mupdf.fz_story_element_position_open_close_get, _mupdf.fz_story_element_position_open_close_set)
    rectangle_num = property(_mupdf.fz_story_element_position_rectangle_num_get, _mupdf.fz_story_element_position_rectangle_num_set)

    def __init__(self):
        _mupdf.fz_story_element_position_swiginit(self, _mupdf.new_fz_story_element_position())
    __swig_destroy__ = _mupdf.delete_fz_story_element_position

# Register fz_story_element_position in _mupdf:
_mupdf.fz_story_element_position_swigregister(fz_story_element_position)
class fz_write_story_position(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    element = property(_mupdf.fz_write_story_position_element_get, _mupdf.fz_write_story_position_element_set)
    page_num = property(_mupdf.fz_write_story_position_page_num_get, _mupdf.fz_write_story_position_page_num_set)

    def __init__(self):
        _mupdf.fz_write_story_position_swiginit(self, _mupdf.new_fz_write_story_position())
    __swig_destroy__ = _mupdf.delete_fz_write_story_position

# Register fz_write_story_position in _mupdf:
_mupdf.fz_write_story_position_swigregister(fz_write_story_position)
class fz_write_story_positions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    positions = property(_mupdf.fz_write_story_positions_positions_get, _mupdf.fz_write_story_positions_positions_set)
    num = property(_mupdf.fz_write_story_positions_num_get, _mupdf.fz_write_story_positions_num_set)

    def __init__(self):
        _mupdf.fz_write_story_positions_swiginit(self, _mupdf.new_fz_write_story_positions())
    __swig_destroy__ = _mupdf.delete_fz_write_story_positions

# Register fz_write_story_positions in _mupdf:
_mupdf.fz_write_story_positions_swigregister(fz_write_story_positions)
FZ_DESKEW_BORDER_INCREASE = _mupdf.FZ_DESKEW_BORDER_INCREASE
FZ_DESKEW_BORDER_MAINTAIN = _mupdf.FZ_DESKEW_BORDER_MAINTAIN
FZ_DESKEW_BORDER_DECREASE = _mupdf.FZ_DESKEW_BORDER_DECREASE
PDF_MAX_OBJECT_NUMBER = _mupdf.PDF_MAX_OBJECT_NUMBER
PDF_MAX_GEN_NUMBER = _mupdf.PDF_MAX_GEN_NUMBER
class pdf_cycle_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    up = property(_mupdf.pdf_cycle_list_up_get, _mupdf.pdf_cycle_list_up_set)
    num = property(_mupdf.pdf_cycle_list_num_get, _mupdf.pdf_cycle_list_num_set)

    def __init__(self):
        _mupdf.pdf_cycle_list_swiginit(self, _mupdf.new_pdf_cycle_list())
    __swig_destroy__ = _mupdf.delete_pdf_cycle_list

# Register pdf_cycle_list in _mupdf:
_mupdf.pdf_cycle_list_swigregister(pdf_cycle_list)
class pdf_mark_bits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.pdf_mark_bits_len_get, _mupdf.pdf_mark_bits_len_set)
    bits = property(_mupdf.pdf_mark_bits_bits_get, _mupdf.pdf_mark_bits_bits_set)

    def __init__(self):
        _mupdf.pdf_mark_bits_swiginit(self, _mupdf.new_pdf_mark_bits())
    __swig_destroy__ = _mupdf.delete_pdf_mark_bits

# Register pdf_mark_bits in _mupdf:
_mupdf.pdf_mark_bits_swigregister(pdf_mark_bits)
class pdf_mark_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.pdf_mark_list_len_get, _mupdf.pdf_mark_list_len_set)
    max = property(_mupdf.pdf_mark_list_max_get, _mupdf.pdf_mark_list_max_set)
    list = property(_mupdf.pdf_mark_list_list_get, _mupdf.pdf_mark_list_list_set)
    local_list = property(_mupdf.pdf_mark_list_local_list_get, _mupdf.pdf_mark_list_local_list_set)

    def __init__(self):
        _mupdf.pdf_mark_list_swiginit(self, _mupdf.new_pdf_mark_list())
    __swig_destroy__ = _mupdf.delete_pdf_mark_list

# Register pdf_mark_list in _mupdf:
_mupdf.pdf_mark_list_swigregister(pdf_mark_list)
PDF_ENUM_NULL = _mupdf.PDF_ENUM_NULL
PDF_ENUM_TRUE = _mupdf.PDF_ENUM_TRUE
PDF_ENUM_FALSE = _mupdf.PDF_ENUM_FALSE
PDF_ENUM_NAME_1_2 = _mupdf.PDF_ENUM_NAME_1_2
PDF_ENUM_NAME_1_5 = _mupdf.PDF_ENUM_NAME_1_5
PDF_ENUM_NAME_3D = _mupdf.PDF_ENUM_NAME_3D
PDF_ENUM_NAME_A = _mupdf.PDF_ENUM_NAME_A
PDF_ENUM_NAME_A85 = _mupdf.PDF_ENUM_NAME_A85
PDF_ENUM_NAME_AA = _mupdf.PDF_ENUM_NAME_AA
PDF_ENUM_NAME_AC = _mupdf.PDF_ENUM_NAME_AC
PDF_ENUM_NAME_AESV2 = _mupdf.PDF_ENUM_NAME_AESV2
PDF_ENUM_NAME_AESV3 = _mupdf.PDF_ENUM_NAME_AESV3
PDF_ENUM_NAME_AF = _mupdf.PDF_ENUM_NAME_AF
PDF_ENUM_NAME_AFRelationship = _mupdf.PDF_ENUM_NAME_AFRelationship
PDF_ENUM_NAME_AHx = _mupdf.PDF_ENUM_NAME_AHx
PDF_ENUM_NAME_AP = _mupdf.PDF_ENUM_NAME_AP
PDF_ENUM_NAME_AS = _mupdf.PDF_ENUM_NAME_AS
PDF_ENUM_NAME_ASCII85Decode = _mupdf.PDF_ENUM_NAME_ASCII85Decode
PDF_ENUM_NAME_ASCIIHexDecode = _mupdf.PDF_ENUM_NAME_ASCIIHexDecode
PDF_ENUM_NAME_AcroForm = _mupdf.PDF_ENUM_NAME_AcroForm
PDF_ENUM_NAME_Action = _mupdf.PDF_ENUM_NAME_Action
PDF_ENUM_NAME_ActualText = _mupdf.PDF_ENUM_NAME_ActualText
PDF_ENUM_NAME_Adobe_PPKLite = _mupdf.PDF_ENUM_NAME_Adobe_PPKLite
PDF_ENUM_NAME_All = _mupdf.PDF_ENUM_NAME_All
PDF_ENUM_NAME_AllOff = _mupdf.PDF_ENUM_NAME_AllOff
PDF_ENUM_NAME_AllOn = _mupdf.PDF_ENUM_NAME_AllOn
PDF_ENUM_NAME_Alpha = _mupdf.PDF_ENUM_NAME_Alpha
PDF_ENUM_NAME_Alt = _mupdf.PDF_ENUM_NAME_Alt
PDF_ENUM_NAME_Alternate = _mupdf.PDF_ENUM_NAME_Alternate
PDF_ENUM_NAME_Alternative = _mupdf.PDF_ENUM_NAME_Alternative
PDF_ENUM_NAME_Annot = _mupdf.PDF_ENUM_NAME_Annot
PDF_ENUM_NAME_Annots = _mupdf.PDF_ENUM_NAME_Annots
PDF_ENUM_NAME_AnyOff = _mupdf.PDF_ENUM_NAME_AnyOff
PDF_ENUM_NAME_App = _mupdf.PDF_ENUM_NAME_App
PDF_ENUM_NAME_Approved = _mupdf.PDF_ENUM_NAME_Approved
PDF_ENUM_NAME_Art = _mupdf.PDF_ENUM_NAME_Art
PDF_ENUM_NAME_ArtBox = _mupdf.PDF_ENUM_NAME_ArtBox
PDF_ENUM_NAME_Artifact = _mupdf.PDF_ENUM_NAME_Artifact
PDF_ENUM_NAME_AsIs = _mupdf.PDF_ENUM_NAME_AsIs
PDF_ENUM_NAME_Ascent = _mupdf.PDF_ENUM_NAME_Ascent
PDF_ENUM_NAME_Aside = _mupdf.PDF_ENUM_NAME_Aside
PDF_ENUM_NAME_AuthEvent = _mupdf.PDF_ENUM_NAME_AuthEvent
PDF_ENUM_NAME_Author = _mupdf.PDF_ENUM_NAME_Author
PDF_ENUM_NAME_B = _mupdf.PDF_ENUM_NAME_B
PDF_ENUM_NAME_BBox = _mupdf.PDF_ENUM_NAME_BBox
PDF_ENUM_NAME_BC = _mupdf.PDF_ENUM_NAME_BC
PDF_ENUM_NAME_BE = _mupdf.PDF_ENUM_NAME_BE
PDF_ENUM_NAME_BG = _mupdf.PDF_ENUM_NAME_BG
PDF_ENUM_NAME_BM = _mupdf.PDF_ENUM_NAME_BM
PDF_ENUM_NAME_BPC = _mupdf.PDF_ENUM_NAME_BPC
PDF_ENUM_NAME_BS = _mupdf.PDF_ENUM_NAME_BS
PDF_ENUM_NAME_Background = _mupdf.PDF_ENUM_NAME_Background
PDF_ENUM_NAME_BaseEncoding = _mupdf.PDF_ENUM_NAME_BaseEncoding
PDF_ENUM_NAME_BaseFont = _mupdf.PDF_ENUM_NAME_BaseFont
PDF_ENUM_NAME_BaseState = _mupdf.PDF_ENUM_NAME_BaseState
PDF_ENUM_NAME_BibEntry = _mupdf.PDF_ENUM_NAME_BibEntry
PDF_ENUM_NAME_BitsPerComponent = _mupdf.PDF_ENUM_NAME_BitsPerComponent
PDF_ENUM_NAME_BitsPerCoordinate = _mupdf.PDF_ENUM_NAME_BitsPerCoordinate
PDF_ENUM_NAME_BitsPerFlag = _mupdf.PDF_ENUM_NAME_BitsPerFlag
PDF_ENUM_NAME_BitsPerSample = _mupdf.PDF_ENUM_NAME_BitsPerSample
PDF_ENUM_NAME_BlackIs1 = _mupdf.PDF_ENUM_NAME_BlackIs1
PDF_ENUM_NAME_BlackPoint = _mupdf.PDF_ENUM_NAME_BlackPoint
PDF_ENUM_NAME_BleedBox = _mupdf.PDF_ENUM_NAME_BleedBox
PDF_ENUM_NAME_Blinds = _mupdf.PDF_ENUM_NAME_Blinds
PDF_ENUM_NAME_BlockQuote = _mupdf.PDF_ENUM_NAME_BlockQuote
PDF_ENUM_NAME_Border = _mupdf.PDF_ENUM_NAME_Border
PDF_ENUM_NAME_Bounds = _mupdf.PDF_ENUM_NAME_Bounds
PDF_ENUM_NAME_Box = _mupdf.PDF_ENUM_NAME_Box
PDF_ENUM_NAME_Bt = _mupdf.PDF_ENUM_NAME_Bt
PDF_ENUM_NAME_Btn = _mupdf.PDF_ENUM_NAME_Btn
PDF_ENUM_NAME_Butt = _mupdf.PDF_ENUM_NAME_Butt
PDF_ENUM_NAME_ByteRange = _mupdf.PDF_ENUM_NAME_ByteRange
PDF_ENUM_NAME_C = _mupdf.PDF_ENUM_NAME_C
PDF_ENUM_NAME_C0 = _mupdf.PDF_ENUM_NAME_C0
PDF_ENUM_NAME_C1 = _mupdf.PDF_ENUM_NAME_C1
PDF_ENUM_NAME_CA = _mupdf.PDF_ENUM_NAME_CA
PDF_ENUM_NAME_CCF = _mupdf.PDF_ENUM_NAME_CCF
PDF_ENUM_NAME_CCITTFaxDecode = _mupdf.PDF_ENUM_NAME_CCITTFaxDecode
PDF_ENUM_NAME_CF = _mupdf.PDF_ENUM_NAME_CF
PDF_ENUM_NAME_CFM = _mupdf.PDF_ENUM_NAME_CFM
PDF_ENUM_NAME_CI = _mupdf.PDF_ENUM_NAME_CI
PDF_ENUM_NAME_CIDFontType0 = _mupdf.PDF_ENUM_NAME_CIDFontType0
PDF_ENUM_NAME_CIDFontType0C = _mupdf.PDF_ENUM_NAME_CIDFontType0C
PDF_ENUM_NAME_CIDFontType2 = _mupdf.PDF_ENUM_NAME_CIDFontType2
PDF_ENUM_NAME_CIDSystemInfo = _mupdf.PDF_ENUM_NAME_CIDSystemInfo
PDF_ENUM_NAME_CIDToGIDMap = _mupdf.PDF_ENUM_NAME_CIDToGIDMap
PDF_ENUM_NAME_CL = _mupdf.PDF_ENUM_NAME_CL
PDF_ENUM_NAME_CMYK = _mupdf.PDF_ENUM_NAME_CMYK
PDF_ENUM_NAME_CO = _mupdf.PDF_ENUM_NAME_CO
PDF_ENUM_NAME_CP = _mupdf.PDF_ENUM_NAME_CP
PDF_ENUM_NAME_CS = _mupdf.PDF_ENUM_NAME_CS
PDF_ENUM_NAME_CalCMYK = _mupdf.PDF_ENUM_NAME_CalCMYK
PDF_ENUM_NAME_CalGray = _mupdf.PDF_ENUM_NAME_CalGray
PDF_ENUM_NAME_CalRGB = _mupdf.PDF_ENUM_NAME_CalRGB
PDF_ENUM_NAME_Cap = _mupdf.PDF_ENUM_NAME_Cap
PDF_ENUM_NAME_CapHeight = _mupdf.PDF_ENUM_NAME_CapHeight
PDF_ENUM_NAME_Caption = _mupdf.PDF_ENUM_NAME_Caption
PDF_ENUM_NAME_Caret = _mupdf.PDF_ENUM_NAME_Caret
PDF_ENUM_NAME_Catalog = _mupdf.PDF_ENUM_NAME_Catalog
PDF_ENUM_NAME_Cert = _mupdf.PDF_ENUM_NAME_Cert
PDF_ENUM_NAME_Ch = _mupdf.PDF_ENUM_NAME_Ch
PDF_ENUM_NAME_Changes = _mupdf.PDF_ENUM_NAME_Changes
PDF_ENUM_NAME_CharProcs = _mupdf.PDF_ENUM_NAME_CharProcs
PDF_ENUM_NAME_CheckSum = _mupdf.PDF_ENUM_NAME_CheckSum
PDF_ENUM_NAME_Circle = _mupdf.PDF_ENUM_NAME_Circle
PDF_ENUM_NAME_ClosedArrow = _mupdf.PDF_ENUM_NAME_ClosedArrow
PDF_ENUM_NAME_Code = _mupdf.PDF_ENUM_NAME_Code
PDF_ENUM_NAME_Collection = _mupdf.PDF_ENUM_NAME_Collection
PDF_ENUM_NAME_ColorSpace = _mupdf.PDF_ENUM_NAME_ColorSpace
PDF_ENUM_NAME_ColorTransform = _mupdf.PDF_ENUM_NAME_ColorTransform
PDF_ENUM_NAME_Colorants = _mupdf.PDF_ENUM_NAME_Colorants
PDF_ENUM_NAME_Colors = _mupdf.PDF_ENUM_NAME_Colors
PDF_ENUM_NAME_Columns = _mupdf.PDF_ENUM_NAME_Columns
PDF_ENUM_NAME_Confidential = _mupdf.PDF_ENUM_NAME_Confidential
PDF_ENUM_NAME_Configs = _mupdf.PDF_ENUM_NAME_Configs
PDF_ENUM_NAME_ContactInfo = _mupdf.PDF_ENUM_NAME_ContactInfo
PDF_ENUM_NAME_Contents = _mupdf.PDF_ENUM_NAME_Contents
PDF_ENUM_NAME_Coords = _mupdf.PDF_ENUM_NAME_Coords
PDF_ENUM_NAME_Count = _mupdf.PDF_ENUM_NAME_Count
PDF_ENUM_NAME_Cover = _mupdf.PDF_ENUM_NAME_Cover
PDF_ENUM_NAME_CreationDate = _mupdf.PDF_ENUM_NAME_CreationDate
PDF_ENUM_NAME_Creator = _mupdf.PDF_ENUM_NAME_Creator
PDF_ENUM_NAME_CropBox = _mupdf.PDF_ENUM_NAME_CropBox
PDF_ENUM_NAME_Crypt = _mupdf.PDF_ENUM_NAME_Crypt
PDF_ENUM_NAME_D = _mupdf.PDF_ENUM_NAME_D
PDF_ENUM_NAME_DA = _mupdf.PDF_ENUM_NAME_DA
PDF_ENUM_NAME_DC = _mupdf.PDF_ENUM_NAME_DC
PDF_ENUM_NAME_DCT = _mupdf.PDF_ENUM_NAME_DCT
PDF_ENUM_NAME_DCTDecode = _mupdf.PDF_ENUM_NAME_DCTDecode
PDF_ENUM_NAME_DL = _mupdf.PDF_ENUM_NAME_DL
PDF_ENUM_NAME_DOS = _mupdf.PDF_ENUM_NAME_DOS
PDF_ENUM_NAME_DP = _mupdf.PDF_ENUM_NAME_DP
PDF_ENUM_NAME_DR = _mupdf.PDF_ENUM_NAME_DR
PDF_ENUM_NAME_DS = _mupdf.PDF_ENUM_NAME_DS
PDF_ENUM_NAME_DV = _mupdf.PDF_ENUM_NAME_DV
PDF_ENUM_NAME_DW = _mupdf.PDF_ENUM_NAME_DW
PDF_ENUM_NAME_DW2 = _mupdf.PDF_ENUM_NAME_DW2
PDF_ENUM_NAME_DamagedRowsBeforeError = _mupdf.PDF_ENUM_NAME_DamagedRowsBeforeError
PDF_ENUM_NAME_Data = _mupdf.PDF_ENUM_NAME_Data
PDF_ENUM_NAME_Date = _mupdf.PDF_ENUM_NAME_Date
PDF_ENUM_NAME_Decode = _mupdf.PDF_ENUM_NAME_Decode
PDF_ENUM_NAME_DecodeParms = _mupdf.PDF_ENUM_NAME_DecodeParms
PDF_ENUM_NAME_Default = _mupdf.PDF_ENUM_NAME_Default
PDF_ENUM_NAME_DefaultCMYK = _mupdf.PDF_ENUM_NAME_DefaultCMYK
PDF_ENUM_NAME_DefaultGray = _mupdf.PDF_ENUM_NAME_DefaultGray
PDF_ENUM_NAME_DefaultRGB = _mupdf.PDF_ENUM_NAME_DefaultRGB
PDF_ENUM_NAME_Departmental = _mupdf.PDF_ENUM_NAME_Departmental
PDF_ENUM_NAME_Desc = _mupdf.PDF_ENUM_NAME_Desc
PDF_ENUM_NAME_DescendantFonts = _mupdf.PDF_ENUM_NAME_DescendantFonts
PDF_ENUM_NAME_Descent = _mupdf.PDF_ENUM_NAME_Descent
PDF_ENUM_NAME_Design = _mupdf.PDF_ENUM_NAME_Design
PDF_ENUM_NAME_Dest = _mupdf.PDF_ENUM_NAME_Dest
PDF_ENUM_NAME_DestOutputProfile = _mupdf.PDF_ENUM_NAME_DestOutputProfile
PDF_ENUM_NAME_Dests = _mupdf.PDF_ENUM_NAME_Dests
PDF_ENUM_NAME_DeviceCMYK = _mupdf.PDF_ENUM_NAME_DeviceCMYK
PDF_ENUM_NAME_DeviceGray = _mupdf.PDF_ENUM_NAME_DeviceGray
PDF_ENUM_NAME_DeviceN = _mupdf.PDF_ENUM_NAME_DeviceN
PDF_ENUM_NAME_DeviceRGB = _mupdf.PDF_ENUM_NAME_DeviceRGB
PDF_ENUM_NAME_Di = _mupdf.PDF_ENUM_NAME_Di
PDF_ENUM_NAME_Diamond = _mupdf.PDF_ENUM_NAME_Diamond
PDF_ENUM_NAME_Differences = _mupdf.PDF_ENUM_NAME_Differences
PDF_ENUM_NAME_DigestLocation = _mupdf.PDF_ENUM_NAME_DigestLocation
PDF_ENUM_NAME_DigestMethod = _mupdf.PDF_ENUM_NAME_DigestMethod
PDF_ENUM_NAME_DigestValue = _mupdf.PDF_ENUM_NAME_DigestValue
PDF_ENUM_NAME_Dissolve = _mupdf.PDF_ENUM_NAME_Dissolve
PDF_ENUM_NAME_Div = _mupdf.PDF_ENUM_NAME_Div
PDF_ENUM_NAME_Dm = _mupdf.PDF_ENUM_NAME_Dm
PDF_ENUM_NAME_DocMDP = _mupdf.PDF_ENUM_NAME_DocMDP
PDF_ENUM_NAME_Document = _mupdf.PDF_ENUM_NAME_Document
PDF_ENUM_NAME_DocumentFragment = _mupdf.PDF_ENUM_NAME_DocumentFragment
PDF_ENUM_NAME_Domain = _mupdf.PDF_ENUM_NAME_Domain
PDF_ENUM_NAME_Draft = _mupdf.PDF_ENUM_NAME_Draft
PDF_ENUM_NAME_Dur = _mupdf.PDF_ENUM_NAME_Dur
PDF_ENUM_NAME_E = _mupdf.PDF_ENUM_NAME_E
PDF_ENUM_NAME_EF = _mupdf.PDF_ENUM_NAME_EF
PDF_ENUM_NAME_EarlyChange = _mupdf.PDF_ENUM_NAME_EarlyChange
PDF_ENUM_NAME_Em = _mupdf.PDF_ENUM_NAME_Em
PDF_ENUM_NAME_EmbeddedFile = _mupdf.PDF_ENUM_NAME_EmbeddedFile
PDF_ENUM_NAME_EmbeddedFiles = _mupdf.PDF_ENUM_NAME_EmbeddedFiles
PDF_ENUM_NAME_Encode = _mupdf.PDF_ENUM_NAME_Encode
PDF_ENUM_NAME_EncodedByteAlign = _mupdf.PDF_ENUM_NAME_EncodedByteAlign
PDF_ENUM_NAME_Encoding = _mupdf.PDF_ENUM_NAME_Encoding
PDF_ENUM_NAME_Encrypt = _mupdf.PDF_ENUM_NAME_Encrypt
PDF_ENUM_NAME_EncryptMetadata = _mupdf.PDF_ENUM_NAME_EncryptMetadata
PDF_ENUM_NAME_EncryptedPayload = _mupdf.PDF_ENUM_NAME_EncryptedPayload
PDF_ENUM_NAME_EndOfBlock = _mupdf.PDF_ENUM_NAME_EndOfBlock
PDF_ENUM_NAME_EndOfLine = _mupdf.PDF_ENUM_NAME_EndOfLine
PDF_ENUM_NAME_Exclude = _mupdf.PDF_ENUM_NAME_Exclude
PDF_ENUM_NAME_Experimental = _mupdf.PDF_ENUM_NAME_Experimental
PDF_ENUM_NAME_Expired = _mupdf.PDF_ENUM_NAME_Expired
PDF_ENUM_NAME_ExtGState = _mupdf.PDF_ENUM_NAME_ExtGState
PDF_ENUM_NAME_Extend = _mupdf.PDF_ENUM_NAME_Extend
PDF_ENUM_NAME_F = _mupdf.PDF_ENUM_NAME_F
PDF_ENUM_NAME_FENote = _mupdf.PDF_ENUM_NAME_FENote
PDF_ENUM_NAME_FL = _mupdf.PDF_ENUM_NAME_FL
PDF_ENUM_NAME_FRM = _mupdf.PDF_ENUM_NAME_FRM
PDF_ENUM_NAME_FS = _mupdf.PDF_ENUM_NAME_FS
PDF_ENUM_NAME_FT = _mupdf.PDF_ENUM_NAME_FT
PDF_ENUM_NAME_Fade = _mupdf.PDF_ENUM_NAME_Fade
PDF_ENUM_NAME_Ff = _mupdf.PDF_ENUM_NAME_Ff
PDF_ENUM_NAME_FieldMDP = _mupdf.PDF_ENUM_NAME_FieldMDP
PDF_ENUM_NAME_Fields = _mupdf.PDF_ENUM_NAME_Fields
PDF_ENUM_NAME_Figure = _mupdf.PDF_ENUM_NAME_Figure
PDF_ENUM_NAME_FileAttachment = _mupdf.PDF_ENUM_NAME_FileAttachment
PDF_ENUM_NAME_FileSize = _mupdf.PDF_ENUM_NAME_FileSize
PDF_ENUM_NAME_Filespec = _mupdf.PDF_ENUM_NAME_Filespec
PDF_ENUM_NAME_Filter = _mupdf.PDF_ENUM_NAME_Filter
PDF_ENUM_NAME_Final = _mupdf.PDF_ENUM_NAME_Final
PDF_ENUM_NAME_Fingerprint = _mupdf.PDF_ENUM_NAME_Fingerprint
PDF_ENUM_NAME_First = _mupdf.PDF_ENUM_NAME_First
PDF_ENUM_NAME_FirstChar = _mupdf.PDF_ENUM_NAME_FirstChar
PDF_ENUM_NAME_FirstPage = _mupdf.PDF_ENUM_NAME_FirstPage
PDF_ENUM_NAME_Fit = _mupdf.PDF_ENUM_NAME_Fit
PDF_ENUM_NAME_FitB = _mupdf.PDF_ENUM_NAME_FitB
PDF_ENUM_NAME_FitBH = _mupdf.PDF_ENUM_NAME_FitBH
PDF_ENUM_NAME_FitBV = _mupdf.PDF_ENUM_NAME_FitBV
PDF_ENUM_NAME_FitH = _mupdf.PDF_ENUM_NAME_FitH
PDF_ENUM_NAME_FitR = _mupdf.PDF_ENUM_NAME_FitR
PDF_ENUM_NAME_FitV = _mupdf.PDF_ENUM_NAME_FitV
PDF_ENUM_NAME_Fl = _mupdf.PDF_ENUM_NAME_Fl
PDF_ENUM_NAME_Flags = _mupdf.PDF_ENUM_NAME_Flags
PDF_ENUM_NAME_FlateDecode = _mupdf.PDF_ENUM_NAME_FlateDecode
PDF_ENUM_NAME_Fly = _mupdf.PDF_ENUM_NAME_Fly
PDF_ENUM_NAME_Font = _mupdf.PDF_ENUM_NAME_Font
PDF_ENUM_NAME_FontBBox = _mupdf.PDF_ENUM_NAME_FontBBox
PDF_ENUM_NAME_FontDescriptor = _mupdf.PDF_ENUM_NAME_FontDescriptor
PDF_ENUM_NAME_FontFile = _mupdf.PDF_ENUM_NAME_FontFile
PDF_ENUM_NAME_FontFile2 = _mupdf.PDF_ENUM_NAME_FontFile2
PDF_ENUM_NAME_FontFile3 = _mupdf.PDF_ENUM_NAME_FontFile3
PDF_ENUM_NAME_FontMatrix = _mupdf.PDF_ENUM_NAME_FontMatrix
PDF_ENUM_NAME_FontName = _mupdf.PDF_ENUM_NAME_FontName
PDF_ENUM_NAME_ForComment = _mupdf.PDF_ENUM_NAME_ForComment
PDF_ENUM_NAME_ForPublicRelease = _mupdf.PDF_ENUM_NAME_ForPublicRelease
PDF_ENUM_NAME_Form = _mupdf.PDF_ENUM_NAME_Form
PDF_ENUM_NAME_FormData = _mupdf.PDF_ENUM_NAME_FormData
PDF_ENUM_NAME_FormEx = _mupdf.PDF_ENUM_NAME_FormEx
PDF_ENUM_NAME_FormType = _mupdf.PDF_ENUM_NAME_FormType
PDF_ENUM_NAME_Formula = _mupdf.PDF_ENUM_NAME_Formula
PDF_ENUM_NAME_FreeText = _mupdf.PDF_ENUM_NAME_FreeText
PDF_ENUM_NAME_FreeTextCallout = _mupdf.PDF_ENUM_NAME_FreeTextCallout
PDF_ENUM_NAME_FreeTextTypeWriter = _mupdf.PDF_ENUM_NAME_FreeTextTypeWriter
PDF_ENUM_NAME_Function = _mupdf.PDF_ENUM_NAME_Function
PDF_ENUM_NAME_FunctionType = _mupdf.PDF_ENUM_NAME_FunctionType
PDF_ENUM_NAME_Functions = _mupdf.PDF_ENUM_NAME_Functions
PDF_ENUM_NAME_G = _mupdf.PDF_ENUM_NAME_G
PDF_ENUM_NAME_GTS_PDFX = _mupdf.PDF_ENUM_NAME_GTS_PDFX
PDF_ENUM_NAME_Gamma = _mupdf.PDF_ENUM_NAME_Gamma
PDF_ENUM_NAME_Glitter = _mupdf.PDF_ENUM_NAME_Glitter
PDF_ENUM_NAME_GoTo = _mupdf.PDF_ENUM_NAME_GoTo
PDF_ENUM_NAME_GoToR = _mupdf.PDF_ENUM_NAME_GoToR
PDF_ENUM_NAME_Group = _mupdf.PDF_ENUM_NAME_Group
PDF_ENUM_NAME_H = _mupdf.PDF_ENUM_NAME_H
PDF_ENUM_NAME_H1 = _mupdf.PDF_ENUM_NAME_H1
PDF_ENUM_NAME_H2 = _mupdf.PDF_ENUM_NAME_H2
PDF_ENUM_NAME_H3 = _mupdf.PDF_ENUM_NAME_H3
PDF_ENUM_NAME_H4 = _mupdf.PDF_ENUM_NAME_H4
PDF_ENUM_NAME_H5 = _mupdf.PDF_ENUM_NAME_H5
PDF_ENUM_NAME_H6 = _mupdf.PDF_ENUM_NAME_H6
PDF_ENUM_NAME_Height = _mupdf.PDF_ENUM_NAME_Height
PDF_ENUM_NAME_Helv = _mupdf.PDF_ENUM_NAME_Helv
PDF_ENUM_NAME_Highlight = _mupdf.PDF_ENUM_NAME_Highlight
PDF_ENUM_NAME_HistoryPos = _mupdf.PDF_ENUM_NAME_HistoryPos
PDF_ENUM_NAME_I = _mupdf.PDF_ENUM_NAME_I
PDF_ENUM_NAME_IC = _mupdf.PDF_ENUM_NAME_IC
PDF_ENUM_NAME_ICCBased = _mupdf.PDF_ENUM_NAME_ICCBased
PDF_ENUM_NAME_ID = _mupdf.PDF_ENUM_NAME_ID
PDF_ENUM_NAME_IM = _mupdf.PDF_ENUM_NAME_IM
PDF_ENUM_NAME_IRT = _mupdf.PDF_ENUM_NAME_IRT
PDF_ENUM_NAME_IT = _mupdf.PDF_ENUM_NAME_IT
PDF_ENUM_NAME_Identity = _mupdf.PDF_ENUM_NAME_Identity
PDF_ENUM_NAME_Identity_H = _mupdf.PDF_ENUM_NAME_Identity_H
PDF_ENUM_NAME_Identity_V = _mupdf.PDF_ENUM_NAME_Identity_V
PDF_ENUM_NAME_Image = _mupdf.PDF_ENUM_NAME_Image
PDF_ENUM_NAME_ImageB = _mupdf.PDF_ENUM_NAME_ImageB
PDF_ENUM_NAME_ImageC = _mupdf.PDF_ENUM_NAME_ImageC
PDF_ENUM_NAME_ImageI = _mupdf.PDF_ENUM_NAME_ImageI
PDF_ENUM_NAME_ImageMask = _mupdf.PDF_ENUM_NAME_ImageMask
PDF_ENUM_NAME_Include = _mupdf.PDF_ENUM_NAME_Include
PDF_ENUM_NAME_Index = _mupdf.PDF_ENUM_NAME_Index
PDF_ENUM_NAME_Indexed = _mupdf.PDF_ENUM_NAME_Indexed
PDF_ENUM_NAME_Info = _mupdf.PDF_ENUM_NAME_Info
PDF_ENUM_NAME_Ink = _mupdf.PDF_ENUM_NAME_Ink
PDF_ENUM_NAME_InkList = _mupdf.PDF_ENUM_NAME_InkList
PDF_ENUM_NAME_Intent = _mupdf.PDF_ENUM_NAME_Intent
PDF_ENUM_NAME_Interpolate = _mupdf.PDF_ENUM_NAME_Interpolate
PDF_ENUM_NAME_IsMap = _mupdf.PDF_ENUM_NAME_IsMap
PDF_ENUM_NAME_ItalicAngle = _mupdf.PDF_ENUM_NAME_ItalicAngle
PDF_ENUM_NAME_JBIG2Decode = _mupdf.PDF_ENUM_NAME_JBIG2Decode
PDF_ENUM_NAME_JBIG2Globals = _mupdf.PDF_ENUM_NAME_JBIG2Globals
PDF_ENUM_NAME_JPXDecode = _mupdf.PDF_ENUM_NAME_JPXDecode
PDF_ENUM_NAME_JS = _mupdf.PDF_ENUM_NAME_JS
PDF_ENUM_NAME_JavaScript = _mupdf.PDF_ENUM_NAME_JavaScript
PDF_ENUM_NAME_K = _mupdf.PDF_ENUM_NAME_K
PDF_ENUM_NAME_Keywords = _mupdf.PDF_ENUM_NAME_Keywords
PDF_ENUM_NAME_Kids = _mupdf.PDF_ENUM_NAME_Kids
PDF_ENUM_NAME_L = _mupdf.PDF_ENUM_NAME_L
PDF_ENUM_NAME_LBody = _mupdf.PDF_ENUM_NAME_LBody
PDF_ENUM_NAME_LC = _mupdf.PDF_ENUM_NAME_LC
PDF_ENUM_NAME_LE = _mupdf.PDF_ENUM_NAME_LE
PDF_ENUM_NAME_LI = _mupdf.PDF_ENUM_NAME_LI
PDF_ENUM_NAME_LJ = _mupdf.PDF_ENUM_NAME_LJ
PDF_ENUM_NAME_LL = _mupdf.PDF_ENUM_NAME_LL
PDF_ENUM_NAME_LLE = _mupdf.PDF_ENUM_NAME_LLE
PDF_ENUM_NAME_LLO = _mupdf.PDF_ENUM_NAME_LLO
PDF_ENUM_NAME_LW = _mupdf.PDF_ENUM_NAME_LW
PDF_ENUM_NAME_LZ = _mupdf.PDF_ENUM_NAME_LZ
PDF_ENUM_NAME_LZW = _mupdf.PDF_ENUM_NAME_LZW
PDF_ENUM_NAME_LZWDecode = _mupdf.PDF_ENUM_NAME_LZWDecode
PDF_ENUM_NAME_Lab = _mupdf.PDF_ENUM_NAME_Lab
PDF_ENUM_NAME_Label = _mupdf.PDF_ENUM_NAME_Label
PDF_ENUM_NAME_Lang = _mupdf.PDF_ENUM_NAME_Lang
PDF_ENUM_NAME_Last = _mupdf.PDF_ENUM_NAME_Last
PDF_ENUM_NAME_LastChar = _mupdf.PDF_ENUM_NAME_LastChar
PDF_ENUM_NAME_LastPage = _mupdf.PDF_ENUM_NAME_LastPage
PDF_ENUM_NAME_Launch = _mupdf.PDF_ENUM_NAME_Launch
PDF_ENUM_NAME_Layer = _mupdf.PDF_ENUM_NAME_Layer
PDF_ENUM_NAME_Lbl = _mupdf.PDF_ENUM_NAME_Lbl
PDF_ENUM_NAME_Length = _mupdf.PDF_ENUM_NAME_Length
PDF_ENUM_NAME_Length1 = _mupdf.PDF_ENUM_NAME_Length1
PDF_ENUM_NAME_Length2 = _mupdf.PDF_ENUM_NAME_Length2
PDF_ENUM_NAME_Length3 = _mupdf.PDF_ENUM_NAME_Length3
PDF_ENUM_NAME_Limits = _mupdf.PDF_ENUM_NAME_Limits
PDF_ENUM_NAME_Line = _mupdf.PDF_ENUM_NAME_Line
PDF_ENUM_NAME_LineArrow = _mupdf.PDF_ENUM_NAME_LineArrow
PDF_ENUM_NAME_LineDimension = _mupdf.PDF_ENUM_NAME_LineDimension
PDF_ENUM_NAME_Linearized = _mupdf.PDF_ENUM_NAME_Linearized
PDF_ENUM_NAME_Link = _mupdf.PDF_ENUM_NAME_Link
PDF_ENUM_NAME_List = _mupdf.PDF_ENUM_NAME_List
PDF_ENUM_NAME_Location = _mupdf.PDF_ENUM_NAME_Location
PDF_ENUM_NAME_Lock = _mupdf.PDF_ENUM_NAME_Lock
PDF_ENUM_NAME_Locked = _mupdf.PDF_ENUM_NAME_Locked
PDF_ENUM_NAME_Luminosity = _mupdf.PDF_ENUM_NAME_Luminosity
PDF_ENUM_NAME_M = _mupdf.PDF_ENUM_NAME_M
PDF_ENUM_NAME_MCID = _mupdf.PDF_ENUM_NAME_MCID
PDF_ENUM_NAME_MK = _mupdf.PDF_ENUM_NAME_MK
PDF_ENUM_NAME_ML = _mupdf.PDF_ENUM_NAME_ML
PDF_ENUM_NAME_MMType1 = _mupdf.PDF_ENUM_NAME_MMType1
PDF_ENUM_NAME_Mac = _mupdf.PDF_ENUM_NAME_Mac
PDF_ENUM_NAME_Mask = _mupdf.PDF_ENUM_NAME_Mask
PDF_ENUM_NAME_Matrix = _mupdf.PDF_ENUM_NAME_Matrix
PDF_ENUM_NAME_Matte = _mupdf.PDF_ENUM_NAME_Matte
PDF_ENUM_NAME_MaxLen = _mupdf.PDF_ENUM_NAME_MaxLen
PDF_ENUM_NAME_MediaBox = _mupdf.PDF_ENUM_NAME_MediaBox
PDF_ENUM_NAME_Metadata = _mupdf.PDF_ENUM_NAME_Metadata
PDF_ENUM_NAME_MissingWidth = _mupdf.PDF_ENUM_NAME_MissingWidth
PDF_ENUM_NAME_ModDate = _mupdf.PDF_ENUM_NAME_ModDate
PDF_ENUM_NAME_Movie = _mupdf.PDF_ENUM_NAME_Movie
PDF_ENUM_NAME_Msg = _mupdf.PDF_ENUM_NAME_Msg
PDF_ENUM_NAME_Multiply = _mupdf.PDF_ENUM_NAME_Multiply
PDF_ENUM_NAME_N = _mupdf.PDF_ENUM_NAME_N
PDF_ENUM_NAME_Name = _mupdf.PDF_ENUM_NAME_Name
PDF_ENUM_NAME_Named = _mupdf.PDF_ENUM_NAME_Named
PDF_ENUM_NAME_Names = _mupdf.PDF_ENUM_NAME_Names
PDF_ENUM_NAME_NewWindow = _mupdf.PDF_ENUM_NAME_NewWindow
PDF_ENUM_NAME_Next = _mupdf.PDF_ENUM_NAME_Next
PDF_ENUM_NAME_NextPage = _mupdf.PDF_ENUM_NAME_NextPage
PDF_ENUM_NAME_NonEFontNoWarn = _mupdf.PDF_ENUM_NAME_NonEFontNoWarn
PDF_ENUM_NAME_NonStruct = _mupdf.PDF_ENUM_NAME_NonStruct
PDF_ENUM_NAME_None = _mupdf.PDF_ENUM_NAME_None
PDF_ENUM_NAME_Normal = _mupdf.PDF_ENUM_NAME_Normal
PDF_ENUM_NAME_NotApproved = _mupdf.PDF_ENUM_NAME_NotApproved
PDF_ENUM_NAME_NotForPublicRelease = _mupdf.PDF_ENUM_NAME_NotForPublicRelease
PDF_ENUM_NAME_Note = _mupdf.PDF_ENUM_NAME_Note
PDF_ENUM_NAME_NumSections = _mupdf.PDF_ENUM_NAME_NumSections
PDF_ENUM_NAME_Nums = _mupdf.PDF_ENUM_NAME_Nums
PDF_ENUM_NAME_O = _mupdf.PDF_ENUM_NAME_O
PDF_ENUM_NAME_OC = _mupdf.PDF_ENUM_NAME_OC
PDF_ENUM_NAME_OCG = _mupdf.PDF_ENUM_NAME_OCG
PDF_ENUM_NAME_OCGs = _mupdf.PDF_ENUM_NAME_OCGs
PDF_ENUM_NAME_OCMD = _mupdf.PDF_ENUM_NAME_OCMD
PDF_ENUM_NAME_OCProperties = _mupdf.PDF_ENUM_NAME_OCProperties
PDF_ENUM_NAME_OE = _mupdf.PDF_ENUM_NAME_OE
PDF_ENUM_NAME_OFF = _mupdf.PDF_ENUM_NAME_OFF
PDF_ENUM_NAME_ON = _mupdf.PDF_ENUM_NAME_ON
PDF_ENUM_NAME_OP = _mupdf.PDF_ENUM_NAME_OP
PDF_ENUM_NAME_OPM = _mupdf.PDF_ENUM_NAME_OPM
PDF_ENUM_NAME_OS = _mupdf.PDF_ENUM_NAME_OS
PDF_ENUM_NAME_ObjStm = _mupdf.PDF_ENUM_NAME_ObjStm
PDF_ENUM_NAME_Of = _mupdf.PDF_ENUM_NAME_Of
PDF_ENUM_NAME_Off = _mupdf.PDF_ENUM_NAME_Off
PDF_ENUM_NAME_Open = _mupdf.PDF_ENUM_NAME_Open
PDF_ENUM_NAME_OpenArrow = _mupdf.PDF_ENUM_NAME_OpenArrow
PDF_ENUM_NAME_OpenType = _mupdf.PDF_ENUM_NAME_OpenType
PDF_ENUM_NAME_Opt = _mupdf.PDF_ENUM_NAME_Opt
PDF_ENUM_NAME_Order = _mupdf.PDF_ENUM_NAME_Order
PDF_ENUM_NAME_Ordering = _mupdf.PDF_ENUM_NAME_Ordering
PDF_ENUM_NAME_Outlines = _mupdf.PDF_ENUM_NAME_Outlines
PDF_ENUM_NAME_OutputCondition = _mupdf.PDF_ENUM_NAME_OutputCondition
PDF_ENUM_NAME_OutputConditionIdentifier = _mupdf.PDF_ENUM_NAME_OutputConditionIdentifier
PDF_ENUM_NAME_OutputIntent = _mupdf.PDF_ENUM_NAME_OutputIntent
PDF_ENUM_NAME_OutputIntents = _mupdf.PDF_ENUM_NAME_OutputIntents
PDF_ENUM_NAME_P = _mupdf.PDF_ENUM_NAME_P
PDF_ENUM_NAME_PDF = _mupdf.PDF_ENUM_NAME_PDF
PDF_ENUM_NAME_PS = _mupdf.PDF_ENUM_NAME_PS
PDF_ENUM_NAME_Page = _mupdf.PDF_ENUM_NAME_Page
PDF_ENUM_NAME_PageLabels = _mupdf.PDF_ENUM_NAME_PageLabels
PDF_ENUM_NAME_PageMode = _mupdf.PDF_ENUM_NAME_PageMode
PDF_ENUM_NAME_Pages = _mupdf.PDF_ENUM_NAME_Pages
PDF_ENUM_NAME_PaintType = _mupdf.PDF_ENUM_NAME_PaintType
PDF_ENUM_NAME_Params = _mupdf.PDF_ENUM_NAME_Params
PDF_ENUM_NAME_Parent = _mupdf.PDF_ENUM_NAME_Parent
PDF_ENUM_NAME_ParentTree = _mupdf.PDF_ENUM_NAME_ParentTree
PDF_ENUM_NAME_Part = _mupdf.PDF_ENUM_NAME_Part
PDF_ENUM_NAME_Pattern = _mupdf.PDF_ENUM_NAME_Pattern
PDF_ENUM_NAME_PatternType = _mupdf.PDF_ENUM_NAME_PatternType
PDF_ENUM_NAME_Perms = _mupdf.PDF_ENUM_NAME_Perms
PDF_ENUM_NAME_PieceInfo = _mupdf.PDF_ENUM_NAME_PieceInfo
PDF_ENUM_NAME_PolyLine = _mupdf.PDF_ENUM_NAME_PolyLine
PDF_ENUM_NAME_PolyLineDimension = _mupdf.PDF_ENUM_NAME_PolyLineDimension
PDF_ENUM_NAME_Polygon = _mupdf.PDF_ENUM_NAME_Polygon
PDF_ENUM_NAME_PolygonCloud = _mupdf.PDF_ENUM_NAME_PolygonCloud
PDF_ENUM_NAME_PolygonDimension = _mupdf.PDF_ENUM_NAME_PolygonDimension
PDF_ENUM_NAME_Popup = _mupdf.PDF_ENUM_NAME_Popup
PDF_ENUM_NAME_PreRelease = _mupdf.PDF_ENUM_NAME_PreRelease
PDF_ENUM_NAME_Predictor = _mupdf.PDF_ENUM_NAME_Predictor
PDF_ENUM_NAME_Prev = _mupdf.PDF_ENUM_NAME_Prev
PDF_ENUM_NAME_PrevPage = _mupdf.PDF_ENUM_NAME_PrevPage
PDF_ENUM_NAME_Preview = _mupdf.PDF_ENUM_NAME_Preview
PDF_ENUM_NAME_Print = _mupdf.PDF_ENUM_NAME_Print
PDF_ENUM_NAME_PrinterMark = _mupdf.PDF_ENUM_NAME_PrinterMark
PDF_ENUM_NAME_Private = _mupdf.PDF_ENUM_NAME_Private
PDF_ENUM_NAME_ProcSet = _mupdf.PDF_ENUM_NAME_ProcSet
PDF_ENUM_NAME_Producer = _mupdf.PDF_ENUM_NAME_Producer
PDF_ENUM_NAME_Prop_AuthTime = _mupdf.PDF_ENUM_NAME_Prop_AuthTime
PDF_ENUM_NAME_Prop_AuthType = _mupdf.PDF_ENUM_NAME_Prop_AuthType
PDF_ENUM_NAME_Prop_Build = _mupdf.PDF_ENUM_NAME_Prop_Build
PDF_ENUM_NAME_Properties = _mupdf.PDF_ENUM_NAME_Properties
PDF_ENUM_NAME_PubSec = _mupdf.PDF_ENUM_NAME_PubSec
PDF_ENUM_NAME_Push = _mupdf.PDF_ENUM_NAME_Push
PDF_ENUM_NAME_Q = _mupdf.PDF_ENUM_NAME_Q
PDF_ENUM_NAME_QuadPoints = _mupdf.PDF_ENUM_NAME_QuadPoints
PDF_ENUM_NAME_Quote = _mupdf.PDF_ENUM_NAME_Quote
PDF_ENUM_NAME_R = _mupdf.PDF_ENUM_NAME_R
PDF_ENUM_NAME_RB = _mupdf.PDF_ENUM_NAME_RB
PDF_ENUM_NAME_RBGroups = _mupdf.PDF_ENUM_NAME_RBGroups
PDF_ENUM_NAME_RC = _mupdf.PDF_ENUM_NAME_RC
PDF_ENUM_NAME_RClosedArrow = _mupdf.PDF_ENUM_NAME_RClosedArrow
PDF_ENUM_NAME_RD = _mupdf.PDF_ENUM_NAME_RD
PDF_ENUM_NAME_REx = _mupdf.PDF_ENUM_NAME_REx
PDF_ENUM_NAME_RGB = _mupdf.PDF_ENUM_NAME_RGB
PDF_ENUM_NAME_RI = _mupdf.PDF_ENUM_NAME_RI
PDF_ENUM_NAME_RL = _mupdf.PDF_ENUM_NAME_RL
PDF_ENUM_NAME_ROpenArrow = _mupdf.PDF_ENUM_NAME_ROpenArrow
PDF_ENUM_NAME_RP = _mupdf.PDF_ENUM_NAME_RP
PDF_ENUM_NAME_RT = _mupdf.PDF_ENUM_NAME_RT
PDF_ENUM_NAME_Range = _mupdf.PDF_ENUM_NAME_Range
PDF_ENUM_NAME_Reason = _mupdf.PDF_ENUM_NAME_Reason
PDF_ENUM_NAME_Rect = _mupdf.PDF_ENUM_NAME_Rect
PDF_ENUM_NAME_Redact = _mupdf.PDF_ENUM_NAME_Redact
PDF_ENUM_NAME_Ref = _mupdf.PDF_ENUM_NAME_Ref
PDF_ENUM_NAME_Reference = _mupdf.PDF_ENUM_NAME_Reference
PDF_ENUM_NAME_Registry = _mupdf.PDF_ENUM_NAME_Registry
PDF_ENUM_NAME_ResetForm = _mupdf.PDF_ENUM_NAME_ResetForm
PDF_ENUM_NAME_Resources = _mupdf.PDF_ENUM_NAME_Resources
PDF_ENUM_NAME_RoleMap = _mupdf.PDF_ENUM_NAME_RoleMap
PDF_ENUM_NAME_Root = _mupdf.PDF_ENUM_NAME_Root
PDF_ENUM_NAME_Rotate = _mupdf.PDF_ENUM_NAME_Rotate
PDF_ENUM_NAME_Rows = _mupdf.PDF_ENUM_NAME_Rows
PDF_ENUM_NAME_Ruby = _mupdf.PDF_ENUM_NAME_Ruby
PDF_ENUM_NAME_RunLengthDecode = _mupdf.PDF_ENUM_NAME_RunLengthDecode
PDF_ENUM_NAME_S = _mupdf.PDF_ENUM_NAME_S
PDF_ENUM_NAME_SMask = _mupdf.PDF_ENUM_NAME_SMask
PDF_ENUM_NAME_SMaskInData = _mupdf.PDF_ENUM_NAME_SMaskInData
PDF_ENUM_NAME_Schema = _mupdf.PDF_ENUM_NAME_Schema
PDF_ENUM_NAME_Screen = _mupdf.PDF_ENUM_NAME_Screen
PDF_ENUM_NAME_Sect = _mupdf.PDF_ENUM_NAME_Sect
PDF_ENUM_NAME_Separation = _mupdf.PDF_ENUM_NAME_Separation
PDF_ENUM_NAME_Shading = _mupdf.PDF_ENUM_NAME_Shading
PDF_ENUM_NAME_ShadingType = _mupdf.PDF_ENUM_NAME_ShadingType
PDF_ENUM_NAME_Si = _mupdf.PDF_ENUM_NAME_Si
PDF_ENUM_NAME_Sig = _mupdf.PDF_ENUM_NAME_Sig
PDF_ENUM_NAME_SigFlags = _mupdf.PDF_ENUM_NAME_SigFlags
PDF_ENUM_NAME_SigQ = _mupdf.PDF_ENUM_NAME_SigQ
PDF_ENUM_NAME_SigRef = _mupdf.PDF_ENUM_NAME_SigRef
PDF_ENUM_NAME_Size = _mupdf.PDF_ENUM_NAME_Size
PDF_ENUM_NAME_Slash = _mupdf.PDF_ENUM_NAME_Slash
PDF_ENUM_NAME_Sold = _mupdf.PDF_ENUM_NAME_Sold
PDF_ENUM_NAME_Sound = _mupdf.PDF_ENUM_NAME_Sound
PDF_ENUM_NAME_Source = _mupdf.PDF_ENUM_NAME_Source
PDF_ENUM_NAME_Span = _mupdf.PDF_ENUM_NAME_Span
PDF_ENUM_NAME_Split = _mupdf.PDF_ENUM_NAME_Split
PDF_ENUM_NAME_Square = _mupdf.PDF_ENUM_NAME_Square
PDF_ENUM_NAME_Squiggly = _mupdf.PDF_ENUM_NAME_Squiggly
PDF_ENUM_NAME_St = _mupdf.PDF_ENUM_NAME_St
PDF_ENUM_NAME_Stamp = _mupdf.PDF_ENUM_NAME_Stamp
PDF_ENUM_NAME_StampImage = _mupdf.PDF_ENUM_NAME_StampImage
PDF_ENUM_NAME_StampSnapshot = _mupdf.PDF_ENUM_NAME_StampSnapshot
PDF_ENUM_NAME_Standard = _mupdf.PDF_ENUM_NAME_Standard
PDF_ENUM_NAME_StdCF = _mupdf.PDF_ENUM_NAME_StdCF
PDF_ENUM_NAME_StemV = _mupdf.PDF_ENUM_NAME_StemV
PDF_ENUM_NAME_StmF = _mupdf.PDF_ENUM_NAME_StmF
PDF_ENUM_NAME_StrF = _mupdf.PDF_ENUM_NAME_StrF
PDF_ENUM_NAME_StrikeOut = _mupdf.PDF_ENUM_NAME_StrikeOut
PDF_ENUM_NAME_Strong = _mupdf.PDF_ENUM_NAME_Strong
PDF_ENUM_NAME_StructParent = _mupdf.PDF_ENUM_NAME_StructParent
PDF_ENUM_NAME_StructParents = _mupdf.PDF_ENUM_NAME_StructParents
PDF_ENUM_NAME_StructTreeRoot = _mupdf.PDF_ENUM_NAME_StructTreeRoot
PDF_ENUM_NAME_Sub = _mupdf.PDF_ENUM_NAME_Sub
PDF_ENUM_NAME_SubFilter = _mupdf.PDF_ENUM_NAME_SubFilter
PDF_ENUM_NAME_Subject = _mupdf.PDF_ENUM_NAME_Subject
PDF_ENUM_NAME_Subtype = _mupdf.PDF_ENUM_NAME_Subtype
PDF_ENUM_NAME_Subtype2 = _mupdf.PDF_ENUM_NAME_Subtype2
PDF_ENUM_NAME_Supplement = _mupdf.PDF_ENUM_NAME_Supplement
PDF_ENUM_NAME_Symb = _mupdf.PDF_ENUM_NAME_Symb
PDF_ENUM_NAME_T = _mupdf.PDF_ENUM_NAME_T
PDF_ENUM_NAME_TBody = _mupdf.PDF_ENUM_NAME_TBody
PDF_ENUM_NAME_TD = _mupdf.PDF_ENUM_NAME_TD
PDF_ENUM_NAME_TFoot = _mupdf.PDF_ENUM_NAME_TFoot
PDF_ENUM_NAME_TH = _mupdf.PDF_ENUM_NAME_TH
PDF_ENUM_NAME_THead = _mupdf.PDF_ENUM_NAME_THead
PDF_ENUM_NAME_TI = _mupdf.PDF_ENUM_NAME_TI
PDF_ENUM_NAME_TOC = _mupdf.PDF_ENUM_NAME_TOC
PDF_ENUM_NAME_TOCI = _mupdf.PDF_ENUM_NAME_TOCI
PDF_ENUM_NAME_TR = _mupdf.PDF_ENUM_NAME_TR
PDF_ENUM_NAME_TR2 = _mupdf.PDF_ENUM_NAME_TR2
PDF_ENUM_NAME_TU = _mupdf.PDF_ENUM_NAME_TU
PDF_ENUM_NAME_Table = _mupdf.PDF_ENUM_NAME_Table
PDF_ENUM_NAME_Text = _mupdf.PDF_ENUM_NAME_Text
PDF_ENUM_NAME_Thumb = _mupdf.PDF_ENUM_NAME_Thumb
PDF_ENUM_NAME_TilingType = _mupdf.PDF_ENUM_NAME_TilingType
PDF_ENUM_NAME_Times = _mupdf.PDF_ENUM_NAME_Times
PDF_ENUM_NAME_Title = _mupdf.PDF_ENUM_NAME_Title
PDF_ENUM_NAME_ToUnicode = _mupdf.PDF_ENUM_NAME_ToUnicode
PDF_ENUM_NAME_Top = _mupdf.PDF_ENUM_NAME_Top
PDF_ENUM_NAME_TopSecret = _mupdf.PDF_ENUM_NAME_TopSecret
PDF_ENUM_NAME_Trans = _mupdf.PDF_ENUM_NAME_Trans
PDF_ENUM_NAME_TransformMethod = _mupdf.PDF_ENUM_NAME_TransformMethod
PDF_ENUM_NAME_TransformParams = _mupdf.PDF_ENUM_NAME_TransformParams
PDF_ENUM_NAME_Transparency = _mupdf.PDF_ENUM_NAME_Transparency
PDF_ENUM_NAME_TrapNet = _mupdf.PDF_ENUM_NAME_TrapNet
PDF_ENUM_NAME_TrimBox = _mupdf.PDF_ENUM_NAME_TrimBox
PDF_ENUM_NAME_TrueType = _mupdf.PDF_ENUM_NAME_TrueType
PDF_ENUM_NAME_TrustedMode = _mupdf.PDF_ENUM_NAME_TrustedMode
PDF_ENUM_NAME_Tx = _mupdf.PDF_ENUM_NAME_Tx
PDF_ENUM_NAME_Type = _mupdf.PDF_ENUM_NAME_Type
PDF_ENUM_NAME_Type0 = _mupdf.PDF_ENUM_NAME_Type0
PDF_ENUM_NAME_Type1 = _mupdf.PDF_ENUM_NAME_Type1
PDF_ENUM_NAME_Type1C = _mupdf.PDF_ENUM_NAME_Type1C
PDF_ENUM_NAME_Type3 = _mupdf.PDF_ENUM_NAME_Type3
PDF_ENUM_NAME_U = _mupdf.PDF_ENUM_NAME_U
PDF_ENUM_NAME_UE = _mupdf.PDF_ENUM_NAME_UE
PDF_ENUM_NAME_UF = _mupdf.PDF_ENUM_NAME_UF
PDF_ENUM_NAME_URI = _mupdf.PDF_ENUM_NAME_URI
PDF_ENUM_NAME_URL = _mupdf.PDF_ENUM_NAME_URL
PDF_ENUM_NAME_Unchanged = _mupdf.PDF_ENUM_NAME_Unchanged
PDF_ENUM_NAME_Uncover = _mupdf.PDF_ENUM_NAME_Uncover
PDF_ENUM_NAME_Underline = _mupdf.PDF_ENUM_NAME_Underline
PDF_ENUM_NAME_Unix = _mupdf.PDF_ENUM_NAME_Unix
PDF_ENUM_NAME_Unspecified = _mupdf.PDF_ENUM_NAME_Unspecified
PDF_ENUM_NAME_Usage = _mupdf.PDF_ENUM_NAME_Usage
PDF_ENUM_NAME_UseBlackPtComp = _mupdf.PDF_ENUM_NAME_UseBlackPtComp
PDF_ENUM_NAME_UseCMap = _mupdf.PDF_ENUM_NAME_UseCMap
PDF_ENUM_NAME_UseOutlines = _mupdf.PDF_ENUM_NAME_UseOutlines
PDF_ENUM_NAME_UserUnit = _mupdf.PDF_ENUM_NAME_UserUnit
PDF_ENUM_NAME_V = _mupdf.PDF_ENUM_NAME_V
PDF_ENUM_NAME_V2 = _mupdf.PDF_ENUM_NAME_V2
PDF_ENUM_NAME_VE = _mupdf.PDF_ENUM_NAME_VE
PDF_ENUM_NAME_Version = _mupdf.PDF_ENUM_NAME_Version
PDF_ENUM_NAME_Vertices = _mupdf.PDF_ENUM_NAME_Vertices
PDF_ENUM_NAME_VerticesPerRow = _mupdf.PDF_ENUM_NAME_VerticesPerRow
PDF_ENUM_NAME_View = _mupdf.PDF_ENUM_NAME_View
PDF_ENUM_NAME_W = _mupdf.PDF_ENUM_NAME_W
PDF_ENUM_NAME_W2 = _mupdf.PDF_ENUM_NAME_W2
PDF_ENUM_NAME_WMode = _mupdf.PDF_ENUM_NAME_WMode
PDF_ENUM_NAME_WP = _mupdf.PDF_ENUM_NAME_WP
PDF_ENUM_NAME_WT = _mupdf.PDF_ENUM_NAME_WT
PDF_ENUM_NAME_Warichu = _mupdf.PDF_ENUM_NAME_Warichu
PDF_ENUM_NAME_Watermark = _mupdf.PDF_ENUM_NAME_Watermark
PDF_ENUM_NAME_WhitePoint = _mupdf.PDF_ENUM_NAME_WhitePoint
PDF_ENUM_NAME_Widget = _mupdf.PDF_ENUM_NAME_Widget
PDF_ENUM_NAME_Width = _mupdf.PDF_ENUM_NAME_Width
PDF_ENUM_NAME_Widths = _mupdf.PDF_ENUM_NAME_Widths
PDF_ENUM_NAME_WinAnsiEncoding = _mupdf.PDF_ENUM_NAME_WinAnsiEncoding
PDF_ENUM_NAME_Wipe = _mupdf.PDF_ENUM_NAME_Wipe
PDF_ENUM_NAME_XFA = _mupdf.PDF_ENUM_NAME_XFA
PDF_ENUM_NAME_XHeight = _mupdf.PDF_ENUM_NAME_XHeight
PDF_ENUM_NAME_XML = _mupdf.PDF_ENUM_NAME_XML
PDF_ENUM_NAME_XObject = _mupdf.PDF_ENUM_NAME_XObject
PDF_ENUM_NAME_XRef = _mupdf.PDF_ENUM_NAME_XRef
PDF_ENUM_NAME_XRefStm = _mupdf.PDF_ENUM_NAME_XRefStm
PDF_ENUM_NAME_XStep = _mupdf.PDF_ENUM_NAME_XStep
PDF_ENUM_NAME_XYZ = _mupdf.PDF_ENUM_NAME_XYZ
PDF_ENUM_NAME_YStep = _mupdf.PDF_ENUM_NAME_YStep
PDF_ENUM_NAME_Yes = _mupdf.PDF_ENUM_NAME_Yes
PDF_ENUM_NAME_ZaDb = _mupdf.PDF_ENUM_NAME_ZaDb
PDF_ENUM_NAME_a = _mupdf.PDF_ENUM_NAME_a
PDF_ENUM_NAME_adbe_pkcs7_detached = _mupdf.PDF_ENUM_NAME_adbe_pkcs7_detached
PDF_ENUM_NAME_ca = _mupdf.PDF_ENUM_NAME_ca
PDF_ENUM_NAME_n0 = _mupdf.PDF_ENUM_NAME_n0
PDF_ENUM_NAME_n1 = _mupdf.PDF_ENUM_NAME_n1
PDF_ENUM_NAME_n2 = _mupdf.PDF_ENUM_NAME_n2
PDF_ENUM_NAME_op = _mupdf.PDF_ENUM_NAME_op
PDF_ENUM_NAME_r = _mupdf.PDF_ENUM_NAME_r
PDF_ENUM_LIMIT = _mupdf.PDF_ENUM_LIMIT
PDF_LEXBUF_SMALL = _mupdf.PDF_LEXBUF_SMALL
PDF_LEXBUF_LARGE = _mupdf.PDF_LEXBUF_LARGE
class pdf_lexbuf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    size = property(_mupdf.pdf_lexbuf_size_get, _mupdf.pdf_lexbuf_size_set)
    base_size = property(_mupdf.pdf_lexbuf_base_size_get, _mupdf.pdf_lexbuf_base_size_set)
    len = property(_mupdf.pdf_lexbuf_len_get, _mupdf.pdf_lexbuf_len_set)
    i = property(_mupdf.pdf_lexbuf_i_get, _mupdf.pdf_lexbuf_i_set)
    f = property(_mupdf.pdf_lexbuf_f_get, _mupdf.pdf_lexbuf_f_set)
    scratch = property(_mupdf.pdf_lexbuf_scratch_get, _mupdf.pdf_lexbuf_scratch_set)
    buffer = property(_mupdf.pdf_lexbuf_buffer_get, _mupdf.pdf_lexbuf_buffer_set)

    def __init__(self):
        _mupdf.pdf_lexbuf_swiginit(self, _mupdf.new_pdf_lexbuf())
    __swig_destroy__ = _mupdf.delete_pdf_lexbuf

# Register pdf_lexbuf in _mupdf:
_mupdf.pdf_lexbuf_swigregister(pdf_lexbuf)
class pdf_lexbuf_large(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    base = property(_mupdf.pdf_lexbuf_large_base_get, _mupdf.pdf_lexbuf_large_base_set)
    buffer = property(_mupdf.pdf_lexbuf_large_buffer_get, _mupdf.pdf_lexbuf_large_buffer_set)

    def __init__(self):
        _mupdf.pdf_lexbuf_large_swiginit(self, _mupdf.new_pdf_lexbuf_large())
    __swig_destroy__ = _mupdf.delete_pdf_lexbuf_large

# Register pdf_lexbuf_large in _mupdf:
_mupdf.pdf_lexbuf_large_swigregister(pdf_lexbuf_large)
class pdf_js_console(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.pdf_js_console_drop_get, _mupdf.pdf_js_console_drop_set)
    show = property(_mupdf.pdf_js_console_show_get, _mupdf.pdf_js_console_show_set)
    hide = property(_mupdf.pdf_js_console_hide_get, _mupdf.pdf_js_console_hide_set)
    clear = property(_mupdf.pdf_js_console_clear_get, _mupdf.pdf_js_console_clear_set)
    write = property(_mupdf.pdf_js_console_write_get, _mupdf.pdf_js_console_write_set)

    def __init__(self):
        _mupdf.pdf_js_console_swiginit(self, _mupdf.new_pdf_js_console())
    __swig_destroy__ = _mupdf.delete_pdf_js_console

# Register pdf_js_console in _mupdf:
_mupdf.pdf_js_console_swigregister(pdf_js_console)
class pdf_layer_config(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_mupdf.pdf_layer_config_name_get, _mupdf.pdf_layer_config_name_set)
    creator = property(_mupdf.pdf_layer_config_creator_get, _mupdf.pdf_layer_config_creator_set)

    def __init__(self):
        _mupdf.pdf_layer_config_swiginit(self, _mupdf.new_pdf_layer_config())
    __swig_destroy__ = _mupdf.delete_pdf_layer_config

# Register pdf_layer_config in _mupdf:
_mupdf.pdf_layer_config_swigregister(pdf_layer_config)
PDF_LAYER_UI_LABEL = _mupdf.PDF_LAYER_UI_LABEL
PDF_LAYER_UI_CHECKBOX = _mupdf.PDF_LAYER_UI_CHECKBOX
PDF_LAYER_UI_RADIOBOX = _mupdf.PDF_LAYER_UI_RADIOBOX
class pdf_layer_config_ui(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    text = property(_mupdf.pdf_layer_config_ui_text_get, _mupdf.pdf_layer_config_ui_text_set)
    depth = property(_mupdf.pdf_layer_config_ui_depth_get, _mupdf.pdf_layer_config_ui_depth_set)
    type = property(_mupdf.pdf_layer_config_ui_type_get, _mupdf.pdf_layer_config_ui_type_set)
    selected = property(_mupdf.pdf_layer_config_ui_selected_get, _mupdf.pdf_layer_config_ui_selected_set)
    locked = property(_mupdf.pdf_layer_config_ui_locked_get, _mupdf.pdf_layer_config_ui_locked_set)

    def __init__(self):
        _mupdf.pdf_layer_config_ui_swiginit(self, _mupdf.new_pdf_layer_config_ui())
    __swig_destroy__ = _mupdf.delete_pdf_layer_config_ui

# Register pdf_layer_config_ui in _mupdf:
_mupdf.pdf_layer_config_ui_swigregister(pdf_layer_config_ui)
class pdf_unsaved_sig(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    field = property(_mupdf.pdf_unsaved_sig_field_get, _mupdf.pdf_unsaved_sig_field_set)
    byte_range_start = property(_mupdf.pdf_unsaved_sig_byte_range_start_get, _mupdf.pdf_unsaved_sig_byte_range_start_set)
    byte_range_end = property(_mupdf.pdf_unsaved_sig_byte_range_end_get, _mupdf.pdf_unsaved_sig_byte_range_end_set)
    contents_start = property(_mupdf.pdf_unsaved_sig_contents_start_get, _mupdf.pdf_unsaved_sig_contents_start_set)
    contents_end = property(_mupdf.pdf_unsaved_sig_contents_end_get, _mupdf.pdf_unsaved_sig_contents_end_set)
    signer = property(_mupdf.pdf_unsaved_sig_signer_get, _mupdf.pdf_unsaved_sig_signer_set)
    next = property(_mupdf.pdf_unsaved_sig_next_get, _mupdf.pdf_unsaved_sig_next_set)

    def __init__(self):
        _mupdf.pdf_unsaved_sig_swiginit(self, _mupdf.new_pdf_unsaved_sig())
    __swig_destroy__ = _mupdf.delete_pdf_unsaved_sig

# Register pdf_unsaved_sig in _mupdf:
_mupdf.pdf_unsaved_sig_swigregister(pdf_unsaved_sig)
class pdf_rev_page_map(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    page = property(_mupdf.pdf_rev_page_map_page_get, _mupdf.pdf_rev_page_map_page_set)
    object = property(_mupdf.pdf_rev_page_map_object_get, _mupdf.pdf_rev_page_map_object_set)

    def __init__(self):
        _mupdf.pdf_rev_page_map_swiginit(self, _mupdf.new_pdf_rev_page_map())
    __swig_destroy__ = _mupdf.delete_pdf_rev_page_map

# Register pdf_rev_page_map in _mupdf:
_mupdf.pdf_rev_page_map_swigregister(pdf_rev_page_map)
class pdf_hint_page(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    number = property(_mupdf.pdf_hint_page_number_get, _mupdf.pdf_hint_page_number_set)
    offset = property(_mupdf.pdf_hint_page_offset_get, _mupdf.pdf_hint_page_offset_set)
    index = property(_mupdf.pdf_hint_page_index_get, _mupdf.pdf_hint_page_index_set)

    def __init__(self):
        _mupdf.pdf_hint_page_swiginit(self, _mupdf.new_pdf_hint_page())
    __swig_destroy__ = _mupdf.delete_pdf_hint_page

# Register pdf_hint_page in _mupdf:
_mupdf.pdf_hint_page_swigregister(pdf_hint_page)
class pdf_hint_shared(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    number = property(_mupdf.pdf_hint_shared_number_get, _mupdf.pdf_hint_shared_number_set)
    offset = property(_mupdf.pdf_hint_shared_offset_get, _mupdf.pdf_hint_shared_offset_set)

    def __init__(self):
        _mupdf.pdf_hint_shared_swiginit(self, _mupdf.new_pdf_hint_shared())
    __swig_destroy__ = _mupdf.delete_pdf_hint_shared

# Register pdf_hint_shared in _mupdf:
_mupdf.pdf_hint_shared_swigregister(pdf_hint_shared)
class pdf_document(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    super = property(_mupdf.pdf_document_super_get, _mupdf.pdf_document_super_set)
    file = property(_mupdf.pdf_document_file_get, _mupdf.pdf_document_file_set)
    version = property(_mupdf.pdf_document_version_get, _mupdf.pdf_document_version_set)
    is_fdf = property(_mupdf.pdf_document_is_fdf_get, _mupdf.pdf_document_is_fdf_set)
    startxref = property(_mupdf.pdf_document_startxref_get, _mupdf.pdf_document_startxref_set)
    file_size = property(_mupdf.pdf_document_file_size_get, _mupdf.pdf_document_file_size_set)
    crypt = property(_mupdf.pdf_document_crypt_get, _mupdf.pdf_document_crypt_set)
    ocg = property(_mupdf.pdf_document_ocg_get, _mupdf.pdf_document_ocg_set)
    oi = property(_mupdf.pdf_document_oi_get, _mupdf.pdf_document_oi_set)
    max_xref_len = property(_mupdf.pdf_document_max_xref_len_get, _mupdf.pdf_document_max_xref_len_set)
    num_xref_sections = property(_mupdf.pdf_document_num_xref_sections_get, _mupdf.pdf_document_num_xref_sections_set)
    saved_num_xref_sections = property(_mupdf.pdf_document_saved_num_xref_sections_get, _mupdf.pdf_document_saved_num_xref_sections_set)
    num_incremental_sections = property(_mupdf.pdf_document_num_incremental_sections_get, _mupdf.pdf_document_num_incremental_sections_set)
    xref_base = property(_mupdf.pdf_document_xref_base_get, _mupdf.pdf_document_xref_base_set)
    disallow_new_increments = property(_mupdf.pdf_document_disallow_new_increments_get, _mupdf.pdf_document_disallow_new_increments_set)
    local_xref = property(_mupdf.pdf_document_local_xref_get, _mupdf.pdf_document_local_xref_set)
    local_xref_nesting = property(_mupdf.pdf_document_local_xref_nesting_get, _mupdf.pdf_document_local_xref_nesting_set)
    xref_sections = property(_mupdf.pdf_document_xref_sections_get, _mupdf.pdf_document_xref_sections_set)
    saved_xref_sections = property(_mupdf.pdf_document_saved_xref_sections_get, _mupdf.pdf_document_saved_xref_sections_set)
    xref_index = property(_mupdf.pdf_document_xref_index_get, _mupdf.pdf_document_xref_index_set)
    save_in_progress = property(_mupdf.pdf_document_save_in_progress_get, _mupdf.pdf_document_save_in_progress_set)
    last_xref_was_old_style = property(_mupdf.pdf_document_last_xref_was_old_style_get, _mupdf.pdf_document_last_xref_was_old_style_set)
    has_linearization_object = property(_mupdf.pdf_document_has_linearization_object_get, _mupdf.pdf_document_has_linearization_object_set)
    map_page_count = property(_mupdf.pdf_document_map_page_count_get, _mupdf.pdf_document_map_page_count_set)
    rev_page_map = property(_mupdf.pdf_document_rev_page_map_get, _mupdf.pdf_document_rev_page_map_set)
    fwd_page_map = property(_mupdf.pdf_document_fwd_page_map_get, _mupdf.pdf_document_fwd_page_map_set)
    page_tree_broken = property(_mupdf.pdf_document_page_tree_broken_get, _mupdf.pdf_document_page_tree_broken_set)
    repair_attempted = property(_mupdf.pdf_document_repair_attempted_get, _mupdf.pdf_document_repair_attempted_set)
    repair_in_progress = property(_mupdf.pdf_document_repair_in_progress_get, _mupdf.pdf_document_repair_in_progress_set)
    non_structural_change = property(_mupdf.pdf_document_non_structural_change_get, _mupdf.pdf_document_non_structural_change_set)
    file_reading_linearly = property(_mupdf.pdf_document_file_reading_linearly_get, _mupdf.pdf_document_file_reading_linearly_set)
    file_length = property(_mupdf.pdf_document_file_length_get, _mupdf.pdf_document_file_length_set)
    linear_page_count = property(_mupdf.pdf_document_linear_page_count_get, _mupdf.pdf_document_linear_page_count_set)
    linear_obj = property(_mupdf.pdf_document_linear_obj_get, _mupdf.pdf_document_linear_obj_set)
    linear_page_refs = property(_mupdf.pdf_document_linear_page_refs_get, _mupdf.pdf_document_linear_page_refs_set)
    linear_page1_obj_num = property(_mupdf.pdf_document_linear_page1_obj_num_get, _mupdf.pdf_document_linear_page1_obj_num_set)
    linear_pos = property(_mupdf.pdf_document_linear_pos_get, _mupdf.pdf_document_linear_pos_set)
    linear_page_num = property(_mupdf.pdf_document_linear_page_num_get, _mupdf.pdf_document_linear_page_num_set)
    hint_object_offset = property(_mupdf.pdf_document_hint_object_offset_get, _mupdf.pdf_document_hint_object_offset_set)
    hint_object_length = property(_mupdf.pdf_document_hint_object_length_get, _mupdf.pdf_document_hint_object_length_set)
    hints_loaded = property(_mupdf.pdf_document_hints_loaded_get, _mupdf.pdf_document_hints_loaded_set)
    hint_page = property(_mupdf.pdf_document_hint_page_get, _mupdf.pdf_document_hint_page_set)
    hint_shared_ref = property(_mupdf.pdf_document_hint_shared_ref_get, _mupdf.pdf_document_hint_shared_ref_set)
    hint_shared = property(_mupdf.pdf_document_hint_shared_get, _mupdf.pdf_document_hint_shared_set)
    hint_obj_offsets_max = property(_mupdf.pdf_document_hint_obj_offsets_max_get, _mupdf.pdf_document_hint_obj_offsets_max_set)
    hint_obj_offsets = property(_mupdf.pdf_document_hint_obj_offsets_get, _mupdf.pdf_document_hint_obj_offsets_set)
    resources_localised = property(_mupdf.pdf_document_resources_localised_get, _mupdf.pdf_document_resources_localised_set)
    lexbuf = property(_mupdf.pdf_document_lexbuf_get, _mupdf.pdf_document_lexbuf_set)
    js = property(_mupdf.pdf_document_js_get, _mupdf.pdf_document_js_set)
    recalculate = property(_mupdf.pdf_document_recalculate_get, _mupdf.pdf_document_recalculate_set)
    redacted = property(_mupdf.pdf_document_redacted_get, _mupdf.pdf_document_redacted_set)
    resynth_required = property(_mupdf.pdf_document_resynth_required_get, _mupdf.pdf_document_resynth_required_set)
    event_cb = property(_mupdf.pdf_document_event_cb_get, _mupdf.pdf_document_event_cb_set)
    free_event_data_cb = property(_mupdf.pdf_document_free_event_data_cb_get, _mupdf.pdf_document_free_event_data_cb_set)
    event_cb_data = property(_mupdf.pdf_document_event_cb_data_get, _mupdf.pdf_document_event_cb_data_set)
    num_type3_fonts = property(_mupdf.pdf_document_num_type3_fonts_get, _mupdf.pdf_document_num_type3_fonts_set)
    max_type3_fonts = property(_mupdf.pdf_document_max_type3_fonts_get, _mupdf.pdf_document_max_type3_fonts_set)
    type3_fonts = property(_mupdf.pdf_document_type3_fonts_get, _mupdf.pdf_document_type3_fonts_set)
    orphans_max = property(_mupdf.pdf_document_orphans_max_get, _mupdf.pdf_document_orphans_max_set)
    orphans_count = property(_mupdf.pdf_document_orphans_count_get, _mupdf.pdf_document_orphans_count_set)
    orphans = property(_mupdf.pdf_document_orphans_get, _mupdf.pdf_document_orphans_set)
    xfa = property(_mupdf.pdf_document_xfa_get, _mupdf.pdf_document_xfa_set)
    journal = property(_mupdf.pdf_document_journal_get, _mupdf.pdf_document_journal_set)

    def __init__(self):
        _mupdf.pdf_document_swiginit(self, _mupdf.new_pdf_document())
    __swig_destroy__ = _mupdf.delete_pdf_document

# Register pdf_document in _mupdf:
_mupdf.pdf_document_swigregister(pdf_document)
PDF_PAGE_LABEL_NONE = _mupdf.PDF_PAGE_LABEL_NONE
PDF_PAGE_LABEL_DECIMAL = _mupdf.PDF_PAGE_LABEL_DECIMAL
PDF_PAGE_LABEL_ROMAN_UC = _mupdf.PDF_PAGE_LABEL_ROMAN_UC
PDF_PAGE_LABEL_ROMAN_LC = _mupdf.PDF_PAGE_LABEL_ROMAN_LC
PDF_PAGE_LABEL_ALPHA_UC = _mupdf.PDF_PAGE_LABEL_ALPHA_UC
PDF_PAGE_LABEL_ALPHA_LC = _mupdf.PDF_PAGE_LABEL_ALPHA_LC
class pdf_write_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    do_incremental = property(_mupdf.pdf_write_options_do_incremental_get, _mupdf.pdf_write_options_do_incremental_set)
    do_pretty = property(_mupdf.pdf_write_options_do_pretty_get, _mupdf.pdf_write_options_do_pretty_set)
    do_ascii = property(_mupdf.pdf_write_options_do_ascii_get, _mupdf.pdf_write_options_do_ascii_set)
    do_compress = property(_mupdf.pdf_write_options_do_compress_get, _mupdf.pdf_write_options_do_compress_set)
    do_compress_images = property(_mupdf.pdf_write_options_do_compress_images_get, _mupdf.pdf_write_options_do_compress_images_set)
    do_compress_fonts = property(_mupdf.pdf_write_options_do_compress_fonts_get, _mupdf.pdf_write_options_do_compress_fonts_set)
    do_decompress = property(_mupdf.pdf_write_options_do_decompress_get, _mupdf.pdf_write_options_do_decompress_set)
    do_garbage = property(_mupdf.pdf_write_options_do_garbage_get, _mupdf.pdf_write_options_do_garbage_set)
    do_linear = property(_mupdf.pdf_write_options_do_linear_get, _mupdf.pdf_write_options_do_linear_set)
    do_clean = property(_mupdf.pdf_write_options_do_clean_get, _mupdf.pdf_write_options_do_clean_set)
    do_sanitize = property(_mupdf.pdf_write_options_do_sanitize_get, _mupdf.pdf_write_options_do_sanitize_set)
    do_appearance = property(_mupdf.pdf_write_options_do_appearance_get, _mupdf.pdf_write_options_do_appearance_set)
    do_encrypt = property(_mupdf.pdf_write_options_do_encrypt_get, _mupdf.pdf_write_options_do_encrypt_set)
    dont_regenerate_id = property(_mupdf.pdf_write_options_dont_regenerate_id_get, _mupdf.pdf_write_options_dont_regenerate_id_set)
    permissions = property(_mupdf.pdf_write_options_permissions_get, _mupdf.pdf_write_options_permissions_set)
    opwd_utf8 = property(_mupdf.pdf_write_options_opwd_utf8_get, _mupdf.pdf_write_options_opwd_utf8_set)
    upwd_utf8 = property(_mupdf.pdf_write_options_upwd_utf8_get, _mupdf.pdf_write_options_upwd_utf8_set)
    do_snapshot = property(_mupdf.pdf_write_options_do_snapshot_get, _mupdf.pdf_write_options_do_snapshot_set)
    do_preserve_metadata = property(_mupdf.pdf_write_options_do_preserve_metadata_get, _mupdf.pdf_write_options_do_preserve_metadata_set)
    do_use_objstms = property(_mupdf.pdf_write_options_do_use_objstms_get, _mupdf.pdf_write_options_do_use_objstms_set)
    compression_effort = property(_mupdf.pdf_write_options_compression_effort_get, _mupdf.pdf_write_options_compression_effort_set)

    def __init__(self):
        _mupdf.pdf_write_options_swiginit(self, _mupdf.new_pdf_write_options())
    __swig_destroy__ = _mupdf.delete_pdf_write_options

# Register pdf_write_options in _mupdf:
_mupdf.pdf_write_options_swigregister(pdf_write_options)
PDF_TOK_ERROR = _mupdf.PDF_TOK_ERROR
PDF_TOK_EOF = _mupdf.PDF_TOK_EOF
PDF_TOK_OPEN_ARRAY = _mupdf.PDF_TOK_OPEN_ARRAY
PDF_TOK_CLOSE_ARRAY = _mupdf.PDF_TOK_CLOSE_ARRAY
PDF_TOK_OPEN_DICT = _mupdf.PDF_TOK_OPEN_DICT
PDF_TOK_CLOSE_DICT = _mupdf.PDF_TOK_CLOSE_DICT
PDF_TOK_OPEN_BRACE = _mupdf.PDF_TOK_OPEN_BRACE
PDF_TOK_CLOSE_BRACE = _mupdf.PDF_TOK_CLOSE_BRACE
PDF_TOK_NAME = _mupdf.PDF_TOK_NAME
PDF_TOK_INT = _mupdf.PDF_TOK_INT
PDF_TOK_REAL = _mupdf.PDF_TOK_REAL
PDF_TOK_STRING = _mupdf.PDF_TOK_STRING
PDF_TOK_KEYWORD = _mupdf.PDF_TOK_KEYWORD
PDF_TOK_R = _mupdf.PDF_TOK_R
PDF_TOK_TRUE = _mupdf.PDF_TOK_TRUE
PDF_TOK_FALSE = _mupdf.PDF_TOK_FALSE
PDF_TOK_NULL = _mupdf.PDF_TOK_NULL
PDF_TOK_OBJ = _mupdf.PDF_TOK_OBJ
PDF_TOK_ENDOBJ = _mupdf.PDF_TOK_ENDOBJ
PDF_TOK_STREAM = _mupdf.PDF_TOK_STREAM
PDF_TOK_ENDSTREAM = _mupdf.PDF_TOK_ENDSTREAM
PDF_TOK_XREF = _mupdf.PDF_TOK_XREF
PDF_TOK_TRAILER = _mupdf.PDF_TOK_TRAILER
PDF_TOK_STARTXREF = _mupdf.PDF_TOK_STARTXREF
PDF_TOK_NEWOBJ = _mupdf.PDF_TOK_NEWOBJ
PDF_NUM_TOKENS = _mupdf.PDF_NUM_TOKENS
class pdf_xref_entry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.pdf_xref_entry_type_get, _mupdf.pdf_xref_entry_type_set)
    marked = property(_mupdf.pdf_xref_entry_marked_get, _mupdf.pdf_xref_entry_marked_set)
    gen = property(_mupdf.pdf_xref_entry_gen_get, _mupdf.pdf_xref_entry_gen_set)
    num = property(_mupdf.pdf_xref_entry_num_get, _mupdf.pdf_xref_entry_num_set)
    ofs = property(_mupdf.pdf_xref_entry_ofs_get, _mupdf.pdf_xref_entry_ofs_set)
    stm_ofs = property(_mupdf.pdf_xref_entry_stm_ofs_get, _mupdf.pdf_xref_entry_stm_ofs_set)
    stm_buf = property(_mupdf.pdf_xref_entry_stm_buf_get, _mupdf.pdf_xref_entry_stm_buf_set)
    obj = property(_mupdf.pdf_xref_entry_obj_get, _mupdf.pdf_xref_entry_obj_set)

    def __init__(self):
        _mupdf.pdf_xref_entry_swiginit(self, _mupdf.new_pdf_xref_entry())
    __swig_destroy__ = _mupdf.delete_pdf_xref_entry

# Register pdf_xref_entry in _mupdf:
_mupdf.pdf_xref_entry_swigregister(pdf_xref_entry)
pdf_default_write_options = cvar.pdf_default_write_options

class pdf_xref_subsec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    next = property(_mupdf.pdf_xref_subsec_next_get, _mupdf.pdf_xref_subsec_next_set)
    len = property(_mupdf.pdf_xref_subsec_len_get, _mupdf.pdf_xref_subsec_len_set)
    start = property(_mupdf.pdf_xref_subsec_start_get, _mupdf.pdf_xref_subsec_start_set)
    table = property(_mupdf.pdf_xref_subsec_table_get, _mupdf.pdf_xref_subsec_table_set)

    def __init__(self):
        _mupdf.pdf_xref_subsec_swiginit(self, _mupdf.new_pdf_xref_subsec())
    __swig_destroy__ = _mupdf.delete_pdf_xref_subsec

# Register pdf_xref_subsec in _mupdf:
_mupdf.pdf_xref_subsec_swigregister(pdf_xref_subsec)
class pdf_xref(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_objects = property(_mupdf.pdf_xref_num_objects_get, _mupdf.pdf_xref_num_objects_set)
    subsec = property(_mupdf.pdf_xref_subsec_get, _mupdf.pdf_xref_subsec_set)
    trailer = property(_mupdf.pdf_xref_trailer_get, _mupdf.pdf_xref_trailer_set)
    pre_repair_trailer = property(_mupdf.pdf_xref_pre_repair_trailer_get, _mupdf.pdf_xref_pre_repair_trailer_set)
    unsaved_sigs = property(_mupdf.pdf_xref_unsaved_sigs_get, _mupdf.pdf_xref_unsaved_sigs_set)
    unsaved_sigs_end = property(_mupdf.pdf_xref_unsaved_sigs_end_get, _mupdf.pdf_xref_unsaved_sigs_end_set)
    end_ofs = property(_mupdf.pdf_xref_end_ofs_get, _mupdf.pdf_xref_end_ofs_set)

    def __init__(self):
        _mupdf.pdf_xref_swiginit(self, _mupdf.new_pdf_xref())
    __swig_destroy__ = _mupdf.delete_pdf_xref

# Register pdf_xref in _mupdf:
_mupdf.pdf_xref_swigregister(pdf_xref)
PDF_ENCRYPT_KEEP = _mupdf.PDF_ENCRYPT_KEEP
PDF_ENCRYPT_NONE = _mupdf.PDF_ENCRYPT_NONE
PDF_ENCRYPT_RC4_40 = _mupdf.PDF_ENCRYPT_RC4_40
PDF_ENCRYPT_RC4_128 = _mupdf.PDF_ENCRYPT_RC4_128
PDF_ENCRYPT_AES_128 = _mupdf.PDF_ENCRYPT_AES_128
PDF_ENCRYPT_AES_256 = _mupdf.PDF_ENCRYPT_AES_256
PDF_ENCRYPT_UNKNOWN = _mupdf.PDF_ENCRYPT_UNKNOWN
PDF_PERM_PRINT = _mupdf.PDF_PERM_PRINT
PDF_PERM_MODIFY = _mupdf.PDF_PERM_MODIFY
PDF_PERM_COPY = _mupdf.PDF_PERM_COPY
PDF_PERM_ANNOTATE = _mupdf.PDF_PERM_ANNOTATE
PDF_PERM_FORM = _mupdf.PDF_PERM_FORM
PDF_PERM_ACCESSIBILITY = _mupdf.PDF_PERM_ACCESSIBILITY
PDF_PERM_ASSEMBLE = _mupdf.PDF_PERM_ASSEMBLE
PDF_PERM_PRINT_HQ = _mupdf.PDF_PERM_PRINT_HQ
PDF_MRANGE_CAP = _mupdf.PDF_MRANGE_CAP
class pdf_range(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    low = property(_mupdf.pdf_range_low_get, _mupdf.pdf_range_low_set)
    high = property(_mupdf.pdf_range_high_get, _mupdf.pdf_range_high_set)
    out = property(_mupdf.pdf_range_out_get, _mupdf.pdf_range_out_set)

    def __init__(self):
        _mupdf.pdf_range_swiginit(self, _mupdf.new_pdf_range())
    __swig_destroy__ = _mupdf.delete_pdf_range

# Register pdf_range in _mupdf:
_mupdf.pdf_range_swigregister(pdf_range)
class pdf_xrange(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    low = property(_mupdf.pdf_xrange_low_get, _mupdf.pdf_xrange_low_set)
    high = property(_mupdf.pdf_xrange_high_get, _mupdf.pdf_xrange_high_set)
    out = property(_mupdf.pdf_xrange_out_get, _mupdf.pdf_xrange_out_set)

    def __init__(self):
        _mupdf.pdf_xrange_swiginit(self, _mupdf.new_pdf_xrange())
    __swig_destroy__ = _mupdf.delete_pdf_xrange

# Register pdf_xrange in _mupdf:
_mupdf.pdf_xrange_swigregister(pdf_xrange)
class pdf_mrange(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    low = property(_mupdf.pdf_mrange_low_get, _mupdf.pdf_mrange_low_set)
    out = property(_mupdf.pdf_mrange_out_get, _mupdf.pdf_mrange_out_set)

    def __init__(self):
        _mupdf.pdf_mrange_swiginit(self, _mupdf.new_pdf_mrange())
    __swig_destroy__ = _mupdf.delete_pdf_mrange

# Register pdf_mrange in _mupdf:
_mupdf.pdf_mrange_swigregister(pdf_mrange)
class pdf_cmap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.pdf_cmap_storable_get, _mupdf.pdf_cmap_storable_set)
    cmap_name = property(_mupdf.pdf_cmap_cmap_name_get, _mupdf.pdf_cmap_cmap_name_set)
    usecmap_name = property(_mupdf.pdf_cmap_usecmap_name_get, _mupdf.pdf_cmap_usecmap_name_set)
    usecmap = property(_mupdf.pdf_cmap_usecmap_get, _mupdf.pdf_cmap_usecmap_set)
    wmode = property(_mupdf.pdf_cmap_wmode_get, _mupdf.pdf_cmap_wmode_set)
    codespace_len = property(_mupdf.pdf_cmap_codespace_len_get, _mupdf.pdf_cmap_codespace_len_set)
    rlen = property(_mupdf.pdf_cmap_rlen_get, _mupdf.pdf_cmap_rlen_set)
    rcap = property(_mupdf.pdf_cmap_rcap_get, _mupdf.pdf_cmap_rcap_set)
    ranges = property(_mupdf.pdf_cmap_ranges_get, _mupdf.pdf_cmap_ranges_set)
    xlen = property(_mupdf.pdf_cmap_xlen_get, _mupdf.pdf_cmap_xlen_set)
    xcap = property(_mupdf.pdf_cmap_xcap_get, _mupdf.pdf_cmap_xcap_set)
    xranges = property(_mupdf.pdf_cmap_xranges_get, _mupdf.pdf_cmap_xranges_set)
    mlen = property(_mupdf.pdf_cmap_mlen_get, _mupdf.pdf_cmap_mlen_set)
    mcap = property(_mupdf.pdf_cmap_mcap_get, _mupdf.pdf_cmap_mcap_set)
    mranges = property(_mupdf.pdf_cmap_mranges_get, _mupdf.pdf_cmap_mranges_set)
    dlen = property(_mupdf.pdf_cmap_dlen_get, _mupdf.pdf_cmap_dlen_set)
    dcap = property(_mupdf.pdf_cmap_dcap_get, _mupdf.pdf_cmap_dcap_set)
    dict = property(_mupdf.pdf_cmap_dict_get, _mupdf.pdf_cmap_dict_set)
    tlen = property(_mupdf.pdf_cmap_tlen_get, _mupdf.pdf_cmap_tlen_set)
    tcap = property(_mupdf.pdf_cmap_tcap_get, _mupdf.pdf_cmap_tcap_set)
    ttop = property(_mupdf.pdf_cmap_ttop_get, _mupdf.pdf_cmap_ttop_set)
    tree = property(_mupdf.pdf_cmap_tree_get, _mupdf.pdf_cmap_tree_set)

    def __init__(self):
        _mupdf.pdf_cmap_swiginit(self, _mupdf.new_pdf_cmap())
    __swig_destroy__ = _mupdf.delete_pdf_cmap

# Register pdf_cmap in _mupdf:
_mupdf.pdf_cmap_swigregister(pdf_cmap)
PDF_FD_FIXED_PITCH = _mupdf.PDF_FD_FIXED_PITCH
PDF_FD_SERIF = _mupdf.PDF_FD_SERIF
PDF_FD_SYMBOLIC = _mupdf.PDF_FD_SYMBOLIC
PDF_FD_SCRIPT = _mupdf.PDF_FD_SCRIPT
PDF_FD_NONSYMBOLIC = _mupdf.PDF_FD_NONSYMBOLIC
PDF_FD_ITALIC = _mupdf.PDF_FD_ITALIC
PDF_FD_ALL_CAP = _mupdf.PDF_FD_ALL_CAP
PDF_FD_SMALL_CAP = _mupdf.PDF_FD_SMALL_CAP
PDF_FD_FORCE_BOLD = _mupdf.PDF_FD_FORCE_BOLD
class pdf_hmtx(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lo = property(_mupdf.pdf_hmtx_lo_get, _mupdf.pdf_hmtx_lo_set)
    hi = property(_mupdf.pdf_hmtx_hi_get, _mupdf.pdf_hmtx_hi_set)
    w = property(_mupdf.pdf_hmtx_w_get, _mupdf.pdf_hmtx_w_set)

    def __init__(self):
        _mupdf.pdf_hmtx_swiginit(self, _mupdf.new_pdf_hmtx())
    __swig_destroy__ = _mupdf.delete_pdf_hmtx

# Register pdf_hmtx in _mupdf:
_mupdf.pdf_hmtx_swigregister(pdf_hmtx)
class pdf_vmtx(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lo = property(_mupdf.pdf_vmtx_lo_get, _mupdf.pdf_vmtx_lo_set)
    hi = property(_mupdf.pdf_vmtx_hi_get, _mupdf.pdf_vmtx_hi_set)
    x = property(_mupdf.pdf_vmtx_x_get, _mupdf.pdf_vmtx_x_set)
    y = property(_mupdf.pdf_vmtx_y_get, _mupdf.pdf_vmtx_y_set)
    w = property(_mupdf.pdf_vmtx_w_get, _mupdf.pdf_vmtx_w_set)

    def __init__(self):
        _mupdf.pdf_vmtx_swiginit(self, _mupdf.new_pdf_vmtx())
    __swig_destroy__ = _mupdf.delete_pdf_vmtx

# Register pdf_vmtx in _mupdf:
_mupdf.pdf_vmtx_swigregister(pdf_vmtx)
class pdf_font_desc(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.pdf_font_desc_storable_get, _mupdf.pdf_font_desc_storable_set)
    size = property(_mupdf.pdf_font_desc_size_get, _mupdf.pdf_font_desc_size_set)
    font = property(_mupdf.pdf_font_desc_font_get, _mupdf.pdf_font_desc_font_set)
    flags = property(_mupdf.pdf_font_desc_flags_get, _mupdf.pdf_font_desc_flags_set)
    italic_angle = property(_mupdf.pdf_font_desc_italic_angle_get, _mupdf.pdf_font_desc_italic_angle_set)
    ascent = property(_mupdf.pdf_font_desc_ascent_get, _mupdf.pdf_font_desc_ascent_set)
    descent = property(_mupdf.pdf_font_desc_descent_get, _mupdf.pdf_font_desc_descent_set)
    cap_height = property(_mupdf.pdf_font_desc_cap_height_get, _mupdf.pdf_font_desc_cap_height_set)
    x_height = property(_mupdf.pdf_font_desc_x_height_get, _mupdf.pdf_font_desc_x_height_set)
    missing_width = property(_mupdf.pdf_font_desc_missing_width_get, _mupdf.pdf_font_desc_missing_width_set)
    encoding = property(_mupdf.pdf_font_desc_encoding_get, _mupdf.pdf_font_desc_encoding_set)
    to_ttf_cmap = property(_mupdf.pdf_font_desc_to_ttf_cmap_get, _mupdf.pdf_font_desc_to_ttf_cmap_set)
    cid_to_gid_len = property(_mupdf.pdf_font_desc_cid_to_gid_len_get, _mupdf.pdf_font_desc_cid_to_gid_len_set)
    cid_to_gid = property(_mupdf.pdf_font_desc_cid_to_gid_get, _mupdf.pdf_font_desc_cid_to_gid_set)
    to_unicode = property(_mupdf.pdf_font_desc_to_unicode_get, _mupdf.pdf_font_desc_to_unicode_set)
    cid_to_ucs_len = property(_mupdf.pdf_font_desc_cid_to_ucs_len_get, _mupdf.pdf_font_desc_cid_to_ucs_len_set)
    cid_to_ucs = property(_mupdf.pdf_font_desc_cid_to_ucs_get, _mupdf.pdf_font_desc_cid_to_ucs_set)
    wmode = property(_mupdf.pdf_font_desc_wmode_get, _mupdf.pdf_font_desc_wmode_set)
    hmtx_len = property(_mupdf.pdf_font_desc_hmtx_len_get, _mupdf.pdf_font_desc_hmtx_len_set)
    hmtx_cap = property(_mupdf.pdf_font_desc_hmtx_cap_get, _mupdf.pdf_font_desc_hmtx_cap_set)
    dhmtx = property(_mupdf.pdf_font_desc_dhmtx_get, _mupdf.pdf_font_desc_dhmtx_set)
    hmtx = property(_mupdf.pdf_font_desc_hmtx_get, _mupdf.pdf_font_desc_hmtx_set)
    vmtx_len = property(_mupdf.pdf_font_desc_vmtx_len_get, _mupdf.pdf_font_desc_vmtx_len_set)
    vmtx_cap = property(_mupdf.pdf_font_desc_vmtx_cap_get, _mupdf.pdf_font_desc_vmtx_cap_set)
    dvmtx = property(_mupdf.pdf_font_desc_dvmtx_get, _mupdf.pdf_font_desc_dvmtx_set)
    vmtx = property(_mupdf.pdf_font_desc_vmtx_get, _mupdf.pdf_font_desc_vmtx_set)
    is_embedded = property(_mupdf.pdf_font_desc_is_embedded_get, _mupdf.pdf_font_desc_is_embedded_set)
    t3loading = property(_mupdf.pdf_font_desc_t3loading_get, _mupdf.pdf_font_desc_t3loading_set)

    def __init__(self):
        _mupdf.pdf_font_desc_swiginit(self, _mupdf.new_pdf_font_desc())
    __swig_destroy__ = _mupdf.delete_pdf_font_desc

# Register pdf_font_desc in _mupdf:
_mupdf.pdf_font_desc_swigregister(pdf_font_desc)
PDF_SIMPLE_FONT_RESOURCE = _mupdf.PDF_SIMPLE_FONT_RESOURCE
PDF_CID_FONT_RESOURCE = _mupdf.PDF_CID_FONT_RESOURCE
PDF_CJK_FONT_RESOURCE = _mupdf.PDF_CJK_FONT_RESOURCE
PDF_SIMPLE_ENCODING_LATIN = _mupdf.PDF_SIMPLE_ENCODING_LATIN
PDF_SIMPLE_ENCODING_GREEK = _mupdf.PDF_SIMPLE_ENCODING_GREEK
PDF_SIMPLE_ENCODING_CYRILLIC = _mupdf.PDF_SIMPLE_ENCODING_CYRILLIC
class pdf_font_resource_key(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    digest = property(_mupdf.pdf_font_resource_key_digest_get, _mupdf.pdf_font_resource_key_digest_set)
    type = property(_mupdf.pdf_font_resource_key_type_get, _mupdf.pdf_font_resource_key_type_set)
    encoding = property(_mupdf.pdf_font_resource_key_encoding_get, _mupdf.pdf_font_resource_key_encoding_set)
    local_xref = property(_mupdf.pdf_font_resource_key_local_xref_get, _mupdf.pdf_font_resource_key_local_xref_set)

    def __init__(self):
        _mupdf.pdf_font_resource_key_swiginit(self, _mupdf.new_pdf_font_resource_key())
    __swig_destroy__ = _mupdf.delete_pdf_font_resource_key

# Register pdf_font_resource_key in _mupdf:
_mupdf.pdf_font_resource_key_swigregister(pdf_font_resource_key)
class pdf_pattern(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.pdf_pattern_storable_get, _mupdf.pdf_pattern_storable_set)
    ismask = property(_mupdf.pdf_pattern_ismask_get, _mupdf.pdf_pattern_ismask_set)
    xstep = property(_mupdf.pdf_pattern_xstep_get, _mupdf.pdf_pattern_xstep_set)
    ystep = property(_mupdf.pdf_pattern_ystep_get, _mupdf.pdf_pattern_ystep_set)
    matrix = property(_mupdf.pdf_pattern_matrix_get, _mupdf.pdf_pattern_matrix_set)
    bbox = property(_mupdf.pdf_pattern_bbox_get, _mupdf.pdf_pattern_bbox_set)
    document = property(_mupdf.pdf_pattern_document_get, _mupdf.pdf_pattern_document_set)
    resources = property(_mupdf.pdf_pattern_resources_get, _mupdf.pdf_pattern_resources_set)
    contents = property(_mupdf.pdf_pattern_contents_get, _mupdf.pdf_pattern_contents_set)
    id = property(_mupdf.pdf_pattern_id_get, _mupdf.pdf_pattern_id_set)

    def __init__(self):
        _mupdf.pdf_pattern_swiginit(self, _mupdf.new_pdf_pattern())
    __swig_destroy__ = _mupdf.delete_pdf_pattern

# Register pdf_pattern in _mupdf:
_mupdf.pdf_pattern_swigregister(pdf_pattern)
PDF_PROCESSOR_REQUIRES_DECODED_IMAGES = _mupdf.PDF_PROCESSOR_REQUIRES_DECODED_IMAGES
class pdf_processor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.pdf_processor_refs_get, _mupdf.pdf_processor_refs_set)
    closed = property(_mupdf.pdf_processor_closed_get, _mupdf.pdf_processor_closed_set)
    close_processor = property(_mupdf.pdf_processor_close_processor_get, _mupdf.pdf_processor_close_processor_set)
    drop_processor = property(_mupdf.pdf_processor_drop_processor_get, _mupdf.pdf_processor_drop_processor_set)
    reset_processor = property(_mupdf.pdf_processor_reset_processor_get, _mupdf.pdf_processor_reset_processor_set)
    push_resources = property(_mupdf.pdf_processor_push_resources_get, _mupdf.pdf_processor_push_resources_set)
    pop_resources = property(_mupdf.pdf_processor_pop_resources_get, _mupdf.pdf_processor_pop_resources_set)
    op_w = property(_mupdf.pdf_processor_op_w_get, _mupdf.pdf_processor_op_w_set)
    op_j = property(_mupdf.pdf_processor_op_j_get, _mupdf.pdf_processor_op_j_set)
    op_J = property(_mupdf.pdf_processor_op_J_get, _mupdf.pdf_processor_op_J_set)
    op_M = property(_mupdf.pdf_processor_op_M_get, _mupdf.pdf_processor_op_M_set)
    op_d = property(_mupdf.pdf_processor_op_d_get, _mupdf.pdf_processor_op_d_set)
    op_ri = property(_mupdf.pdf_processor_op_ri_get, _mupdf.pdf_processor_op_ri_set)
    op_i = property(_mupdf.pdf_processor_op_i_get, _mupdf.pdf_processor_op_i_set)
    op_gs_begin = property(_mupdf.pdf_processor_op_gs_begin_get, _mupdf.pdf_processor_op_gs_begin_set)
    op_gs_BM = property(_mupdf.pdf_processor_op_gs_BM_get, _mupdf.pdf_processor_op_gs_BM_set)
    op_gs_ca = property(_mupdf.pdf_processor_op_gs_ca_get, _mupdf.pdf_processor_op_gs_ca_set)
    op_gs_CA = property(_mupdf.pdf_processor_op_gs_CA_get, _mupdf.pdf_processor_op_gs_CA_set)
    op_gs_SMask = property(_mupdf.pdf_processor_op_gs_SMask_get, _mupdf.pdf_processor_op_gs_SMask_set)
    op_gs_end = property(_mupdf.pdf_processor_op_gs_end_get, _mupdf.pdf_processor_op_gs_end_set)
    op_q = property(_mupdf.pdf_processor_op_q_get, _mupdf.pdf_processor_op_q_set)
    op_Q = property(_mupdf.pdf_processor_op_Q_get, _mupdf.pdf_processor_op_Q_set)
    op_cm = property(_mupdf.pdf_processor_op_cm_get, _mupdf.pdf_processor_op_cm_set)
    op_m = property(_mupdf.pdf_processor_op_m_get, _mupdf.pdf_processor_op_m_set)
    op_l = property(_mupdf.pdf_processor_op_l_get, _mupdf.pdf_processor_op_l_set)
    op_c = property(_mupdf.pdf_processor_op_c_get, _mupdf.pdf_processor_op_c_set)
    op_v = property(_mupdf.pdf_processor_op_v_get, _mupdf.pdf_processor_op_v_set)
    op_y = property(_mupdf.pdf_processor_op_y_get, _mupdf.pdf_processor_op_y_set)
    op_h = property(_mupdf.pdf_processor_op_h_get, _mupdf.pdf_processor_op_h_set)
    op_re = property(_mupdf.pdf_processor_op_re_get, _mupdf.pdf_processor_op_re_set)
    op_S = property(_mupdf.pdf_processor_op_S_get, _mupdf.pdf_processor_op_S_set)
    op_s = property(_mupdf.pdf_processor_op_s_get, _mupdf.pdf_processor_op_s_set)
    op_F = property(_mupdf.pdf_processor_op_F_get, _mupdf.pdf_processor_op_F_set)
    op_f = property(_mupdf.pdf_processor_op_f_get, _mupdf.pdf_processor_op_f_set)
    op_fstar = property(_mupdf.pdf_processor_op_fstar_get, _mupdf.pdf_processor_op_fstar_set)
    op_B = property(_mupdf.pdf_processor_op_B_get, _mupdf.pdf_processor_op_B_set)
    op_Bstar = property(_mupdf.pdf_processor_op_Bstar_get, _mupdf.pdf_processor_op_Bstar_set)
    op_b = property(_mupdf.pdf_processor_op_b_get, _mupdf.pdf_processor_op_b_set)
    op_bstar = property(_mupdf.pdf_processor_op_bstar_get, _mupdf.pdf_processor_op_bstar_set)
    op_n = property(_mupdf.pdf_processor_op_n_get, _mupdf.pdf_processor_op_n_set)
    op_W = property(_mupdf.pdf_processor_op_W_get, _mupdf.pdf_processor_op_W_set)
    op_Wstar = property(_mupdf.pdf_processor_op_Wstar_get, _mupdf.pdf_processor_op_Wstar_set)
    op_BT = property(_mupdf.pdf_processor_op_BT_get, _mupdf.pdf_processor_op_BT_set)
    op_ET = property(_mupdf.pdf_processor_op_ET_get, _mupdf.pdf_processor_op_ET_set)
    op_Tc = property(_mupdf.pdf_processor_op_Tc_get, _mupdf.pdf_processor_op_Tc_set)
    op_Tw = property(_mupdf.pdf_processor_op_Tw_get, _mupdf.pdf_processor_op_Tw_set)
    op_Tz = property(_mupdf.pdf_processor_op_Tz_get, _mupdf.pdf_processor_op_Tz_set)
    op_TL = property(_mupdf.pdf_processor_op_TL_get, _mupdf.pdf_processor_op_TL_set)
    op_Tf = property(_mupdf.pdf_processor_op_Tf_get, _mupdf.pdf_processor_op_Tf_set)
    op_Tr = property(_mupdf.pdf_processor_op_Tr_get, _mupdf.pdf_processor_op_Tr_set)
    op_Ts = property(_mupdf.pdf_processor_op_Ts_get, _mupdf.pdf_processor_op_Ts_set)
    op_Td = property(_mupdf.pdf_processor_op_Td_get, _mupdf.pdf_processor_op_Td_set)
    op_TD = property(_mupdf.pdf_processor_op_TD_get, _mupdf.pdf_processor_op_TD_set)
    op_Tm = property(_mupdf.pdf_processor_op_Tm_get, _mupdf.pdf_processor_op_Tm_set)
    op_Tstar = property(_mupdf.pdf_processor_op_Tstar_get, _mupdf.pdf_processor_op_Tstar_set)
    op_TJ = property(_mupdf.pdf_processor_op_TJ_get, _mupdf.pdf_processor_op_TJ_set)
    op_Tj = property(_mupdf.pdf_processor_op_Tj_get, _mupdf.pdf_processor_op_Tj_set)
    op_squote = property(_mupdf.pdf_processor_op_squote_get, _mupdf.pdf_processor_op_squote_set)
    op_dquote = property(_mupdf.pdf_processor_op_dquote_get, _mupdf.pdf_processor_op_dquote_set)
    op_d0 = property(_mupdf.pdf_processor_op_d0_get, _mupdf.pdf_processor_op_d0_set)
    op_d1 = property(_mupdf.pdf_processor_op_d1_get, _mupdf.pdf_processor_op_d1_set)
    op_CS = property(_mupdf.pdf_processor_op_CS_get, _mupdf.pdf_processor_op_CS_set)
    op_cs = property(_mupdf.pdf_processor_op_cs_get, _mupdf.pdf_processor_op_cs_set)
    op_SC_pattern = property(_mupdf.pdf_processor_op_SC_pattern_get, _mupdf.pdf_processor_op_SC_pattern_set)
    op_sc_pattern = property(_mupdf.pdf_processor_op_sc_pattern_get, _mupdf.pdf_processor_op_sc_pattern_set)
    op_SC_shade = property(_mupdf.pdf_processor_op_SC_shade_get, _mupdf.pdf_processor_op_SC_shade_set)
    op_sc_shade = property(_mupdf.pdf_processor_op_sc_shade_get, _mupdf.pdf_processor_op_sc_shade_set)
    op_SC_color = property(_mupdf.pdf_processor_op_SC_color_get, _mupdf.pdf_processor_op_SC_color_set)
    op_sc_color = property(_mupdf.pdf_processor_op_sc_color_get, _mupdf.pdf_processor_op_sc_color_set)
    op_G = property(_mupdf.pdf_processor_op_G_get, _mupdf.pdf_processor_op_G_set)
    op_g = property(_mupdf.pdf_processor_op_g_get, _mupdf.pdf_processor_op_g_set)
    op_RG = property(_mupdf.pdf_processor_op_RG_get, _mupdf.pdf_processor_op_RG_set)
    op_rg = property(_mupdf.pdf_processor_op_rg_get, _mupdf.pdf_processor_op_rg_set)
    op_K = property(_mupdf.pdf_processor_op_K_get, _mupdf.pdf_processor_op_K_set)
    op_k = property(_mupdf.pdf_processor_op_k_get, _mupdf.pdf_processor_op_k_set)
    op_BI = property(_mupdf.pdf_processor_op_BI_get, _mupdf.pdf_processor_op_BI_set)
    op_sh = property(_mupdf.pdf_processor_op_sh_get, _mupdf.pdf_processor_op_sh_set)
    op_Do_image = property(_mupdf.pdf_processor_op_Do_image_get, _mupdf.pdf_processor_op_Do_image_set)
    op_Do_form = property(_mupdf.pdf_processor_op_Do_form_get, _mupdf.pdf_processor_op_Do_form_set)
    op_MP = property(_mupdf.pdf_processor_op_MP_get, _mupdf.pdf_processor_op_MP_set)
    op_DP = property(_mupdf.pdf_processor_op_DP_get, _mupdf.pdf_processor_op_DP_set)
    op_BMC = property(_mupdf.pdf_processor_op_BMC_get, _mupdf.pdf_processor_op_BMC_set)
    op_BDC = property(_mupdf.pdf_processor_op_BDC_get, _mupdf.pdf_processor_op_BDC_set)
    op_EMC = property(_mupdf.pdf_processor_op_EMC_get, _mupdf.pdf_processor_op_EMC_set)
    op_BX = property(_mupdf.pdf_processor_op_BX_get, _mupdf.pdf_processor_op_BX_set)
    op_EX = property(_mupdf.pdf_processor_op_EX_get, _mupdf.pdf_processor_op_EX_set)
    op_gs_OP = property(_mupdf.pdf_processor_op_gs_OP_get, _mupdf.pdf_processor_op_gs_OP_set)
    op_gs_op = property(_mupdf.pdf_processor_op_gs_op_get, _mupdf.pdf_processor_op_gs_op_set)
    op_gs_OPM = property(_mupdf.pdf_processor_op_gs_OPM_get, _mupdf.pdf_processor_op_gs_OPM_set)
    op_gs_UseBlackPtComp = property(_mupdf.pdf_processor_op_gs_UseBlackPtComp_get, _mupdf.pdf_processor_op_gs_UseBlackPtComp_set)
    op_EOD = property(_mupdf.pdf_processor_op_EOD_get, _mupdf.pdf_processor_op_EOD_set)
    op_END = property(_mupdf.pdf_processor_op_END_get, _mupdf.pdf_processor_op_END_set)
    usage = property(_mupdf.pdf_processor_usage_get, _mupdf.pdf_processor_usage_set)
    hidden = property(_mupdf.pdf_processor_hidden_get, _mupdf.pdf_processor_hidden_set)
    requirements = property(_mupdf.pdf_processor_requirements_get, _mupdf.pdf_processor_requirements_set)

    def __init__(self):
        _mupdf.pdf_processor_swiginit(self, _mupdf.new_pdf_processor())
    __swig_destroy__ = _mupdf.delete_pdf_processor

# Register pdf_processor in _mupdf:
_mupdf.pdf_processor_swigregister(pdf_processor)
class pdf_csi(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    doc = property(_mupdf.pdf_csi_doc_get, _mupdf.pdf_csi_doc_set)
    rdb = property(_mupdf.pdf_csi_rdb_get, _mupdf.pdf_csi_rdb_set)
    buf = property(_mupdf.pdf_csi_buf_get, _mupdf.pdf_csi_buf_set)
    cookie = property(_mupdf.pdf_csi_cookie_get, _mupdf.pdf_csi_cookie_set)
    gstate = property(_mupdf.pdf_csi_gstate_get, _mupdf.pdf_csi_gstate_set)
    xbalance = property(_mupdf.pdf_csi_xbalance_get, _mupdf.pdf_csi_xbalance_set)
    in_text = property(_mupdf.pdf_csi_in_text_get, _mupdf.pdf_csi_in_text_set)
    d1_rect = property(_mupdf.pdf_csi_d1_rect_get, _mupdf.pdf_csi_d1_rect_set)
    obj = property(_mupdf.pdf_csi_obj_get, _mupdf.pdf_csi_obj_set)
    name = property(_mupdf.pdf_csi_name_get, _mupdf.pdf_csi_name_set)
    string = property(_mupdf.pdf_csi_string_get, _mupdf.pdf_csi_string_set)
    string_len = property(_mupdf.pdf_csi_string_len_get, _mupdf.pdf_csi_string_len_set)
    top = property(_mupdf.pdf_csi_top_get, _mupdf.pdf_csi_top_set)
    stack = property(_mupdf.pdf_csi_stack_get, _mupdf.pdf_csi_stack_set)

    def __init__(self):
        _mupdf.pdf_csi_swiginit(self, _mupdf.new_pdf_csi())
    __swig_destroy__ = _mupdf.delete_pdf_csi

# Register pdf_csi in _mupdf:
_mupdf.pdf_csi_swigregister(pdf_csi)
class pdf_filter_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    filter = property(_mupdf.pdf_filter_factory_filter_get, _mupdf.pdf_filter_factory_filter_set)
    options = property(_mupdf.pdf_filter_factory_options_get, _mupdf.pdf_filter_factory_options_set)

    def __init__(self):
        _mupdf.pdf_filter_factory_swiginit(self, _mupdf.new_pdf_filter_factory())
    __swig_destroy__ = _mupdf.delete_pdf_filter_factory

# Register pdf_filter_factory in _mupdf:
_mupdf.pdf_filter_factory_swigregister(pdf_filter_factory)
class pdf_filter_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    recurse = property(_mupdf.pdf_filter_options_recurse_get, _mupdf.pdf_filter_options_recurse_set)
    instance_forms = property(_mupdf.pdf_filter_options_instance_forms_get, _mupdf.pdf_filter_options_instance_forms_set)
    ascii = property(_mupdf.pdf_filter_options_ascii_get, _mupdf.pdf_filter_options_ascii_set)
    no_update = property(_mupdf.pdf_filter_options_no_update_get, _mupdf.pdf_filter_options_no_update_set)
    opaque = property(_mupdf.pdf_filter_options_opaque_get, _mupdf.pdf_filter_options_opaque_set)
    complete = property(_mupdf.pdf_filter_options_complete_get, _mupdf.pdf_filter_options_complete_set)
    filters = property(_mupdf.pdf_filter_options_filters_get, _mupdf.pdf_filter_options_filters_set)
    newlines = property(_mupdf.pdf_filter_options_newlines_get, _mupdf.pdf_filter_options_newlines_set)

    def __init__(self):
        _mupdf.pdf_filter_options_swiginit(self, _mupdf.new_pdf_filter_options())
    __swig_destroy__ = _mupdf.delete_pdf_filter_options

# Register pdf_filter_options in _mupdf:
_mupdf.pdf_filter_options_swigregister(pdf_filter_options)
FZ_CULL_PATH_DROP = _mupdf.FZ_CULL_PATH_DROP
FZ_CULL_PATH_FILL = _mupdf.FZ_CULL_PATH_FILL
FZ_CULL_PATH_STROKE = _mupdf.FZ_CULL_PATH_STROKE
FZ_CULL_PATH_FILL_STROKE = _mupdf.FZ_CULL_PATH_FILL_STROKE
FZ_CULL_CLIP_PATH_DROP = _mupdf.FZ_CULL_CLIP_PATH_DROP
FZ_CULL_CLIP_PATH_FILL = _mupdf.FZ_CULL_CLIP_PATH_FILL
FZ_CULL_CLIP_PATH_STROKE = _mupdf.FZ_CULL_CLIP_PATH_STROKE
FZ_CULL_CLIP_PATH_FILL_STROKE = _mupdf.FZ_CULL_CLIP_PATH_FILL_STROKE
FZ_CULL_GLYPH = _mupdf.FZ_CULL_GLYPH
FZ_CULL_IMAGE = _mupdf.FZ_CULL_IMAGE
FZ_CULL_SHADING = _mupdf.FZ_CULL_SHADING
class pdf_sanitize_filter_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    opaque = property(_mupdf.pdf_sanitize_filter_options_opaque_get, _mupdf.pdf_sanitize_filter_options_opaque_set)
    image_filter = property(_mupdf.pdf_sanitize_filter_options_image_filter_get, _mupdf.pdf_sanitize_filter_options_image_filter_set)
    text_filter = property(_mupdf.pdf_sanitize_filter_options_text_filter_get, _mupdf.pdf_sanitize_filter_options_text_filter_set)
    after_text_object = property(_mupdf.pdf_sanitize_filter_options_after_text_object_get, _mupdf.pdf_sanitize_filter_options_after_text_object_set)
    culler = property(_mupdf.pdf_sanitize_filter_options_culler_get, _mupdf.pdf_sanitize_filter_options_culler_set)

    def __init__(self):
        _mupdf.pdf_sanitize_filter_options_swiginit(self, _mupdf.new_pdf_sanitize_filter_options())
    __swig_destroy__ = _mupdf.delete_pdf_sanitize_filter_options

# Register pdf_sanitize_filter_options in _mupdf:
_mupdf.pdf_sanitize_filter_options_swigregister(pdf_sanitize_filter_options)
class pdf_color_filter_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    opaque = property(_mupdf.pdf_color_filter_options_opaque_get, _mupdf.pdf_color_filter_options_opaque_set)
    color_rewrite = property(_mupdf.pdf_color_filter_options_color_rewrite_get, _mupdf.pdf_color_filter_options_color_rewrite_set)
    image_rewrite = property(_mupdf.pdf_color_filter_options_image_rewrite_get, _mupdf.pdf_color_filter_options_image_rewrite_set)
    shade_rewrite = property(_mupdf.pdf_color_filter_options_shade_rewrite_get, _mupdf.pdf_color_filter_options_shade_rewrite_set)
    repeated_image_rewrite = property(_mupdf.pdf_color_filter_options_repeated_image_rewrite_get, _mupdf.pdf_color_filter_options_repeated_image_rewrite_set)

    def __init__(self):
        _mupdf.pdf_color_filter_options_swiginit(self, _mupdf.new_pdf_color_filter_options())
    __swig_destroy__ = _mupdf.delete_pdf_color_filter_options

# Register pdf_color_filter_options in _mupdf:
_mupdf.pdf_color_filter_options_swigregister(pdf_color_filter_options)
class pdf_text_state(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    char_space = property(_mupdf.pdf_text_state_char_space_get, _mupdf.pdf_text_state_char_space_set)
    word_space = property(_mupdf.pdf_text_state_word_space_get, _mupdf.pdf_text_state_word_space_set)
    scale = property(_mupdf.pdf_text_state_scale_get, _mupdf.pdf_text_state_scale_set)
    leading = property(_mupdf.pdf_text_state_leading_get, _mupdf.pdf_text_state_leading_set)
    font = property(_mupdf.pdf_text_state_font_get, _mupdf.pdf_text_state_font_set)
    fontname = property(_mupdf.pdf_text_state_fontname_get, _mupdf.pdf_text_state_fontname_set)
    size = property(_mupdf.pdf_text_state_size_get, _mupdf.pdf_text_state_size_set)
    render = property(_mupdf.pdf_text_state_render_get, _mupdf.pdf_text_state_render_set)
    rise = property(_mupdf.pdf_text_state_rise_get, _mupdf.pdf_text_state_rise_set)

    def __init__(self):
        _mupdf.pdf_text_state_swiginit(self, _mupdf.new_pdf_text_state())
    __swig_destroy__ = _mupdf.delete_pdf_text_state

# Register pdf_text_state in _mupdf:
_mupdf.pdf_text_state_swigregister(pdf_text_state)
class pdf_text_object_state(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    text = property(_mupdf.pdf_text_object_state_text_get, _mupdf.pdf_text_object_state_text_set)
    text_bbox = property(_mupdf.pdf_text_object_state_text_bbox_get, _mupdf.pdf_text_object_state_text_bbox_set)
    tlm = property(_mupdf.pdf_text_object_state_tlm_get, _mupdf.pdf_text_object_state_tlm_set)
    tm = property(_mupdf.pdf_text_object_state_tm_get, _mupdf.pdf_text_object_state_tm_set)
    text_mode = property(_mupdf.pdf_text_object_state_text_mode_get, _mupdf.pdf_text_object_state_text_mode_set)
    cid = property(_mupdf.pdf_text_object_state_cid_get, _mupdf.pdf_text_object_state_cid_set)
    gid = property(_mupdf.pdf_text_object_state_gid_get, _mupdf.pdf_text_object_state_gid_set)
    char_bbox = property(_mupdf.pdf_text_object_state_char_bbox_get, _mupdf.pdf_text_object_state_char_bbox_set)
    fontdesc = property(_mupdf.pdf_text_object_state_fontdesc_get, _mupdf.pdf_text_object_state_fontdesc_set)
    char_tx = property(_mupdf.pdf_text_object_state_char_tx_get, _mupdf.pdf_text_object_state_char_tx_set)
    char_ty = property(_mupdf.pdf_text_object_state_char_ty_get, _mupdf.pdf_text_object_state_char_ty_set)

    def __init__(self):
        _mupdf.pdf_text_object_state_swiginit(self, _mupdf.new_pdf_text_object_state())
    __swig_destroy__ = _mupdf.delete_pdf_text_object_state

# Register pdf_text_object_state in _mupdf:
_mupdf.pdf_text_object_state_swigregister(pdf_text_object_state)
PDF_REDACT_IMAGE_NONE = _mupdf.PDF_REDACT_IMAGE_NONE
PDF_REDACT_IMAGE_REMOVE = _mupdf.PDF_REDACT_IMAGE_REMOVE
PDF_REDACT_IMAGE_PIXELS = _mupdf.PDF_REDACT_IMAGE_PIXELS
PDF_REDACT_IMAGE_REMOVE_UNLESS_INVISIBLE = _mupdf.PDF_REDACT_IMAGE_REMOVE_UNLESS_INVISIBLE
PDF_REDACT_LINE_ART_NONE = _mupdf.PDF_REDACT_LINE_ART_NONE
PDF_REDACT_LINE_ART_REMOVE_IF_COVERED = _mupdf.PDF_REDACT_LINE_ART_REMOVE_IF_COVERED
PDF_REDACT_LINE_ART_REMOVE_IF_TOUCHED = _mupdf.PDF_REDACT_LINE_ART_REMOVE_IF_TOUCHED
PDF_REDACT_TEXT_REMOVE = _mupdf.PDF_REDACT_TEXT_REMOVE
PDF_REDACT_TEXT_NONE = _mupdf.PDF_REDACT_TEXT_NONE
class pdf_redact_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    black_boxes = property(_mupdf.pdf_redact_options_black_boxes_get, _mupdf.pdf_redact_options_black_boxes_set)
    image_method = property(_mupdf.pdf_redact_options_image_method_get, _mupdf.pdf_redact_options_image_method_set)
    line_art = property(_mupdf.pdf_redact_options_line_art_get, _mupdf.pdf_redact_options_line_art_set)
    text = property(_mupdf.pdf_redact_options_text_get, _mupdf.pdf_redact_options_text_set)

    def __init__(self):
        _mupdf.pdf_redact_options_swiginit(self, _mupdf.new_pdf_redact_options())
    __swig_destroy__ = _mupdf.delete_pdf_redact_options

# Register pdf_redact_options in _mupdf:
_mupdf.pdf_redact_options_swigregister(pdf_redact_options)
class pdf_page(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    super = property(_mupdf.pdf_page_super_get, _mupdf.pdf_page_super_set)
    doc = property(_mupdf.pdf_page_doc_get, _mupdf.pdf_page_doc_set)
    obj = property(_mupdf.pdf_page_obj_get, _mupdf.pdf_page_obj_set)
    transparency = property(_mupdf.pdf_page_transparency_get, _mupdf.pdf_page_transparency_set)
    overprint = property(_mupdf.pdf_page_overprint_get, _mupdf.pdf_page_overprint_set)
    links = property(_mupdf.pdf_page_links_get, _mupdf.pdf_page_links_set)
    annots = property(_mupdf.pdf_page_annots_get, _mupdf.pdf_page_annots_set)
    annot_tailp = property(_mupdf.pdf_page_annot_tailp_get, _mupdf.pdf_page_annot_tailp_set)
    widgets = property(_mupdf.pdf_page_widgets_get, _mupdf.pdf_page_widgets_set)
    widget_tailp = property(_mupdf.pdf_page_widget_tailp_get, _mupdf.pdf_page_widget_tailp_set)

    def __init__(self):
        _mupdf.pdf_page_swiginit(self, _mupdf.new_pdf_page())
    __swig_destroy__ = _mupdf.delete_pdf_page

# Register pdf_page in _mupdf:
_mupdf.pdf_page_swigregister(pdf_page)
PDF_ANNOT_TEXT = _mupdf.PDF_ANNOT_TEXT
PDF_ANNOT_LINK = _mupdf.PDF_ANNOT_LINK
PDF_ANNOT_FREE_TEXT = _mupdf.PDF_ANNOT_FREE_TEXT
PDF_ANNOT_LINE = _mupdf.PDF_ANNOT_LINE
PDF_ANNOT_SQUARE = _mupdf.PDF_ANNOT_SQUARE
PDF_ANNOT_CIRCLE = _mupdf.PDF_ANNOT_CIRCLE
PDF_ANNOT_POLYGON = _mupdf.PDF_ANNOT_POLYGON
PDF_ANNOT_POLY_LINE = _mupdf.PDF_ANNOT_POLY_LINE
PDF_ANNOT_HIGHLIGHT = _mupdf.PDF_ANNOT_HIGHLIGHT
PDF_ANNOT_UNDERLINE = _mupdf.PDF_ANNOT_UNDERLINE
PDF_ANNOT_SQUIGGLY = _mupdf.PDF_ANNOT_SQUIGGLY
PDF_ANNOT_STRIKE_OUT = _mupdf.PDF_ANNOT_STRIKE_OUT
PDF_ANNOT_REDACT = _mupdf.PDF_ANNOT_REDACT
PDF_ANNOT_STAMP = _mupdf.PDF_ANNOT_STAMP
PDF_ANNOT_CARET = _mupdf.PDF_ANNOT_CARET
PDF_ANNOT_INK = _mupdf.PDF_ANNOT_INK
PDF_ANNOT_POPUP = _mupdf.PDF_ANNOT_POPUP
PDF_ANNOT_FILE_ATTACHMENT = _mupdf.PDF_ANNOT_FILE_ATTACHMENT
PDF_ANNOT_SOUND = _mupdf.PDF_ANNOT_SOUND
PDF_ANNOT_MOVIE = _mupdf.PDF_ANNOT_MOVIE
PDF_ANNOT_RICH_MEDIA = _mupdf.PDF_ANNOT_RICH_MEDIA
PDF_ANNOT_WIDGET = _mupdf.PDF_ANNOT_WIDGET
PDF_ANNOT_SCREEN = _mupdf.PDF_ANNOT_SCREEN
PDF_ANNOT_PRINTER_MARK = _mupdf.PDF_ANNOT_PRINTER_MARK
PDF_ANNOT_TRAP_NET = _mupdf.PDF_ANNOT_TRAP_NET
PDF_ANNOT_WATERMARK = _mupdf.PDF_ANNOT_WATERMARK
PDF_ANNOT_3D = _mupdf.PDF_ANNOT_3D
PDF_ANNOT_PROJECTION = _mupdf.PDF_ANNOT_PROJECTION
PDF_ANNOT_UNKNOWN = _mupdf.PDF_ANNOT_UNKNOWN
PDF_ANNOT_IS_INVISIBLE = _mupdf.PDF_ANNOT_IS_INVISIBLE
PDF_ANNOT_IS_HIDDEN = _mupdf.PDF_ANNOT_IS_HIDDEN
PDF_ANNOT_IS_PRINT = _mupdf.PDF_ANNOT_IS_PRINT
PDF_ANNOT_IS_NO_ZOOM = _mupdf.PDF_ANNOT_IS_NO_ZOOM
PDF_ANNOT_IS_NO_ROTATE = _mupdf.PDF_ANNOT_IS_NO_ROTATE
PDF_ANNOT_IS_NO_VIEW = _mupdf.PDF_ANNOT_IS_NO_VIEW
PDF_ANNOT_IS_READ_ONLY = _mupdf.PDF_ANNOT_IS_READ_ONLY
PDF_ANNOT_IS_LOCKED = _mupdf.PDF_ANNOT_IS_LOCKED
PDF_ANNOT_IS_TOGGLE_NO_VIEW = _mupdf.PDF_ANNOT_IS_TOGGLE_NO_VIEW
PDF_ANNOT_IS_LOCKED_CONTENTS = _mupdf.PDF_ANNOT_IS_LOCKED_CONTENTS
PDF_ANNOT_LE_NONE = _mupdf.PDF_ANNOT_LE_NONE
PDF_ANNOT_LE_SQUARE = _mupdf.PDF_ANNOT_LE_SQUARE
PDF_ANNOT_LE_CIRCLE = _mupdf.PDF_ANNOT_LE_CIRCLE
PDF_ANNOT_LE_DIAMOND = _mupdf.PDF_ANNOT_LE_DIAMOND
PDF_ANNOT_LE_OPEN_ARROW = _mupdf.PDF_ANNOT_LE_OPEN_ARROW
PDF_ANNOT_LE_CLOSED_ARROW = _mupdf.PDF_ANNOT_LE_CLOSED_ARROW
PDF_ANNOT_LE_BUTT = _mupdf.PDF_ANNOT_LE_BUTT
PDF_ANNOT_LE_R_OPEN_ARROW = _mupdf.PDF_ANNOT_LE_R_OPEN_ARROW
PDF_ANNOT_LE_R_CLOSED_ARROW = _mupdf.PDF_ANNOT_LE_R_CLOSED_ARROW
PDF_ANNOT_LE_SLASH = _mupdf.PDF_ANNOT_LE_SLASH
PDF_ANNOT_Q_LEFT = _mupdf.PDF_ANNOT_Q_LEFT
PDF_ANNOT_Q_CENTER = _mupdf.PDF_ANNOT_Q_CENTER
PDF_ANNOT_Q_RIGHT = _mupdf.PDF_ANNOT_Q_RIGHT
PDF_ANNOT_IT_DEFAULT = _mupdf.PDF_ANNOT_IT_DEFAULT
PDF_ANNOT_IT_FREETEXT_CALLOUT = _mupdf.PDF_ANNOT_IT_FREETEXT_CALLOUT
PDF_ANNOT_IT_FREETEXT_TYPEWRITER = _mupdf.PDF_ANNOT_IT_FREETEXT_TYPEWRITER
PDF_ANNOT_IT_LINE_ARROW = _mupdf.PDF_ANNOT_IT_LINE_ARROW
PDF_ANNOT_IT_LINE_DIMENSION = _mupdf.PDF_ANNOT_IT_LINE_DIMENSION
PDF_ANNOT_IT_POLYLINE_DIMENSION = _mupdf.PDF_ANNOT_IT_POLYLINE_DIMENSION
PDF_ANNOT_IT_POLYGON_CLOUD = _mupdf.PDF_ANNOT_IT_POLYGON_CLOUD
PDF_ANNOT_IT_POLYGON_DIMENSION = _mupdf.PDF_ANNOT_IT_POLYGON_DIMENSION
PDF_ANNOT_IT_STAMP_IMAGE = _mupdf.PDF_ANNOT_IT_STAMP_IMAGE
PDF_ANNOT_IT_STAMP_SNAPSHOT = _mupdf.PDF_ANNOT_IT_STAMP_SNAPSHOT
PDF_ANNOT_IT_UNKNOWN = _mupdf.PDF_ANNOT_IT_UNKNOWN
PDF_BORDER_STYLE_SOLID = _mupdf.PDF_BORDER_STYLE_SOLID
PDF_BORDER_STYLE_DASHED = _mupdf.PDF_BORDER_STYLE_DASHED
PDF_BORDER_STYLE_BEVELED = _mupdf.PDF_BORDER_STYLE_BEVELED
PDF_BORDER_STYLE_INSET = _mupdf.PDF_BORDER_STYLE_INSET
PDF_BORDER_STYLE_UNDERLINE = _mupdf.PDF_BORDER_STYLE_UNDERLINE
PDF_BORDER_EFFECT_NONE = _mupdf.PDF_BORDER_EFFECT_NONE
PDF_BORDER_EFFECT_CLOUDY = _mupdf.PDF_BORDER_EFFECT_CLOUDY
class pdf_filespec_params(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    filename = property(_mupdf.pdf_filespec_params_filename_get, _mupdf.pdf_filespec_params_filename_set)
    mimetype = property(_mupdf.pdf_filespec_params_mimetype_get, _mupdf.pdf_filespec_params_mimetype_set)
    size = property(_mupdf.pdf_filespec_params_size_get, _mupdf.pdf_filespec_params_size_set)
    created = property(_mupdf.pdf_filespec_params_created_get, _mupdf.pdf_filespec_params_created_set)
    modified = property(_mupdf.pdf_filespec_params_modified_get, _mupdf.pdf_filespec_params_modified_set)

    def __init__(self):
        _mupdf.pdf_filespec_params_swiginit(self, _mupdf.new_pdf_filespec_params())
    __swig_destroy__ = _mupdf.delete_pdf_filespec_params

# Register pdf_filespec_params in _mupdf:
_mupdf.pdf_filespec_params_swigregister(pdf_filespec_params)
PDF_WIDGET_TYPE_UNKNOWN = _mupdf.PDF_WIDGET_TYPE_UNKNOWN
PDF_WIDGET_TYPE_BUTTON = _mupdf.PDF_WIDGET_TYPE_BUTTON
PDF_WIDGET_TYPE_CHECKBOX = _mupdf.PDF_WIDGET_TYPE_CHECKBOX
PDF_WIDGET_TYPE_COMBOBOX = _mupdf.PDF_WIDGET_TYPE_COMBOBOX
PDF_WIDGET_TYPE_LISTBOX = _mupdf.PDF_WIDGET_TYPE_LISTBOX
PDF_WIDGET_TYPE_RADIOBUTTON = _mupdf.PDF_WIDGET_TYPE_RADIOBUTTON
PDF_WIDGET_TYPE_SIGNATURE = _mupdf.PDF_WIDGET_TYPE_SIGNATURE
PDF_WIDGET_TYPE_TEXT = _mupdf.PDF_WIDGET_TYPE_TEXT
PDF_WIDGET_TX_FORMAT_NONE = _mupdf.PDF_WIDGET_TX_FORMAT_NONE
PDF_WIDGET_TX_FORMAT_NUMBER = _mupdf.PDF_WIDGET_TX_FORMAT_NUMBER
PDF_WIDGET_TX_FORMAT_SPECIAL = _mupdf.PDF_WIDGET_TX_FORMAT_SPECIAL
PDF_WIDGET_TX_FORMAT_DATE = _mupdf.PDF_WIDGET_TX_FORMAT_DATE
PDF_WIDGET_TX_FORMAT_TIME = _mupdf.PDF_WIDGET_TX_FORMAT_TIME
PDF_FIELD_IS_READ_ONLY = _mupdf.PDF_FIELD_IS_READ_ONLY
PDF_FIELD_IS_REQUIRED = _mupdf.PDF_FIELD_IS_REQUIRED
PDF_FIELD_IS_NO_EXPORT = _mupdf.PDF_FIELD_IS_NO_EXPORT
PDF_TX_FIELD_IS_MULTILINE = _mupdf.PDF_TX_FIELD_IS_MULTILINE
PDF_TX_FIELD_IS_PASSWORD = _mupdf.PDF_TX_FIELD_IS_PASSWORD
PDF_TX_FIELD_IS_FILE_SELECT = _mupdf.PDF_TX_FIELD_IS_FILE_SELECT
PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK = _mupdf.PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK
PDF_TX_FIELD_IS_DO_NOT_SCROLL = _mupdf.PDF_TX_FIELD_IS_DO_NOT_SCROLL
PDF_TX_FIELD_IS_COMB = _mupdf.PDF_TX_FIELD_IS_COMB
PDF_TX_FIELD_IS_RICH_TEXT = _mupdf.PDF_TX_FIELD_IS_RICH_TEXT
PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF = _mupdf.PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF
PDF_BTN_FIELD_IS_RADIO = _mupdf.PDF_BTN_FIELD_IS_RADIO
PDF_BTN_FIELD_IS_PUSHBUTTON = _mupdf.PDF_BTN_FIELD_IS_PUSHBUTTON
PDF_BTN_FIELD_IS_RADIOS_IN_UNISON = _mupdf.PDF_BTN_FIELD_IS_RADIOS_IN_UNISON
PDF_CH_FIELD_IS_COMBO = _mupdf.PDF_CH_FIELD_IS_COMBO
PDF_CH_FIELD_IS_EDIT = _mupdf.PDF_CH_FIELD_IS_EDIT
PDF_CH_FIELD_IS_SORT = _mupdf.PDF_CH_FIELD_IS_SORT
PDF_CH_FIELD_IS_MULTI_SELECT = _mupdf.PDF_CH_FIELD_IS_MULTI_SELECT
PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK = _mupdf.PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK
PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE = _mupdf.PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE
class pdf_pkcs7_distinguished_name(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cn = property(_mupdf.pdf_pkcs7_distinguished_name_cn_get, _mupdf.pdf_pkcs7_distinguished_name_cn_set)
    o = property(_mupdf.pdf_pkcs7_distinguished_name_o_get, _mupdf.pdf_pkcs7_distinguished_name_o_set)
    ou = property(_mupdf.pdf_pkcs7_distinguished_name_ou_get, _mupdf.pdf_pkcs7_distinguished_name_ou_set)
    email = property(_mupdf.pdf_pkcs7_distinguished_name_email_get, _mupdf.pdf_pkcs7_distinguished_name_email_set)
    c = property(_mupdf.pdf_pkcs7_distinguished_name_c_get, _mupdf.pdf_pkcs7_distinguished_name_c_set)

    def __init__(self):
        _mupdf.pdf_pkcs7_distinguished_name_swiginit(self, _mupdf.new_pdf_pkcs7_distinguished_name())
    __swig_destroy__ = _mupdf.delete_pdf_pkcs7_distinguished_name

# Register pdf_pkcs7_distinguished_name in _mupdf:
_mupdf.pdf_pkcs7_distinguished_name_swigregister(pdf_pkcs7_distinguished_name)
PDF_SIGNATURE_ERROR_OKAY = _mupdf.PDF_SIGNATURE_ERROR_OKAY
PDF_SIGNATURE_ERROR_NO_SIGNATURES = _mupdf.PDF_SIGNATURE_ERROR_NO_SIGNATURES
PDF_SIGNATURE_ERROR_NO_CERTIFICATE = _mupdf.PDF_SIGNATURE_ERROR_NO_CERTIFICATE
PDF_SIGNATURE_ERROR_DIGEST_FAILURE = _mupdf.PDF_SIGNATURE_ERROR_DIGEST_FAILURE
PDF_SIGNATURE_ERROR_SELF_SIGNED = _mupdf.PDF_SIGNATURE_ERROR_SELF_SIGNED
PDF_SIGNATURE_ERROR_SELF_SIGNED_IN_CHAIN = _mupdf.PDF_SIGNATURE_ERROR_SELF_SIGNED_IN_CHAIN
PDF_SIGNATURE_ERROR_NOT_TRUSTED = _mupdf.PDF_SIGNATURE_ERROR_NOT_TRUSTED
PDF_SIGNATURE_ERROR_NOT_SIGNED = _mupdf.PDF_SIGNATURE_ERROR_NOT_SIGNED
PDF_SIGNATURE_ERROR_UNKNOWN = _mupdf.PDF_SIGNATURE_ERROR_UNKNOWN
class pdf_pkcs7_signer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    keep = property(_mupdf.pdf_pkcs7_signer_keep_get, _mupdf.pdf_pkcs7_signer_keep_set)
    drop = property(_mupdf.pdf_pkcs7_signer_drop_get, _mupdf.pdf_pkcs7_signer_drop_set)
    get_signing_name = property(_mupdf.pdf_pkcs7_signer_get_signing_name_get, _mupdf.pdf_pkcs7_signer_get_signing_name_set)
    max_digest_size = property(_mupdf.pdf_pkcs7_signer_max_digest_size_get, _mupdf.pdf_pkcs7_signer_max_digest_size_set)
    create_digest = property(_mupdf.pdf_pkcs7_signer_create_digest_get, _mupdf.pdf_pkcs7_signer_create_digest_set)

    def __init__(self):
        _mupdf.pdf_pkcs7_signer_swiginit(self, _mupdf.new_pdf_pkcs7_signer())
    __swig_destroy__ = _mupdf.delete_pdf_pkcs7_signer

# Register pdf_pkcs7_signer in _mupdf:
_mupdf.pdf_pkcs7_signer_swigregister(pdf_pkcs7_signer)
class pdf_pkcs7_verifier(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.pdf_pkcs7_verifier_drop_get, _mupdf.pdf_pkcs7_verifier_drop_set)
    check_certificate = property(_mupdf.pdf_pkcs7_verifier_check_certificate_get, _mupdf.pdf_pkcs7_verifier_check_certificate_set)
    check_digest = property(_mupdf.pdf_pkcs7_verifier_check_digest_get, _mupdf.pdf_pkcs7_verifier_check_digest_set)
    get_signatory = property(_mupdf.pdf_pkcs7_verifier_get_signatory_get, _mupdf.pdf_pkcs7_verifier_get_signatory_set)

    def __init__(self):
        _mupdf.pdf_pkcs7_verifier_swiginit(self, _mupdf.new_pdf_pkcs7_verifier())
    __swig_destroy__ = _mupdf.delete_pdf_pkcs7_verifier

# Register pdf_pkcs7_verifier in _mupdf:
_mupdf.pdf_pkcs7_verifier_swigregister(pdf_pkcs7_verifier)
PDF_SIGNATURE_SHOW_LABELS = _mupdf.PDF_SIGNATURE_SHOW_LABELS
PDF_SIGNATURE_SHOW_DN = _mupdf.PDF_SIGNATURE_SHOW_DN
PDF_SIGNATURE_SHOW_DATE = _mupdf.PDF_SIGNATURE_SHOW_DATE
PDF_SIGNATURE_SHOW_TEXT_NAME = _mupdf.PDF_SIGNATURE_SHOW_TEXT_NAME
PDF_SIGNATURE_SHOW_GRAPHIC_NAME = _mupdf.PDF_SIGNATURE_SHOW_GRAPHIC_NAME
PDF_SIGNATURE_SHOW_LOGO = _mupdf.PDF_SIGNATURE_SHOW_LOGO
class pdf_keystroke_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = property(_mupdf.pdf_keystroke_event_value_get, _mupdf.pdf_keystroke_event_value_set)
    change = property(_mupdf.pdf_keystroke_event_change_get, _mupdf.pdf_keystroke_event_change_set)
    selStart = property(_mupdf.pdf_keystroke_event_selStart_get, _mupdf.pdf_keystroke_event_selStart_set)
    selEnd = property(_mupdf.pdf_keystroke_event_selEnd_get, _mupdf.pdf_keystroke_event_selEnd_set)
    willCommit = property(_mupdf.pdf_keystroke_event_willCommit_get, _mupdf.pdf_keystroke_event_willCommit_set)
    newChange = property(_mupdf.pdf_keystroke_event_newChange_get, _mupdf.pdf_keystroke_event_newChange_set)
    newValue = property(_mupdf.pdf_keystroke_event_newValue_get, _mupdf.pdf_keystroke_event_newValue_set)

    def __init__(self):
        _mupdf.pdf_keystroke_event_swiginit(self, _mupdf.new_pdf_keystroke_event())
    __swig_destroy__ = _mupdf.delete_pdf_keystroke_event

# Register pdf_keystroke_event in _mupdf:
_mupdf.pdf_keystroke_event_swigregister(pdf_keystroke_event)
class pdf_doc_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.pdf_doc_event_type_get, _mupdf.pdf_doc_event_type_set)

    def __init__(self):
        _mupdf.pdf_doc_event_swiginit(self, _mupdf.new_pdf_doc_event())
    __swig_destroy__ = _mupdf.delete_pdf_doc_event

# Register pdf_doc_event in _mupdf:
_mupdf.pdf_doc_event_swigregister(pdf_doc_event)
PDF_DOCUMENT_EVENT_ALERT = _mupdf.PDF_DOCUMENT_EVENT_ALERT
PDF_DOCUMENT_EVENT_PRINT = _mupdf.PDF_DOCUMENT_EVENT_PRINT
PDF_DOCUMENT_EVENT_LAUNCH_URL = _mupdf.PDF_DOCUMENT_EVENT_LAUNCH_URL
PDF_DOCUMENT_EVENT_MAIL_DOC = _mupdf.PDF_DOCUMENT_EVENT_MAIL_DOC
PDF_DOCUMENT_EVENT_SUBMIT = _mupdf.PDF_DOCUMENT_EVENT_SUBMIT
PDF_DOCUMENT_EVENT_EXEC_MENU_ITEM = _mupdf.PDF_DOCUMENT_EVENT_EXEC_MENU_ITEM
class pdf_alert_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    doc = property(_mupdf.pdf_alert_event_doc_get, _mupdf.pdf_alert_event_doc_set)
    message = property(_mupdf.pdf_alert_event_message_get, _mupdf.pdf_alert_event_message_set)
    icon_type = property(_mupdf.pdf_alert_event_icon_type_get, _mupdf.pdf_alert_event_icon_type_set)
    button_group_type = property(_mupdf.pdf_alert_event_button_group_type_get, _mupdf.pdf_alert_event_button_group_type_set)
    title = property(_mupdf.pdf_alert_event_title_get, _mupdf.pdf_alert_event_title_set)
    has_check_box = property(_mupdf.pdf_alert_event_has_check_box_get, _mupdf.pdf_alert_event_has_check_box_set)
    check_box_message = property(_mupdf.pdf_alert_event_check_box_message_get, _mupdf.pdf_alert_event_check_box_message_set)
    initially_checked = property(_mupdf.pdf_alert_event_initially_checked_get, _mupdf.pdf_alert_event_initially_checked_set)
    finally_checked = property(_mupdf.pdf_alert_event_finally_checked_get, _mupdf.pdf_alert_event_finally_checked_set)
    button_pressed = property(_mupdf.pdf_alert_event_button_pressed_get, _mupdf.pdf_alert_event_button_pressed_set)

    def __init__(self):
        _mupdf.pdf_alert_event_swiginit(self, _mupdf.new_pdf_alert_event())
    __swig_destroy__ = _mupdf.delete_pdf_alert_event

# Register pdf_alert_event in _mupdf:
_mupdf.pdf_alert_event_swigregister(pdf_alert_event)
PDF_ALERT_ICON_ERROR = _mupdf.PDF_ALERT_ICON_ERROR
PDF_ALERT_ICON_WARNING = _mupdf.PDF_ALERT_ICON_WARNING
PDF_ALERT_ICON_QUESTION = _mupdf.PDF_ALERT_ICON_QUESTION
PDF_ALERT_ICON_STATUS = _mupdf.PDF_ALERT_ICON_STATUS
PDF_ALERT_BUTTON_GROUP_OK = _mupdf.PDF_ALERT_BUTTON_GROUP_OK
PDF_ALERT_BUTTON_GROUP_OK_CANCEL = _mupdf.PDF_ALERT_BUTTON_GROUP_OK_CANCEL
PDF_ALERT_BUTTON_GROUP_YES_NO = _mupdf.PDF_ALERT_BUTTON_GROUP_YES_NO
PDF_ALERT_BUTTON_GROUP_YES_NO_CANCEL = _mupdf.PDF_ALERT_BUTTON_GROUP_YES_NO_CANCEL
PDF_ALERT_BUTTON_NONE = _mupdf.PDF_ALERT_BUTTON_NONE
PDF_ALERT_BUTTON_OK = _mupdf.PDF_ALERT_BUTTON_OK
PDF_ALERT_BUTTON_CANCEL = _mupdf.PDF_ALERT_BUTTON_CANCEL
PDF_ALERT_BUTTON_NO = _mupdf.PDF_ALERT_BUTTON_NO
PDF_ALERT_BUTTON_YES = _mupdf.PDF_ALERT_BUTTON_YES
class pdf_launch_url_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    url = property(_mupdf.pdf_launch_url_event_url_get, _mupdf.pdf_launch_url_event_url_set)
    new_frame = property(_mupdf.pdf_launch_url_event_new_frame_get, _mupdf.pdf_launch_url_event_new_frame_set)

    def __init__(self):
        _mupdf.pdf_launch_url_event_swiginit(self, _mupdf.new_pdf_launch_url_event())
    __swig_destroy__ = _mupdf.delete_pdf_launch_url_event

# Register pdf_launch_url_event in _mupdf:
_mupdf.pdf_launch_url_event_swigregister(pdf_launch_url_event)
class pdf_mail_doc_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ask_user = property(_mupdf.pdf_mail_doc_event_ask_user_get, _mupdf.pdf_mail_doc_event_ask_user_set)
    to = property(_mupdf.pdf_mail_doc_event_to_get, _mupdf.pdf_mail_doc_event_to_set)
    cc = property(_mupdf.pdf_mail_doc_event_cc_get, _mupdf.pdf_mail_doc_event_cc_set)
    bcc = property(_mupdf.pdf_mail_doc_event_bcc_get, _mupdf.pdf_mail_doc_event_bcc_set)
    subject = property(_mupdf.pdf_mail_doc_event_subject_get, _mupdf.pdf_mail_doc_event_subject_set)
    message = property(_mupdf.pdf_mail_doc_event_message_get, _mupdf.pdf_mail_doc_event_message_set)

    def __init__(self):
        _mupdf.pdf_mail_doc_event_swiginit(self, _mupdf.new_pdf_mail_doc_event())
    __swig_destroy__ = _mupdf.delete_pdf_mail_doc_event

# Register pdf_mail_doc_event in _mupdf:
_mupdf.pdf_mail_doc_event_swigregister(pdf_mail_doc_event)
FZ_SUBSAMPLE_AVERAGE = _mupdf.FZ_SUBSAMPLE_AVERAGE
FZ_SUBSAMPLE_BICUBIC = _mupdf.FZ_SUBSAMPLE_BICUBIC
FZ_RECOMPRESS_NEVER = _mupdf.FZ_RECOMPRESS_NEVER
FZ_RECOMPRESS_SAME = _mupdf.FZ_RECOMPRESS_SAME
FZ_RECOMPRESS_LOSSLESS = _mupdf.FZ_RECOMPRESS_LOSSLESS
FZ_RECOMPRESS_JPEG = _mupdf.FZ_RECOMPRESS_JPEG
FZ_RECOMPRESS_J2K = _mupdf.FZ_RECOMPRESS_J2K
FZ_RECOMPRESS_FAX = _mupdf.FZ_RECOMPRESS_FAX
class pdf_image_rewriter_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    color_lossless_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_method_set)
    color_lossy_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_method_set)
    color_lossless_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_threshold_set)
    color_lossless_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_to_set)
    color_lossy_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_threshold_set)
    color_lossy_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_to_set)
    color_lossless_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_method_set)
    color_lossy_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_method_set)
    color_lossy_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_quality_set)
    color_lossless_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_quality_set)
    gray_lossless_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_method_set)
    gray_lossy_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_method_set)
    gray_lossless_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_threshold_set)
    gray_lossless_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_to_set)
    gray_lossy_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_threshold_set)
    gray_lossy_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_to_set)
    gray_lossless_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_method_set)
    gray_lossy_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_method_set)
    gray_lossy_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_quality_set)
    gray_lossless_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_quality_set)
    bitonal_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_bitonal_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_bitonal_image_subsample_method_set)
    bitonal_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_bitonal_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_bitonal_image_subsample_threshold_set)
    bitonal_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_bitonal_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_bitonal_image_subsample_to_set)
    bitonal_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_bitonal_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_bitonal_image_recompress_method_set)
    bitonal_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_bitonal_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_bitonal_image_recompress_quality_set)

    def __init__(self):
        _mupdf.pdf_image_rewriter_options_swiginit(self, _mupdf.new_pdf_image_rewriter_options())
    __swig_destroy__ = _mupdf.delete_pdf_image_rewriter_options

# Register pdf_image_rewriter_options in _mupdf:
_mupdf.pdf_image_rewriter_options_swigregister(pdf_image_rewriter_options)
PDF_CLEAN_STRUCTURE_DROP = _mupdf.PDF_CLEAN_STRUCTURE_DROP
PDF_CLEAN_STRUCTURE_KEEP = _mupdf.PDF_CLEAN_STRUCTURE_KEEP
class pdf_clean_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    write = property(_mupdf.pdf_clean_options_write_get, _mupdf.pdf_clean_options_write_set)
    image = property(_mupdf.pdf_clean_options_image_get, _mupdf.pdf_clean_options_image_set)
    subset_fonts = property(_mupdf.pdf_clean_options_subset_fonts_get, _mupdf.pdf_clean_options_subset_fonts_set)
    structure = property(_mupdf.pdf_clean_options_structure_get, _mupdf.pdf_clean_options_structure_set)

    def __init__(self):
        _mupdf.pdf_clean_options_swiginit(self, _mupdf.new_pdf_clean_options())
    __swig_destroy__ = _mupdf.delete_pdf_clean_options

# Register pdf_clean_options in _mupdf:
_mupdf.pdf_clean_options_swigregister(pdf_clean_options)
class pdf_recolor_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_comp = property(_mupdf.pdf_recolor_options_num_comp_get, _mupdf.pdf_recolor_options_num_comp_set)

    def __init__(self):
        _mupdf.pdf_recolor_options_swiginit(self, _mupdf.new_pdf_recolor_options())
    __swig_destroy__ = _mupdf.delete_pdf_recolor_options

# Register pdf_recolor_options in _mupdf:
_mupdf.pdf_recolor_options_swigregister(pdf_recolor_options)
PDF_NOT_ZUGFERD = _mupdf.PDF_NOT_ZUGFERD
PDF_ZUGFERD_COMFORT = _mupdf.PDF_ZUGFERD_COMFORT
PDF_ZUGFERD_BASIC = _mupdf.PDF_ZUGFERD_BASIC
PDF_ZUGFERD_EXTENDED = _mupdf.PDF_ZUGFERD_EXTENDED
PDF_ZUGFERD_BASIC_WL = _mupdf.PDF_ZUGFERD_BASIC_WL
PDF_ZUGFERD_MINIMUM = _mupdf.PDF_ZUGFERD_MINIMUM
PDF_ZUGFERD_XRECHNUNG = _mupdf.PDF_ZUGFERD_XRECHNUNG
PDF_ZUGFERD_UNKNOWN = _mupdf.PDF_ZUGFERD_UNKNOWN
class fz_search_page2_hit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    quad = property(_mupdf.fz_search_page2_hit_quad_get, _mupdf.fz_search_page2_hit_quad_set)
    mark = property(_mupdf.fz_search_page2_hit_mark_get, _mupdf.fz_search_page2_hit_mark_set)

    def __init__(self):
        _mupdf.fz_search_page2_hit_swiginit(self, _mupdf.new_fz_search_page2_hit())
    __swig_destroy__ = _mupdf.delete_fz_search_page2_hit

# Register fz_search_page2_hit in _mupdf:
_mupdf.fz_search_page2_hit_swigregister(fz_search_page2_hit)
class fz_install_load_system_font_funcs_args(object):
    r"""
    Extra struct containing fz_install_load_system_font_funcs()'s args,
    which we wrap with virtual_fnptrs set to allow use from Python/C# via
    Swig Directors.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    f = property(_mupdf.fz_install_load_system_font_funcs_args_f_get, _mupdf.fz_install_load_system_font_funcs_args_f_set)
    f_cjk = property(_mupdf.fz_install_load_system_font_funcs_args_f_cjk_get, _mupdf.fz_install_load_system_font_funcs_args_f_cjk_set)
    f_fallback = property(_mupdf.fz_install_load_system_font_funcs_args_f_fallback_get, _mupdf.fz_install_load_system_font_funcs_args_f_fallback_set)

    def __init__(self):
        _mupdf.fz_install_load_system_font_funcs_args_swiginit(self, _mupdf.new_fz_install_load_system_font_funcs_args())
    __swig_destroy__ = _mupdf.delete_fz_install_load_system_font_funcs_args

# Register fz_install_load_system_font_funcs_args in _mupdf:
_mupdf.fz_install_load_system_font_funcs_args_swigregister(fz_install_load_system_font_funcs_args)
class fz_font_ucs_gid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ucs = property(_mupdf.fz_font_ucs_gid_ucs_get, _mupdf.fz_font_ucs_gid_ucs_set)
    gid = property(_mupdf.fz_font_ucs_gid_gid_get, _mupdf.fz_font_ucs_gid_gid_set)

    def __init__(self):
        _mupdf.fz_font_ucs_gid_swiginit(self, _mupdf.new_fz_font_ucs_gid())
    __swig_destroy__ = _mupdf.delete_fz_font_ucs_gid

# Register fz_font_ucs_gid in _mupdf:
_mupdf.fz_font_ucs_gid_swigregister(fz_font_ucs_gid)

def ll_fz_aa_level():
    r"""
    Low-level wrapper for `::fz_aa_level()`.
    Get the number of bits of antialiasing we are
    using (for graphics). Between 0 and 8.
    """
    return _mupdf.ll_fz_aa_level()

def ll_fz_abs(f):
    r"""
    Low-level wrapper for `::fz_abs()`.
    Some standard math functions, done as static inlines for speed.
    People with compilers that do not adequately implement inline
    may like to reimplement these using macros.
    """
    return _mupdf.ll_fz_abs(f)

def ll_fz_absi(i):
    r"""Low-level wrapper for `::fz_absi()`."""
    return _mupdf.ll_fz_absi(i)

def ll_fz_add_layout_char(block, x, w, p):
    r"""
    Low-level wrapper for `::fz_add_layout_char()`.
    Add a new char to the line at the end of the layout block.
    """
    return _mupdf.ll_fz_add_layout_char(block, x, w, p)

def ll_fz_add_layout_line(block, x, y, h, p):
    r"""
    Low-level wrapper for `::fz_add_layout_line()`.
    Add a new line to the end of the layout block.
    """
    return _mupdf.ll_fz_add_layout_line(block, x, y, h, p)

def ll_fz_add_separation(sep, name, cs, cs_channel):
    r"""
    Low-level wrapper for `::fz_add_separation()`.
    Add a separation (null terminated name, colorspace)
    """
    return _mupdf.ll_fz_add_separation(sep, name, cs, cs_channel)

def ll_fz_add_separation_equivalents(sep, rgba, cmyk, name):
    r"""
    Low-level wrapper for `::fz_add_separation_equivalents()`.
    Add a separation with equivalents (null terminated name,
    colorspace)

    (old, deprecated)
    """
    return _mupdf.ll_fz_add_separation_equivalents(sep, rgba, cmyk, name)

def ll_fz_adjust_rect_for_stroke(rect, stroke, ctm):
    r"""
    Low-level wrapper for `::fz_adjust_rect_for_stroke()`.
    Given a rectangle (assumed to be the bounding box for a path),
    expand it to allow for the expansion of the bbox that would be
    seen by stroking the path with the given stroke state and
    transform.
    """
    return _mupdf.ll_fz_adjust_rect_for_stroke(rect, stroke, ctm)

def ll_fz_advance_glyph(font, glyph, wmode):
    r"""
    Low-level wrapper for `::fz_advance_glyph()`.
    Return the advance for a given glyph.

    font: The font to look for the glyph in.

    glyph: The glyph to find the advance for.

    wmode: 1 for vertical mode, 0 for horizontal.

    Returns the advance for the glyph.
    """
    return _mupdf.ll_fz_advance_glyph(font, glyph, wmode)

def ll_fz_aes_crypt_cbc(ctx, mode, length, iv, input, output):
    r"""
    Low-level wrapper for `::fz_aes_crypt_cbc()`.
    AES block processing. Encrypts or Decrypts (according to mode,
    which must match what was initially set up) length bytes (which
    must be a multiple of 16), using (and modifying) the insertion
    vector iv, reading from input, and writing to output.

    Never throws an exception.
    """
    return _mupdf.ll_fz_aes_crypt_cbc(ctx, mode, length, iv, input, output)

def ll_fz_aes_setkey_dec(ctx, key, keysize):
    r"""
    Low-level wrapper for `::fz_aes_setkey_dec()`.
    AES decryption intialisation. Fills in the supplied context
    and prepares for decryption using the given key.

    Returns non-zero for error (key size other than 128/192/256).

    Never throws an exception.
    """
    return _mupdf.ll_fz_aes_setkey_dec(ctx, key, keysize)

def ll_fz_aes_setkey_enc(ctx, key, keysize):
    r"""
    Low-level wrapper for `::fz_aes_setkey_enc()`.
    AES encryption intialisation. Fills in the supplied context
    and prepares for encryption using the given key.

    Returns non-zero for error (key size other than 128/192/256).

    Never throws an exception.
    """
    return _mupdf.ll_fz_aes_setkey_enc(ctx, key, keysize)

def ll_fz_alpha_from_gray(gray):
    r"""Low-level wrapper for `::fz_alpha_from_gray()`."""
    return _mupdf.ll_fz_alpha_from_gray(gray)

def ll_fz_append_base64(out, data, size, newline):
    r"""
    Low-level wrapper for `::fz_append_base64()`.
    Write a base64 encoded data block, optionally with periodic newlines.
    """
    return _mupdf.ll_fz_append_base64(out, data, size, newline)

def ll_fz_append_base64_buffer(out, data, newline):
    r"""
    Low-level wrapper for `::fz_append_base64_buffer()`.
    Append a base64 encoded fz_buffer, optionally with periodic newlines.
    """
    return _mupdf.ll_fz_append_base64_buffer(out, data, newline)

def ll_fz_append_bits(buf, value, count):
    r"""Low-level wrapper for `::fz_append_bits()`."""
    return _mupdf.ll_fz_append_bits(buf, value, count)

def ll_fz_append_bits_pad(buf):
    r"""Low-level wrapper for `::fz_append_bits_pad()`."""
    return _mupdf.ll_fz_append_bits_pad(buf)

def ll_fz_append_buffer(destination, source):
    r"""
    Low-level wrapper for `::fz_append_buffer()`.
    Append the contents of the source buffer onto the end of the
    destination buffer, extending automatically as required.

    Ownership of buffers does not change.
    """
    return _mupdf.ll_fz_append_buffer(destination, source)

def ll_fz_append_byte(buf, c):
    r"""Low-level wrapper for `::fz_append_byte()`."""
    return _mupdf.ll_fz_append_byte(buf, c)

def ll_fz_append_data(buf, data, len):
    r"""
    Low-level wrapper for `::fz_append_data()`.
    fz_append_*: Append data to a buffer.

    The buffer will automatically grow as required.
    """
    return _mupdf.ll_fz_append_data(buf, data, len)

def ll_fz_append_image_as_data_uri(out, image):
    r"""Low-level wrapper for `::fz_append_image_as_data_uri()`."""
    return _mupdf.ll_fz_append_image_as_data_uri(out, image)

def ll_fz_append_int16_be(buf, x):
    r"""Low-level wrapper for `::fz_append_int16_be()`."""
    return _mupdf.ll_fz_append_int16_be(buf, x)

def ll_fz_append_int16_le(buf, x):
    r"""Low-level wrapper for `::fz_append_int16_le()`."""
    return _mupdf.ll_fz_append_int16_le(buf, x)

def ll_fz_append_int32_be(buf, x):
    r"""Low-level wrapper for `::fz_append_int32_be()`."""
    return _mupdf.ll_fz_append_int32_be(buf, x)

def ll_fz_append_int32_le(buf, x):
    r"""Low-level wrapper for `::fz_append_int32_le()`."""
    return _mupdf.ll_fz_append_int32_le(buf, x)

def ll_fz_append_pdf_string(buffer, text):
    r"""
    Low-level wrapper for `::fz_append_pdf_string()`.
    fz_append_pdf_string: Append a string with PDF syntax quotes and
    escapes.

    The buffer will automatically grow as required.
    """
    return _mupdf.ll_fz_append_pdf_string(buffer, text)

def ll_fz_append_pixmap_as_data_uri(out, pixmap):
    r"""Low-level wrapper for `::fz_append_pixmap_as_data_uri()`."""
    return _mupdf.ll_fz_append_pixmap_as_data_uri(out, pixmap)

def ll_fz_append_rune(buf, c):
    r"""Low-level wrapper for `::fz_append_rune()`."""
    return _mupdf.ll_fz_append_rune(buf, c)

def ll_fz_append_string(buf, data):
    r"""Low-level wrapper for `::fz_append_string()`."""
    return _mupdf.ll_fz_append_string(buf, data)

def ll_fz_arc4_encrypt(state, dest, src, len):
    r"""
    Low-level wrapper for `::fz_arc4_encrypt()`.
    RC4 block encrypt operation; encrypt src into dst (both of
    length len) updating the RC4 state as we go.

    Never throws an exception.
    """
    return _mupdf.ll_fz_arc4_encrypt(state, dest, src, len)

def ll_fz_arc4_final(state):
    r"""
    Low-level wrapper for `::fz_arc4_final()`.
    RC4 finalization. Zero the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_arc4_final(state)

def ll_fz_arc4_init(state, key, len):
    r"""
    Low-level wrapper for `::fz_arc4_init()`.
    RC4 initialization. Begins an RC4 operation, writing a new
    context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_arc4_init(state, key, len)

def ll_fz_archive_format(arch):
    r"""
    Low-level wrapper for `::fz_archive_format()`.
    Return a pointer to a string describing the format of the
    archive.

    The lifetime of the string is unspecified (in current
    implementations the string will persist until the archive
    is closed, but this is not guaranteed).
    """
    return _mupdf.ll_fz_archive_format(arch)

def ll_fz_atof(s):
    r"""
    Low-level wrapper for `::fz_atof()`.
    Range checking atof
    """
    return _mupdf.ll_fz_atof(s)

def ll_fz_atoi(s):
    r"""
    Low-level wrapper for `::fz_atoi()`.
    atoi that copes with NULL
    """
    return _mupdf.ll_fz_atoi(s)

def ll_fz_atoi64(s):
    r"""
    Low-level wrapper for `::fz_atoi64()`.
    64bit atoi that copes with NULL
    """
    return _mupdf.ll_fz_atoi64(s)

def ll_fz_atoz(s):
    r"""
    Low-level wrapper for `::fz_atoz()`.
    size_t atoi that copes with NULL.

    NOTE: limited to 63bits. Negative numbers
    are returned as 0.
    """
    return _mupdf.ll_fz_atoz(s)

def ll_fz_authenticate_password(doc, password):
    r"""
    Low-level wrapper for `::fz_authenticate_password()`.
    Test if the given password can decrypt the document.

    password: The password string to be checked. Some document
    specifications do not specify any particular text encoding, so
    neither do we.

    Returns 0 for failure to authenticate, non-zero for success.

    For PDF documents, further information can be given by examining
    the bits in the return code.

    	Bit 0 => No password required
    	Bit 1 => User password authenticated
    	Bit 2 => Owner password authenticated
    """
    return _mupdf.ll_fz_authenticate_password(doc, password)

def ll_fz_autowarp_pixmap(src, points):
    r"""Low-level wrapper for `::fz_autowarp_pixmap()`."""
    return _mupdf.ll_fz_autowarp_pixmap(src, points)

def ll_fz_available(stm, max):
    r"""
    Low-level wrapper for `::fz_available()`.
    Ask how many bytes are available immediately from
    a given stream.

    stm: The stream to read from.

    max: A hint for the underlying stream; the maximum number of
    bytes that we are sure we will want to read. If you do not know
    this number, give 1.

    Returns the number of bytes immediately available between the
    read and write pointers. This number is guaranteed only to be 0
    if we have hit EOF. The number of bytes returned here need have
    no relation to max (could be larger, could be smaller).
    """
    return _mupdf.ll_fz_available(stm, max)

def ll_fz_base_colorspace(cs):
    r"""
    Low-level wrapper for `::fz_base_colorspace()`.
    Get the 'base' colorspace for a colorspace.

    For indexed colorspaces, this is the colorspace the index
    decodes into. For all other colorspaces, it is the colorspace
    itself.

    The returned colorspace is 'borrowed' (i.e. no additional
    references are taken or dropped).
    """
    return _mupdf.ll_fz_base_colorspace(cs)

def ll_fz_basename(path):
    r"""
    Low-level wrapper for `::fz_basename()`.
    Find the filename component in a path.
    """
    return _mupdf.ll_fz_basename(path)

def ll_fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha):
    r"""Low-level wrapper for `::fz_begin_group()`."""
    return _mupdf.ll_fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha)

def ll_fz_begin_layer(dev, layer_name):
    r"""Low-level wrapper for `::fz_begin_layer()`."""
    return _mupdf.ll_fz_begin_layer(dev, layer_name)

def ll_fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params):
    r"""Low-level wrapper for `::fz_begin_mask()`."""
    return _mupdf.ll_fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params)

def ll_fz_begin_metatext(dev, meta, text):
    r"""Low-level wrapper for `::fz_begin_metatext()`."""
    return _mupdf.ll_fz_begin_metatext(dev, meta, text)

def ll_fz_begin_page(wri, mediabox):
    r"""
    Low-level wrapper for `::fz_begin_page()`.
    Called to start the process of writing a page to
    a document.

    mediabox: page size rectangle in points.

    Returns a borrowed fz_device to write page contents to. This
    should be kept if required, and only dropped if it was kept.
    """
    return _mupdf.ll_fz_begin_page(wri, mediabox)

def ll_fz_begin_structure(dev, standard, raw, idx):
    r"""Low-level wrapper for `::fz_begin_structure()`."""
    return _mupdf.ll_fz_begin_structure(dev, standard, raw, idx)

def ll_fz_begin_tile(dev, area, view, xstep, ystep, ctm):
    r"""Low-level wrapper for `::fz_begin_tile()`."""
    return _mupdf.ll_fz_begin_tile(dev, area, view, xstep, ystep, ctm)

def ll_fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id):
    r"""Low-level wrapper for `::fz_begin_tile_id()`."""
    return _mupdf.ll_fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id)

def ll_fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags):
    r"""
     Low-level wrapper for `::fz_bidi_fragment_text()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_fragment_fn *callback, void *arg, int flags)` => ::fz_bidi_direction baseDir

    	Partitions the given Unicode sequence into one or more
    	unidirectional fragments and invokes the given callback
    	function for each fragment.

    	For example, if directionality of text is:
    			0123456789
    			rrlllrrrrr,
    	we'll invoke callback with:
    			&text[0], length == 2
    			&text[2], length == 3
    			&text[5], length == 5

    	:type text: int, in
    :param text:	start of Unicode sequence
        	:type textlen: int, in
    :param textlen:   number of Unicodes to analyse
        	:type baseDir: int, in
    :param baseDir:   direction of paragraph (specify FZ_BIDI_NEUTRAL to force auto-detection)
        	:type callback: ::fz_bidi_fragment_fn, in
    :param callback:  function to be called for each fragment
        	:type arg: void, in
    :param arg:	data to be passed to the callback function
        	:type flags: int, in
    :param flags:     flags to control operation (see fz_bidi_flags above)
    """
    return _mupdf.ll_fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags)

def ll_fz_bitmap_details(bitmap, w, h, n, stride):
    r"""
     Low-level wrapper for `::fz_bitmap_details()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_bitmap_details(::fz_bitmap *bitmap)` => `(int w, int h, int n, int stride)`

    	Retrieve details of a given bitmap.

    	bitmap: The bitmap to query.

    	w: Pointer to storage to retrieve width (or NULL).

    	h: Pointer to storage to retrieve height (or NULL).

    	n: Pointer to storage to retrieve number of color components (or
    	NULL).

    	stride: Pointer to storage to retrieve bitmap stride (or NULL).
    """
    return _mupdf.ll_fz_bitmap_details(bitmap, w, h, n, stride)

def ll_fz_blendmode_name(blendmode):
    r"""
    Low-level wrapper for `::fz_blendmode_name()`.
    Map from enumeration to blend mode string.

    The string is static, with arbitrary lifespan.
    """
    return _mupdf.ll_fz_blendmode_name(blendmode)

def ll_fz_bound_display_list(list):
    r"""
    Low-level wrapper for `::fz_bound_display_list()`.
    Return the bounding box of the page recorded in a display list.
    """
    return _mupdf.ll_fz_bound_display_list(list)

def ll_fz_bound_glyph(font, gid, trm):
    r"""
    Low-level wrapper for `::fz_bound_glyph()`.
    Return a bbox for a given glyph in a font.

    font: The font to look for the glyph in.

    gid: The glyph to bound.

    trm: The matrix to apply to the glyph before bounding.

    Returns rectangle by value containing the bounds of the given
    glyph.
    """
    return _mupdf.ll_fz_bound_glyph(font, gid, trm)

def ll_fz_bound_page(page):
    r"""
    Low-level wrapper for `::fz_bound_page()`.
    Determine the size of a page at 72 dpi.
    """
    return _mupdf.ll_fz_bound_page(page)

def ll_fz_bound_page_box(page, box):
    r"""Low-level wrapper for `::fz_bound_page_box()`."""
    return _mupdf.ll_fz_bound_page_box(page, box)

def ll_fz_bound_path(path, stroke, ctm):
    r"""
    Low-level wrapper for `::fz_bound_path()`.
    Return a bounding rectangle for a path.

    path: The path to bound.

    stroke: If NULL, the bounding rectangle given is for
    the filled path. If non-NULL the bounding rectangle
    given is for the path stroked with the given attributes.

    ctm: The matrix to apply to the path during stroking.

    r: Pointer to a fz_rect which will be used to hold
    the result.

    Returns r, updated to contain the bounding rectangle.
    """
    return _mupdf.ll_fz_bound_path(path, stroke, ctm)

def ll_fz_bound_shade(shade, ctm):
    r"""
    Low-level wrapper for `::fz_bound_shade()`.
    Bound a given shading.

    shade: The shade to bound.

    ctm: The transform to apply to the shade before bounding.

    r: Pointer to storage to put the bounds in.

    Returns r, updated to contain the bounds for the shading.
    """
    return _mupdf.ll_fz_bound_shade(shade, ctm)

def ll_fz_bound_text(text, stroke, ctm):
    r"""
    Low-level wrapper for `::fz_bound_text()`.
    Find the bounds of a given text object.

    text: The text object to find the bounds of.

    stroke: Pointer to the stroke attributes (for stroked
    text), or NULL (for filled text).

    ctm: The matrix in use.

    r: pointer to storage for the bounds.

    Returns a pointer to r, which is updated to contain the
    bounding box for the text object.
    """
    return _mupdf.ll_fz_bound_text(text, stroke, ctm)

def ll_fz_box_type_from_string(name):
    r"""Low-level wrapper for `::fz_box_type_from_string()`."""
    return _mupdf.ll_fz_box_type_from_string(name)

def ll_fz_buffer_extract(buf, data):
    r"""
     Low-level wrapper for `::fz_buffer_extract()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_buffer_extract(::fz_buffer *buf)` => `(size_t, unsigned char *data)`

    	Take ownership of buffer contents.

    	Performs the same task as fz_buffer_storage, but ownership of
    	the data buffer returns with this call. The buffer is left
    	empty.

    	Note: Bad things may happen if this is called on a buffer with
    	multiple references that is being used from multiple threads.

    	data: Pointer to place to retrieve data pointer.

    	Returns length of stream.
    """
    return _mupdf.ll_fz_buffer_extract(buf, data)

def ll_fz_buffer_storage(buf, datap):
    r"""
     Low-level wrapper for `::fz_buffer_storage()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_buffer_storage(::fz_buffer *buf)` => `(size_t, unsigned char *datap)`

    	Retrieve internal memory of buffer.

    	datap: Output parameter that will be pointed to the data.

    	Returns the current size of the data in bytes.
    """
    return _mupdf.ll_fz_buffer_storage(buf, datap)

def ll_fz_calloc(count, size):
    r"""
    Low-level wrapper for `::fz_calloc()`.
    Allocate array of memory of count entries of size bytes.
    Clears the memory to zero.

    Throws exception in the event of failure to allocate.
    """
    return _mupdf.ll_fz_calloc(count, size)

def ll_fz_calloc_no_throw(count, size):
    r"""
    Low-level wrapper for `::fz_calloc_no_throw()`.
    fz_calloc equivalent that returns NULL rather than throwing
    exceptions.
    """
    return _mupdf.ll_fz_calloc_no_throw(count, size)

def ll_fz_caught():
    r"""
    Low-level wrapper for `::fz_caught()`.
    Within an fz_catch() block, retrieve the error code for
    the current exception.

    This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.ll_fz_caught()

def ll_fz_caught_errno():
    r"""Low-level wrapper for `::fz_caught_errno()`."""
    return _mupdf.ll_fz_caught_errno()

def ll_fz_caught_message():
    r"""
    Low-level wrapper for `::fz_caught_message()`.
    Within an fz_catch() block, retrieve the formatted message
    string for the current exception.

    This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.ll_fz_caught_message()

def ll_fz_chartorune(rune, str):
    r"""
     Low-level wrapper for `::fz_chartorune()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_chartorune(const char *str)` => `(int, int rune)`

    	UTF8 decode a single rune from a sequence of chars.

    	rune: Pointer to an int to assign the decoded 'rune' to.

    	str: Pointer to a UTF8 encoded string.

    	Returns the number of bytes consumed.
    """
    return _mupdf.ll_fz_chartorune(rune, str)

def ll_fz_clamp(x, min, max):
    r"""Low-level wrapper for `::fz_clamp()`."""
    return _mupdf.ll_fz_clamp(x, min, max)

def ll_fz_clamp64(x, min, max):
    r"""Low-level wrapper for `::fz_clamp64()`."""
    return _mupdf.ll_fz_clamp64(x, min, max)

def ll_fz_clamp_color(cs, _in, out):
    r"""
     Low-level wrapper for `::fz_clamp_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_clamp_color(::fz_colorspace *cs, const float *in)` => float out

    	Clamp the samples in a color to the correct ranges for a
    	given colorspace.
    """
    return _mupdf.ll_fz_clamp_color(cs, _in, out)

def ll_fz_clamp_location(doc, loc):
    r"""
    Low-level wrapper for `::fz_clamp_location()`.
    Clamps a location into valid chapter/page range. (First clamps
    the chapter into range, then the page into range).
    """
    return _mupdf.ll_fz_clamp_location(doc, loc)

def ll_fz_clampd(x, min, max):
    r"""Low-level wrapper for `::fz_clampd()`."""
    return _mupdf.ll_fz_clampd(x, min, max)

def ll_fz_clampi(x, min, max):
    r"""Low-level wrapper for `::fz_clampi()`."""
    return _mupdf.ll_fz_clampi(x, min, max)

def ll_fz_clampp(x, min, max):
    r"""Low-level wrapper for `::fz_clampp()`."""
    return _mupdf.ll_fz_clampp(x, min, max)

def ll_fz_cleanname(name):
    r"""
    Low-level wrapper for `::fz_cleanname()`.
    rewrite path to the shortest string that names the same path.

    Eliminates multiple and trailing slashes, interprets "." and
    "..". Overwrites the string in place.
    """
    return _mupdf.ll_fz_cleanname(name)

def ll_fz_cleanname_strdup(name):
    r"""
    Low-level wrapper for `::fz_cleanname_strdup()`.
    rewrite path to the shortest string that names the same path.

    Eliminates multiple and trailing slashes, interprets "." and
    "..". Allocates a new string that the caller must free.
    """
    return _mupdf.ll_fz_cleanname_strdup(name)

def ll_fz_clear_bitmap(bit):
    r"""
    Low-level wrapper for `::fz_clear_bitmap()`.
    Set the entire bitmap to 0.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_clear_bitmap(bit)

def ll_fz_clear_buffer(buf):
    r"""
    Low-level wrapper for `::fz_clear_buffer()`.
    Empties the buffer. Storage is not freed, but is held ready
    to be reused as the buffer is refilled.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_clear_buffer(buf)

def ll_fz_clear_pixmap(pix):
    r"""
    Low-level wrapper for `::fz_clear_pixmap()`.
    Sets all components (including alpha) of
    all pixels in a pixmap to 0.

    pix: The pixmap to clear.
    """
    return _mupdf.ll_fz_clear_pixmap(pix)

def ll_fz_clear_pixmap_rect_with_value(pix, value, r):
    r"""
    Low-level wrapper for `::fz_clear_pixmap_rect_with_value()`.
    Clears a subrect of a pixmap with the given value.

    pix: The pixmap to clear.

    value: Values in the range 0 to 255 are valid. Each component
    sample for each pixel in the pixmap will be set to this value,
    while alpha will always be set to 255 (non-transparent).

    r: the rectangle.
    """
    return _mupdf.ll_fz_clear_pixmap_rect_with_value(pix, value, r)

def ll_fz_clear_pixmap_with_value(pix, value):
    r"""
    Low-level wrapper for `::fz_clear_pixmap_with_value()`.
    Clears a pixmap with the given value.

    pix: The pixmap to clear.

    value: Values in the range 0 to 255 are valid. Each component
    sample for each pixel in the pixmap will be set to this value,
    while alpha will always be set to 255 (non-transparent).

    This function is horrible, and should be removed from the
    API and replaced with a less magic one.
    """
    return _mupdf.ll_fz_clear_pixmap_with_value(pix, value)

def ll_fz_clip_image_mask(dev, image, ctm, scissor):
    r"""Low-level wrapper for `::fz_clip_image_mask()`."""
    return _mupdf.ll_fz_clip_image_mask(dev, image, ctm, scissor)

def ll_fz_clip_path(dev, path, even_odd, ctm, scissor):
    r"""Low-level wrapper for `::fz_clip_path()`."""
    return _mupdf.ll_fz_clip_path(dev, path, even_odd, ctm, scissor)

def ll_fz_clip_stroke_path(dev, path, stroke, ctm, scissor):
    r"""Low-level wrapper for `::fz_clip_stroke_path()`."""
    return _mupdf.ll_fz_clip_stroke_path(dev, path, stroke, ctm, scissor)

def ll_fz_clip_stroke_text(dev, text, stroke, ctm, scissor):
    r"""Low-level wrapper for `::fz_clip_stroke_text()`."""
    return _mupdf.ll_fz_clip_stroke_text(dev, text, stroke, ctm, scissor)

def ll_fz_clip_text(dev, text, ctm, scissor):
    r"""Low-level wrapper for `::fz_clip_text()`."""
    return _mupdf.ll_fz_clip_text(dev, text, ctm, scissor)

def ll_fz_clone_buffer(buf):
    r"""
    Low-level wrapper for `::fz_clone_buffer()`.
    Make a new buffer, containing a copy of the data used in
    the original.
    """
    return _mupdf.ll_fz_clone_buffer(buf)

def ll_fz_clone_context():
    r"""
    Low-level wrapper for `::fz_clone_context()`.
    Make a clone of an existing context.

    This function is meant to be used in multi-threaded
    applications where each thread requires its own context, yet
    parts of the global state, for example caching, are shared.

    ctx: Context obtained from fz_new_context to make a copy of.
    ctx must have had locks and lock/functions setup when created.
    The two contexts will share the memory allocator, resource
    store, locks and lock/unlock functions. They will each have
    their own exception stacks though.

    May return NULL.
    """
    return _mupdf.ll_fz_clone_context()

def ll_fz_clone_default_colorspaces(base):
    r"""
    Low-level wrapper for `::fz_clone_default_colorspaces()`.
    Returns a reference to a newly cloned default colorspaces
    structure.

    The new clone may safely be altered without fear of race
    conditions as the caller is the only reference holder.
    """
    return _mupdf.ll_fz_clone_default_colorspaces(base)

def ll_fz_clone_path(path):
    r"""
    Low-level wrapper for `::fz_clone_path()`.
    Clone the data for a path.

    This is used in preference to fz_keep_path when a whole
    new copy of a path is required, rather than just a shared
    pointer. This probably indicates that the path is about to
    be modified.

    path: path to clone.

    Throws exceptions on failure to allocate.
    """
    return _mupdf.ll_fz_clone_path(path)

def ll_fz_clone_pixmap(old):
    r"""
    Low-level wrapper for `::fz_clone_pixmap()`.
    Clone a pixmap, copying the pixels and associated data to new
    storage.

    The reference count of 'old' is unchanged.
    """
    return _mupdf.ll_fz_clone_pixmap(old)

def ll_fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs):
    r"""Low-level wrapper for `::fz_clone_pixmap_area_with_different_seps()`."""
    return _mupdf.ll_fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs)

def ll_fz_clone_separations_for_overprint(seps):
    r"""
    Low-level wrapper for `::fz_clone_separations_for_overprint()`.
    Return a separations object with all the spots in the input
    separations object that are set to composite, reset to be
    enabled. If there ARE no spots in the object, this returns
    NULL. If the object already has all its spots enabled, then
    just returns another handle on the same object.
    """
    return _mupdf.ll_fz_clone_separations_for_overprint(seps)

def ll_fz_clone_stroke_state(stroke):
    r"""
    Low-level wrapper for `::fz_clone_stroke_state()`.
    Create an identical stroke_state structure and return a
    reference to it.

    stroke: The stroke state reference to clone.

    Exceptions may be thrown in the event of a failure to
    allocate.
    """
    return _mupdf.ll_fz_clone_stroke_state(stroke)

def ll_fz_close_band_writer(writer):
    r"""
    Low-level wrapper for `::fz_close_band_writer()`.
    Finishes up the output and closes the band writer. After this
    call no more headers or bands may be written.
    """
    return _mupdf.ll_fz_close_band_writer(writer)

def ll_fz_close_device(dev):
    r"""
    Low-level wrapper for `::fz_close_device()`.
    Signal the end of input, and flush any buffered output.
    This is NOT called implicitly on fz_drop_device. This
    may throw exceptions.
    """
    return _mupdf.ll_fz_close_device(dev)

def ll_fz_close_document_writer(wri):
    r"""
    Low-level wrapper for `::fz_close_document_writer()`.
    Called to end the process of writing
    pages to a document.

    This writes any file level trailers required. After this
    completes successfully the file is up to date and complete.
    """
    return _mupdf.ll_fz_close_document_writer(wri)

def ll_fz_close_output(arg_1):
    r"""
    Low-level wrapper for `::fz_close_output()`.
    Flush pending output and close an output stream.
    """
    return _mupdf.ll_fz_close_output(arg_1)

def ll_fz_close_zip_writer(zip):
    r"""
    Low-level wrapper for `::fz_close_zip_writer()`.
    Close the zip file for writing.

    This flushes any pending data to the file. This can throw
    exceptions.
    """
    return _mupdf.ll_fz_close_zip_writer(zip)

def ll_fz_closepath(path):
    r"""
    Low-level wrapper for `::fz_closepath()`.
    Close the current subpath.

    path: The path to modify.

    Throws exceptions on failure to allocate, attempting to modify
    a packed path, and illegal path closes (i.e. closing a non open
    path).
    """
    return _mupdf.ll_fz_closepath(path)

def ll_fz_colorspace_colorant(cs, n):
    r"""
    Low-level wrapper for `::fz_colorspace_colorant()`.
    Retrieve a the name for a colorant.

    Returns a pointer with the same lifespan as the colorspace.
    """
    return _mupdf.ll_fz_colorspace_colorant(cs, n)

def ll_fz_colorspace_device_n_has_cmyk(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_device_n_has_cmyk()`.
    True if DeviceN color space has cyan magenta yellow or black as
    one of its colorants.
    """
    return _mupdf.ll_fz_colorspace_device_n_has_cmyk(cs)

def ll_fz_colorspace_device_n_has_only_cmyk(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.
    True if DeviceN color space has only colorants from the CMYK set.
    """
    return _mupdf.ll_fz_colorspace_device_n_has_only_cmyk(cs)

def ll_fz_colorspace_is_cmyk(cs):
    r"""Low-level wrapper for `::fz_colorspace_is_cmyk()`."""
    return _mupdf.ll_fz_colorspace_is_cmyk(cs)

def ll_fz_colorspace_is_device(cs):
    r"""Low-level wrapper for `::fz_colorspace_is_device()`."""
    return _mupdf.ll_fz_colorspace_is_device(cs)

def ll_fz_colorspace_is_device_cmyk(cs):
    r"""Low-level wrapper for `::fz_colorspace_is_device_cmyk()`."""
    return _mupdf.ll_fz_colorspace_is_device_cmyk(cs)

def ll_fz_colorspace_is_device_gray(cs):
    r"""Low-level wrapper for `::fz_colorspace_is_device_gray()`."""
    return _mupdf.ll_fz_colorspace_is_device_gray(cs)

def ll_fz_colorspace_is_device_n(cs):
    r"""Low-level wrapper for `::fz_colorspace_is_device_n()`."""
    return _mupdf.ll_fz_colorspace_is_device_n(cs)

def ll_fz_colorspace_is_gray(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_is_gray()`.
    Tests for particular types of colorspaces
    """
    return _mupdf.ll_fz_colorspace_is_gray(cs)

def ll_fz_colorspace_is_indexed(cs):
    r"""Low-level wrapper for `::fz_colorspace_is_indexed()`."""
    return _mupdf.ll_fz_colorspace_is_indexed(cs)

def ll_fz_colorspace_is_lab(cs):
    r"""Low-level wrapper for `::fz_colorspace_is_lab()`."""
    return _mupdf.ll_fz_colorspace_is_lab(cs)

def ll_fz_colorspace_is_lab_icc(cs):
    r"""Low-level wrapper for `::fz_colorspace_is_lab_icc()`."""
    return _mupdf.ll_fz_colorspace_is_lab_icc(cs)

def ll_fz_colorspace_is_rgb(cs):
    r"""Low-level wrapper for `::fz_colorspace_is_rgb()`."""
    return _mupdf.ll_fz_colorspace_is_rgb(cs)

def ll_fz_colorspace_is_subtractive(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_is_subtractive()`.
    True for CMYK, Separation and DeviceN colorspaces.
    """
    return _mupdf.ll_fz_colorspace_is_subtractive(cs)

def ll_fz_colorspace_n(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_n()`.
    Query the number of colorants in a colorspace.
    """
    return _mupdf.ll_fz_colorspace_n(cs)

def ll_fz_colorspace_name(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_name()`.
    Query the name of a colorspace.

    The returned string has the same lifespan as the colorspace
    does. Caller should not free it.
    """
    return _mupdf.ll_fz_colorspace_name(cs)

def ll_fz_colorspace_name_colorant(cs, n, name):
    r"""
    Low-level wrapper for `::fz_colorspace_name_colorant()`.
    Assign a name for a given colorant in a colorspace.

    Used while initially setting up a colorspace. The string is
    copied into local storage, so need not be retained by the
    caller.
    """
    return _mupdf.ll_fz_colorspace_name_colorant(cs, n, name)

def ll_fz_colorspace_type(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_type()`.
    Query the type of colorspace.
    """
    return _mupdf.ll_fz_colorspace_type(cs)

def ll_fz_compare_separations(sep1, sep2):
    r"""
    Low-level wrapper for `::fz_compare_separations()`.
    Compare 2 separations structures (or NULLs).

    Return 0 if identical, non-zero if not identical.
    """
    return _mupdf.ll_fz_compare_separations(sep1, sep2)

def ll_fz_compress_ccitt_fax_g3(data, columns, rows, stride):
    r"""
    Low-level wrapper for `::fz_compress_ccitt_fax_g3()`.
    Compress bitmap data as CCITT Group 3 1D fax image.
    Creates a stream assuming the default PDF parameters,
    except the number of columns.
    """
    return _mupdf.ll_fz_compress_ccitt_fax_g3(data, columns, rows, stride)

def ll_fz_compress_ccitt_fax_g4(data, columns, rows, stride):
    r"""
    Low-level wrapper for `::fz_compress_ccitt_fax_g4()`.
    Compress bitmap data as CCITT Group 4 2D fax image.
    Creates a stream assuming the default PDF parameters, except
    K=-1 and the number of columns.
    """
    return _mupdf.ll_fz_compress_ccitt_fax_g4(data, columns, rows, stride)

def ll_fz_compressed_buffer_size(buffer):
    r"""
    Low-level wrapper for `::fz_compressed_buffer_size()`.
    Return the storage size used for a buffer and its data.
    Used in implementing store handling.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_compressed_buffer_size(buffer)

def ll_fz_compressed_image_buffer(image):
    r"""
    Low-level wrapper for `::fz_compressed_image_buffer()`.
    Retrieve the underlying compressed data for an image.

    Returns a pointer to the underlying data buffer for an image,
    or NULL if this image is not based upon a compressed data
    buffer.

    This is not a reference counted structure, so no reference is
    returned. Lifespan is limited to that of the image itself.
    """
    return _mupdf.ll_fz_compressed_image_buffer(image)

def ll_fz_compressed_image_type(image):
    r"""
    Low-level wrapper for `::fz_compressed_image_type()`.
    Return the type of a compressed image.

    Any non-compressed image will have the type returned as UNKNOWN.
    """
    return _mupdf.ll_fz_compressed_image_type(image)

def ll_fz_concat(left, right):
    r"""
    Low-level wrapper for `::fz_concat()`.
    Multiply two matrices.

    The order of the two matrices are important since matrix
    multiplication is not commutative.

    Returns result.
    """
    return _mupdf.ll_fz_concat(left, right)

def ll_fz_concat_push_drop(concat, chain):
    r"""
    Low-level wrapper for `::fz_concat_push_drop()`.
    Add a chained stream to the end of the concatenate filter.

    Ownership of chain is passed in.
    """
    return _mupdf.ll_fz_concat_push_drop(concat, chain)

def ll_fz_contains_rect(a, b):
    r"""
    Low-level wrapper for `::fz_contains_rect()`.
    Test rectangle inclusion.

    Return true if a entirely contains b.
    """
    return _mupdf.ll_fz_contains_rect(a, b)

def ll_fz_convert_color(ss, sv, ds, dv, _is, params):
    r"""
     Low-level wrapper for `::fz_convert_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_convert_color(::fz_colorspace *ss, const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv

    	Convert color values sv from colorspace ss into colorvalues dv
    	for colorspace ds, via an optional intervening space is,
    	respecting the given color_params.
    """
    return _mupdf.ll_fz_convert_color(ss, sv, ds, dv, _is, params)

def ll_fz_convert_error(code):
    r"""
     Low-level wrapper for `::fz_convert_error()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_convert_error()` => `(const char *, int code)`
    """
    return _mupdf.ll_fz_convert_error(code)

def ll_fz_convert_indexed_pixmap_to_base(src):
    r"""
    Low-level wrapper for `::fz_convert_indexed_pixmap_to_base()`.
    Convert pixmap from indexed to base colorspace.

    This creates a new bitmap containing the converted pixmap data.
    """
    return _mupdf.ll_fz_convert_indexed_pixmap_to_base(src)

def ll_fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha):
    r"""
    Low-level wrapper for `::fz_convert_pixmap()`.
    Convert an existing pixmap to a desired
    colorspace. Other properties of the pixmap, such as resolution
    and position are copied to the converted pixmap.

    pix: The pixmap to convert.

    default_cs: If NULL pix->colorspace is used. It is possible that
    the data may need to be interpreted as one of the color spaces
    in default_cs.

    cs_des: Desired colorspace, may be NULL to denote alpha-only.

    prf: Proofing color space through which we need to convert.

    color_params: Parameters that may be used in conversion (e.g.
    ri).

    keep_alpha: If 0 any alpha component is removed, otherwise
    alpha is kept if present in the pixmap.
    """
    return _mupdf.ll_fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha)

def ll_fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params):
    r"""
     Low-level wrapper for `::fz_convert_separation_colors()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_convert_separation_colors(::fz_colorspace *src_cs, const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color

    	Convert a color given in terms of one colorspace,
    	to a color in terms of another colorspace/separations.
    """
    return _mupdf.ll_fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params)

def ll_fz_convert_separation_pixmap_to_base(src):
    r"""
    Low-level wrapper for `::fz_convert_separation_pixmap_to_base()`.
    Convert pixmap from DeviceN/Separation to base colorspace.

    This creates a new bitmap containing the converted pixmap data.
    """
    return _mupdf.ll_fz_convert_separation_pixmap_to_base(src)

def ll_fz_copy_option(val, dest, maxlen):
    r"""
    Low-level wrapper for `::fz_copy_option()`.
    Copy an option (val) into a destination buffer (dest), of maxlen
    bytes.

    Returns the number of bytes (including terminator) that did not
    fit. If val is maxlen or greater bytes in size, it will be left
    unterminated.
    """
    return _mupdf.ll_fz_copy_option(val, dest, maxlen)

def ll_fz_copy_pixmap_rect(dest, src, r, default_cs):
    r"""Low-level wrapper for `::fz_copy_pixmap_rect()`."""
    return _mupdf.ll_fz_copy_pixmap_rect(dest, src, r, default_cs)

def ll_fz_copy_rectangle(page, area, crlf):
    r"""
    Low-level wrapper for `::fz_copy_rectangle()`.
    Return a newly allocated UTF-8 string with the text for a given
    selection rectangle.

    crlf: If true, write "\r\n" style line endings (otherwise "\n"
    only).
    """
    return _mupdf.ll_fz_copy_rectangle(page, area, crlf)

def ll_fz_copy_selection(page, a, b, crlf):
    r"""
    Low-level wrapper for `::fz_copy_selection()`.
    Return a newly allocated UTF-8 string with the text for a given
    selection.

    crlf: If true, write "\r\n" style line endings (otherwise "\n"
    only).
    """
    return _mupdf.ll_fz_copy_selection(page, a, b, crlf)

def ll_fz_count_active_separations(seps):
    r"""
    Low-level wrapper for `::fz_count_active_separations()`.
    Return the number of active separations.
    """
    return _mupdf.ll_fz_count_active_separations(seps)

def ll_fz_count_archive_entries(arch):
    r"""
    Low-level wrapper for `::fz_count_archive_entries()`.
    Number of entries in archive.

    Will always return a value >= 0.

    May throw an exception if this type of archive cannot count the
    entries (such as a directory).
    """
    return _mupdf.ll_fz_count_archive_entries(arch)

def ll_fz_count_chapter_pages(doc, chapter):
    r"""
    Low-level wrapper for `::fz_count_chapter_pages()`.
    Return the number of pages in a chapter.
    May return 0.
    """
    return _mupdf.ll_fz_count_chapter_pages(doc, chapter)

def ll_fz_count_chapters(doc):
    r"""
    Low-level wrapper for `::fz_count_chapters()`.
    Return the number of chapters in the document.
    At least 1.
    """
    return _mupdf.ll_fz_count_chapters(doc)

def ll_fz_count_pages(doc):
    r"""
    Low-level wrapper for `::fz_count_pages()`.
    Return the number of pages in document

    May return 0 for documents with no pages.
    """
    return _mupdf.ll_fz_count_pages(doc)

def ll_fz_count_separations(sep):
    r"""Low-level wrapper for `::fz_count_separations()`."""
    return _mupdf.ll_fz_count_separations(sep)

def ll_fz_create_link(page, bbox, uri):
    r"""
    Low-level wrapper for `::fz_create_link()`.
    Create a new link on a page.
    """
    return _mupdf.ll_fz_create_link(page, bbox, uri)

def ll_fz_currentpoint(path):
    r"""
    Low-level wrapper for `::fz_currentpoint()`.
    Return the current point that a path has
    reached or (0,0) if empty.

    path: path to return the current point of.
    """
    return _mupdf.ll_fz_currentpoint(path)

def ll_fz_curveto(path, x0, y0, x1, y1, x2, y2):
    r"""
    Low-level wrapper for `::fz_curveto()`.
    Append a 'curveto' command to an open path. (For a
    cubic bezier).

    path: The path to modify.

    x0, y0: The coordinates of the first control point for the
    curve.

    x1, y1: The coordinates of the second control point for the
    curve.

    x2, y2: The end coordinates for the curve.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_curveto(path, x0, y0, x1, y1, x2, y2)

def ll_fz_curvetov(path, x1, y1, x2, y2):
    r"""
    Low-level wrapper for `::fz_curvetov()`.
    Append a 'curvetov' command to an open path. (For a
    cubic bezier with the first control coordinate equal to
    the start point).

    path: The path to modify.

    x1, y1: The coordinates of the second control point for the
    curve.

    x2, y2: The end coordinates for the curve.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_curvetov(path, x1, y1, x2, y2)

def ll_fz_curvetoy(path, x0, y0, x2, y2):
    r"""
    Low-level wrapper for `::fz_curvetoy()`.
    Append a 'curvetoy' command to an open path. (For a
    cubic bezier with the second control coordinate equal to
    the end point).

    path: The path to modify.

    x0, y0: The coordinates of the first control point for the
    curve.

    x2, y2: The end coordinates for the curve (and the second
    control coordinate).

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_curvetoy(path, x0, y0, x2, y2)

def ll_fz_debug_store(out):
    r"""
    Low-level wrapper for `::fz_debug_store()`.
    Output debugging information for the current state of the store
    to the given output channel.
    """
    return _mupdf.ll_fz_debug_store(out)

def ll_fz_debug_xml(item, level):
    r"""
    Low-level wrapper for `::fz_debug_xml()`.
    Pretty-print an XML tree to stdout. (Deprecated, use
    fz_output_xml in preference).
    """
    return _mupdf.ll_fz_debug_xml(item, level)

def ll_fz_decode_tile(pix, decode):
    r"""Low-level wrapper for `::fz_decode_tile()`."""
    return _mupdf.ll_fz_decode_tile(pix, decode)

def ll_fz_decode_uri(s):
    r"""
     Low-level wrapper for `::fz_decode_uri()`.
    Return a new string representing the unencoded version of the given URI.
    This decodes all escape sequences except those that would result in a reserved
    character that are part of the URI syntax (; / ? : @ & = + $ , #).
    """
    return _mupdf.ll_fz_decode_uri(s)

def ll_fz_decode_uri_component(s):
    r"""
     Low-level wrapper for `::fz_decode_uri_component()`.
    Return a new string representing the unencoded version of the given URI component.
    This decodes all escape sequences!
    """
    return _mupdf.ll_fz_decode_uri_component(s)

def ll_fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra):
    r"""
     Low-level wrapper for `::fz_decomp_image_from_stream()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_decomp_image_from_stream(::fz_stream *stm, ::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`

    	Decode a subarea of a compressed image. l2factor is the amount
    	of subsampling inbuilt to the stream (i.e. performed by the
    	decoder). If non NULL, l2extra is the extra amount of
    	subsampling that should be performed by this routine. This will
    	be updated on exit to the amount of subsampling that is still
    	required to be done.

    	Returns a kept reference.
    """
    return _mupdf.ll_fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra)

def ll_fz_decouple_type3_font(font, t3doc):
    r"""Low-level wrapper for `::fz_decouple_type3_font()`."""
    return _mupdf.ll_fz_decouple_type3_font(font, t3doc)

def ll_fz_default_cmyk(default_cs):
    r"""Low-level wrapper for `::fz_default_cmyk()`."""
    return _mupdf.ll_fz_default_cmyk(default_cs)

def ll_fz_default_error_callback(user, message):
    r"""
    Low-level wrapper for `::fz_default_error_callback()`.
    FIXME: Better not to expose fz_default_error_callback, and
    fz_default_warning callback and to allow 'NULL' to be used
    int fz_set_xxxx_callback to mean "defaults".

    FIXME: Do we need/want functions like
    fz_error_callback(ctx, message) to allow callers to inject
    stuff into the error/warning streams?

    The default error callback. Declared publicly just so that the
    error callback can be set back to this after it has been
    overridden.
    """
    return _mupdf.ll_fz_default_error_callback(user, message)

def ll_fz_default_gray(default_cs):
    r"""
    Low-level wrapper for `::fz_default_gray()`.
    Retrieve default colorspaces (typically page local).

    If default_cs is non NULL, the default is retrieved from there,
    otherwise the global default is retrieved.

    These return borrowed references that should not be dropped,
    unless they are kept first.
    """
    return _mupdf.ll_fz_default_gray(default_cs)

def ll_fz_default_halftone(num_comps):
    r"""
    Low-level wrapper for `::fz_default_halftone()`.
    Create a 'default' halftone structure
    for the given number of components.

    num_comps: The number of components to use.

    Returns a simple default halftone. The default halftone uses
    the same halftone tile for each plane, which may not be ideal
    for all purposes.
    """
    return _mupdf.ll_fz_default_halftone(num_comps)

def ll_fz_default_output_intent(default_cs):
    r"""Low-level wrapper for `::fz_default_output_intent()`."""
    return _mupdf.ll_fz_default_output_intent(default_cs)

def ll_fz_default_rgb(default_cs):
    r"""Low-level wrapper for `::fz_default_rgb()`."""
    return _mupdf.ll_fz_default_rgb(default_cs)

def ll_fz_default_warning_callback(user, message):
    r"""
    Low-level wrapper for `::fz_default_warning_callback()`.
    The default warning callback. Declared publicly just so that
    the warning callback can be set back to this after it has been
    overridden.
    """
    return _mupdf.ll_fz_default_warning_callback(user, message)

def ll_fz_defer_reap_end():
    r"""
    Low-level wrapper for `::fz_defer_reap_end()`.
    Decrement the defer reap count.

    If the defer reap count returns to 0, and the store
    has reapable objects in, a reap pass will begin.

    Call this at the end of a process during which you
    potentially might drop many reapable objects.

    It is vital that every fz_defer_reap_start is matched
    by a fz_defer_reap_end call.
    """
    return _mupdf.ll_fz_defer_reap_end()

def ll_fz_defer_reap_start():
    r"""
    Low-level wrapper for `::fz_defer_reap_start()`.
    Increment the defer reap count.

    No reap operations will take place (except for those
    triggered by an immediate failed malloc) until the
    defer reap count returns to 0.

    Call this at the start of a process during which you
    potentially might drop many reapable objects.

    It is vital that every fz_defer_reap_start is matched
    by a fz_defer_reap_end call.
    """
    return _mupdf.ll_fz_defer_reap_start()

def ll_fz_deflate(dest, compressed_length, source, source_length, level):
    r"""
     Low-level wrapper for `::fz_deflate()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_deflate(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => size_t compressed_length

    	Compress source_length bytes of data starting
    	at source, into a buffer of length *destLen, starting at dest.
    compressed_length will be updated on exit to contain the size
    	actually used.
    """
    return _mupdf.ll_fz_deflate(dest, compressed_length, source, source_length, level)

def ll_fz_deflate_bound(size):
    r"""
    Low-level wrapper for `::fz_deflate_bound()`.
    Returns the upper bound on the
    size of flated data of length size.
    """
    return _mupdf.ll_fz_deflate_bound(size)

def ll_fz_delete_link(page, link):
    r"""
    Low-level wrapper for `::fz_delete_link()`.
    Delete an existing link on a page.
    """
    return _mupdf.ll_fz_delete_link(page, link)

def ll_fz_deskew_pixmap(src, degrees, border):
    r"""Low-level wrapper for `::fz_deskew_pixmap()`."""
    return _mupdf.ll_fz_deskew_pixmap(src, degrees, border)

def ll_fz_detach_xml(node):
    r"""
    Low-level wrapper for `::fz_detach_xml()`.
    Detach a node from the tree, unlinking it from its parent,
    and setting the document root to the node.
    """
    return _mupdf.ll_fz_detach_xml(node)

def ll_fz_detect_document(points, src):
    r"""Low-level wrapper for `::fz_detect_document()`."""
    return _mupdf.ll_fz_detect_document(points, src)

def ll_fz_device_bgr():
    r"""Low-level wrapper for `::fz_device_bgr()`."""
    return _mupdf.ll_fz_device_bgr()

def ll_fz_device_cmyk():
    r"""Low-level wrapper for `::fz_device_cmyk()`."""
    return _mupdf.ll_fz_device_cmyk()

def ll_fz_device_current_scissor(dev):
    r"""
    Low-level wrapper for `::fz_device_current_scissor()`.
    Find current scissor region as tracked by the device.
    """
    return _mupdf.ll_fz_device_current_scissor(dev)

def ll_fz_device_gray():
    r"""
    Low-level wrapper for `::fz_device_gray()`.
    Retrieve global default colorspaces.

    These return borrowed references that should not be dropped,
    unless they are kept first.
    """
    return _mupdf.ll_fz_device_gray()

def ll_fz_device_lab():
    r"""Low-level wrapper for `::fz_device_lab()`."""
    return _mupdf.ll_fz_device_lab()

def ll_fz_device_rgb():
    r"""Low-level wrapper for `::fz_device_rgb()`."""
    return _mupdf.ll_fz_device_rgb()

def ll_fz_dirname(dir, path, dirsize):
    r"""
    Low-level wrapper for `::fz_dirname()`.
    extract the directory component from a path.
    """
    return _mupdf.ll_fz_dirname(dir, path, dirsize)

def ll_fz_disable_device_hints(dev, hints):
    r"""
    Low-level wrapper for `::fz_disable_device_hints()`.
    Disable (clear) hint bits within the hint bitfield for a device.
    """
    return _mupdf.ll_fz_disable_device_hints(dev, hints)

def ll_fz_disable_icc():
    r"""
    Low-level wrapper for `::fz_disable_icc()`.
    Disable icc profile based operation.
    """
    return _mupdf.ll_fz_disable_icc()

def ll_fz_display_list_is_empty(list):
    r"""
    Low-level wrapper for `::fz_display_list_is_empty()`.
    Check for a display list being empty

    list: The list to check.

    Returns true if empty, false otherwise.
    """
    return _mupdf.ll_fz_display_list_is_empty(list)

def ll_fz_div255(c, a):
    r"""
    Low-level wrapper for `::fz_div255()`.
    Undo alpha premultiplication.
    """
    return _mupdf.ll_fz_div255(c, a)

def ll_fz_do_always():
    r"""Low-level wrapper for `::fz_do_always()`."""
    return _mupdf.ll_fz_do_always()

def ll_fz_do_catch():
    r"""Low-level wrapper for `::fz_do_catch()`."""
    return _mupdf.ll_fz_do_catch()

def ll_fz_do_try():
    r"""Low-level wrapper for `::fz_do_try()`."""
    return _mupdf.ll_fz_do_try()

def ll_fz_document_handler_open(handler, stream, accel, dir, recognize_state):
    r"""
     Low-level wrapper for `::fz_document_handler_open()`.  Helper for calling `fz_document_handler::open` function pointer via
    Swig from Python/C#.
    """
    return _mupdf.ll_fz_document_handler_open(handler, stream, accel, dir, recognize_state)

def ll_fz_document_handler_recognize(handler, magic):
    r"""
     Low-level wrapper for `::fz_document_handler_recognize()`.  Helper for calling a `fz_document_handler::recognize` function
    pointer via Swig from Python/C#.
    """
    return _mupdf.ll_fz_document_handler_recognize(handler, magic)

def ll_fz_document_output_intent(doc):
    r"""
    Low-level wrapper for `::fz_document_output_intent()`.
    Find the output intent colorspace if the document has defined
    one.

    Returns a borrowed reference that should not be dropped, unless
    it is kept first.
    """
    return _mupdf.ll_fz_document_output_intent(doc)

def ll_fz_document_supports_accelerator(doc):
    r"""
    Low-level wrapper for `::fz_document_supports_accelerator()`.
    Query if the document supports the saving of accelerator data.
    """
    return _mupdf.ll_fz_document_supports_accelerator(doc)

def ll_fz_dom_add_attribute(elt, att, value):
    r"""
    Low-level wrapper for `::fz_dom_add_attribute()`.
    Add an attribute to an element.

    Ownership of att and value remain with the caller.
    """
    return _mupdf.ll_fz_dom_add_attribute(elt, att, value)

def ll_fz_dom_append_child(parent, child):
    r"""
    Low-level wrapper for `::fz_dom_append_child()`.
    Insert an element as the last child of a parent, unlinking the
    child from its current position if required.
    """
    return _mupdf.ll_fz_dom_append_child(parent, child)

def ll_fz_dom_attribute(elt, att):
    r"""
    Low-level wrapper for `::fz_dom_attribute()`.
    Retrieve the value of a given attribute from a given element.

    Returns a borrowed pointer to the value or NULL if not found.
    """
    return _mupdf.ll_fz_dom_attribute(elt, att)

def ll_fz_dom_body(dom):
    r"""
    Low-level wrapper for `::fz_dom_body()`.
    Return a borrowed reference for the 'body' element of
    the given DOM.
    """
    return _mupdf.ll_fz_dom_body(dom)

def ll_fz_dom_clone(elt):
    r"""
    Low-level wrapper for `::fz_dom_clone()`.
    Clone an element (and its children).

    A borrowed reference to the clone is returned. The clone is not
    yet linked into the DOM.
    """
    return _mupdf.ll_fz_dom_clone(elt)

def ll_fz_dom_create_element(dom, tag):
    r"""
    Low-level wrapper for `::fz_dom_create_element()`.
    Create an element of a given tag type for the given DOM.

    The element is not linked into the DOM yet.
    """
    return _mupdf.ll_fz_dom_create_element(dom, tag)

def ll_fz_dom_create_text_node(dom, text):
    r"""
    Low-level wrapper for `::fz_dom_create_text_node()`.
    Create a text node for the given DOM.

    The element is not linked into the DOM yet.
    """
    return _mupdf.ll_fz_dom_create_text_node(dom, text)

def ll_fz_dom_document_element(dom):
    r"""
    Low-level wrapper for `::fz_dom_document_element()`.
    Return a borrowed reference for the document (the top
    level element) of the DOM.
    """
    return _mupdf.ll_fz_dom_document_element(dom)

def ll_fz_dom_find(elt, tag, att, match):
    r"""
    Low-level wrapper for `::fz_dom_find()`.
    Find the first element matching the requirements in a depth first traversal from elt.

    The tagname must match tag, unless tag is NULL, when all tag names are considered to match.

    If att is NULL, then all tags match.
    Otherwise:
    	If match is NULL, then only nodes that have an att attribute match.
    	If match is non-NULL, then only nodes that have an att attribute that matches match match.

    Returns NULL (if no match found), or a borrowed reference to the first matching element.
    """
    return _mupdf.ll_fz_dom_find(elt, tag, att, match)

def ll_fz_dom_find_next(elt, tag, att, match):
    r"""
    Low-level wrapper for `::fz_dom_find_next()`.
    Find the next element matching the requirements.
    """
    return _mupdf.ll_fz_dom_find_next(elt, tag, att, match)

def ll_fz_dom_first_child(elt):
    r"""
    Low-level wrapper for `::fz_dom_first_child()`.
    Return a borrowed reference to the first child of a node,
    or NULL if there isn't one.
    """
    return _mupdf.ll_fz_dom_first_child(elt)

def ll_fz_dom_get_attribute(elt, i, att):
    r"""
     Low-level wrapper for `::fz_dom_get_attribute()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_dom_get_attribute(::fz_xml *elt, int i)` => `(const char *, const char *att)`

    	Enumerate through the attributes of an element.

    	Call with i=0,1,2,3... to enumerate attributes.

    	On return *att and the return value will be NULL if there are not
    	that many attributes to read. Otherwise, *att will be filled in
    	with a borrowed pointer to the attribute name, and the return
    	value will be a borrowed pointer to the value.
    """
    return _mupdf.ll_fz_dom_get_attribute(elt, i, att)

def ll_fz_dom_insert_after(node, new_elt):
    r"""
    Low-level wrapper for `::fz_dom_insert_after()`.
    Insert an element (new_elt), after another element (node),
    unlinking the new_elt from its current position if required.
    """
    return _mupdf.ll_fz_dom_insert_after(node, new_elt)

def ll_fz_dom_insert_before(node, new_elt):
    r"""
    Low-level wrapper for `::fz_dom_insert_before()`.
    Insert an element (new_elt), before another element (node),
    unlinking the new_elt from its current position if required.
    """
    return _mupdf.ll_fz_dom_insert_before(node, new_elt)

def ll_fz_dom_next(elt):
    r"""
    Low-level wrapper for `::fz_dom_next()`.
    Return a borrowed reference to the next sibling of a node,
    or NULL if there isn't one.
    """
    return _mupdf.ll_fz_dom_next(elt)

def ll_fz_dom_parent(elt):
    r"""
    Low-level wrapper for `::fz_dom_parent()`.
    Return a borrowed reference to the parent of a node,
    or NULL if there isn't one.
    """
    return _mupdf.ll_fz_dom_parent(elt)

def ll_fz_dom_previous(elt):
    r"""
    Low-level wrapper for `::fz_dom_previous()`.
    Return a borrowed reference to the previous sibling of a node,
    or NULL if there isn't one.
    """
    return _mupdf.ll_fz_dom_previous(elt)

def ll_fz_dom_remove(elt):
    r"""
    Low-level wrapper for `::fz_dom_remove()`.
    Remove an element from the DOM. The element can be added back elsewhere
    if required.

    No reference counting changes for the element.
    """
    return _mupdf.ll_fz_dom_remove(elt)

def ll_fz_dom_remove_attribute(elt, att):
    r"""
    Low-level wrapper for `::fz_dom_remove_attribute()`.
    Remove an attribute from an element.
    """
    return _mupdf.ll_fz_dom_remove_attribute(elt, att)

def ll_fz_draw_story(story, dev, ctm):
    r"""Low-level wrapper for `::fz_draw_story()`."""
    return _mupdf.ll_fz_draw_story(story, dev, ctm)

def ll_fz_drop_archive(arch):
    r"""
    Low-level wrapper for `::fz_drop_archive()`.
    Drop a reference to an archive.

    When the last reference is dropped, this closes and releases
    any memory or filehandles associated with the archive.
    """
    return _mupdf.ll_fz_drop_archive(arch)

def ll_fz_drop_band_writer(writer):
    r"""
    Low-level wrapper for `::fz_drop_band_writer()`.
    Drop the reference to the band writer, causing it to be
    destroyed.

    Never throws an exception.
    """
    return _mupdf.ll_fz_drop_band_writer(writer)

def ll_fz_drop_bitmap(bit):
    r"""
    Low-level wrapper for `::fz_drop_bitmap()`.
    Drop a reference to the bitmap. When the reference count reaches
    zero, the bitmap will be destroyed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_bitmap(bit)

def ll_fz_drop_buffer(buf):
    r"""
    Low-level wrapper for `::fz_drop_buffer()`.
    Drop a reference to the buffer. When the reference count reaches
    zero, the buffer is destroyed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_buffer(buf)

def ll_fz_drop_colorspace(colorspace):
    r"""
    Low-level wrapper for `::fz_drop_colorspace()`.
    Drops a reference to the colorspace.

    When the reference count reaches zero, the colorspace is
    destroyed.
    """
    return _mupdf.ll_fz_drop_colorspace(colorspace)

def ll_fz_drop_colorspace_imp(cs_):
    r"""Low-level wrapper for `::fz_drop_colorspace_imp()`."""
    return _mupdf.ll_fz_drop_colorspace_imp(cs_)

def ll_fz_drop_compressed_buffer(buf):
    r"""
    Low-level wrapper for `::fz_drop_compressed_buffer()`.
    Drop a reference to a compressed buffer. Destroys the buffer
    and frees any storage/other references held by it.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_compressed_buffer(buf)

def ll_fz_drop_context():
    r"""
    Low-level wrapper for `::fz_drop_context()`.
    Free a context and its global state.

    The context and all of its global state is freed, and any
    buffered warnings are flushed (see fz_flush_warnings). If NULL
    is passed in nothing will happen.

    Must not be called for a context that is being used in an active
    fz_try(), fz_always() or fz_catch() block.
    """
    return _mupdf.ll_fz_drop_context()

def ll_fz_drop_default_colorspaces(default_cs):
    r"""
    Low-level wrapper for `::fz_drop_default_colorspaces()`.
    Drop a reference to the default colorspaces structure. When the
    reference count reaches 0, the references it holds internally
    to the underlying colorspaces will be dropped, and the structure
    will be destroyed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_default_colorspaces(default_cs)

def ll_fz_drop_device(dev):
    r"""
    Low-level wrapper for `::fz_drop_device()`.
    Reduce the reference count on a device. When the reference count
    reaches zero, the device and its resources will be freed.
    Don't forget to call fz_close_device before dropping the device,
    or you may get incomplete output!

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_device(dev)

def ll_fz_drop_display_list(list):
    r"""
    Low-level wrapper for `::fz_drop_display_list()`.
    Decrement the reference count for a display list. When the
    reference count reaches zero, all the references in the display
    list itself are dropped, and the display list is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_display_list(list)

def ll_fz_drop_document(doc):
    r"""
    Low-level wrapper for `::fz_drop_document()`.
    Decrement the document reference count. When the reference
    count reaches 0, the document and all it's references are
    freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_document(doc)

def ll_fz_drop_document_writer(wri):
    r"""
    Low-level wrapper for `::fz_drop_document_writer()`.
    Called to discard a fz_document_writer.
    This may be called at any time during the process to release all
    the resources owned by the writer.

    Calling drop without having previously called close may leave
    the file in an inconsistent state.
    """
    return _mupdf.ll_fz_drop_document_writer(wri)

def ll_fz_drop_font(font):
    r"""
    Low-level wrapper for `::fz_drop_font()`.
    Drop a reference to a fz_font, destroying the
    font when the last reference is dropped.

    font: The font to drop a reference to.
    """
    return _mupdf.ll_fz_drop_font(font)

def ll_fz_drop_function(func):
    r"""Low-level wrapper for `::fz_drop_function()`."""
    return _mupdf.ll_fz_drop_function(func)

def ll_fz_drop_glyph(pix):
    r"""
    Low-level wrapper for `::fz_drop_glyph()`.
    Drop a reference and free a glyph.

    Decrement the reference count for the glyph. When no
    references remain the glyph will be freed.
    """
    return _mupdf.ll_fz_drop_glyph(pix)

def ll_fz_drop_halftone(ht):
    r"""
    Low-level wrapper for `::fz_drop_halftone()`.
    Drop a reference to the halftone. When the reference count
    reaches zero, the halftone is destroyed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_halftone(ht)

def ll_fz_drop_hash_table(table):
    r"""
    Low-level wrapper for `::fz_drop_hash_table()`.
    Destroy the hash table.

    Values are dropped using the drop function.
    """
    return _mupdf.ll_fz_drop_hash_table(table)

def ll_fz_drop_image(image):
    r"""
    Low-level wrapper for `::fz_drop_image()`.
    Decrement the (normal) reference count for an image. When the
    total (normal + key) reference count reaches zero, the image and
    its resources are freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_image(image)

def ll_fz_drop_image_base(image):
    r"""
    Low-level wrapper for `::fz_drop_image_base()`.
    Internal destructor for the base image class members.

    Exposed to allow derived image classes to be written.
    """
    return _mupdf.ll_fz_drop_image_base(image)

def ll_fz_drop_image_imp(image):
    r"""
    Low-level wrapper for `::fz_drop_image_imp()`.
    Internal destructor exposed for fz_store integration.
    """
    return _mupdf.ll_fz_drop_image_imp(image)

def ll_fz_drop_image_store_key(image):
    r"""
    Low-level wrapper for `::fz_drop_image_store_key()`.
    Decrement the store key reference count for an image. When the
    total (normal + key) reference count reaches zero, the image and
    its resources are freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_image_store_key(image)

def ll_fz_drop_imp(p, refs):
    r"""
     Low-level wrapper for `::fz_drop_imp()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_drop_imp(void *p)` => `(int, int refs)`
    """
    return _mupdf.ll_fz_drop_imp(p, refs)

def ll_fz_drop_imp16(p, refs):
    r"""
     Low-level wrapper for `::fz_drop_imp16()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_drop_imp16(void *p)` => `(int, int16_t refs)`
    """
    return _mupdf.ll_fz_drop_imp16(p, refs)

def ll_fz_drop_imp8(p, refs):
    r"""Low-level wrapper for `::fz_drop_imp8()`."""
    return _mupdf.ll_fz_drop_imp8(p, refs)

def ll_fz_drop_jbig2_globals(globals):
    r"""
    Low-level wrapper for `::fz_drop_jbig2_globals()`.
    Decrement the reference count for a jbig2 globals record.
    When the reference count hits zero, the record is freed.

    Never throws an exception.
    """
    return _mupdf.ll_fz_drop_jbig2_globals(globals)

def ll_fz_drop_jbig2_globals_imp(globals):
    r"""
    Low-level wrapper for `::fz_drop_jbig2_globals_imp()`.
    Special jbig2 globals drop function for use in implementing
    store support.
    """
    return _mupdf.ll_fz_drop_jbig2_globals_imp(globals)

def ll_fz_drop_key_storable(arg_1):
    r"""
    Low-level wrapper for `::fz_drop_key_storable()`.
    Decrement the (normal) reference count for a storable object.
    When the total reference count hits zero, the drop function for
    that object is called to free the object.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_key_storable(arg_1)

def ll_fz_drop_key_storable_key(arg_1):
    r"""
    Low-level wrapper for `::fz_drop_key_storable_key()`.
    Decrement the (key) reference count for a storable object.
    When the total reference count hits zero, the drop function for
    that object is called to free the object.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_key_storable_key(arg_1)

def ll_fz_drop_layout(block):
    r"""
    Low-level wrapper for `::fz_drop_layout()`.
    Drop layout block. Free the pool, and linked blocks.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_layout(block)

def ll_fz_drop_link(link):
    r"""
    Low-level wrapper for `::fz_drop_link()`.
    Decrement the reference count for a link. When the reference
    count reaches zero, the link is destroyed.

    When a link is freed, the reference for any linked link (next)
    is dropped too, thus an entire linked list of fz_link's can be
    freed by just dropping the head.
    """
    return _mupdf.ll_fz_drop_link(link)

def ll_fz_drop_outline(outline):
    r"""
    Low-level wrapper for `::fz_drop_outline()`.
    Decrements the reference count. When the reference point
    reaches zero, the outline is freed.

    When freed, it will drop linked	outline entries (next and down)
    too, thus a whole outline structure can be dropped by dropping
    the top entry.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_outline(outline)

def ll_fz_drop_outline_iterator(iter):
    r"""
    Low-level wrapper for `::fz_drop_outline_iterator()`.
    Drop the current iterator.
    """
    return _mupdf.ll_fz_drop_outline_iterator(iter)

def ll_fz_drop_output(arg_1):
    r"""
    Low-level wrapper for `::fz_drop_output()`.
    Free an output stream. Don't forget to close it first!
    """
    return _mupdf.ll_fz_drop_output(arg_1)

def ll_fz_drop_page(page):
    r"""
    Low-level wrapper for `::fz_drop_page()`.
    Decrements the reference count for the page. When the reference
    count hits 0, the page and its references are freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_page(page)

def ll_fz_drop_path(path):
    r"""
    Low-level wrapper for `::fz_drop_path()`.
    Decrement the reference count. When the reference count hits
    zero, free the path.

    All paths can be dropped, regardless of their packing type.
    Packed paths do not own the blocks into which they are packed
    so dropping them does not free those blocks.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_path(path)

def ll_fz_drop_pixmap(pix):
    r"""
    Low-level wrapper for `::fz_drop_pixmap()`.
    Decrement the reference count for the pixmap. When the
    reference count hits 0, the pixmap is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_pixmap(pix)

def ll_fz_drop_pool(pool):
    r"""
    Low-level wrapper for `::fz_drop_pool()`.
    Drop a pool, freeing and invalidating all storage returned from
    the pool.
    """
    return _mupdf.ll_fz_drop_pool(pool)

def ll_fz_drop_separations(sep):
    r"""
    Low-level wrapper for `::fz_drop_separations()`.
    Decrement the reference count for a separations structure.
    When the reference count hits zero, the separations structure
    is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_separations(sep)

def ll_fz_drop_shade(shade):
    r"""
    Low-level wrapper for `::fz_drop_shade()`.
    Decrement the reference count for the shade structure. When
    the reference count hits zero, the structure is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_shade(shade)

def ll_fz_drop_shade_color_cache(cache):
    r"""Low-level wrapper for `::fz_drop_shade_color_cache()`."""
    return _mupdf.ll_fz_drop_shade_color_cache(cache)

def ll_fz_drop_shade_imp(shade):
    r"""
    Low-level wrapper for `::fz_drop_shade_imp()`.
    Internal function to destroy a
    shade. Only exposed for use with the fz_store.

    shade: The reference to destroy.
    """
    return _mupdf.ll_fz_drop_shade_imp(shade)

def ll_fz_drop_stext_page(page):
    r"""Low-level wrapper for `::fz_drop_stext_page()`."""
    return _mupdf.ll_fz_drop_stext_page(page)

def ll_fz_drop_storable(arg_1):
    r"""
    Low-level wrapper for `::fz_drop_storable()`.
    Decrement the reference count for a storable object. When the
    reference count hits zero, the drop function for that object
    is called to free the object.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_storable(arg_1)

def ll_fz_drop_store_context():
    r"""
    Low-level wrapper for `::fz_drop_store_context()`.
    Decrement the reference count for the store context. When the
    reference count hits zero, the store context is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_store_context()

def ll_fz_drop_story(story):
    r"""Low-level wrapper for `::fz_drop_story()`."""
    return _mupdf.ll_fz_drop_story(story)

def ll_fz_drop_stream(stm):
    r"""
    Low-level wrapper for `::fz_drop_stream()`.
    Decrements the reference count for a stream.

    When the reference count for the stream hits zero, frees the
    storage used for the fz_stream itself, and (usually)
    releases the underlying resources that the stream is based upon
    (depends on the method used to open the stream initially).
    """
    return _mupdf.ll_fz_drop_stream(stm)

def ll_fz_drop_string(str):
    r"""Low-level wrapper for `::fz_drop_string()`."""
    return _mupdf.ll_fz_drop_string(str)

def ll_fz_drop_stroke_state(stroke):
    r"""
    Low-level wrapper for `::fz_drop_stroke_state()`.
    Drop a reference to a stroke state structure, destroying the
    structure if it is the last reference.
    """
    return _mupdf.ll_fz_drop_stroke_state(stroke)

def ll_fz_drop_text(text):
    r"""
    Low-level wrapper for `::fz_drop_text()`.
    Decrement the reference count for the text object. When the
    reference count hits zero, the text object is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_text(text)

def ll_fz_drop_tree(node, dropfunc):
    r"""
    Low-level wrapper for `::fz_drop_tree()`.
    Drop the tree.

    The storage used by the tree is freed, and each value has
    dropfunc called on it.
    """
    return _mupdf.ll_fz_drop_tree(node, dropfunc)

def ll_fz_drop_xml(xml):
    r"""
    Low-level wrapper for `::fz_drop_xml()`.
    Drop a reference to the XML. When the last reference is
    dropped, the node and all its children and siblings will
    be freed.
    """
    return _mupdf.ll_fz_drop_xml(xml)

def ll_fz_drop_zip_writer(zip):
    r"""
    Low-level wrapper for `::fz_drop_zip_writer()`.
    Drop the reference to the zipfile.

    In common with other 'drop' methods, this will never throw an
    exception.
    """
    return _mupdf.ll_fz_drop_zip_writer(zip)

def ll_fz_dump_glyph_cache_stats(out):
    r"""
    Low-level wrapper for `::fz_dump_glyph_cache_stats()`.
    Dump debug statistics for the glyph cache.
    """
    return _mupdf.ll_fz_dump_glyph_cache_stats(out)

def ll_fz_duplicate_glyph_names_from_unicode(unicode):
    r"""Low-level wrapper for `::fz_duplicate_glyph_names_from_unicode()`."""
    return _mupdf.ll_fz_duplicate_glyph_names_from_unicode(unicode)

def ll_fz_empty_store():
    r"""
    Low-level wrapper for `::fz_empty_store()`.
    Evict every item from the store.
    """
    return _mupdf.ll_fz_empty_store()

def ll_fz_enable_device_hints(dev, hints):
    r"""
    Low-level wrapper for `::fz_enable_device_hints()`.
    Enable (set) hint bits within the hint bitfield for a device.
    """
    return _mupdf.ll_fz_enable_device_hints(dev, hints)

def ll_fz_enable_icc():
    r"""
    Low-level wrapper for `::fz_enable_icc()`.
    Enable icc profile based operation.
    """
    return _mupdf.ll_fz_enable_icc()

def ll_fz_encode_character(font, unicode):
    r"""
    Low-level wrapper for `::fz_encode_character()`.
    Find the glyph id for a given unicode
    character within a font.

    font: The font to look for the unicode character in.

    unicode: The unicode character to encode.

    Returns the glyph id for the given unicode value, or 0 if
    unknown.
    """
    return _mupdf.ll_fz_encode_character(font, unicode)

def ll_fz_encode_character_by_glyph_name(font, glyphname):
    r"""
    Low-level wrapper for `::fz_encode_character_by_glyph_name()`.
    Encode character.

    Either by direct lookup of glyphname within a font, or, failing
    that, by mapping glyphname to unicode and thence to the glyph
    index within the given font.

    Returns zero for type3 fonts.
    """
    return _mupdf.ll_fz_encode_character_by_glyph_name(font, glyphname)

def ll_fz_encode_character_sc(font, unicode):
    r"""
    Low-level wrapper for `::fz_encode_character_sc()`.
    Encode character, preferring small-caps variant if available.

    font: The font to look for the unicode character in.

    unicode: The unicode character to encode.

    Returns the glyph id for the given unicode value, or 0 if
    unknown.
    """
    return _mupdf.ll_fz_encode_character_sc(font, unicode)

def ll_fz_encode_character_with_fallback(font, unicode, script, language, out_font):
    r"""
     Low-level wrapper for `::fz_encode_character_with_fallback()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_encode_character_with_fallback(::fz_font *font, int unicode, int script, int language, ::fz_font **out_font)` => `(int)`

    	Find the glyph id for
    	a given unicode character within a font, falling back to
    	an alternative if not found.

    	font: The font to look for the unicode character in.

    	unicode: The unicode character to encode.

    	script: The script in use.

    	language: The language in use.

    	out_font: The font handle in which the given glyph represents
    	the requested unicode character. The caller does not own the
    	reference it is passed, so should call fz_keep_font if it is
    	not simply to be used immediately.

    	Returns the glyph id for the given unicode value in the supplied
    	font (and sets *out_font to font) if it is present. Otherwise
    	an alternative fallback font (based on script/language) is
    	searched for. If the glyph is found therein, *out_font is set
    	to this reference, and the glyph reference is returned. If it
    	cannot be found anywhere, the function returns 0.
    """
    return _mupdf.ll_fz_encode_character_with_fallback(font, unicode, script, language, out_font)

def ll_fz_encode_uri(s):
    r"""
     Low-level wrapper for `::fz_encode_uri()`.
    Return a new string representing the provided string encoded as a URI.
    """
    return _mupdf.ll_fz_encode_uri(s)

def ll_fz_encode_uri_component(s):
    r"""
     Low-level wrapper for `::fz_encode_uri_component()`.
    Return a new string representing the provided string encoded as an URI component.
    This also encodes the special reserved characters (; / ? : @ & = + $ , #).
    """
    return _mupdf.ll_fz_encode_uri_component(s)

def ll_fz_encode_uri_pathname(s):
    r"""
     Low-level wrapper for `::fz_encode_uri_pathname()`.
    Return a new string representing the provided string encoded as an URI path name.
    This also encodes the special reserved characters except /.
    """
    return _mupdf.ll_fz_encode_uri_pathname(s)

def ll_fz_end_group(dev):
    r"""Low-level wrapper for `::fz_end_group()`."""
    return _mupdf.ll_fz_end_group(dev)

def ll_fz_end_layer(dev):
    r"""Low-level wrapper for `::fz_end_layer()`."""
    return _mupdf.ll_fz_end_layer(dev)

def ll_fz_end_mask(dev):
    r"""Low-level wrapper for `::fz_end_mask()`."""
    return _mupdf.ll_fz_end_mask(dev)

def ll_fz_end_mask_tr(dev, fn):
    r"""Low-level wrapper for `::fz_end_mask_tr()`."""
    return _mupdf.ll_fz_end_mask_tr(dev, fn)

def ll_fz_end_metatext(dev):
    r"""Low-level wrapper for `::fz_end_metatext()`."""
    return _mupdf.ll_fz_end_metatext(dev)

def ll_fz_end_page(wri):
    r"""
    Low-level wrapper for `::fz_end_page()`.
    Called to end the process of writing a page to a
    document.
    """
    return _mupdf.ll_fz_end_page(wri)

def ll_fz_end_structure(dev):
    r"""Low-level wrapper for `::fz_end_structure()`."""
    return _mupdf.ll_fz_end_structure(dev)

def ll_fz_end_throw_on_repair():
    r"""Low-level wrapper for `::fz_end_throw_on_repair()`."""
    return _mupdf.ll_fz_end_throw_on_repair()

def ll_fz_end_tile(dev):
    r"""Low-level wrapper for `::fz_end_tile()`."""
    return _mupdf.ll_fz_end_tile(dev)

def ll_fz_enumerate_font_cmap(font, cb, opaque):
    r"""
    Low-level wrapper for `::fz_enumerate_font_cmap()`.
    Enumerate a cmap using a callback.
    """
    return _mupdf.ll_fz_enumerate_font_cmap(font, cb, opaque)

def ll_fz_enumerate_font_cmap2(font):
    r"""Low-level wrapper for `::fz_enumerate_font_cmap2()`.  SWIG-friendly wrapper for fz_enumerate_font_cmap()."""
    return _mupdf.ll_fz_enumerate_font_cmap2(font)

def ll_fz_error_callback(user):
    r"""
     Low-level wrapper for `::fz_error_callback()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_error_callback()` => `(fz_error_cb *, void *user)`

    	Retrieve the currently set error callback, or NULL if none
    	has been set. Optionally, if user is non-NULL, the user pointer
    	given when the warning callback was set is also passed back to
    	the caller.
    """
    return _mupdf.ll_fz_error_callback(user)

def ll_fz_eval_function(func, _in, inlen, out, outlen):
    r"""
     Low-level wrapper for `::fz_eval_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_eval_function(::fz_function *func, const float *in, int inlen, int outlen)` => float out
    """
    return _mupdf.ll_fz_eval_function(func, _in, inlen, out, outlen)

def ll_fz_expand_irect(a, expand):
    r"""Low-level wrapper for `::fz_expand_irect()`."""
    return _mupdf.ll_fz_expand_irect(a, expand)

def ll_fz_expand_rect(b, expand):
    r"""
    Low-level wrapper for `::fz_expand_rect()`.
    Expand a bbox by a given amount in all directions.
    """
    return _mupdf.ll_fz_expand_rect(b, expand)

def ll_fz_extract_ttf_from_ttc(font):
    r"""Low-level wrapper for `::fz_extract_ttf_from_ttc()`."""
    return _mupdf.ll_fz_extract_ttf_from_ttc(font)

def ll_fz_file_exists(path):
    r"""
    Low-level wrapper for `::fz_file_exists()`.
    Return true if the named file exists and is readable.
    """
    return _mupdf.ll_fz_file_exists(path)

def ll_fz_fill_image(dev, image, ctm, alpha, color_params):
    r"""Low-level wrapper for `::fz_fill_image()`."""
    return _mupdf.ll_fz_fill_image(dev, image, ctm, alpha, color_params)

def ll_fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params):
    r"""Low-level wrapper for `::fz_fill_image_mask()`."""
    return _mupdf.ll_fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params)

def ll_fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params):
    r"""
    Low-level wrapper for `::fz_fill_path()`.
    Device calls; graphics primitives and containers.
    """
    return _mupdf.ll_fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params)

def ll_fz_fill_pixmap_from_display_list(list, ctm, pix):
    r"""Low-level wrapper for `::fz_fill_pixmap_from_display_list()`."""
    return _mupdf.ll_fz_fill_pixmap_from_display_list(list, ctm, pix)

def ll_fz_fill_pixmap_with_color(pix, colorspace, color, color_params):
    r"""
     Low-level wrapper for `::fz_fill_pixmap_with_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_fill_pixmap_with_color(::fz_pixmap *pix, ::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color

    	Fill pixmap with solid color.
    """
    return _mupdf.ll_fz_fill_pixmap_with_color(pix, colorspace, color, color_params)

def ll_fz_fill_shade(dev, shade, ctm, alpha, color_params):
    r"""Low-level wrapper for `::fz_fill_shade()`."""
    return _mupdf.ll_fz_fill_shade(dev, shade, ctm, alpha, color_params)

def ll_fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params):
    r"""Low-level wrapper for `::fz_fill_text()`."""
    return _mupdf.ll_fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params)

def ll_fz_filter_store(fn, arg, type):
    r"""
    Low-level wrapper for `::fz_filter_store()`.
    Filter every element in the store with a matching type with the
    given function.

    If the function returns 1 for an element, drop the element.
    """
    return _mupdf.ll_fz_filter_store(fn, arg, type)

def ll_fz_find_item(drop, key, type):
    r"""
    Low-level wrapper for `::fz_find_item()`.
    Find an item within the store.

    drop: The function used to free the value (to ensure we get a
    value of the correct type).

    key: The key used to index the item.

    type: Functions used to manipulate the key.

    Returns NULL for not found, otherwise returns a pointer to the
    value indexed by key to which a reference has been taken.
    """
    return _mupdf.ll_fz_find_item(drop, key, type)

def ll_fz_flush_output(out):
    r"""
    Low-level wrapper for `::fz_flush_output()`.
    Flush unwritten data.
    """
    return _mupdf.ll_fz_flush_output(out)

def ll_fz_flush_warnings():
    r"""
    Low-level wrapper for `::fz_flush_warnings()`.
    Flush any repeated warnings.

    Repeated warnings are buffered, counted and eventually printed
    along with the number of repetitions. Call fz_flush_warnings
    to force printing of the latest buffered warning and the
    number of repetitions, for example to make sure that all
    warnings are printed before exiting an application.
    """
    return _mupdf.ll_fz_flush_warnings()

def ll_fz_font_ascender(font):
    r"""
    Low-level wrapper for `::fz_font_ascender()`.
    Retrieve font ascender in ems.
    """
    return _mupdf.ll_fz_font_ascender(font)

def ll_fz_font_bbox(font):
    r"""
    Low-level wrapper for `::fz_font_bbox()`.
    Retrieve the font bbox.

    font: The font to query.

    Returns the font bbox by value; it is valid only if
    fz_font_flags(font)->invalid_bbox is zero.
    """
    return _mupdf.ll_fz_font_bbox(font)

def ll_fz_font_descender(font):
    r"""
    Low-level wrapper for `::fz_font_descender()`.
    Retrieve font descender in ems.
    """
    return _mupdf.ll_fz_font_descender(font)

def ll_fz_font_digest(font, digest):
    r"""
    Low-level wrapper for `::fz_font_digest()`.
    Retrieve the MD5 digest for the font's data.
    """
    return _mupdf.ll_fz_font_digest(font, digest)

def ll_fz_font_flags(font):
    r"""
    Low-level wrapper for `::fz_font_flags()`.
    Retrieve a pointer to the font flags
    for a given font. These can then be updated as required.

    font: The font to query

    Returns a pointer to the flags structure (or NULL, if
    the font is NULL).
    """
    return _mupdf.ll_fz_font_flags(font)

def ll_fz_font_ft_face(font):
    r"""
    Low-level wrapper for `::fz_font_ft_face()`.
    Retrieve the FT_Face handle
    for the font.

    font: The font to query

    Returns the FT_Face handle for the font, or NULL
    if not a freetype handled font. (Cast to void *
    to avoid nasty header exposure).
    """
    return _mupdf.ll_fz_font_ft_face(font)

def ll_fz_font_is_bold(font):
    r"""
    Low-level wrapper for `::fz_font_is_bold()`.
    Query whether the font flags say that this font is bold.
    """
    return _mupdf.ll_fz_font_is_bold(font)

def ll_fz_font_is_italic(font):
    r"""
    Low-level wrapper for `::fz_font_is_italic()`.
    Query whether the font flags say that this font is italic.
    """
    return _mupdf.ll_fz_font_is_italic(font)

def ll_fz_font_is_monospaced(font):
    r"""
    Low-level wrapper for `::fz_font_is_monospaced()`.
    Query whether the font flags say that this font is monospaced.
    """
    return _mupdf.ll_fz_font_is_monospaced(font)

def ll_fz_font_is_serif(font):
    r"""
    Low-level wrapper for `::fz_font_is_serif()`.
    Query whether the font flags say that this font is serif.
    """
    return _mupdf.ll_fz_font_is_serif(font)

def ll_fz_font_name(font):
    r"""
    Low-level wrapper for `::fz_font_name()`.
    Retrieve a pointer to the name of the font.

    font: The font to query.

    Returns a pointer to an internal copy of the font name.
    Will never be NULL, but may be the empty string.
    """
    return _mupdf.ll_fz_font_name(font)

def ll_fz_font_shaper_data(font):
    r"""
    Low-level wrapper for `::fz_font_shaper_data()`.
    Retrieve a pointer to the shaper data
    structure for the given font.

    font: The font to query.

    Returns a pointer to the shaper data structure (or NULL if
    font is NULL).
    """
    return _mupdf.ll_fz_font_shaper_data(font)

def ll_fz_font_t3_procs(font):
    r"""
    Low-level wrapper for `::fz_font_t3_procs()`.
    Retrieve the Type3 procs
    for a font.

    font: The font to query

    Returns the t3_procs pointer. Will be NULL for a
    non type-3 font.
    """
    return _mupdf.ll_fz_font_t3_procs(font)

def ll_fz_format_double(fmt, value):
    r"""
     Low-level wrapper for `::fz_format_double()`.  Swig-friendly and typesafe way to do fz_snprintf(fmt, value). `fmt`
    must end with one of 'efg' otherwise we throw an exception.
    """
    return _mupdf.ll_fz_format_double(fmt, value)

def ll_fz_format_link_uri(doc, dest):
    r"""
    Low-level wrapper for `::fz_format_link_uri()`.
    Format an internal link to a page number, location, and possible viewing parameters,
    suitable for use with fz_create_link.

    Returns a newly allocated string that the caller must free.
    """
    return _mupdf.ll_fz_format_link_uri(doc, dest)

def ll_fz_format_output_path(path, size, fmt, page):
    r"""
    Low-level wrapper for `::fz_format_output_path()`.
    create output file name using a template.

    If the path contains %[0-9]*d, the first such pattern will be
    replaced with the page number. If the template does not contain
    such a pattern, the page number will be inserted before the
    filename extension. If the template does not have a filename
    extension, the page number will be added to the end.
    """
    return _mupdf.ll_fz_format_output_path(path, size, fmt, page)

def ll_fz_free(p):
    r"""
    Low-level wrapper for `::fz_free()`.
    Free a previously allocated block of memory.

    fz_free(ctx, NULL) does nothing.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_free(p)

def ll_fz_free_aligned(p):
    r"""
    Low-level wrapper for `::fz_free_aligned()`.
    fz_free equivalent, for blocks allocated via fz_malloc_aligned.
    """
    return _mupdf.ll_fz_free_aligned(p)

def ll_fz_ft_lock():
    r"""Low-level wrapper for `::fz_ft_lock()`."""
    return _mupdf.ll_fz_ft_lock()

def ll_fz_ft_lock_held():
    r"""Low-level wrapper for `::fz_ft_lock_held()`."""
    return _mupdf.ll_fz_ft_lock_held()

def ll_fz_ft_unlock():
    r"""Low-level wrapper for `::fz_ft_unlock()`."""
    return _mupdf.ll_fz_ft_unlock()

def ll_fz_function_size(func):
    r"""Low-level wrapper for `::fz_function_size()`."""
    return _mupdf.ll_fz_function_size(func)

def ll_fz_gamma_pixmap(pix, gamma):
    r"""
    Low-level wrapper for `::fz_gamma_pixmap()`.
    Apply gamma correction to a pixmap. All components
    of all pixels are modified (except alpha, which is unchanged).

    gamma: The gamma value to apply; 1.0 for no change.
    """
    return _mupdf.ll_fz_gamma_pixmap(pix, gamma)

def ll_fz_generate_transition(tpix, opix, npix, time, trans):
    r"""
    Low-level wrapper for `::fz_generate_transition()`.
    Generate a frame of a transition.

    tpix: Target pixmap
    opix: Old pixmap
    npix: New pixmap
    time: Position within the transition (0 to 256)
    trans: Transition details

    Returns 1 if successfully generated a frame.

    Note: Pixmaps must include alpha.
    """
    return _mupdf.ll_fz_generate_transition(tpix, opix, npix, time, trans)

def ll_fz_get_glyph_name(font, glyph, buf, size):
    r"""
    Low-level wrapper for `::fz_get_glyph_name()`.
    Find the name of a glyph

    font: The font to look for the glyph in.

    glyph: The glyph id to look for.

    buf: Pointer to a buffer for the name to be inserted into.

    size: The size of the buffer.

    If a font contains a name table, then the name of the glyph
    will be returned in the supplied buffer. Otherwise a name
    is synthesised. The name will be truncated to fit in
    the buffer.
    """
    return _mupdf.ll_fz_get_glyph_name(font, glyph, buf, size)

def ll_fz_get_glyph_name2(font, glyph):
    r"""
     Low-level wrapper for `::fz_get_glyph_name2()`.
    C++ alternative to fz_get_glyph_name() that returns information in a std::string.
    """
    return _mupdf.ll_fz_get_glyph_name2(font, glyph)

def ll_fz_get_pixmap_from_image(image, subarea, ctm, w, h):
    r"""
     Low-level wrapper for `::fz_get_pixmap_from_image()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_get_pixmap_from_image(::fz_image *image, const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`

    	Called to get a handle to a pixmap from an image.

    	image: The image to retrieve a pixmap from.

    	subarea: The subarea of the image that we actually care about
    	(or NULL to indicate the whole image).

    	ctm: Optional, unless subarea is given. If given, then on
    	entry this is the transform that will be applied to the complete
    	image. It should be updated on exit to the transform to apply to
    	the given subarea of the image. This is used to calculate the
    	desired width/height for subsampling.

    	w: If non-NULL, a pointer to an int to be updated on exit to the
    	width (in pixels) that the scaled output will cover.

    	h: If non-NULL, a pointer to an int to be updated on exit to the
    	height (in pixels) that the scaled output will cover.

    	Returns a non NULL kept pixmap pointer. May throw exceptions.
    """
    return _mupdf.ll_fz_get_pixmap_from_image(image, subarea, ctm, w, h)

def ll_fz_get_unscaled_pixmap_from_image(image):
    r"""
    Low-level wrapper for `::fz_get_unscaled_pixmap_from_image()`.
    Calls fz_get_pixmap_from_image() with ctm, subarea, w and h all set to NULL.
    """
    return _mupdf.ll_fz_get_unscaled_pixmap_from_image(image)

def ll_fz_getopt(nargc, nargv, ostr):
    r"""
     Low-level wrapper for `::fz_getopt()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_getopt(int nargc, const char *ostr)` => `(int, char *nargv)`

    	Identical to fz_getopt_long, but with a NULL longopts field, signifying no long
    	options.
    """
    return _mupdf.ll_fz_getopt(nargc, nargv, ostr)

def ll_fz_getopt_long(nargc, nargv, ostr, longopts):
    r"""
     Low-level wrapper for `::fz_getopt_long()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_getopt_long(int nargc, const char *ostr, const ::fz_getopt_long_options *longopts)` => `(int, char *nargv)`

    	Simple functions/variables for use in tools.

    	ostr = option string. Comprises single letter options, followed by : if there
    	is an argument to the option.

    	longopts: NULL (indicating no long options), or a pointer to an array of
    	longoptions, terminated by an entry with option == NULL.

    	In the event of matching a single char option, this function will normally
    	return the char. The exception to this is when the option requires an
    	argument and none is supplied; in this case we return ':'.

    	In the event of matching a long option, this function returns 0, with fz_optlong
    	set to point to the matching option.

    	A long option entry may be followed with : to indicate there is an argument to the
    	option. If the need for an argument is specified in this way, and no argument is
    	given, an error will be displayed and argument processing will stop. If an argument
    	is given, and the long option record contains a non-null flag pointer, then the code
    	will decode the argument and fill in that flag pointer. Specifically,
    	case-insensitive matches to 'yes', 'no', 'true' and 'false' will cause a value of 0
    	or 1 as appropriate to be written; failing this the arg will be interpreted as a
    	decimal integer using atoi.

    	A long option entry may be followed by an list of options (e.g. myoption=foo|bar|baz)
    	and the option will be passed to fz_opt_from_list. The return value of that will be
    	placed in fz_optitem. If the return value of that function is -1, then an error will
    	be displayed and argument processing will stop.

    	In the event of reaching the end of the arg list or '--', this function returns EOF.

    	In the event of failing to match anything, an error is printed, and we return '?'.

    	If an argument is expected for the option, then fz_optarg will be returned pointing
    	at the start of the argument. Examples of supported argument formats: '-r500', '-r 500',
    	'--resolution 500', '--resolution=500'.
    """
    return _mupdf.ll_fz_getopt_long(nargc, nargv, ostr, longopts)

def ll_fz_glyph_bbox(glyph):
    r"""
    Low-level wrapper for `::fz_glyph_bbox()`.
    Return the bounding box of the glyph in pixels.
    """
    return _mupdf.ll_fz_glyph_bbox(glyph)

def ll_fz_glyph_bbox_no_ctx(src):
    r"""Low-level wrapper for `::fz_glyph_bbox_no_ctx()`."""
    return _mupdf.ll_fz_glyph_bbox_no_ctx(src)

def ll_fz_glyph_cacheable(font, gid):
    r"""
    Low-level wrapper for `::fz_glyph_cacheable()`.
    Determine if a given glyph in a font
    is cacheable. Certain glyphs in a type 3 font cannot safely
    be cached, as their appearance depends on the enclosing
    graphic state.

    font: The font to look for the glyph in.

    gif: The glyph to query.

    Returns non-zero if cacheable, 0 if not.
    """
    return _mupdf.ll_fz_glyph_cacheable(font, gid)

def ll_fz_glyph_height(glyph):
    r"""
    Low-level wrapper for `::fz_glyph_height()`.
    Return the height of the glyph in pixels.
    """
    return _mupdf.ll_fz_glyph_height(glyph)

def ll_fz_glyph_name_from_unicode_sc(unicode):
    r"""Low-level wrapper for `::fz_glyph_name_from_unicode_sc()`."""
    return _mupdf.ll_fz_glyph_name_from_unicode_sc(unicode)

def ll_fz_glyph_width(glyph):
    r"""
    Low-level wrapper for `::fz_glyph_width()`.
    Return the width of the glyph in pixels.
    """
    return _mupdf.ll_fz_glyph_width(glyph)

def ll_fz_graphics_aa_level():
    r"""
    Low-level wrapper for `::fz_graphics_aa_level()`.
    Get the number of bits of antialiasing we are
    using for graphics. Between 0 and 8.
    """
    return _mupdf.ll_fz_graphics_aa_level()

def ll_fz_graphics_min_line_width():
    r"""
    Low-level wrapper for `::fz_graphics_min_line_width()`.
    Get the minimum line width to be
    used for stroked lines.

    min_line_width: The minimum line width to use (in pixels).
    """
    return _mupdf.ll_fz_graphics_min_line_width()

def ll_fz_gridfit_matrix(as_tiled, m):
    r"""
    Low-level wrapper for `::fz_gridfit_matrix()`.
    Grid fit a matrix.

    as_tiled = 0 => adjust the matrix so that the image of the unit
    square completely covers any pixel that was touched by the
    image of the unit square under the original matrix.

    as_tiled = 1 => adjust the matrix so that the corners of the
    image of the unit square align with the closest integer corner
    of the image of the unit square under the original matrix.
    """
    return _mupdf.ll_fz_gridfit_matrix(as_tiled, m)

def ll_fz_grisu(f, s, exp):
    r"""
     Low-level wrapper for `::fz_grisu()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_grisu(float f, char *s)` => `(int, int exp)`
    """
    return _mupdf.ll_fz_grisu(f, s, exp)

def ll_fz_grow_buffer(buf):
    r"""
    Low-level wrapper for `::fz_grow_buffer()`.
    Make some space within a buffer (i.e. ensure that
    capacity > size).
    """
    return _mupdf.ll_fz_grow_buffer(buf)

def ll_fz_has_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_has_archive_entry()`.
    Check if entry by given name exists.

    If named entry does not exist 0 will be returned, if it does
    exist 1 is returned.

    name: Entry name to look for, this must be an exact match to
    the entry name in the archive.
    """
    return _mupdf.ll_fz_has_archive_entry(arch, name)

def ll_fz_has_option(opts, key, val):
    r"""
     Low-level wrapper for `::fz_has_option()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_has_option(const char *opts, const char *key)` => `(int, const char *val)`

    	Look for a given option (key) in the opts string. Return 1 if
    	it has it, and update *val to point to the value within opts.
    """
    return _mupdf.ll_fz_has_option(opts, key, val)

def ll_fz_has_permission(doc, p):
    r"""
    Low-level wrapper for `::fz_has_permission()`.
    Check permission flags on document.
    """
    return _mupdf.ll_fz_has_permission(doc, p)

def ll_fz_hash_filter(table, state, callback):
    r"""
    Low-level wrapper for `::fz_hash_filter()`.
    Iterate over the entries in a hash table, removing all the ones where callback returns true.
    Does NOT free the value of the entry, so the caller is expected to take care of this.
    """
    return _mupdf.ll_fz_hash_filter(table, state, callback)

def ll_fz_hash_find(table, key):
    r"""
    Low-level wrapper for `::fz_hash_find()`.
    Search for a matching hash within the table, and return the
    associated value.
    """
    return _mupdf.ll_fz_hash_find(table, key)

def ll_fz_hash_for_each(table, state, callback):
    r"""
    Low-level wrapper for `::fz_hash_for_each()`.
    Iterate over the entries in a hash table.
    """
    return _mupdf.ll_fz_hash_for_each(table, state, callback)

def ll_fz_hash_insert(table, key, val):
    r"""
    Low-level wrapper for `::fz_hash_insert()`.
    Insert a new key/value pair into the hash table.

    If an existing entry with the same key is found, no change is
    made to the hash table, and a pointer to the existing value is
    returned.

    If no existing entry with the same key is found, ownership of
    val passes in, key is copied, and NULL is returned.
    """
    return _mupdf.ll_fz_hash_insert(table, key, val)

def ll_fz_hash_remove(table, key):
    r"""
    Low-level wrapper for `::fz_hash_remove()`.
    Remove the entry for a given key.

    The value is NOT freed, so the caller is expected to take care
    of this.
    """
    return _mupdf.ll_fz_hash_remove(table, key)

def ll_fz_hb_lock():
    r"""
    Low-level wrapper for `::fz_hb_lock()`.
    Lock against Harfbuzz being called
    simultaneously in several threads. This reuses
    FZ_LOCK_FREETYPE.
    """
    return _mupdf.ll_fz_hb_lock()

def ll_fz_hb_unlock():
    r"""
    Low-level wrapper for `::fz_hb_unlock()`.
    Unlock after a Harfbuzz call. This reuses
    FZ_LOCK_FREETYPE.
    """
    return _mupdf.ll_fz_hb_unlock()

def ll_fz_highlight_selection(page, a, b, quads, max_quads):
    r"""
    Low-level wrapper for `::fz_highlight_selection()`.
    Return a list of quads to highlight lines inside the selection
    points.
    """
    return _mupdf.ll_fz_highlight_selection(page, a, b, quads, max_quads)

def ll_fz_highlight_selection2(page, a, b, max_quads):
    r"""
     Low-level wrapper for `::fz_highlight_selection2()`.
    C++ alternative to fz_highlight_selection() that returns quads in a
    std::vector.
    """
    return _mupdf.ll_fz_highlight_selection2(page, a, b, max_quads)

def ll_fz_ignore_error():
    r"""Low-level wrapper for `::fz_ignore_error()`."""
    return _mupdf.ll_fz_ignore_error()

def ll_fz_ignore_text(dev, text, ctm):
    r"""Low-level wrapper for `::fz_ignore_text()`."""
    return _mupdf.ll_fz_ignore_text(dev, text, ctm)

def ll_fz_image_orientation(image):
    r"""
    Low-level wrapper for `::fz_image_orientation()`.
    Request the natural orientation of an image.

    This is for images (such as JPEG) that can contain internal
    specifications of rotation/flips. This is ignored by all the
    internal decode/rendering routines, but can be used by callers
    (such as the image document handler) to respect such
    specifications.

    The values used by MuPDF are as follows, with the equivalent
    Exif specifications given for information:

    0: Undefined
    1: 0 degree ccw rotation. (Exif = 1)
    2: 90 degree ccw rotation. (Exif = 8)
    3: 180 degree ccw rotation. (Exif = 3)
    4: 270 degree ccw rotation. (Exif = 6)
    5: flip on X. (Exif = 2)
    6: flip on X, then rotate ccw by 90 degrees. (Exif = 5)
    7: flip on X, then rotate ccw by 180 degrees. (Exif = 4)
    8: flip on X, then rotate ccw by 270 degrees. (Exif = 7)
    """
    return _mupdf.ll_fz_image_orientation(image)

def ll_fz_image_orientation_matrix(image):
    r"""Low-level wrapper for `::fz_image_orientation_matrix()`."""
    return _mupdf.ll_fz_image_orientation_matrix(image)

def ll_fz_image_resolution(image, xres, yres):
    r"""
     Low-level wrapper for `::fz_image_resolution()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_image_resolution(::fz_image *image)` => `(int xres, int yres)`

    	Request the natural resolution
    	of an image.

    	xres, yres: Pointers to ints to be updated with the
    	natural resolution of an image (or a sensible default
    	if not encoded).
    """
    return _mupdf.ll_fz_image_resolution(image, xres, yres)

def ll_fz_image_size(im):
    r"""
    Low-level wrapper for `::fz_image_size()`.
    Return the size of the storage used by an image.
    """
    return _mupdf.ll_fz_image_size(im)

def ll_fz_image_type_name(type):
    r"""
    Low-level wrapper for `::fz_image_type_name()`.
    Map from FZ_IMAGE_* value to string.

    The returned string is static and therefore must not be freed.
    """
    return _mupdf.ll_fz_image_type_name(type)

def ll_fz_include_point_in_rect(r, p):
    r"""
    Low-level wrapper for `::fz_include_point_in_rect()`.
    Expand a bbox to include a given point.
    To create a rectangle that encompasses a sequence of points, the
    rectangle must first be set to be the empty rectangle at one of
    the points before including the others.
    """
    return _mupdf.ll_fz_include_point_in_rect(r, p)

def ll_fz_init_text_decoder(dec, encoding):
    r"""Low-level wrapper for `::fz_init_text_decoder()`."""
    return _mupdf.ll_fz_init_text_decoder(dec, encoding)

def ll_fz_install_load_system_font_funcs(f, f_cjk, f_fallback):
    r"""
    Low-level wrapper for `::fz_install_load_system_font_funcs()`.
    Install functions to allow MuPDF to request fonts from the
    system.

    Only one set of hooks can be in use at a time.
    """
    return _mupdf.ll_fz_install_load_system_font_funcs(f, f_cjk, f_fallback)

def ll_fz_install_load_system_font_funcs2(args):
    r"""
     Low-level wrapper for `::fz_install_load_system_font_funcs2()`.
    Alternative to fz_install_load_system_font_funcs() that takes args in a
    struct, to allow use from Python/C# via Swig Directors.
    """
    return _mupdf.ll_fz_install_load_system_font_funcs2(args)

def ll_fz_int2_heap_insert(heap, v):
    r"""Low-level wrapper for `::fz_int2_heap_insert()`."""
    return _mupdf.ll_fz_int2_heap_insert(heap, v)

def ll_fz_int2_heap_sort(heap):
    r"""Low-level wrapper for `::fz_int2_heap_sort()`."""
    return _mupdf.ll_fz_int2_heap_sort(heap)

def ll_fz_int2_heap_uniq(heap):
    r"""Low-level wrapper for `::fz_int2_heap_uniq()`."""
    return _mupdf.ll_fz_int2_heap_uniq(heap)

def ll_fz_int_heap_insert(heap, v):
    r"""Low-level wrapper for `::fz_int_heap_insert()`."""
    return _mupdf.ll_fz_int_heap_insert(heap, v)

def ll_fz_int_heap_sort(heap):
    r"""Low-level wrapper for `::fz_int_heap_sort()`."""
    return _mupdf.ll_fz_int_heap_sort(heap)

def ll_fz_int_heap_uniq(heap):
    r"""Low-level wrapper for `::fz_int_heap_uniq()`."""
    return _mupdf.ll_fz_int_heap_uniq(heap)

def ll_fz_intersect_irect(a, b):
    r"""
    Low-level wrapper for `::fz_intersect_irect()`.
    Compute intersection of two bounding boxes.

    Similar to fz_intersect_rect but operates on two bounding
    boxes instead of two rectangles.
    """
    return _mupdf.ll_fz_intersect_irect(a, b)

def ll_fz_intersect_rect(a, b):
    r"""
    Low-level wrapper for `::fz_intersect_rect()`.
    Compute intersection of two rectangles.

    Given two rectangles, update the first to be the smallest
    axis-aligned rectangle that covers the area covered by both
    given rectangles. If either rectangle is empty then the
    intersection is also empty. If either rectangle is infinite
    then the intersection is simply the non-infinite rectangle.
    Should both rectangles be infinite, then the intersection is
    also infinite.
    """
    return _mupdf.ll_fz_intersect_rect(a, b)

def ll_fz_intptr_heap_insert(heap, v):
    r"""Low-level wrapper for `::fz_intptr_heap_insert()`."""
    return _mupdf.ll_fz_intptr_heap_insert(heap, v)

def ll_fz_intptr_heap_sort(heap):
    r"""Low-level wrapper for `::fz_intptr_heap_sort()`."""
    return _mupdf.ll_fz_intptr_heap_sort(heap)

def ll_fz_intptr_heap_uniq(heap):
    r"""Low-level wrapper for `::fz_intptr_heap_uniq()`."""
    return _mupdf.ll_fz_intptr_heap_uniq(heap)

def ll_fz_invert_bitmap(bmp):
    r"""
    Low-level wrapper for `::fz_invert_bitmap()`.
    Invert bitmap.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_invert_bitmap(bmp)

def ll_fz_invert_matrix(matrix):
    r"""
    Low-level wrapper for `::fz_invert_matrix()`.
    Create an inverse matrix.

    matrix: Matrix to invert. A degenerate matrix, where the
    determinant is equal to zero, can not be inverted and the
    original matrix is returned instead.

    Returns inverse.
    """
    return _mupdf.ll_fz_invert_matrix(matrix)

def ll_fz_invert_pixmap(pix):
    r"""
    Low-level wrapper for `::fz_invert_pixmap()`.
    Invert all the pixels in a pixmap. All components (process and
    spots) of all pixels are inverted (except alpha, which is
    unchanged).
    """
    return _mupdf.ll_fz_invert_pixmap(pix)

def ll_fz_invert_pixmap_alpha(pix):
    r"""
    Low-level wrapper for `::fz_invert_pixmap_alpha()`.
    Invert the alpha fo all the pixels in a pixmap.
    """
    return _mupdf.ll_fz_invert_pixmap_alpha(pix)

def ll_fz_invert_pixmap_luminance(pix):
    r"""
    Low-level wrapper for `::fz_invert_pixmap_luminance()`.
    Transform the pixels in a pixmap so that luminance of each
    pixel is inverted, and the chrominance remains unchanged (as
    much as accuracy allows).

    All components of all pixels are inverted (except alpha, which
    is unchanged). Only supports Grey and RGB bitmaps.
    """
    return _mupdf.ll_fz_invert_pixmap_luminance(pix)

def ll_fz_invert_pixmap_raw(pix):
    r"""
    Low-level wrapper for `::fz_invert_pixmap_raw()`.
    Invert all the pixels in a non-premultiplied pixmap in a
    very naive manner.
    """
    return _mupdf.ll_fz_invert_pixmap_raw(pix)

def ll_fz_invert_pixmap_rect(image, rect):
    r"""
    Low-level wrapper for `::fz_invert_pixmap_rect()`.
    Invert all the pixels in a given rectangle of a (premultiplied)
    pixmap. All components of all pixels in the rectangle are
    inverted (except alpha, which is unchanged).
    """
    return _mupdf.ll_fz_invert_pixmap_rect(image, rect)

def ll_fz_irect_from_rect(rect):
    r"""
    Low-level wrapper for `::fz_irect_from_rect()`.
    Convert a rect into the minimal bounding box
    that covers the rectangle.

    Coordinates in a bounding box are integers, so rounding of the
    rects coordinates takes place. The top left corner is rounded
    upwards and left while the bottom right corner is rounded
    downwards and to the right.
    """
    return _mupdf.ll_fz_irect_from_rect(rect)

def ll_fz_irect_height(r):
    r"""
    Low-level wrapper for `::fz_irect_height()`.
    Return the height of an irect. Invalid irects return 0.
    """
    return _mupdf.ll_fz_irect_height(r)

def ll_fz_irect_width(r):
    r"""
    Low-level wrapper for `::fz_irect_width()`.
    Return the width of an irect. Invalid irects return 0.
    """
    return _mupdf.ll_fz_irect_width(r)

def ll_fz_is_cfb_archive(file):
    r"""
    Low-level wrapper for `::fz_is_cfb_archive()`.
    Detect if stream object is a cfb archive.

    Assumes that the stream object is seekable.
    """
    return _mupdf.ll_fz_is_cfb_archive(file)

def ll_fz_is_directory(path):
    r"""
    Low-level wrapper for `::fz_is_directory()`.
    Determine if a given path is a directory.

    In the case of the path not existing, or having no access
    we will return 0.
    """
    return _mupdf.ll_fz_is_directory(path)

def ll_fz_is_document_reflowable(doc):
    r"""
    Low-level wrapper for `::fz_is_document_reflowable()`.
    Is the document reflowable.

    Returns 1 to indicate reflowable documents, otherwise 0.
    """
    return _mupdf.ll_fz_is_document_reflowable(doc)

def ll_fz_is_empty_irect(r):
    r"""Low-level wrapper for `::fz_is_empty_irect()`."""
    return _mupdf.ll_fz_is_empty_irect(r)

def ll_fz_is_empty_quad(q):
    r"""
    Low-level wrapper for `::fz_is_empty_quad()`.
    Is a quad empty?
    """
    return _mupdf.ll_fz_is_empty_quad(q)

def ll_fz_is_empty_rect(r):
    r"""
    Low-level wrapper for `::fz_is_empty_rect()`.
    Check if rectangle is empty.

    An empty rectangle is defined as one whose area is zero.
    All invalid rectangles are empty.
    """
    return _mupdf.ll_fz_is_empty_rect(r)

def ll_fz_is_eof(stm):
    r"""
    Low-level wrapper for `::fz_is_eof()`.
    Query if the stream has reached EOF (during normal bytewise
    reading).

    See fz_is_eof_bits for the equivalent function for bitwise
    reading.
    """
    return _mupdf.ll_fz_is_eof(stm)

def ll_fz_is_eof_bits(stm):
    r"""
    Low-level wrapper for `::fz_is_eof_bits()`.
    Query if the stream has reached EOF (during bitwise
    reading).

    See fz_is_eof for the equivalent function for bytewise
    reading.
    """
    return _mupdf.ll_fz_is_eof_bits(stm)

def ll_fz_is_external_link(uri):
    r"""
    Low-level wrapper for `::fz_is_external_link()`.
    Query whether a link is external to a document (determined by
    uri containing a ':', intended to match with '://' which
    separates the scheme from the scheme specific parts in URIs).
    """
    return _mupdf.ll_fz_is_external_link(uri)

def ll_fz_is_identity(m):
    r"""Low-level wrapper for `::fz_is_identity()`."""
    return _mupdf.ll_fz_is_identity(m)

def ll_fz_is_infinite_irect(r):
    r"""
    Low-level wrapper for `::fz_is_infinite_irect()`.
    Check if an integer rectangle
    is infinite.
    """
    return _mupdf.ll_fz_is_infinite_irect(r)

def ll_fz_is_infinite_quad(q):
    r"""
    Low-level wrapper for `::fz_is_infinite_quad()`.
    Is a quad infinite?
    """
    return _mupdf.ll_fz_is_infinite_quad(q)

def ll_fz_is_infinite_rect(r):
    r"""
    Low-level wrapper for `::fz_is_infinite_rect()`.
    Check if rectangle is infinite.
    """
    return _mupdf.ll_fz_is_infinite_rect(r)

def ll_fz_is_libarchive_archive(file):
    r"""
    Low-level wrapper for `::fz_is_libarchive_archive()`.
    Detect if stream object is an archive supported by libarchive.

    Assumes that the stream object is seekable.
    """
    return _mupdf.ll_fz_is_libarchive_archive(file)

def ll_fz_is_page_range(s):
    r"""
     Low-level wrapper for `::fz_is_page_range()`.
    	Check and parse string into page ranges:
    ,?(-?+|N)(-(-?+|N))?/
    """
    return _mupdf.ll_fz_is_page_range(s)

def ll_fz_is_pixmap_monochrome(pixmap):
    r"""
    Low-level wrapper for `::fz_is_pixmap_monochrome()`.
    Check if the pixmap is a 1-channel image containing samples with
    only values 0 and 255
    """
    return _mupdf.ll_fz_is_pixmap_monochrome(pixmap)

def ll_fz_is_point_inside_irect(x, y, r):
    r"""
    Low-level wrapper for `::fz_is_point_inside_irect()`.
    Inclusion test for irects. (Rect is assumed to be open, i.e.
    top right corner is not included).
    """
    return _mupdf.ll_fz_is_point_inside_irect(x, y, r)

def ll_fz_is_point_inside_quad(p, q):
    r"""
    Low-level wrapper for `::fz_is_point_inside_quad()`.
    Inclusion test for quads.
    """
    return _mupdf.ll_fz_is_point_inside_quad(p, q)

def ll_fz_is_point_inside_rect(p, r):
    r"""
    Low-level wrapper for `::fz_is_point_inside_rect()`.
    Inclusion test for rects. (Rect is assumed to be open, i.e.
    top right corner is not included).
    """
    return _mupdf.ll_fz_is_point_inside_rect(p, r)

def ll_fz_is_pow2(a):
    r"""Low-level wrapper for `::fz_is_pow2()`."""
    return _mupdf.ll_fz_is_pow2(a)

def ll_fz_is_quad_inside_quad(needle, haystack):
    r"""
    Low-level wrapper for `::fz_is_quad_inside_quad()`.
    Inclusion test for quad in quad.

    This may break down if quads are not 'well formed'.
    """
    return _mupdf.ll_fz_is_quad_inside_quad(needle, haystack)

def ll_fz_is_quad_intersecting_quad(a, b):
    r"""
    Low-level wrapper for `::fz_is_quad_intersecting_quad()`.
    Intersection test for quads.

    This may break down if quads are not 'well formed'.
    """
    return _mupdf.ll_fz_is_quad_intersecting_quad(a, b)

def ll_fz_is_rectilinear(m):
    r"""
    Low-level wrapper for `::fz_is_rectilinear()`.
    Check if a transformation is rectilinear.

    Rectilinear means that no shearing is present and that any
    rotations present are a multiple of 90 degrees. Usually this
    is used to make sure that axis-aligned rectangles before the
    transformation are still axis-aligned rectangles afterwards.
    """
    return _mupdf.ll_fz_is_rectilinear(m)

def ll_fz_is_tar_archive(file):
    r"""
    Low-level wrapper for `::fz_is_tar_archive()`.
    Detect if stream object is a tar archive.

    Assumes that the stream object is seekable.
    """
    return _mupdf.ll_fz_is_tar_archive(file)

def ll_fz_is_valid_blend_colorspace(cs):
    r"""
    Low-level wrapper for `::fz_is_valid_blend_colorspace()`.
    Check to see that a colorspace is appropriate to be used as
    a blending space (i.e. only grey, rgb or cmyk).
    """
    return _mupdf.ll_fz_is_valid_blend_colorspace(cs)

def ll_fz_is_valid_irect(r):
    r"""
    Low-level wrapper for `::fz_is_valid_irect()`.
    Check if an integer rectangle is valid.
    """
    return _mupdf.ll_fz_is_valid_irect(r)

def ll_fz_is_valid_quad(q):
    r"""
    Low-level wrapper for `::fz_is_valid_quad()`.
    Is a quad valid?
    """
    return _mupdf.ll_fz_is_valid_quad(q)

def ll_fz_is_valid_rect(r):
    r"""
    Low-level wrapper for `::fz_is_valid_rect()`.
    Check if rectangle is valid.
    """
    return _mupdf.ll_fz_is_valid_rect(r)

def ll_fz_is_zip_archive(file):
    r"""
    Low-level wrapper for `::fz_is_zip_archive()`.
    Detect if stream object is a zip archive.

    Assumes that the stream object is seekable.
    """
    return _mupdf.ll_fz_is_zip_archive(file)

def ll_fz_iso8859_1_from_unicode(u):
    r"""Low-level wrapper for `::fz_iso8859_1_from_unicode()`."""
    return _mupdf.ll_fz_iso8859_1_from_unicode(u)

def ll_fz_iso8859_7_from_unicode(u):
    r"""Low-level wrapper for `::fz_iso8859_7_from_unicode()`."""
    return _mupdf.ll_fz_iso8859_7_from_unicode(u)

def ll_fz_jbig2_globals_data(globals):
    r"""
    Low-level wrapper for `::fz_jbig2_globals_data()`.
    Return buffer containing jbig2 globals data stream.
    """
    return _mupdf.ll_fz_jbig2_globals_data(globals)

def ll_fz_keep_archive(arch):
    r"""
    Low-level wrapper for `::fz_keep_archive()`.
    Keep a reference to an archive.
    """
    return _mupdf.ll_fz_keep_archive(arch)

def ll_fz_keep_bitmap(bit):
    r"""
    Low-level wrapper for `::fz_keep_bitmap()`.
    Take an additional reference to the bitmap. The same pointer
    is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_bitmap(bit)

def ll_fz_keep_buffer(buf):
    r"""
    Low-level wrapper for `::fz_keep_buffer()`.
    Take an additional reference to the buffer. The same pointer
    is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_buffer(buf)

def ll_fz_keep_colorspace(colorspace):
    r"""
    Low-level wrapper for `::fz_keep_colorspace()`.
    Increment the reference count for the colorspace.

    Returns the same pointer. Never throws an exception.
    """
    return _mupdf.ll_fz_keep_colorspace(colorspace)

def ll_fz_keep_compressed_buffer(cbuf):
    r"""
    Low-level wrapper for `::fz_keep_compressed_buffer()`.
    Take a reference to an fz_compressed_buffer.
    """
    return _mupdf.ll_fz_keep_compressed_buffer(cbuf)

def ll_fz_keep_default_colorspaces(default_cs):
    r"""
    Low-level wrapper for `::fz_keep_default_colorspaces()`.
    Keep an additional reference to the default colorspaces
    structure.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_default_colorspaces(default_cs)

def ll_fz_keep_device(dev):
    r"""
    Low-level wrapper for `::fz_keep_device()`.
    Increment the reference count for a device. Returns the same
    pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_device(dev)

def ll_fz_keep_display_list(list):
    r"""
    Low-level wrapper for `::fz_keep_display_list()`.
    Increment the reference count for a display list. Returns the
    same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_display_list(list)

def ll_fz_keep_document(doc):
    r"""
    Low-level wrapper for `::fz_keep_document()`.
    Increment the document reference count. The same pointer is
    returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_document(doc)

def ll_fz_keep_font(font):
    r"""
    Low-level wrapper for `::fz_keep_font()`.
    Add a reference to an existing fz_font.

    font: The font to add a reference to.

    Returns the same font.
    """
    return _mupdf.ll_fz_keep_font(font)

def ll_fz_keep_function(func):
    r"""Low-level wrapper for `::fz_keep_function()`."""
    return _mupdf.ll_fz_keep_function(func)

def ll_fz_keep_glyph(pix):
    r"""
    Low-level wrapper for `::fz_keep_glyph()`.
    Take a reference to a glyph.

    pix: The glyph to increment the reference for.

    Returns pix.
    """
    return _mupdf.ll_fz_keep_glyph(pix)

def ll_fz_keep_halftone(half):
    r"""
    Low-level wrapper for `::fz_keep_halftone()`.
    Take an additional reference to the halftone. The same pointer
    is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_halftone(half)

def ll_fz_keep_image(image):
    r"""
    Low-level wrapper for `::fz_keep_image()`.
    Increment the (normal) reference count for an image. Returns the
    same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_image(image)

def ll_fz_keep_image_store_key(image):
    r"""
    Low-level wrapper for `::fz_keep_image_store_key()`.
    Increment the store key reference for an image. Returns the same
    pointer. (This is the count of references for an image held by
    keys in the image store).

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_image_store_key(image)

def ll_fz_keep_imp(p, refs):
    r"""
     Low-level wrapper for `::fz_keep_imp()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_keep_imp(void *p)` => `(void *, int refs)`
    """
    return _mupdf.ll_fz_keep_imp(p, refs)

def ll_fz_keep_imp16(p, refs):
    r"""
     Low-level wrapper for `::fz_keep_imp16()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_keep_imp16(void *p)` => `(void *, int16_t refs)`
    """
    return _mupdf.ll_fz_keep_imp16(p, refs)

def ll_fz_keep_imp8(p, refs):
    r"""Low-level wrapper for `::fz_keep_imp8()`."""
    return _mupdf.ll_fz_keep_imp8(p, refs)

def ll_fz_keep_imp8_locked(p, refs):
    r"""Low-level wrapper for `::fz_keep_imp8_locked()`."""
    return _mupdf.ll_fz_keep_imp8_locked(p, refs)

def ll_fz_keep_imp_locked(p, refs):
    r"""
     Low-level wrapper for `::fz_keep_imp_locked()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_keep_imp_locked(void *p)` => `(void *, int refs)`
    """
    return _mupdf.ll_fz_keep_imp_locked(p, refs)

def ll_fz_keep_jbig2_globals(globals):
    r"""
    Low-level wrapper for `::fz_keep_jbig2_globals()`.
    Increment the reference count for a jbig2 globals record.

    Never throws an exception.
    """
    return _mupdf.ll_fz_keep_jbig2_globals(globals)

def ll_fz_keep_key_storable(arg_1):
    r"""
    Low-level wrapper for `::fz_keep_key_storable()`.
    Increment the (normal) reference count for a key storable
    object. Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_key_storable(arg_1)

def ll_fz_keep_key_storable_key(arg_1):
    r"""
    Low-level wrapper for `::fz_keep_key_storable_key()`.
    Increment the (key) reference count for a key storable
    object. Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_key_storable_key(arg_1)

def ll_fz_keep_link(link):
    r"""
    Low-level wrapper for `::fz_keep_link()`.
    Increment the reference count for a link. The same pointer is
    returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_link(link)

def ll_fz_keep_outline(outline):
    r"""
    Low-level wrapper for `::fz_keep_outline()`.
    Increment the reference count. Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_outline(outline)

def ll_fz_keep_page(page):
    r"""
    Low-level wrapper for `::fz_keep_page()`.
    Increment the reference count for the page. Returns the same
    pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_page(page)

def ll_fz_keep_path(path):
    r"""
    Low-level wrapper for `::fz_keep_path()`.
    Increment the reference count. Returns the same pointer.

    All paths can be kept, regardless of their packing type.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_path(path)

def ll_fz_keep_pixmap(pix):
    r"""
    Low-level wrapper for `::fz_keep_pixmap()`.
    Increment the reference count for the pixmap. The same pointer
    is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_pixmap(pix)

def ll_fz_keep_separations(sep):
    r"""
    Low-level wrapper for `::fz_keep_separations()`.
    Increment the reference count for a separations structure.
    Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_separations(sep)

def ll_fz_keep_shade(shade):
    r"""
    Low-level wrapper for `::fz_keep_shade()`.
    Increment the reference count for the shade structure. The
    same pointer is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_shade(shade)

def ll_fz_keep_storable(arg_1):
    r"""
    Low-level wrapper for `::fz_keep_storable()`.
    Increment the reference count for a storable object.
    Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_storable(arg_1)

def ll_fz_keep_store_context():
    r"""
    Low-level wrapper for `::fz_keep_store_context()`.
    Increment the reference count for the store context. Returns
    the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_store_context()

def ll_fz_keep_stream(stm):
    r"""
    Low-level wrapper for `::fz_keep_stream()`.
    Increments the reference count for a stream. Returns the same
    pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_stream(stm)

def ll_fz_keep_string(str):
    r"""Low-level wrapper for `::fz_keep_string()`."""
    return _mupdf.ll_fz_keep_string(str)

def ll_fz_keep_stroke_state(stroke):
    r"""
    Low-level wrapper for `::fz_keep_stroke_state()`.
    Take an additional reference to a stroke state structure.

    No modifications should be carried out on a stroke
    state to which more than one reference is held, as
    this can cause race conditions.
    """
    return _mupdf.ll_fz_keep_stroke_state(stroke)

def ll_fz_keep_text(text):
    r"""
    Low-level wrapper for `::fz_keep_text()`.
    Increment the reference count for the text object. The same
    pointer is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_text(text)

def ll_fz_keep_xml(xml):
    r"""
    Low-level wrapper for `::fz_keep_xml()`.
    Add a reference to the XML.
    """
    return _mupdf.ll_fz_keep_xml(xml)

def ll_fz_koi8u_from_unicode(u):
    r"""Low-level wrapper for `::fz_koi8u_from_unicode()`."""
    return _mupdf.ll_fz_koi8u_from_unicode(u)

def ll_fz_last_page(doc):
    r"""
    Low-level wrapper for `::fz_last_page()`.
    Function to get the location for the last page in the document.
    Using this can be far more efficient in some cases than calling
    fz_count_pages and using the page number.
    """
    return _mupdf.ll_fz_last_page(doc)

def ll_fz_layout_document(doc, w, h, em):
    r"""
    Low-level wrapper for `::fz_layout_document()`.
    Layout reflowable document types.

    w, h: Page size in points.
    em: Default font size in points.
    """
    return _mupdf.ll_fz_layout_document(doc, w, h, em)

def ll_fz_lineto(path, x, y):
    r"""
    Low-level wrapper for `::fz_lineto()`.
    Append a 'lineto' command to an open path.

    path: The path to modify.

    x, y: The coordinate to line to.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_lineto(path, x, y)

def ll_fz_list_archive_entry(arch, idx):
    r"""
    Low-level wrapper for `::fz_list_archive_entry()`.
    Get listed name of entry position idx.

    idx: Must be a value >= 0 < return value from
    fz_count_archive_entries. If not in range NULL will be
    returned.

    May throw an exception if this type of archive cannot list the
    entries (such as a directory).
    """
    return _mupdf.ll_fz_list_archive_entry(arch, idx)

def ll_fz_load_bmp_subimage(buf, len, subimage):
    r"""Low-level wrapper for `::fz_load_bmp_subimage()`."""
    return _mupdf.ll_fz_load_bmp_subimage(buf, len, subimage)

def ll_fz_load_bmp_subimage_count(buf, len):
    r"""Low-level wrapper for `::fz_load_bmp_subimage_count()`."""
    return _mupdf.ll_fz_load_bmp_subimage_count(buf, len)

def ll_fz_load_chapter_page(doc, chapter, page):
    r"""
    Low-level wrapper for `::fz_load_chapter_page()`.
    Load a page.

    After fz_load_page is it possible to retrieve the size of the
    page using fz_bound_page, or to render the page using
    fz_run_page_*. Free the page by calling fz_drop_page.

    chapter: chapter number, 0 is the first chapter of the document.
    number: page number, 0 is the first page of the chapter.
    """
    return _mupdf.ll_fz_load_chapter_page(doc, chapter, page)

def ll_fz_load_fallback_font(script, language, serif, bold, italic):
    r"""
    Low-level wrapper for `::fz_load_fallback_font()`.
    Try to load a fallback font for the
    given combination of font attributes. Whether a font is
    present or not will depend on the configuration in which
    MuPDF is built.

    script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).

    language: The language desired (e.g. FZ_LANG_ja).

    serif: 1 if serif desired, 0 otherwise.

    bold: 1 if bold desired, 0 otherwise.

    italic: 1 if italic desired, 0 otherwise.

    Returns a new font handle, or NULL if not available.
    """
    return _mupdf.ll_fz_load_fallback_font(script, language, serif, bold, italic)

def ll_fz_load_jbig2_globals(buf):
    r"""
    Low-level wrapper for `::fz_load_jbig2_globals()`.
    Create a jbig2 globals record from a buffer.

    Immutable once created.
    """
    return _mupdf.ll_fz_load_jbig2_globals(buf)

def ll_fz_load_jbig2_subimage(buf, len, subimage):
    r"""Low-level wrapper for `::fz_load_jbig2_subimage()`."""
    return _mupdf.ll_fz_load_jbig2_subimage(buf, len, subimage)

def ll_fz_load_jbig2_subimage_count(buf, len):
    r"""Low-level wrapper for `::fz_load_jbig2_subimage_count()`."""
    return _mupdf.ll_fz_load_jbig2_subimage_count(buf, len)

def ll_fz_load_jpx(data, size, cs):
    r"""
    Low-level wrapper for `::fz_load_jpx()`.
    Exposed for PDF.
    """
    return _mupdf.ll_fz_load_jpx(data, size, cs)

def ll_fz_load_links(page):
    r"""
    Low-level wrapper for `::fz_load_links()`.
    Load the list of links for a page.

    Returns a linked list of all the links on the page, each with
    its clickable region and link destination. Each link is
    reference counted so drop and free the list of links by
    calling fz_drop_link on the pointer return from fz_load_links.

    page: Page obtained from fz_load_page.
    """
    return _mupdf.ll_fz_load_links(page)

def ll_fz_load_outline(doc):
    r"""
    Low-level wrapper for `::fz_load_outline()`.
    Load the hierarchical document outline.

    Should be freed by fz_drop_outline.
    """
    return _mupdf.ll_fz_load_outline(doc)

def ll_fz_load_outline_from_iterator(iter):
    r"""
    Low-level wrapper for `::fz_load_outline_from_iterator()`.
    Routine to implement the old Structure based API from an iterator.
    """
    return _mupdf.ll_fz_load_outline_from_iterator(iter)

def ll_fz_load_page(doc, number):
    r"""
    Low-level wrapper for `::fz_load_page()`.
    Load a given page number from a document. This may be much less
    efficient than loading by location (chapter+page) for some
    document types.
    """
    return _mupdf.ll_fz_load_page(doc, number)

def ll_fz_load_pnm_subimage(buf, len, subimage):
    r"""Low-level wrapper for `::fz_load_pnm_subimage()`."""
    return _mupdf.ll_fz_load_pnm_subimage(buf, len, subimage)

def ll_fz_load_pnm_subimage_count(buf, len):
    r"""Low-level wrapper for `::fz_load_pnm_subimage_count()`."""
    return _mupdf.ll_fz_load_pnm_subimage_count(buf, len)

def ll_fz_load_system_cjk_font(name, ordering, serif):
    r"""
    Low-level wrapper for `::fz_load_system_cjk_font()`.
    Attempt to load a given font from
    the system.

    name: The name of the desired font.

    ordering: The ordering to load the font from (e.g. FZ_ADOBE_KOREA)

    serif: 1 if serif desired, 0 otherwise.

    Returns a new font handle, or NULL if no matching font was found
    (or on error).
    """
    return _mupdf.ll_fz_load_system_cjk_font(name, ordering, serif)

def ll_fz_load_system_font(name, bold, italic, needs_exact_metrics):
    r"""
    Low-level wrapper for `::fz_load_system_font()`.
    Attempt to load a given font from the system.

    name: The name of the desired font.

    bold: 1 if bold desired, 0 otherwise.

    italic: 1 if italic desired, 0 otherwise.

    needs_exact_metrics: 1 if an exact metrical match is required,
    0 otherwise.

    Returns a new font handle, or NULL if no matching font was found
    (or on error).
    """
    return _mupdf.ll_fz_load_system_font(name, bold, italic, needs_exact_metrics)

def ll_fz_load_tiff_subimage(buf, len, subimage):
    r"""Low-level wrapper for `::fz_load_tiff_subimage()`."""
    return _mupdf.ll_fz_load_tiff_subimage(buf, len, subimage)

def ll_fz_load_tiff_subimage_count(buf, len):
    r"""
    Low-level wrapper for `::fz_load_tiff_subimage_count()`.
    Exposed for CBZ.
    """
    return _mupdf.ll_fz_load_tiff_subimage_count(buf, len)

def ll_fz_load_user_css(filename):
    r"""
    Low-level wrapper for `::fz_load_user_css()`.
    Set the user stylesheet by loading the source from a file.
    If the file is missing, do nothing.
    """
    return _mupdf.ll_fz_load_user_css(filename)

def ll_fz_location_from_page_number(doc, number):
    r"""
    Low-level wrapper for `::fz_location_from_page_number()`.
    Converts from page number to chapter+page. This may cause many
    chapters to be laid out in order to calculate the number of
    pages within those chapters.
    """
    return _mupdf.ll_fz_location_from_page_number(doc, number)

def ll_fz_lock(lock):
    r"""
    Low-level wrapper for `::fz_lock()`.
    Lock one of the user supplied mutexes.
    """
    return _mupdf.ll_fz_lock(lock)

def ll_fz_log_error(str):
    r"""
    Low-level wrapper for `::fz_log_error()`.
    Log a (preformatted) string to the registered
    error stream (stderr by default).
    """
    return _mupdf.ll_fz_log_error(str)

def ll_fz_lookup_base14_font(name, len):
    r"""
     Low-level wrapper for `::fz_lookup_base14_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_base14_font(const char *name)` => `(const unsigned char *, int len)`

    	Search the builtin base14 fonts for a match.
    	Whether a given font is present or not will depend on the
    	configuration in which MuPDF is built.

    	name: The name of the font desired.

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_base14_font(name, len)

def ll_fz_lookup_blendmode(name):
    r"""
    Low-level wrapper for `::fz_lookup_blendmode()`.
    Map from (case sensitive) blend mode string to enumeration.
    """
    return _mupdf.ll_fz_lookup_blendmode(name)

def ll_fz_lookup_bookmark(doc, mark):
    r"""
    Low-level wrapper for `::fz_lookup_bookmark()`.
    Find a bookmark and return its page number.
    """
    return _mupdf.ll_fz_lookup_bookmark(doc, mark)

def ll_fz_lookup_builtin_font(name, bold, italic, len):
    r"""
     Low-level wrapper for `::fz_lookup_builtin_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_builtin_font(const char *name, int bold, int italic)` => `(const unsigned char *, int len)`

    	Search the builtin fonts for a match.
    	Whether a given font is present or not will depend on the
    	configuration in which MuPDF is built.

    	name: The name of the font desired.

    	bold: 1 if bold desired, 0 otherwise.

    	italic: 1 if italic desired, 0 otherwise.

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_builtin_font(name, bold, italic, len)

def ll_fz_lookup_cjk_font(ordering, len, index):
    r"""
     Low-level wrapper for `::fz_lookup_cjk_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_cjk_font(int ordering)` => `(const unsigned char *, int len, int index)`

    	Search the builtin cjk fonts for a match.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	ordering: The desired ordering of the font (e.g. FZ_ADOBE_KOREA).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_cjk_font(ordering, len, index)

def ll_fz_lookup_cjk_font_by_language(lang, len, subfont):
    r"""
     Low-level wrapper for `::fz_lookup_cjk_font_by_language()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_cjk_font_by_language(const char *lang)` => `(const unsigned char *, int len, int subfont)`

    	Search the builtin cjk fonts for a match for a given language.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	lang: Pointer to a (case sensitive) language string (e.g.
    	"ja", "ko", "zh-Hant" etc).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	subfont: Pointer to a place to store the subfont index of the
    	discovered font.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_cjk_font_by_language(lang, len, subfont)

def ll_fz_lookup_cjk_ordering_by_language(name):
    r"""
    Low-level wrapper for `::fz_lookup_cjk_ordering_by_language()`.
    Return the matching FZ_ADOBE_* ordering
    for the given language tag, such as "zh-Hant", "zh-Hans", "ja", or "ko".
    """
    return _mupdf.ll_fz_lookup_cjk_ordering_by_language(name)

def ll_fz_lookup_image_type(type):
    r"""
    Low-level wrapper for `::fz_lookup_image_type()`.
    Map from (case sensitive) image type string to FZ_IMAGE_*
    type value.
    """
    return _mupdf.ll_fz_lookup_image_type(type)

def ll_fz_lookup_metadata(doc, key, buf, size):
    r"""
    Low-level wrapper for `::fz_lookup_metadata()`.
    Retrieve document meta data strings.

    doc: The document to query.

    key: Which meta data key to retrieve...

    Basic information:
    	'format'	-- Document format and version.
    	'encryption'	-- Description of the encryption used.

    From the document information dictionary:
    	'info:Title'
    	'info:Author'
    	'info:Subject'
    	'info:Keywords'
    	'info:Creator'
    	'info:Producer'
    	'info:CreationDate'
    	'info:ModDate'

    buf: The buffer to hold the results (a nul-terminated UTF-8
    string).

    size: Size of 'buf'.

    Returns the number of bytes need to store the string plus terminator
    (will be larger than 'size' if the output was truncated), or -1 if the
    key is not recognized or found.
    """
    return _mupdf.ll_fz_lookup_metadata(doc, key, buf, size)

def ll_fz_lookup_metadata2(doc, key):
    r"""
     Low-level wrapper for `::fz_lookup_metadata2()`.
    C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
    or calls `fz_throw()` if not found.
    """
    return _mupdf.ll_fz_lookup_metadata2(doc, key)

def ll_fz_lookup_noto_boxes_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_boxes_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_boxes_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_boxes_font(len)

def ll_fz_lookup_noto_emoji_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_emoji_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_emoji_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_emoji_font(len)

def ll_fz_lookup_noto_font(script, lang, len, subfont):
    r"""
     Low-level wrapper for `::fz_lookup_noto_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_font(int script, int lang)` => `(const unsigned char *, int len, int subfont)`

    	Search the builtin noto fonts for a match.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).

    	lang: The language desired (e.g. FZ_LANG_ja).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_noto_font(script, lang, len, subfont)

def ll_fz_lookup_noto_math_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_math_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_math_font()` => `(const unsigned char *, int len)`

    	Search the builtin noto fonts specific symbol fonts.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.
    """
    return _mupdf.ll_fz_lookup_noto_math_font(len)

def ll_fz_lookup_noto_music_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_music_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_music_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_music_font(len)

def ll_fz_lookup_noto_stem_from_script(script, language):
    r"""
    Low-level wrapper for `::fz_lookup_noto_stem_from_script()`.
    Look up the Noto font file name for a given script.
    From the returned font stem, you can look for Noto fonts on the system in the form:
    	Noto(Sans|Serif)${STEM}-Regular.(otf|ttf)
    """
    return _mupdf.ll_fz_lookup_noto_stem_from_script(script, language)

def ll_fz_lookup_noto_symbol1_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_symbol1_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_symbol1_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_symbol1_font(len)

def ll_fz_lookup_noto_symbol2_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_symbol2_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_symbol2_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_symbol2_font(len)

def ll_fz_lookup_rendering_intent(name):
    r"""
    Low-level wrapper for `::fz_lookup_rendering_intent()`.
    Map from (case sensitive) rendering intent string to enumeration
    value.
    """
    return _mupdf.ll_fz_lookup_rendering_intent(name)

def ll_fz_make_bookmark(doc, loc):
    r"""
    Low-level wrapper for `::fz_make_bookmark()`.
    Create a bookmark for the given page, which can be used to find
    the same location after the document has been laid out with
    different parameters.
    """
    return _mupdf.ll_fz_make_bookmark(doc, loc)

def ll_fz_make_irect(x0, y0, x1, y1):
    r"""Low-level wrapper for `::fz_make_irect()`."""
    return _mupdf.ll_fz_make_irect(x0, y0, x1, y1)

def ll_fz_make_link_dest_none():
    r"""Low-level wrapper for `::fz_make_link_dest_none()`."""
    return _mupdf.ll_fz_make_link_dest_none()

def ll_fz_make_link_dest_xyz(chapter, page, x, y, z):
    r"""Low-level wrapper for `::fz_make_link_dest_xyz()`."""
    return _mupdf.ll_fz_make_link_dest_xyz(chapter, page, x, y, z)

def ll_fz_make_location(chapter, page):
    r"""
    Low-level wrapper for `::fz_make_location()`.
    Simple constructor for fz_locations.
    """
    return _mupdf.ll_fz_make_location(chapter, page)

def ll_fz_make_matrix(a, b, c, d, e, f):
    r"""Low-level wrapper for `::fz_make_matrix()`."""
    return _mupdf.ll_fz_make_matrix(a, b, c, d, e, f)

def ll_fz_make_point(x, y):
    r"""Low-level wrapper for `::fz_make_point()`."""
    return _mupdf.ll_fz_make_point(x, y)

def ll_fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y):
    r"""
    Low-level wrapper for `::fz_make_quad()`.
    Inline convenience construction function.
    """
    return _mupdf.ll_fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y)

def ll_fz_make_rect(x0, y0, x1, y1):
    r"""Low-level wrapper for `::fz_make_rect()`."""
    return _mupdf.ll_fz_make_rect(x0, y0, x1, y1)

def ll_fz_malloc(size):
    r"""
    Low-level wrapper for `::fz_malloc()`.
    Allocate uninitialized memory of a given size.
    Does NOT clear the memory!

    May return NULL for size = 0.

    Throws exception in the event of failure to allocate.
    """
    return _mupdf.ll_fz_malloc(size)

def ll_fz_malloc_aligned(size, align):
    r"""
    Low-level wrapper for `::fz_malloc_aligned()`.
    fz_malloc equivalent, except that the block is guaranteed aligned.
    Block must be freed later using fz_free_aligned.
    """
    return _mupdf.ll_fz_malloc_aligned(size, align)

def ll_fz_malloc_no_throw(size):
    r"""
    Low-level wrapper for `::fz_malloc_no_throw()`.
    fz_malloc equivalent that returns NULL rather than throwing
    exceptions.
    """
    return _mupdf.ll_fz_malloc_no_throw(size)

def ll_fz_matrix_expansion(m):
    r"""
    Low-level wrapper for `::fz_matrix_expansion()`.
    Calculate average scaling factor of matrix.
    """
    return _mupdf.ll_fz_matrix_expansion(m)

def ll_fz_matrix_max_expansion(m):
    r"""
    Low-level wrapper for `::fz_matrix_max_expansion()`.
    Find the largest expansion performed by this matrix.
    (i.e. max(abs(m.a),abs(m.b),abs(m.c),abs(m.d))
    """
    return _mupdf.ll_fz_matrix_max_expansion(m)

def ll_fz_max(a, b):
    r"""Low-level wrapper for `::fz_max()`."""
    return _mupdf.ll_fz_max(a, b)

def ll_fz_maxi(a, b):
    r"""Low-level wrapper for `::fz_maxi()`."""
    return _mupdf.ll_fz_maxi(a, b)

def ll_fz_maxi64(a, b):
    r"""Low-level wrapper for `::fz_maxi64()`."""
    return _mupdf.ll_fz_maxi64(a, b)

def ll_fz_maxz(a, b):
    r"""Low-level wrapper for `::fz_maxz()`."""
    return _mupdf.ll_fz_maxz(a, b)

def ll_fz_md5_buffer(buffer, digest):
    r"""
    Low-level wrapper for `::fz_md5_buffer()`.
    Create an MD5 digest from buffer contents.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_md5_buffer(buffer, digest)

def ll_fz_md5_final(state, digest):
    r"""
    Low-level wrapper for `::fz_md5_final()`.
    MD5 finalization. Ends an MD5 message-digest operation, writing
    the message digest and zeroizing the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_md5_final(state, digest)

def ll_fz_md5_final2(md5):
    r"""
     Low-level wrapper for `::fz_md5_final2()`.
    C++ alternative to fz_md5_final() that returns the digest by value.
    """
    return _mupdf.ll_fz_md5_final2(md5)

def ll_fz_md5_init(state):
    r"""
    Low-level wrapper for `::fz_md5_init()`.
    MD5 initialization. Begins an MD5 operation, writing a new
    context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_md5_init(state)

def ll_fz_md5_pixmap(pixmap, digest):
    r"""Low-level wrapper for `::fz_md5_pixmap()`."""
    return _mupdf.ll_fz_md5_pixmap(pixmap, digest)

def ll_fz_md5_pixmap2(pixmap):
    r"""
     Low-level wrapper for `::fz_md5_pixmap2()`.
    C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
    """
    return _mupdf.ll_fz_md5_pixmap2(pixmap)

def ll_fz_md5_update(state, input, inlen):
    r"""
    Low-level wrapper for `::fz_md5_update()`.
    MD5 block update operation. Continues an MD5 message-digest
    operation, processing another message block, and updating the
    context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_md5_update(state, input, inlen)

def ll_fz_md5_update_int64(state, i):
    r"""
    Low-level wrapper for `::fz_md5_update_int64()`.
    MD5 block update operation. Continues an MD5 message-digest
    operation, processing an int64, and updating the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_md5_update_int64(state, i)

def ll_fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language):
    r"""
    Low-level wrapper for `::fz_measure_string()`.
    Measure the advance width of a UTF8 string should it be added to a text object.

    This uses the same layout algorithms as fz_show_string, and can be used
    to calculate text alignment adjustments.
    """
    return _mupdf.ll_fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language)

def ll_fz_memmem(haystack, haystacklen, needle, needlelen):
    r"""
    Low-level wrapper for `::fz_memmem()`.
    Find the start of the first occurrence of the substring needle in haystack.
    """
    return _mupdf.ll_fz_memmem(haystack, haystacklen, needle, needlelen)

def ll_fz_memrnd(block, len):
    r"""
    Low-level wrapper for `::fz_memrnd()`.
    Fill block with len bytes of pseudo-randomness.
    """
    return _mupdf.ll_fz_memrnd(block, len)

def ll_fz_min(a, b):
    r"""Low-level wrapper for `::fz_min()`."""
    return _mupdf.ll_fz_min(a, b)

def ll_fz_mini(a, b):
    r"""Low-level wrapper for `::fz_mini()`."""
    return _mupdf.ll_fz_mini(a, b)

def ll_fz_mini64(a, b):
    r"""Low-level wrapper for `::fz_mini64()`."""
    return _mupdf.ll_fz_mini64(a, b)

def ll_fz_minz(a, b):
    r"""Low-level wrapper for `::fz_minz()`."""
    return _mupdf.ll_fz_minz(a, b)

def ll_fz_mkdir(path):
    r"""Low-level wrapper for `::fz_mkdir()`."""
    return _mupdf.ll_fz_mkdir(path)

def ll_fz_morph_error(fromcode, tocode):
    r"""
    Low-level wrapper for `::fz_morph_error()`.
    Called within a catch block this modifies the current
    exception's code. If it's of type 'fromcode' it is
    modified to 'tocode'. Typically used for 'downgrading'
    exception severity.
    """
    return _mupdf.ll_fz_morph_error(fromcode, tocode)

def ll_fz_mount_multi_archive(arch_, sub, path):
    r"""
    Low-level wrapper for `::fz_mount_multi_archive()`.
    Add an archive to the set of archives handled by a multi
    archive.

    If path is NULL, then the archive contents will appear at the
    top level, otherwise, the archives contents will appear prefixed
    by path.
    """
    return _mupdf.ll_fz_mount_multi_archive(arch_, sub, path)

def ll_fz_moveto(path, x, y):
    r"""
    Low-level wrapper for `::fz_moveto()`.
    Append a 'moveto' command to a path.
    This 'opens' a path.

    path: The path to modify.

    x, y: The coordinate to move to.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_moveto(path, x, y)

def ll_fz_mul255(a, b):
    r"""
    Low-level wrapper for `::fz_mul255()`.
    Multiply scaled two integers in the 0..255 range
    """
    return _mupdf.ll_fz_mul255(a, b)

def ll_fz_needs_password(doc):
    r"""
    Low-level wrapper for `::fz_needs_password()`.
    Check if a document is encrypted with a
    non-blank password.
    """
    return _mupdf.ll_fz_needs_password(doc)

def ll_fz_new_arc4_output(chain, key, keylen):
    r"""Low-level wrapper for `::fz_new_arc4_output()`."""
    return _mupdf.ll_fz_new_arc4_output(chain, key, keylen)

def ll_fz_new_archive_of_size(file, size):
    r"""Low-level wrapper for `::fz_new_archive_of_size()`."""
    return _mupdf.ll_fz_new_archive_of_size(file, size)

def ll_fz_new_ascii85_output(chain):
    r"""Low-level wrapper for `::fz_new_ascii85_output()`."""
    return _mupdf.ll_fz_new_ascii85_output(chain)

def ll_fz_new_asciihex_output(chain):
    r"""
    Low-level wrapper for `::fz_new_asciihex_output()`.
    Compression and other filtering outputs.

    These outputs write encoded data to another output. Create a
    filter output with the destination, write to the filter, then
    close and drop it when you're done. These can also be chained
    together, for example to write ASCII Hex encoded, Deflate
    compressed, and RC4 encrypted data to a buffer output.

    Output streams don't use reference counting, so make sure to
    close all of the filters in the reverse order of creation so
    that data is flushed properly.

    Accordingly, ownership of 'chain' is never passed into the
    following functions, but remains with the caller, whose
    responsibility it is to ensure they exist at least until
    the returned fz_output is dropped.
    """
    return _mupdf.ll_fz_new_asciihex_output(chain)

def ll_fz_new_band_writer_of_size(size, out):
    r"""Low-level wrapper for `::fz_new_band_writer_of_size()`."""
    return _mupdf.ll_fz_new_band_writer_of_size(size, out)

def ll_fz_new_base14_font(name):
    r"""
    Low-level wrapper for `::fz_new_base14_font()`.
    Create a new font from one of the built-in fonts.
    """
    return _mupdf.ll_fz_new_base14_font(name)

def ll_fz_new_bbox_device(rectp):
    r"""
    Low-level wrapper for `::fz_new_bbox_device()`.
    Create a device to compute the bounding
    box of all marks on a page.

    The returned bounding box will be the union of all bounding
    boxes of all objects on a page.
    """
    return _mupdf.ll_fz_new_bbox_device(rectp)

def ll_fz_new_bitmap(w, h, n, xres, yres):
    r"""
    Low-level wrapper for `::fz_new_bitmap()`.
    Create a new bitmap.

    w, h: Width and Height for the bitmap

    n: Number of color components (assumed to be a divisor of 8)

    xres, yres: X and Y resolutions (in pixels per inch).

    Returns pointer to created bitmap structure. The bitmap
    data is uninitialised.
    """
    return _mupdf.ll_fz_new_bitmap(w, h, n, xres, yres)

def ll_fz_new_bitmap_from_pixmap(pix, ht):
    r"""
    Low-level wrapper for `::fz_new_bitmap_from_pixmap()`.
    Make a bitmap from a pixmap and a halftone.

    pix: The pixmap to generate from. Currently must be a single
    color component with no alpha.

    ht: The halftone to use. NULL implies the default halftone.

    Returns the resultant bitmap. Throws exceptions in the case of
    failure to allocate.
    """
    return _mupdf.ll_fz_new_bitmap_from_pixmap(pix, ht)

def ll_fz_new_bitmap_from_pixmap_band(pix, ht, band_start):
    r"""
    Low-level wrapper for `::fz_new_bitmap_from_pixmap_band()`.
    Make a bitmap from a pixmap and a
    halftone, allowing for the position of the pixmap within an
    overall banded rendering.

    pix: The pixmap to generate from. Currently must be a single
    color component with no alpha.

    ht: The halftone to use. NULL implies the default halftone.

    band_start: Vertical offset within the overall banded rendering
    (in pixels)

    Returns the resultant bitmap. Throws exceptions in the case of
    failure to allocate.
    """
    return _mupdf.ll_fz_new_bitmap_from_pixmap_band(pix, ht, band_start)

def ll_fz_new_buffer(capacity):
    r"""Low-level wrapper for `::fz_new_buffer()`."""
    return _mupdf.ll_fz_new_buffer(capacity)

def ll_fz_new_buffer_from_base64(data, size):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_base64()`.
    Create a new buffer with data decoded from a base64 input string.
    """
    return _mupdf.ll_fz_new_buffer_from_base64(data, size)

def ll_fz_new_buffer_from_copied_data(data, size):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_copied_data()`.
    Create a new buffer containing a copy of the passed data.
    """
    return _mupdf.ll_fz_new_buffer_from_copied_data(data, size)

def ll_fz_new_buffer_from_data(data, size):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_data()`.
    Create a new buffer with existing data.

    data: Pointer to existing data.
    size: Size of existing data.

    Takes ownership of data. Does not make a copy. Calls fz_free on
    the data when the buffer is deallocated. Do not use 'data' after
    passing to this function.

    Returns pointer to new buffer. Throws exception on allocation
    failure.
    """
    return _mupdf.ll_fz_new_buffer_from_data(data, size)

def ll_fz_new_buffer_from_display_list(list, options):
    r"""Low-level wrapper for `::fz_new_buffer_from_display_list()`."""
    return _mupdf.ll_fz_new_buffer_from_display_list(list, options)

def ll_fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk):
    r"""Low-level wrapper for `::fz_new_buffer_from_image_as_jpeg()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk)

def ll_fz_new_buffer_from_image_as_jpx(image, color_params, quality):
    r"""Low-level wrapper for `::fz_new_buffer_from_image_as_jpx()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_jpx(image, color_params, quality)

def ll_fz_new_buffer_from_image_as_pam(image, color_params):
    r"""Low-level wrapper for `::fz_new_buffer_from_image_as_pam()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_pam(image, color_params)

def ll_fz_new_buffer_from_image_as_png(image, color_params):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_image_as_png()`.
    Reencode a given image as a PNG into a buffer.

    Ownership of the buffer is returned.
    """
    return _mupdf.ll_fz_new_buffer_from_image_as_png(image, color_params)

def ll_fz_new_buffer_from_image_as_pnm(image, color_params):
    r"""Low-level wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_pnm(image, color_params)

def ll_fz_new_buffer_from_image_as_psd(image, color_params):
    r"""Low-level wrapper for `::fz_new_buffer_from_image_as_psd()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_psd(image, color_params)

def ll_fz_new_buffer_from_page(page, options):
    r"""Low-level wrapper for `::fz_new_buffer_from_page()`."""
    return _mupdf.ll_fz_new_buffer_from_page(page, options)

def ll_fz_new_buffer_from_page_number(doc, number, options):
    r"""Low-level wrapper for `::fz_new_buffer_from_page_number()`."""
    return _mupdf.ll_fz_new_buffer_from_page_number(doc, number, options)

def ll_fz_new_buffer_from_page_with_format(page, format, options, transform, cookie):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_page_with_format()`.
    Returns an fz_buffer containing a page after conversion to specified format.

    page: The page to convert.
    format, options: Passed to fz_new_document_writer_with_output() internally.
    transform, cookie: Passed to fz_run_page() internally.
    """
    return _mupdf.ll_fz_new_buffer_from_page_with_format(page, format, options, transform, cookie)

def ll_fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk):
    r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk)

def ll_fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality):
    r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality)

def ll_fz_new_buffer_from_pixmap_as_pam(pixmap, color_params):
    r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_pam(pixmap, color_params)

def ll_fz_new_buffer_from_pixmap_as_png(pixmap, color_params):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_pixmap_as_png()`.
    Reencode a given pixmap as a PNG into a buffer.

    Ownership of the buffer is returned.
    """
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_png(pixmap, color_params)

def ll_fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params):
    r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params)

def ll_fz_new_buffer_from_pixmap_as_psd(pix, color_params):
    r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_psd(pix, color_params)

def ll_fz_new_buffer_from_shared_data(data, size):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_shared_data()`.
    Like fz_new_buffer, but does not take ownership.
    """
    return _mupdf.ll_fz_new_buffer_from_shared_data(data, size)

def ll_fz_new_buffer_from_stext_page(text):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_stext_page()`.
    Convert structured text into plain text.
    """
    return _mupdf.ll_fz_new_buffer_from_stext_page(text)

def ll_fz_new_builtin_font(name, is_bold, is_italic):
    r"""Low-level wrapper for `::fz_new_builtin_font()`."""
    return _mupdf.ll_fz_new_builtin_font(name, is_bold, is_italic)

def ll_fz_new_cal_gray_colorspace(wp, bp, gamma):
    r"""
    Low-level wrapper for `::fz_new_cal_gray_colorspace()`.
    Create a calibrated gray colorspace.

    The returned reference should be dropped when it is finished
    with.

    Colorspaces are immutable once created.
    """
    return _mupdf.ll_fz_new_cal_gray_colorspace(wp, bp, gamma)

def ll_fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix):
    r"""
    Low-level wrapper for `::fz_new_cal_rgb_colorspace()`.
    Create a calibrated rgb colorspace.

    The returned reference should be dropped when it is finished
    with.

    Colorspaces are immutable once created.
    """
    return _mupdf.ll_fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix)

def ll_fz_new_cbz_writer(path, options):
    r"""Low-level wrapper for `::fz_new_cbz_writer()`."""
    return _mupdf.ll_fz_new_cbz_writer(path, options)

def ll_fz_new_cbz_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_cbz_writer_with_output()`."""
    return _mupdf.ll_fz_new_cbz_writer_with_output(out, options)

def ll_fz_new_cjk_font(ordering):
    r"""Low-level wrapper for `::fz_new_cjk_font()`."""
    return _mupdf.ll_fz_new_cjk_font(ordering)

def ll_fz_new_color_pcl_band_writer(out, options):
    r"""
    Low-level wrapper for `::fz_new_color_pcl_band_writer()`.
    Create a new band writer, outputing color pcl.
    """
    return _mupdf.ll_fz_new_color_pcl_band_writer(out, options)

def ll_fz_new_colorspace(type, flags, n, name):
    r"""
    Low-level wrapper for `::fz_new_colorspace()`.
    Creates a new colorspace instance and returns a reference.

    No internal checking is done that the colorspace type (e.g.
    CMYK) matches with the flags (e.g. FZ_COLORSPACE_HAS_CMYK) or
    colorant count (n) or name.

    The reference should be dropped when it is finished with.

    Colorspaces are immutable once created (with the exception of
    setting up colorant names for separation spaces).
    """
    return _mupdf.ll_fz_new_colorspace(type, flags, n, name)

def ll_fz_new_compressed_buffer():
    r"""
    Low-level wrapper for `::fz_new_compressed_buffer()`.
    Create a new, UNKNOWN format, compressed_buffer.
    """
    return _mupdf.ll_fz_new_compressed_buffer()

def ll_fz_new_context_imp(alloc, locks, max_store, version):
    r"""Low-level wrapper for `::fz_new_context_imp()`."""
    return _mupdf.ll_fz_new_context_imp(alloc, locks, max_store, version)

def ll_fz_new_default_colorspaces():
    r"""
    Low-level wrapper for `::fz_new_default_colorspaces()`.
    Create a new default colorspace structure with values inherited
    from the context, and return a reference to it.

    These can be overridden using fz_set_default_xxxx.

    These should not be overridden while more than one caller has
    the reference for fear of race conditions.

    The caller should drop this reference once finished with it.
    """
    return _mupdf.ll_fz_new_default_colorspaces()

def ll_fz_new_deflate_output(chain, effort, raw):
    r"""Low-level wrapper for `::fz_new_deflate_output()`."""
    return _mupdf.ll_fz_new_deflate_output(chain, effort, raw)

def ll_fz_new_deflated_data(compressed_length, source, source_length, level):
    r"""
     Low-level wrapper for `::fz_new_deflated_data()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_deflated_data(const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`

    	Compress source_length bytes of data starting
    	at source, into a new memory block malloced for that purpose.
    compressed_length is updated on exit to contain the size used.
    	Ownership of the block is returned from this function, and the
    	caller is therefore responsible for freeing it. The block may be
    	considerably larger than is actually required. The caller is
    	free to fz_realloc it down if it wants to.
    """
    return _mupdf.ll_fz_new_deflated_data(compressed_length, source, source_length, level)

def ll_fz_new_deflated_data_from_buffer(compressed_length, buffer, level):
    r"""
     Low-level wrapper for `::fz_new_deflated_data_from_buffer()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_deflated_data_from_buffer(::fz_buffer *buffer, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`

    	Compress the contents of a fz_buffer into a
    	new block malloced for that purpose. *compressed_length is
    	updated on exit to contain the size used. Ownership of the block
    	is returned from this function, and the caller is therefore
    	responsible for freeing it. The block may be considerably larger
    	than is actually required. The caller is free to fz_realloc it
    	down if it wants to.
    """
    return _mupdf.ll_fz_new_deflated_data_from_buffer(compressed_length, buffer, level)

def ll_fz_new_device_of_size(size):
    r"""
    Low-level wrapper for `::fz_new_device_of_size()`.
    Devices are created by calls to device implementations, for
    instance: foo_new_device(). These will be implemented by calling
    fz_new_derived_device(ctx, foo_device) where foo_device is a
    structure "derived from" fz_device, for instance
    typedef struct { fz_device base;  ...extras...} foo_device;
    """
    return _mupdf.ll_fz_new_device_of_size(size)

def ll_fz_new_display_list(mediabox):
    r"""
    Low-level wrapper for `::fz_new_display_list()`.
    Create an empty display list.

    A display list contains drawing commands (text, images, etc.).
    Use fz_new_list_device for populating the list.

    mediabox: Bounds of the page (in points) represented by the
    display list.
    """
    return _mupdf.ll_fz_new_display_list(mediabox)

def ll_fz_new_display_list_from_page(page):
    r"""
    Low-level wrapper for `::fz_new_display_list_from_page()`.
    Create a display list.

    Ownership of the display list is returned to the caller.
    """
    return _mupdf.ll_fz_new_display_list_from_page(page)

def ll_fz_new_display_list_from_page_contents(page):
    r"""
    Low-level wrapper for `::fz_new_display_list_from_page_contents()`.
    Create a display list from page contents (no annotations).

    Ownership of the display list is returned to the caller.
    """
    return _mupdf.ll_fz_new_display_list_from_page_contents(page)

def ll_fz_new_display_list_from_page_number(doc, number):
    r"""Low-level wrapper for `::fz_new_display_list_from_page_number()`."""
    return _mupdf.ll_fz_new_display_list_from_page_number(doc, number)

def ll_fz_new_display_list_from_svg(buf, base_uri, dir, w, h):
    r"""
     Low-level wrapper for `::fz_new_display_list_from_svg()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_display_list_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

    	Parse an SVG document into a display-list.
    """
    return _mupdf.ll_fz_new_display_list_from_svg(buf, base_uri, dir, w, h)

def ll_fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h):
    r"""
     Low-level wrapper for `::fz_new_display_list_from_svg_xml()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_display_list_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

    	Parse an SVG document into a display-list.
    """
    return _mupdf.ll_fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h)

def ll_fz_new_document_of_size(size):
    r"""
    Low-level wrapper for `::fz_new_document_of_size()`.
    New documents are typically created by calls like
    foo_new_document(fz_context *ctx, ...). These work by
    deriving a new document type from fz_document, for instance:
    typedef struct { fz_document base; ...extras... } foo_document;
    These are allocated by calling
    fz_new_derived_document(ctx, foo_document)
    """
    return _mupdf.ll_fz_new_document_of_size(size)

def ll_fz_new_document_writer(path, format, options):
    r"""
    Low-level wrapper for `::fz_new_document_writer()`.
    Create a new fz_document_writer, for a
    file of the given type.

    path: The document name to write (or NULL for default)

    format: Which format to write (currently cbz, html, pdf, pam,
    pbm, pgm, pkm, png, ppm, pnm, svg, text, xhtml, docx, odt)

    options: NULL, or pointer to comma separated string to control
    file generation.
    """
    return _mupdf.ll_fz_new_document_writer(path, format, options)

def ll_fz_new_document_writer_of_size(size, begin_page, end_page, close, drop):
    r"""
    Low-level wrapper for `::fz_new_document_writer_of_size()`.
    Internal function to allocate a
    block for a derived document_writer structure, with the base
    structure's function pointers populated correctly, and the extra
    space zero initialised.
    """
    return _mupdf.ll_fz_new_document_writer_of_size(size, begin_page, end_page, close, drop)

def ll_fz_new_document_writer_with_buffer(buf, format, options):
    r"""Low-level wrapper for `::fz_new_document_writer_with_buffer()`."""
    return _mupdf.ll_fz_new_document_writer_with_buffer(buf, format, options)

def ll_fz_new_document_writer_with_output(out, format, options):
    r"""
    Low-level wrapper for `::fz_new_document_writer_with_output()`.
    Like fz_new_document_writer but takes a fz_output for writing
    the result. Only works for multi-page formats.
    """
    return _mupdf.ll_fz_new_document_writer_with_output(out, format, options)

def ll_fz_new_docx_writer(path, options):
    r"""Low-level wrapper for `::fz_new_docx_writer()`."""
    return _mupdf.ll_fz_new_docx_writer(path, options)

def ll_fz_new_docx_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_docx_writer_with_output()`."""
    return _mupdf.ll_fz_new_docx_writer_with_output(out, options)

def ll_fz_new_dom(tag):
    r"""
    Low-level wrapper for `::fz_new_dom()`.
    Make new xml dom root element.
    """
    return _mupdf.ll_fz_new_dom(tag)

def ll_fz_new_dom_node(dom, tag):
    r"""
    Low-level wrapper for `::fz_new_dom_node()`.
    Create a new dom node.

    This will NOT be linked in yet.
    """
    return _mupdf.ll_fz_new_dom_node(dom, tag)

def ll_fz_new_dom_text_node(dom, text):
    r"""
    Low-level wrapper for `::fz_new_dom_text_node()`.
    Create a new dom text node.

    This will NOT be linked in yet.
    """
    return _mupdf.ll_fz_new_dom_text_node(dom, text)

def ll_fz_new_draw_device(transform, dest):
    r"""
    Low-level wrapper for `::fz_new_draw_device()`.
    Create a device to draw on a pixmap.

    dest: Target pixmap for the draw device. See fz_new_pixmap*
    for how to obtain a pixmap. The pixmap is not cleared by the
    draw device, see fz_clear_pixmap* for how to clear it prior to
    calling fz_new_draw_device. Free the device by calling
    fz_drop_device.

    transform: Transform from user space in points to device space
    in pixels.
    """
    return _mupdf.ll_fz_new_draw_device(transform, dest)

def ll_fz_new_draw_device_type3(transform, dest):
    r"""Low-level wrapper for `::fz_new_draw_device_type3()`."""
    return _mupdf.ll_fz_new_draw_device_type3(transform, dest)

def ll_fz_new_draw_device_with_bbox(transform, dest, clip):
    r"""
    Low-level wrapper for `::fz_new_draw_device_with_bbox()`.
    Create a device to draw on a pixmap.

    dest: Target pixmap for the draw device. See fz_new_pixmap*
    for how to obtain a pixmap. The pixmap is not cleared by the
    draw device, see fz_clear_pixmap* for how to clear it prior to
    calling fz_new_draw_device. Free the device by calling
    fz_drop_device.

    transform: Transform from user space in points to device space
    in pixels.

    clip: Bounding box to restrict any marking operations of the
    draw device.
    """
    return _mupdf.ll_fz_new_draw_device_with_bbox(transform, dest, clip)

def ll_fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs):
    r"""
    Low-level wrapper for `::fz_new_draw_device_with_bbox_proof()`.
    Create a device to draw on a pixmap.

    dest: Target pixmap for the draw device. See fz_new_pixmap*
    for how to obtain a pixmap. The pixmap is not cleared by the
    draw device, see fz_clear_pixmap* for how to clear it prior to
    calling fz_new_draw_device. Free the device by calling
    fz_drop_device.

    transform: Transform from user space in points to device space
    in pixels.

    clip: Bounding box to restrict any marking operations of the
    draw device.

    proof_cs: Color space to render to prior to mapping to color
    space defined by pixmap.
    """
    return _mupdf.ll_fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs)

def ll_fz_new_draw_device_with_options(options, mediabox, pixmap):
    r"""
     Low-level wrapper for `::fz_new_draw_device_with_options()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_draw_device_with_options(const ::fz_draw_options *options, ::fz_rect mediabox, ::fz_pixmap **pixmap)` => `(fz_device *)`

    	Create a new pixmap and draw device, using the specified options.

    	options: Options to configure the draw device, and choose the
    	resolution and colorspace.

    	mediabox: The bounds of the page in points.

    	pixmap: An out parameter containing the newly created pixmap.
    """
    return _mupdf.ll_fz_new_draw_device_with_options(options, mediabox, pixmap)

def ll_fz_new_draw_device_with_proof(transform, dest, proof_cs):
    r"""
    Low-level wrapper for `::fz_new_draw_device_with_proof()`.
    Create a device to draw on a pixmap.

    dest: Target pixmap for the draw device. See fz_new_pixmap*
    for how to obtain a pixmap. The pixmap is not cleared by the
    draw device, see fz_clear_pixmap* for how to clear it prior to
    calling fz_new_draw_device. Free the device by calling
    fz_drop_device.

    transform: Transform from user space in points to device space
    in pixels.

    proof_cs: Intermediate color space to map though when mapping to
    color space defined by pixmap.
    """
    return _mupdf.ll_fz_new_draw_device_with_proof(transform, dest, proof_cs)

def ll_fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox):
    r"""
    Low-level wrapper for `::fz_new_font_from_buffer()`.
    Create a new font from a font file in a fz_buffer.

    Fonts created in this way, will be eligible for embedding by default.

    name: Name of font (leave NULL to use name from font).

    buffer: Buffer to load from.

    index: Which font from the file to load (0 for default).

    use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    Returns new font handle, or throws exception on error.
    """
    return _mupdf.ll_fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox)

def ll_fz_new_font_from_file(name, path, index, use_glyph_bbox):
    r"""
    Low-level wrapper for `::fz_new_font_from_file()`.
    Create a new font from a font file.

    Fonts created in this way, will be eligible for embedding by default.

    name: Name of font (leave NULL to use name from font).

    path: File path to load from.

    index: Which font from the file to load (0 for default).

    use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    Returns new font handle, or throws exception on error.
    """
    return _mupdf.ll_fz_new_font_from_file(name, path, index, use_glyph_bbox)

def ll_fz_new_font_from_memory(name, data, len, index, use_glyph_bbox):
    r"""
    Low-level wrapper for `::fz_new_font_from_memory()`.
    Create a new font from a font file in memory.

    Fonts created in this way, will be eligible for embedding by default.

    name: Name of font (leave NULL to use name from font).

    data: Pointer to the font file data.

    len: Length of the font file data.

    index: Which font from the file to load (0 for default).

    use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    Returns new font handle, or throws exception on error.
    """
    return _mupdf.ll_fz_new_font_from_memory(name, data, len, index, use_glyph_bbox)

def ll_fz_new_function_of_size(size, size2, m, n, eval, drop):
    r"""Low-level wrapper for `::fz_new_function_of_size()`."""
    return _mupdf.ll_fz_new_function_of_size(size, size2, m, n, eval, drop)

def ll_fz_new_hash_table(initialsize, keylen, lock, drop_val):
    r"""
    Low-level wrapper for `::fz_new_hash_table()`.
    Create a new hash table.

    initialsize: The initial size of the hashtable. The hashtable
    may grow (double in size) if it starts to get crowded (80%
    full).

    keylen: byte length for each key.

    lock: -1 for no lock, otherwise the FZ_LOCK to use to protect
    this table.

    drop_val: Function to use to destroy values on table drop.
    """
    return _mupdf.ll_fz_new_hash_table(initialsize, keylen, lock, drop_val)

def ll_fz_new_icc_colorspace(type, flags, name, buf):
    r"""
    Low-level wrapper for `::fz_new_icc_colorspace()`.
    Create a colorspace from an ICC profile supplied in buf.

    Limited checking is done to ensure that the colorspace type is
    appropriate for the supplied ICC profile.

    An additional reference is taken to buf, which will be dropped
    on destruction. Ownership is NOT passed in.

    The returned reference should be dropped when it is finished
    with.

    Colorspaces are immutable once created.
    """
    return _mupdf.ll_fz_new_icc_colorspace(type, flags, name, buf)

def ll_fz_new_image_from_buffer(buffer):
    r"""
    Low-level wrapper for `::fz_new_image_from_buffer()`.
    Create a new image from a
    buffer of data, inferring its type from the format
    of the data.
    """
    return _mupdf.ll_fz_new_image_from_buffer(buffer)

def ll_fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
    r"""
    Low-level wrapper for `::fz_new_image_from_compressed_buffer()`.
    Create an image based on
    the data in the supplied compressed buffer.

    w,h: Width and height of the created image.

    bpc: Bits per component.

    colorspace: The colorspace (determines the number of components,
    and any color conversions required while decoding).

    xres, yres: The X and Y resolutions respectively.

    interpolate: 1 if interpolation should be used when decoding
    this image, 0 otherwise.

    imagemask: 1 if this is an imagemask (i.e. transparency bitmap
    mask), 0 otherwise.

    decode: NULL, or a pointer to to a decode array. The default
    decode array is [0 1] (repeated n times, for n color components).

    colorkey: NULL, or a pointer to a colorkey array. The default
    colorkey array is [0 255] (repeated n times, for n color
    components).

    buffer: Buffer of compressed data and compression parameters.
    Ownership of this reference is passed in.

    mask: NULL, or another image to use as a mask for this one.
    A new reference is taken to this image. Supplying a masked
    image as a mask to another image is illegal!
    """
    return _mupdf.ll_fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)

def ll_fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
    r"""
     Low-level wrapper for `::fz_new_image_from_compressed_buffer2()`.  Swig-friendly wrapper for fz_new_image_from_compressed_buffer(),
    uses specified `decode` and `colorkey` if they are not null (in which
    case we assert that they have size `2*fz_colorspace_n(colorspace)`).
    """
    return _mupdf.ll_fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)

def ll_fz_new_image_from_display_list(w, h, list):
    r"""
    Low-level wrapper for `::fz_new_image_from_display_list()`.
    Create a new image from a display list.

    w, h: The conceptual width/height of the image.

    transform: The matrix that needs to be applied to the given
    list to make it render to the unit square.

    list: The display list.
    """
    return _mupdf.ll_fz_new_image_from_display_list(w, h, list)

def ll_fz_new_image_from_file(path):
    r"""
    Low-level wrapper for `::fz_new_image_from_file()`.
    Create a new image from the contents
    of a file, inferring its type from the format of the
    data.
    """
    return _mupdf.ll_fz_new_image_from_file(path)

def ll_fz_new_image_from_pixmap(pixmap, mask):
    r"""
    Low-level wrapper for `::fz_new_image_from_pixmap()`.
    Create an image from the given
    pixmap.

    pixmap: The pixmap to base the image upon. A new reference
    to this is taken.

    mask: NULL, or another image to use as a mask for this one.
    A new reference is taken to this image. Supplying a masked
    image as a mask to another image is illegal!
    """
    return _mupdf.ll_fz_new_image_from_pixmap(pixmap, mask)

def ll_fz_new_image_from_svg(buf, base_uri, dir):
    r"""
    Low-level wrapper for `::fz_new_image_from_svg()`.
    Create a scalable image from an SVG document.
    """
    return _mupdf.ll_fz_new_image_from_svg(buf, base_uri, dir)

def ll_fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir):
    r"""
    Low-level wrapper for `::fz_new_image_from_svg_xml()`.
    Create a scalable image from an SVG document.
    """
    return _mupdf.ll_fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir)

def ll_fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop):
    r"""
    Low-level wrapper for `::fz_new_image_of_size()`.
    Internal function to make a new fz_image structure
    for a derived class.

    w,h: Width and height of the created image.

    bpc: Bits per component.

    colorspace: The colorspace (determines the number of components,
    and any color conversions required while decoding).

    xres, yres: The X and Y resolutions respectively.

    interpolate: 1 if interpolation should be used when decoding
    this image, 0 otherwise.

    imagemask: 1 if this is an imagemask (i.e. transparent), 0
    otherwise.

    decode: NULL, or a pointer to to a decode array. The default
    decode array is [0 1] (repeated n times, for n color components).

    colorkey: NULL, or a pointer to a colorkey array. The default
    colorkey array is [0 255] (repeated n times, for n color
    components).

    mask: NULL, or another image to use as a mask for this one.
    A new reference is taken to this image. Supplying a masked
    image as a mask to another image is illegal!

    size: The size of the required allocated structure (the size of
    the derived structure).

    get: The function to be called to obtain a decoded pixmap.

    get_size: The function to be called to return the storage size
    used by this image.

    drop: The function to be called to dispose of this image once
    the last reference is dropped.

    Returns a pointer to an allocated structure of the required size,
    with the first sizeof(fz_image) bytes initialised as appropriate
    given the supplied parameters, and the other bytes set to zero.
    """
    return _mupdf.ll_fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop)

def ll_fz_new_indexed_colorspace(base, high, lookup):
    r"""
    Low-level wrapper for `::fz_new_indexed_colorspace()`.
    Create an indexed colorspace.

    The supplied lookup table is high palette entries long. Each
    entry is n bytes long, where n is given by the number of
    colorants in the base colorspace, one byte per colorant.

    Ownership of lookup is passed it; it will be freed on
    destruction, so must be heap allocated.

    The colorspace will keep an additional reference to the base
    colorspace that will be dropped on destruction.

    The returned reference should be dropped when it is finished
    with.

    Colorspaces are immutable once created.
    """
    return _mupdf.ll_fz_new_indexed_colorspace(base, high, lookup)

def ll_fz_new_jpeg_pixmap_writer(path, options):
    r"""Low-level wrapper for `::fz_new_jpeg_pixmap_writer()`."""
    return _mupdf.ll_fz_new_jpeg_pixmap_writer(path, options)

def ll_fz_new_layout():
    r"""
    Low-level wrapper for `::fz_new_layout()`.
    Create a new layout block, with new allocation pool, zero
    matrices, and initialise linked pointers.
    """
    return _mupdf.ll_fz_new_layout()

def ll_fz_new_link_of_size(size, rect, uri):
    r"""
    Low-level wrapper for `::fz_new_link_of_size()`.
    Create a new link record.

    next is set to NULL with the expectation that the caller will
    handle the linked list setup. Internal function.

    Different document types will be implemented by deriving from
    fz_link. This macro allocates such derived structures, and
    initialises the base sections.
    """
    return _mupdf.ll_fz_new_link_of_size(size, rect, uri)

def ll_fz_new_list_device(list):
    r"""
    Low-level wrapper for `::fz_new_list_device()`.
    Create a rendering device for a display list.

    When the device is rendering a page it will populate the
    display list with drawing commands (text, images, etc.). The
    display list can later be reused to render a page many times
    without having to re-interpret the page from the document file
    for each rendering. Once the device is no longer needed, free
    it with fz_drop_device.

    list: A display list that the list device takes a reference to.
    """
    return _mupdf.ll_fz_new_list_device(list)

def ll_fz_new_log_for_module(module):
    r"""
    Low-level wrapper for `::fz_new_log_for_module()`.
    Internal function to actually do the opening of the logfile.

    Caller should close/drop the output when finished with it.
    """
    return _mupdf.ll_fz_new_log_for_module(module)

def ll_fz_new_mono_pcl_band_writer(out, options):
    r"""
    Low-level wrapper for `::fz_new_mono_pcl_band_writer()`.
    Create a new band writer, outputing monochrome pcl.
    """
    return _mupdf.ll_fz_new_mono_pcl_band_writer(out, options)

def ll_fz_new_mono_pwg_band_writer(out, pwg):
    r"""
    Low-level wrapper for `::fz_new_mono_pwg_band_writer()`.
    Create a new monochrome pwg band writer.
    """
    return _mupdf.ll_fz_new_mono_pwg_band_writer(out, pwg)

def ll_fz_new_multi_archive():
    r"""
    Low-level wrapper for `::fz_new_multi_archive()`.
    Create a new multi archive (initially empty).
    """
    return _mupdf.ll_fz_new_multi_archive()

def ll_fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg):
    r"""
    Low-level wrapper for `::fz_new_ocr_device()`.
    Create a device to OCR the text on the page.

    Renders the page internally to a bitmap that is then OCRd. Text
    is then forwarded onto the target device.

    target: The target device to receive the OCRd text.

    ctm: The transform to apply to the mediabox to get the size for
    the rendered page image. Also used to calculate the resolution
    for the page image. In general, this will be the same as the CTM
    that you pass to fz_run_page (or fz_run_display_list) to feed
    this device.

    mediabox: The mediabox (in points). Combined with the CTM to get
    the bounds of the pixmap used internally for the rendered page
    image.

    with_list: If with_list is false, then all non-text operations
    are forwarded instantly to the target device. This results in
    the target device seeing all NON-text operations, followed by
    all the text operations (derived from OCR).

    If with_list is true, then all the marking operations are
    collated into a display list which is then replayed to the
    target device at the end.

    language: NULL (for "eng"), or a pointer to a string to describe
    the languages/scripts that should be used for OCR (e.g.
    "eng,ara").

    datadir: NULL (for ""), or a pointer to a path string otherwise
    provided to Tesseract in the TESSDATA_PREFIX environment variable.

    progress: NULL, or function to be called periodically to indicate
    progress. Return 0 to continue, or 1 to cancel. progress_arg is
    returned as the void *. The int is a value between 0 and 100 to
    indicate progress.

    progress_arg: A void * value to be parrotted back to the progress
    function.
    """
    return _mupdf.ll_fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg)

def ll_fz_new_odt_writer(path, options):
    r"""Low-level wrapper for `::fz_new_odt_writer()`."""
    return _mupdf.ll_fz_new_odt_writer(path, options)

def ll_fz_new_odt_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_odt_writer_with_output()`."""
    return _mupdf.ll_fz_new_odt_writer_with_output(out, options)

def ll_fz_new_outline():
    r"""
    Low-level wrapper for `::fz_new_outline()`.
    Create a new outline entry with zeroed fields for the caller
    to fill in.
    """
    return _mupdf.ll_fz_new_outline()

def ll_fz_new_outline_iterator(doc):
    r"""
    Low-level wrapper for `::fz_new_outline_iterator()`.
    Get an iterator for the document outline.

    Should be freed by fz_drop_outline_iterator.
    """
    return _mupdf.ll_fz_new_outline_iterator(doc)

def ll_fz_new_outline_iterator_of_size(size, doc):
    r"""Low-level wrapper for `::fz_new_outline_iterator_of_size()`."""
    return _mupdf.ll_fz_new_outline_iterator_of_size(size, doc)

def ll_fz_new_output(bufsiz, state, write, close, drop):
    r"""
    Low-level wrapper for `::fz_new_output()`.
    Create a new output object with the given
    internal state and function pointers.

    state: Internal state (opaque to everything but implementation).

    write: Function to output a given buffer.

    close: Cleanup function to destroy state when output closed.
    May permissibly be null.
    """
    return _mupdf.ll_fz_new_output(bufsiz, state, write, close, drop)

def ll_fz_new_output_with_buffer(buf):
    r"""
    Low-level wrapper for `::fz_new_output_with_buffer()`.
    Open an output stream that appends
    to a buffer.

    buf: The buffer to append to.
    """
    return _mupdf.ll_fz_new_output_with_buffer(buf)

def ll_fz_new_output_with_file_ptr(file):
    r"""
    Low-level wrapper for `::fz_new_output_with_file_ptr()`.
    Open an output stream that writes to a
    given FILE *.

    file: The file pointers to write to. NULL is interpreted as effectively
    meaning /dev/null or similar.
    """
    return _mupdf.ll_fz_new_output_with_file_ptr(file)

def ll_fz_new_output_with_path(filename, append):
    r"""
    Low-level wrapper for `::fz_new_output_with_path()`.
    Open an output stream that writes to a
    given path.

    filename: The filename to write to (specified in UTF-8).

    append: non-zero if we should append to the file, rather than
    overwriting it.
    """
    return _mupdf.ll_fz_new_output_with_path(filename, append)

def ll_fz_new_page_of_size(size, doc):
    r"""
    Low-level wrapper for `::fz_new_page_of_size()`.
    Different document types will be implemented by deriving from
    fz_page. This macro allocates such derived structures, and
    initialises the base sections.
    """
    return _mupdf.ll_fz_new_page_of_size(size, doc)

def ll_fz_new_pam_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_pam_band_writer()`.
    Create a band writer targetting pnm (greyscale, rgb or cmyk,
    with or without alpha).
    """
    return _mupdf.ll_fz_new_pam_band_writer(out)

def ll_fz_new_pam_pixmap_writer(path, options):
    r"""Low-level wrapper for `::fz_new_pam_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pam_pixmap_writer(path, options)

def ll_fz_new_path():
    r"""
    Low-level wrapper for `::fz_new_path()`.
    Create a new (empty) path structure.
    """
    return _mupdf.ll_fz_new_path()

def ll_fz_new_pbm_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_pbm_band_writer()`.
    Create a new band writer, targetting pbm.
    """
    return _mupdf.ll_fz_new_pbm_band_writer(out)

def ll_fz_new_pbm_pixmap_writer(path, options):
    r"""Low-level wrapper for `::fz_new_pbm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pbm_pixmap_writer(path, options)

def ll_fz_new_pcl_writer(path, options):
    r"""Low-level wrapper for `::fz_new_pcl_writer()`."""
    return _mupdf.ll_fz_new_pcl_writer(path, options)

def ll_fz_new_pcl_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_pcl_writer_with_output()`."""
    return _mupdf.ll_fz_new_pcl_writer_with_output(out, options)

def ll_fz_new_pclm_band_writer(out, options):
    r"""
    Low-level wrapper for `::fz_new_pclm_band_writer()`.
    Create a new band writer, outputing pclm
    """
    return _mupdf.ll_fz_new_pclm_band_writer(out, options)

def ll_fz_new_pclm_writer(path, options):
    r"""Low-level wrapper for `::fz_new_pclm_writer()`."""
    return _mupdf.ll_fz_new_pclm_writer(path, options)

def ll_fz_new_pclm_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_pclm_writer_with_output()`."""
    return _mupdf.ll_fz_new_pclm_writer_with_output(out, options)

def ll_fz_new_pdf_document_from_fz_document(ptr):
    r"""Low-level wrapper for `::fz_new_pdf_document_from_fz_document()`."""
    return _mupdf.ll_fz_new_pdf_document_from_fz_document(ptr)

def ll_fz_new_pdf_writer(path, options):
    r"""
    Low-level wrapper for `::fz_new_pdf_writer()`.
    Document writers for various possible output formats.

    All of the "_with_output" variants pass the ownership of out in
    immediately upon calling. The writers are responsible for
    dropping the fz_output when they are finished with it (even
    if they throw an exception during creation).
    """
    return _mupdf.ll_fz_new_pdf_writer(path, options)

def ll_fz_new_pdf_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_pdf_writer_with_output()`."""
    return _mupdf.ll_fz_new_pdf_writer_with_output(out, options)

def ll_fz_new_pdfocr_band_writer(out, options):
    r"""
    Low-level wrapper for `::fz_new_pdfocr_band_writer()`.
    Create a new band writer, outputing pdfocr.

    Ownership of output stays with the caller, the band writer
    borrows the reference. The caller must keep the output around
    for the duration of the band writer, and then close/drop as
    appropriate.
    """
    return _mupdf.ll_fz_new_pdfocr_band_writer(out, options)

def ll_fz_new_pdfocr_writer(path, options):
    r"""Low-level wrapper for `::fz_new_pdfocr_writer()`."""
    return _mupdf.ll_fz_new_pdfocr_writer(path, options)

def ll_fz_new_pdfocr_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_pdfocr_writer_with_output()`."""
    return _mupdf.ll_fz_new_pdfocr_writer_with_output(out, options)

def ll_fz_new_pgm_pixmap_writer(path, options):
    r"""Low-level wrapper for `::fz_new_pgm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pgm_pixmap_writer(path, options)

def ll_fz_new_pixmap(cs, w, h, seps, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap()`.
    Create a new pixmap, with its origin at (0,0)

    cs: The colorspace to use for the pixmap, or NULL for an alpha
    plane/mask.

    w: The width of the pixmap (in pixels)

    h: The height of the pixmap (in pixels)

    seps: Details of separations.

    alpha: 0 for no alpha, 1 for alpha.

    Returns a pointer to the new pixmap. Throws exception on failure
    to allocate.
    """
    return _mupdf.ll_fz_new_pixmap(cs, w, h, seps, alpha)

def ll_fz_new_pixmap_from_alpha_channel(src):
    r"""Low-level wrapper for `::fz_new_pixmap_from_alpha_channel()`."""
    return _mupdf.ll_fz_new_pixmap_from_alpha_channel(src)

def ll_fz_new_pixmap_from_color_and_mask(color, mask):
    r"""Low-level wrapper for `::fz_new_pixmap_from_color_and_mask()`."""
    return _mupdf.ll_fz_new_pixmap_from_color_and_mask(color, mask)

def ll_fz_new_pixmap_from_display_list(list, ctm, cs, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap_from_display_list()`.
    Render the page to a pixmap using the transform and colorspace.

    Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.ll_fz_new_pixmap_from_display_list(list, ctm, cs, alpha)

def ll_fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.
    Render the page contents with control over spot colors.

    Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.ll_fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha)

def ll_fz_new_pixmap_from_page(page, ctm, cs, alpha):
    r"""Low-level wrapper for `::fz_new_pixmap_from_page()`."""
    return _mupdf.ll_fz_new_pixmap_from_page(page, ctm, cs, alpha)

def ll_fz_new_pixmap_from_page_contents(page, ctm, cs, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap_from_page_contents()`.
    Render the page contents without annotations.

    Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.ll_fz_new_pixmap_from_page_contents(page, ctm, cs, alpha)

def ll_fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha):
    r"""Low-level wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
    return _mupdf.ll_fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha)

def ll_fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha):
    r"""Low-level wrapper for `::fz_new_pixmap_from_page_number()`."""
    return _mupdf.ll_fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha)

def ll_fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha):
    r"""Low-level wrapper for `::fz_new_pixmap_from_page_number_with_separations()`."""
    return _mupdf.ll_fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha)

def ll_fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha):
    r"""Low-level wrapper for `::fz_new_pixmap_from_page_with_separations()`."""
    return _mupdf.ll_fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha)

def ll_fz_new_pixmap_from_pixmap(pixmap, rect):
    r"""
    Low-level wrapper for `::fz_new_pixmap_from_pixmap()`.
    Create a new pixmap that represents a subarea of the specified
    pixmap. A reference is taken to this pixmap that will be dropped
    on destruction.

    The supplied rectangle must be wholly contained within the
    original pixmap.

    Returns a pointer to the new pixmap. Throws exception on failure
    to allocate.
    """
    return _mupdf.ll_fz_new_pixmap_from_pixmap(pixmap, rect)

def ll_fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap_with_bbox()`.
    Create a pixmap of a given size, location and pixel format.

    The bounding box specifies the size of the created pixmap and
    where it will be located. The colorspace determines the number
    of components per pixel. Alpha is always present. Pixmaps are
    reference counted, so drop references using fz_drop_pixmap.

    colorspace: Colorspace format used for the created pixmap. The
    pixmap will keep a reference to the colorspace.

    bbox: Bounding box specifying location/size of created pixmap.

    seps: Details of separations.

    alpha: 0 for no alpha, 1 for alpha.

    Returns a pointer to the new pixmap. Throws exception on failure
    to allocate.
    """
    return _mupdf.ll_fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha)

def ll_fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples):
    r"""
    Low-level wrapper for `::fz_new_pixmap_with_bbox_and_data()`.
    Create a pixmap of a given size, location and pixel format,
    using the supplied data block.

    The bounding box specifies the size of the created pixmap and
    where it will be located. The colorspace determines the number
    of components per pixel. Alpha is always present. Pixmaps are
    reference counted, so drop references using fz_drop_pixmap.

    colorspace: Colorspace format used for the created pixmap. The
    pixmap will keep a reference to the colorspace.

    rect: Bounding box specifying location/size of created pixmap.

    seps: Details of separations.

    alpha: Number of alpha planes (0 or 1).

    samples: The data block to keep the samples in.

    Returns a pointer to the new pixmap. Throws exception on failure
    to allocate.
    """
    return _mupdf.ll_fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples)

def ll_fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples):
    r"""
    Low-level wrapper for `::fz_new_pixmap_with_data()`.
    Create a new pixmap, with its origin at
    (0,0) using the supplied data block.

    cs: The colorspace to use for the pixmap, or NULL for an alpha
    plane/mask.

    w: The width of the pixmap (in pixels)

    h: The height of the pixmap (in pixels)

    seps: Details of separations.

    alpha: 0 for no alpha, 1 for alpha.

    stride: The byte offset from the pixel data in a row to the
    pixel data in the next row.

    samples: The data block to keep the samples in.

    Returns a pointer to the new pixmap. Throws exception on failure to
    allocate.
    """
    return _mupdf.ll_fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples)

def ll_fz_new_pixmap_writer(path, options, default_path, n, save):
    r"""Low-level wrapper for `::fz_new_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pixmap_writer(path, options, default_path, n, save)

def ll_fz_new_pkm_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_pkm_band_writer()`.
    Create a new pkm band writer for CMYK pixmaps.
    """
    return _mupdf.ll_fz_new_pkm_band_writer(out)

def ll_fz_new_pkm_pixmap_writer(path, options):
    r"""Low-level wrapper for `::fz_new_pkm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pkm_pixmap_writer(path, options)

def ll_fz_new_png_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_png_band_writer()`.
    Create a new png band writer (greyscale or RGB, with or without
    alpha).
    """
    return _mupdf.ll_fz_new_png_band_writer(out)

def ll_fz_new_png_pixmap_writer(path, options):
    r"""Low-level wrapper for `::fz_new_png_pixmap_writer()`."""
    return _mupdf.ll_fz_new_png_pixmap_writer(path, options)

def ll_fz_new_pnm_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_pnm_band_writer()`.
    Create a band writer targetting pnm (greyscale or rgb, no
    alpha).
    """
    return _mupdf.ll_fz_new_pnm_band_writer(out)

def ll_fz_new_pnm_pixmap_writer(path, options):
    r"""Low-level wrapper for `::fz_new_pnm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pnm_pixmap_writer(path, options)

def ll_fz_new_pool():
    r"""
    Low-level wrapper for `::fz_new_pool()`.
    Create a new pool to allocate from.
    """
    return _mupdf.ll_fz_new_pool()

def ll_fz_new_ppm_pixmap_writer(path, options):
    r"""Low-level wrapper for `::fz_new_ppm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_ppm_pixmap_writer(path, options)

def ll_fz_new_ps_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_ps_band_writer()`.
    Create a postscript band writer for gray, rgb, or cmyk, no
    alpha.
    """
    return _mupdf.ll_fz_new_ps_band_writer(out)

def ll_fz_new_ps_writer(path, options):
    r"""Low-level wrapper for `::fz_new_ps_writer()`."""
    return _mupdf.ll_fz_new_ps_writer(path, options)

def ll_fz_new_ps_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_ps_writer_with_output()`."""
    return _mupdf.ll_fz_new_ps_writer_with_output(out, options)

def ll_fz_new_psd_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_psd_band_writer()`.
    Open a PSD band writer.
    """
    return _mupdf.ll_fz_new_psd_band_writer(out)

def ll_fz_new_pwg_band_writer(out, pwg):
    r"""
    Low-level wrapper for `::fz_new_pwg_band_writer()`.
    Create a new color pwg band writer.
    """
    return _mupdf.ll_fz_new_pwg_band_writer(out, pwg)

def ll_fz_new_pwg_writer(path, options):
    r"""Low-level wrapper for `::fz_new_pwg_writer()`."""
    return _mupdf.ll_fz_new_pwg_writer(path, options)

def ll_fz_new_pwg_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_pwg_writer_with_output()`."""
    return _mupdf.ll_fz_new_pwg_writer_with_output(out, options)

def ll_fz_new_rle_output(chain):
    r"""Low-level wrapper for `::fz_new_rle_output()`."""
    return _mupdf.ll_fz_new_rle_output(chain)

def ll_fz_new_separations(controllable):
    r"""
    Low-level wrapper for `::fz_new_separations()`.
    Create a new separations structure (initially empty)
    """
    return _mupdf.ll_fz_new_separations(controllable)

def ll_fz_new_stext_device(page, options):
    r"""
    Low-level wrapper for `::fz_new_stext_device()`.
    Create a device to extract the text on a page.

    Gather the text on a page into blocks and lines.

    The reading order is taken from the order the text is drawn in
    the source file, so may not be accurate.

    page: The text page to which content should be added. This will
    usually be a newly created (empty) text page, but it can be one
    containing data already (for example when merging multiple
    pages, or watermarking).

    options: Options to configure the stext device.
    """
    return _mupdf.ll_fz_new_stext_device(page, options)

def ll_fz_new_stext_page(mediabox):
    r"""
    Low-level wrapper for `::fz_new_stext_page()`.
    Create an empty text page.

    The text page is filled out by the text device to contain the
    blocks and lines of text on the page.

    mediabox: optional mediabox information.
    """
    return _mupdf.ll_fz_new_stext_page(mediabox)

def ll_fz_new_stext_page_from_chapter_page_number(doc, chapter, number, options):
    r"""Low-level wrapper for `::fz_new_stext_page_from_chapter_page_number()`."""
    return _mupdf.ll_fz_new_stext_page_from_chapter_page_number(doc, chapter, number, options)

def ll_fz_new_stext_page_from_display_list(list, options):
    r"""Low-level wrapper for `::fz_new_stext_page_from_display_list()`."""
    return _mupdf.ll_fz_new_stext_page_from_display_list(list, options)

def ll_fz_new_stext_page_from_page(page, options):
    r"""
    Low-level wrapper for `::fz_new_stext_page_from_page()`.
    Extract text from page.

    Ownership of the fz_stext_page is returned to the caller.
    """
    return _mupdf.ll_fz_new_stext_page_from_page(page, options)

def ll_fz_new_stext_page_from_page_number(doc, number, options):
    r"""Low-level wrapper for `::fz_new_stext_page_from_page_number()`."""
    return _mupdf.ll_fz_new_stext_page_from_page_number(doc, number, options)

def ll_fz_new_store_context(max):
    r"""
    Low-level wrapper for `::fz_new_store_context()`.
    Create a new store inside the context

    max: The maximum size (in bytes) that the store is allowed to
    grow to. FZ_STORE_UNLIMITED means no limit.
    """
    return _mupdf.ll_fz_new_store_context(max)

def ll_fz_new_story(buf, user_css, em, dir):
    r"""Low-level wrapper for `::fz_new_story()`."""
    return _mupdf.ll_fz_new_story(buf, user_css, em, dir)

def ll_fz_new_stream(state, next, drop):
    r"""
    Low-level wrapper for `::fz_new_stream()`.
    Create a new stream object with the given
    internal state and function pointers.

    state: Internal state (opaque to everything but implementation).

    next: Should provide the next set of bytes (up to max) of stream
    data. Return the number of bytes read, or EOF when there is no
    more data.

    drop: Should clean up and free the internal state. May not
    throw exceptions.
    """
    return _mupdf.ll_fz_new_stream(state, next, drop)

def ll_fz_new_string(str):
    r"""Low-level wrapper for `::fz_new_string()`."""
    return _mupdf.ll_fz_new_string(str)

def ll_fz_new_stroke_state():
    r"""
    Low-level wrapper for `::fz_new_stroke_state()`.
    Create a new (empty) stroke state structure (with no dash
    data) and return a reference to it.

    Throws exception on failure to allocate.
    """
    return _mupdf.ll_fz_new_stroke_state()

def ll_fz_new_stroke_state_with_dash_len(len):
    r"""
    Low-level wrapper for `::fz_new_stroke_state_with_dash_len()`.
    Create a new (empty) stroke state structure, with room for
    dash data of the given length, and return a reference to it.

    len: The number of dash elements to allow room for.

    Throws exception on failure to allocate.
    """
    return _mupdf.ll_fz_new_stroke_state_with_dash_len(len)

def ll_fz_new_svg_device(out, page_width, page_height, text_format, reuse_images):
    r"""
    Low-level wrapper for `::fz_new_svg_device()`.
    Create a device that outputs (single page) SVG files to
    the given output stream.

    Equivalent to fz_new_svg_device_with_id passing id = NULL.
    """
    return _mupdf.ll_fz_new_svg_device(out, page_width, page_height, text_format, reuse_images)

def ll_fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id):
    r"""
     Low-level wrapper for `::fz_new_svg_device_with_id()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_svg_device_with_id(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`

    	Create a device that outputs (single page) SVG files to
    	the given output stream.

    	output: The output stream to send the constructed SVG page to.

    	page_width, page_height: The page dimensions to use (in points).

    	text_format: How to emit text. One of the following values:
    		FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
    		layout errors and mismatching fonts.
    		FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
    		visual appearance.

    	reuse_images: Share image resources using <symbol> definitions.

    	id: ID parameter to keep generated IDs unique across SVG files.
    """
    return _mupdf.ll_fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id)

def ll_fz_new_svg_writer(path, options):
    r"""Low-level wrapper for `::fz_new_svg_writer()`."""
    return _mupdf.ll_fz_new_svg_writer(path, options)

def ll_fz_new_svg_writer_with_output(out, options):
    r"""Low-level wrapper for `::fz_new_svg_writer_with_output()`."""
    return _mupdf.ll_fz_new_svg_writer_with_output(out, options)

def ll_fz_new_test_device(is_color, threshold, options, passthrough):
    r"""
     Low-level wrapper for `::fz_new_test_device()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_test_device(float threshold, int options, ::fz_device *passthrough)` => `(fz_device *, int is_color)`

    	Create a device to test for features.

    	Currently only tests for the presence of non-grayscale colors.

    	is_color: Possible values returned:
    		0: Definitely greyscale
    		1: Probably color (all colors were grey, but there
    		were images or shadings in a non grey colorspace).
    		2: Definitely color

    	threshold: The difference from grayscale that will be tolerated.
    	Typical values to use are either 0 (be exact) and 0.02 (allow an
    	imperceptible amount of slop).

    	options: A set of bitfield options, from the FZ_TEST_OPT set.

    	passthrough: A device to pass all calls through to, or NULL.
    	If set, then the test device can both test and pass through to
    	an underlying device (like, say, the display list device). This
    	means that a display list can be created and at the end we'll
    	know if it's colored or not.

    	In the absence of a passthrough device, the device will throw
    	an exception to stop page interpretation when color is found.
    """
    return _mupdf.ll_fz_new_test_device(is_color, threshold, options, passthrough)

def ll_fz_new_text():
    r"""
    Low-level wrapper for `::fz_new_text()`.
    Create a new empty fz_text object.

    Throws exception on failure to allocate.
    """
    return _mupdf.ll_fz_new_text()

def ll_fz_new_text_writer(format, path, options):
    r"""Low-level wrapper for `::fz_new_text_writer()`."""
    return _mupdf.ll_fz_new_text_writer(format, path, options)

def ll_fz_new_text_writer_with_output(format, out, options):
    r"""Low-level wrapper for `::fz_new_text_writer_with_output()`."""
    return _mupdf.ll_fz_new_text_writer_with_output(format, out, options)

def ll_fz_new_trace_device(out):
    r"""
    Low-level wrapper for `::fz_new_trace_device()`.
    Create a device to print a debug trace of all device calls.
    """
    return _mupdf.ll_fz_new_trace_device(out)

def ll_fz_new_tree_archive(tree):
    r"""
    Low-level wrapper for `::fz_new_tree_archive()`.
    Create an archive that holds named buffers.

    tree can either be a preformed tree with fz_buffers as values,
    or it can be NULL for an empty tree.
    """
    return _mupdf.ll_fz_new_tree_archive(tree)

def ll_fz_new_type3_font(name, matrix):
    r"""
    Low-level wrapper for `::fz_new_type3_font()`.
    Create a new (empty) type3 font.

    name: Name of font (or NULL).

    matrix: Font matrix.

    Returns a new font handle, or throws exception on
    allocation failure.
    """
    return _mupdf.ll_fz_new_type3_font(name, matrix)

def ll_fz_new_xhtml_document_from_document(old_doc, opts):
    r"""
    Low-level wrapper for `::fz_new_xhtml_document_from_document()`.
    Use text extraction to convert the input document into XHTML,
    then open the result as a new document that can be reflowed.
    """
    return _mupdf.ll_fz_new_xhtml_document_from_document(old_doc, opts)

def ll_fz_new_xmltext_device(out):
    r"""
    Low-level wrapper for `::fz_new_xmltext_device()`.
    Create a device to output raw information.
    """
    return _mupdf.ll_fz_new_xmltext_device(out)

def ll_fz_new_zip_writer(filename):
    r"""
    Low-level wrapper for `::fz_new_zip_writer()`.
    Create a new zip writer that writes to a given file.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.
    """
    return _mupdf.ll_fz_new_zip_writer(filename)

def ll_fz_new_zip_writer_with_output(out):
    r"""
    Low-level wrapper for `::fz_new_zip_writer_with_output()`.
    Create a new zip writer that writes to a given output stream.

    Ownership of out passes in immediately upon calling this function.
    The caller should never drop the fz_output, even if this function throws
    an exception.
    """
    return _mupdf.ll_fz_new_zip_writer_with_output(out)

def ll_fz_next_page(doc, loc):
    r"""
    Low-level wrapper for `::fz_next_page()`.
    Function to get the location of the next page (allowing for the
    end of chapters etc). If at the end of the document, returns the
    current location.
    """
    return _mupdf.ll_fz_next_page(doc, loc)

def ll_fz_normalize_vector(p):
    r"""
    Low-level wrapper for `::fz_normalize_vector()`.
    Normalize a vector to length one.
    """
    return _mupdf.ll_fz_normalize_vector(p)

def ll_fz_open_a85d(chain):
    r"""
    Low-level wrapper for `::fz_open_a85d()`.
    a85d filter performs ASCII 85 Decoding of data read
    from the chained filter.
    """
    return _mupdf.ll_fz_open_a85d(chain)

def ll_fz_open_accelerated_document(filename, accel):
    r"""
    Low-level wrapper for `::fz_open_accelerated_document()`.
    Open a document file and read its basic structure so pages and
    objects can be located. MuPDF will try to repair broken
    documents (without actually changing the file contents).

    The returned fz_document is used when calling most other
    document related functions.

    filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.ll_fz_open_accelerated_document(filename, accel)

def ll_fz_open_accelerated_document_with_stream(magic, stream, accel):
    r"""
    Low-level wrapper for `::fz_open_accelerated_document_with_stream()`.
    Open a document using the specified stream object rather than
    opening a file on disk.

    magic: a string used to detect document type; either a file name
    or mime-type.

    stream: a stream of the document contents.

    accel: NULL, or a stream of the 'accelerator' contents for this document.

    NOTE: The caller retains ownership of 'stream' and 'accel' - the document will
    take its own references if required.
    """
    return _mupdf.ll_fz_open_accelerated_document_with_stream(magic, stream, accel)

def ll_fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir):
    r"""
    Low-level wrapper for `::fz_open_accelerated_document_with_stream_and_dir()`.
    Open a document using the specified stream object rather than
    opening a file on disk.

    magic: a string used to detect document type; either a file name
    or mime-type.

    stream: a stream of the document contents.

    accel: NULL, or a stream of the 'accelerator' contents for this document.

    dir: NULL, or the 'directory context' for the stream contents.

    NOTE: The caller retains ownership of 'stream', 'accel' and 'dir' - the document will
    take its own references if required.
    """
    return _mupdf.ll_fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir)

def ll_fz_open_aesd(chain, key, keylen):
    r"""
    Low-level wrapper for `::fz_open_aesd()`.
    aesd filter performs AES decoding of data read from the chained
    filter using the supplied key.
    """
    return _mupdf.ll_fz_open_aesd(chain, key, keylen)

def ll_fz_open_ahxd(chain):
    r"""
    Low-level wrapper for `::fz_open_ahxd()`.
    ahxd filter performs ASCII Hex decoding of data read
    from the chained filter.
    """
    return _mupdf.ll_fz_open_ahxd(chain)

def ll_fz_open_arc4(chain, key, keylen):
    r"""
    Low-level wrapper for `::fz_open_arc4()`.
    arc4 filter performs RC4 decoding of data read from the chained
    filter using the supplied key.
    """
    return _mupdf.ll_fz_open_arc4(chain, key, keylen)

def ll_fz_open_archive(filename):
    r"""
    Low-level wrapper for `::fz_open_archive()`.
    Open a zip or tar archive

    Open a file and identify its archive type based on the archive
    signature contained inside.

    filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.ll_fz_open_archive(filename)

def ll_fz_open_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_open_archive_entry()`.
    Opens an archive entry as a stream.

    name: Entry name to look for, this must be an exact match to
    the entry name in the archive.

    Throws an exception if a matching entry cannot be found.
    """
    return _mupdf.ll_fz_open_archive_entry(arch, name)

def ll_fz_open_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_archive_with_stream()`.
    Open zip or tar archive stream.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.
    """
    return _mupdf.ll_fz_open_archive_with_stream(file)

def ll_fz_open_buffer(buf):
    r"""
    Low-level wrapper for `::fz_open_buffer()`.
    Open a buffer as a stream.

    buf: The buffer to open. Ownership of the buffer is NOT passed
    in (this function takes its own reference).

    Returns pointer to newly created stream. May throw exceptions on
    failure to allocate.
    """
    return _mupdf.ll_fz_open_buffer(buf)

def ll_fz_open_cfb_archive(filename):
    r"""
    Low-level wrapper for `::fz_open_cfb_archive()`.
    Open a cfb file as an archive.

    An exception is thrown if the file is not recognised as a cfb.

    filename: a path to an archive file as it would be given to
    open(2).
    """
    return _mupdf.ll_fz_open_cfb_archive(filename)

def ll_fz_open_cfb_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_cfb_archive_with_stream()`.
    Open a cfb file as an archive.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.

    An exception is thrown if the file is not recognised as a chm.
    """
    return _mupdf.ll_fz_open_cfb_archive_with_stream(file)

def ll_fz_open_compressed_buffer(arg_1):
    r"""
    Low-level wrapper for `::fz_open_compressed_buffer()`.
    Open a stream to read the decompressed version of a buffer.
    """
    return _mupdf.ll_fz_open_compressed_buffer(arg_1)

def ll_fz_open_concat(max, pad):
    r"""
    Low-level wrapper for `::fz_open_concat()`.
    Concat filter concatenates several streams into one.
    """
    return _mupdf.ll_fz_open_concat(max, pad)

def ll_fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables):
    r"""
    Low-level wrapper for `::fz_open_dctd()`.
    dctd filter performs DCT (JPEG) decoding of data read
    from the chained filter.

    color_transform implements the PDF color_transform option
    	use -1 for default behavior
    	use 0 to disable YUV-RGB / YCCK-CMYK transforms
    	use 1 to enable YUV-RGB / YCCK-CMYK transforms

    invert_cmyk implements the necessary inversion for Photoshop CMYK images
    	use 0 if embedded in PDF
    	use 1 if not embedded in PDF

    For subsampling on decode, set l2factor to the log2 of the
    reduction required (therefore 0 = full size decode).

    jpegtables is an optional stream from which the JPEG tables
    can be read. Use NULL if not required.
    """
    return _mupdf.ll_fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables)

def ll_fz_open_directory(path):
    r"""
    Low-level wrapper for `::fz_open_directory()`.
    Open a directory as if it was an archive.

    A special case where a directory is opened as if it was an
    archive.

    Note that for directories it is not possible to retrieve the
    number of entries or list the entries. It is however possible
    to check if the archive has a particular entry.

    path: a path to a directory as it would be given to opendir(3).
    """
    return _mupdf.ll_fz_open_directory(path)

def ll_fz_open_document(filename):
    r"""
    Low-level wrapper for `::fz_open_document()`.
    Open a document file and read its basic structure so pages and
    objects can be located. MuPDF will try to repair broken
    documents (without actually changing the file contents).

    The returned fz_document is used when calling most other
    document related functions.

    filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.ll_fz_open_document(filename)

def ll_fz_open_document_with_buffer(magic, buffer):
    r"""
    Low-level wrapper for `::fz_open_document_with_buffer()`.
    Open a document using a buffer rather than opening a file on disk.
    """
    return _mupdf.ll_fz_open_document_with_buffer(magic, buffer)

def ll_fz_open_document_with_stream(magic, stream):
    r"""
    Low-level wrapper for `::fz_open_document_with_stream()`.
    Open a document using the specified stream object rather than
    opening a file on disk.

    magic: a string used to detect document type; either a file name
    or mime-type.

    stream: a stream representing the contents of the document file.

    NOTE: The caller retains ownership of 'stream' - the document will take its
    own reference if required.
    """
    return _mupdf.ll_fz_open_document_with_stream(magic, stream)

def ll_fz_open_document_with_stream_and_dir(magic, stream, dir):
    r"""
    Low-level wrapper for `::fz_open_document_with_stream_and_dir()`.
    Open a document using the specified stream object rather than
    opening a file on disk.

    magic: a string used to detect document type; either a file name
    or mime-type.

    stream: a stream representing the contents of the document file.

    dir: a 'directory context' for those filetypes that need it.

    NOTE: The caller retains ownership of 'stream' and 'dir' - the document will
    take its own references if required.
    """
    return _mupdf.ll_fz_open_document_with_stream_and_dir(magic, stream, dir)

def ll_fz_open_endstream_filter(chain, len, offset):
    r"""
    Low-level wrapper for `::fz_open_endstream_filter()`.
    The endstream filter reads a PDF substream, and starts to look
    for an 'endstream' token after the specified length.
    """
    return _mupdf.ll_fz_open_endstream_filter(chain, len, offset)

def ll_fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1):
    r"""
    Low-level wrapper for `::fz_open_faxd()`.
    faxd filter performs FAX decoding of data read from
    the chained filter.

    k: see fax specification (fax default is 0).

    end_of_line: whether we expect end of line markers (fax default
    is 0).

    encoded_byte_align: whether we align to bytes after each line
    (fax default is 0).

    columns: how many columns in the image (fax default is 1728).

    rows: 0 for unspecified or the number of rows of data to expect.

    end_of_block: whether we expect end of block markers (fax
    default is 1).

    black_is_1: determines the polarity of the image (fax default is
    0).
    """
    return _mupdf.ll_fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1)

def ll_fz_open_file(filename):
    r"""
    Low-level wrapper for `::fz_open_file()`.
    Open the named file and wrap it in a stream.

    filename: Path to a file. On non-Windows machines the filename
    should be exactly as it would be passed to fopen(2). On Windows
    machines, the path should be UTF-8 encoded so that non-ASCII
    characters can be represented. Other platforms do the encoding
    as standard anyway (and in most cases, particularly for MacOS
    and Linux, the encoding they use is UTF-8 anyway).
    """
    return _mupdf.ll_fz_open_file(filename)

def ll_fz_open_file_autodelete(filename):
    r"""
    Low-level wrapper for `::fz_open_file_autodelete()`.
    Do the same as fz_open_file, but delete the file upon close.
    """
    return _mupdf.ll_fz_open_file_autodelete(filename)

def ll_fz_open_file_ptr_no_close(file):
    r"""
    Low-level wrapper for `::fz_open_file_ptr_no_close()`.
    Create a stream from a FILE * that will not be closed
    when the stream is dropped.
    """
    return _mupdf.ll_fz_open_file_ptr_no_close(file)

def ll_fz_open_flated(chain, window_bits):
    r"""
    Low-level wrapper for `::fz_open_flated()`.
    flated filter performs LZ77 decoding (inflating) of data read
    from the chained filter.

    window_bits: How large a decompression window to use. Typically
    15. A negative number, -n, means to use n bits, but to expect
    raw data with no header.
    """
    return _mupdf.ll_fz_open_flated(chain, window_bits)

def ll_fz_open_image_decomp_stream(arg_1, arg_2, l2factor):
    r"""
     Low-level wrapper for `::fz_open_image_decomp_stream()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_open_image_decomp_stream(::fz_stream *arg_0, ::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`

    	Open a stream to read the decompressed version of another stream
    	with optional log2 subsampling.
    """
    return _mupdf.ll_fz_open_image_decomp_stream(arg_1, arg_2, l2factor)

def ll_fz_open_image_decomp_stream_from_buffer(arg_1, l2factor):
    r"""
     Low-level wrapper for `::fz_open_image_decomp_stream_from_buffer()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_open_image_decomp_stream_from_buffer(::fz_compressed_buffer *arg_0)` => `(fz_stream *, int l2factor)`

    	Open a stream to read the decompressed version of a buffer,
    	with optional log2 subsampling.

    	l2factor = NULL for no subsampling, or a pointer to an integer
    	containing the maximum log2 subsample factor acceptable (0 =
    	none, 1 = halve dimensions, 2 = quarter dimensions etc). If
    	non-NULL, then *l2factor will be updated on exit with the actual
    	log2 subsample factor achieved.
    """
    return _mupdf.ll_fz_open_image_decomp_stream_from_buffer(arg_1, l2factor)

def ll_fz_open_jbig2d(chain, globals, embedded):
    r"""
    Low-level wrapper for `::fz_open_jbig2d()`.
    Open a filter that performs jbig2 decompression on the chained
    stream, using the optional globals record.
    """
    return _mupdf.ll_fz_open_jbig2d(chain, globals, embedded)

def ll_fz_open_leecher(chain, buf):
    r"""
    Low-level wrapper for `::fz_open_leecher()`.
    Attach a filter to a stream that will store any
    characters read from the stream into the supplied buffer.

    chain: The underlying stream to leech from.

    buf: The buffer into which the read data should be appended.
    The buffer will be resized as required.

    Returns pointer to newly created stream. May throw exceptions on
    failure to allocate.
    """
    return _mupdf.ll_fz_open_leecher(chain, buf)

def ll_fz_open_libarchive_archive(filename):
    r"""
    Low-level wrapper for `::fz_open_libarchive_archive()`.
    Open an archive using libarchive.

    An exception is thrown if the file is not supported by libarchive.

    filename: a path to an archive file as it would be given to
    open(2).
    """
    return _mupdf.ll_fz_open_libarchive_archive(filename)

def ll_fz_open_libarchive_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_libarchive_archive_with_stream()`.
    Open an archive using libarchive.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.

    An exception is thrown if the stream is not supported by libarchive.
    """
    return _mupdf.ll_fz_open_libarchive_archive_with_stream(file)

def ll_fz_open_libarchived(chain):
    r"""
    Low-level wrapper for `::fz_open_libarchived()`.
    libarchived filter performs generic compressed decoding of data
    in any format understood by libarchive from the chained filter.

    This will throw an exception if libarchive is not built in, or
    if the compression format is not recognised.
    """
    return _mupdf.ll_fz_open_libarchived(chain)

def ll_fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff):
    r"""
    Low-level wrapper for `::fz_open_lzwd()`.
    lzwd filter performs LZW decoding of data read from the chained
    filter.

    early_change: (Default 1) specifies whether to change codes 1
    bit early.

    min_bits: (Default 9) specifies the minimum number of bits to
    use.

    reverse_bits: (Default 0) allows for compatibility with gif and
    old style tiffs (1).

    old_tiff: (Default 0) allows for different handling of the clear
    code, as found in old style tiffs.
    """
    return _mupdf.ll_fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff)

def ll_fz_open_memory(data, len):
    r"""
    Low-level wrapper for `::fz_open_memory()`.
    Open a block of memory as a stream.

    data: Pointer to start of data block. Ownership of the data
    block is NOT passed in.

    len: Number of bytes in data block.

    Returns pointer to newly created stream. May throw exceptions on
    failure to allocate.
    """
    return _mupdf.ll_fz_open_memory(data, len)

def ll_fz_open_null_filter(chain, len, offset):
    r"""
    Low-level wrapper for `::fz_open_null_filter()`.
    The null filter reads a specified amount of data from the
    substream.
    """
    return _mupdf.ll_fz_open_null_filter(chain, len, offset)

def ll_fz_open_predict(chain, predictor, columns, colors, bpc):
    r"""
    Low-level wrapper for `::fz_open_predict()`.
    predict filter performs pixel prediction on data read from
    the chained filter.

    predictor: 1 = copy, 2 = tiff, other = inline PNG predictor

    columns: width of image in pixels

    colors: number of components.

    bpc: bits per component (typically 8)
    """
    return _mupdf.ll_fz_open_predict(chain, predictor, columns, colors, bpc)

def ll_fz_open_range_filter(chain, ranges, nranges):
    r"""
    Low-level wrapper for `::fz_open_range_filter()`.
    The range filter copies data from specified ranges of the
    chained stream.
    """
    return _mupdf.ll_fz_open_range_filter(chain, ranges, nranges)

def ll_fz_open_reflowed_document(underdoc, opts):
    r"""Low-level wrapper for `::fz_open_reflowed_document()`."""
    return _mupdf.ll_fz_open_reflowed_document(underdoc, opts)

def ll_fz_open_rld(chain):
    r"""
    Low-level wrapper for `::fz_open_rld()`.
    rld filter performs Run Length Decoding of data read
    from the chained filter.
    """
    return _mupdf.ll_fz_open_rld(chain)

def ll_fz_open_sgilog16(chain, w):
    r"""
    Low-level wrapper for `::fz_open_sgilog16()`.
    SGI Log 16bit (greyscale) decode from the chained filter.
    Decodes lines of w pixels to 8bpp greyscale.
    """
    return _mupdf.ll_fz_open_sgilog16(chain, w)

def ll_fz_open_sgilog24(chain, w):
    r"""
    Low-level wrapper for `::fz_open_sgilog24()`.
    SGI Log 24bit (LUV) decode from the chained filter.
    Decodes lines of w pixels to 8bpc rgb.
    """
    return _mupdf.ll_fz_open_sgilog24(chain, w)

def ll_fz_open_sgilog32(chain, w):
    r"""
    Low-level wrapper for `::fz_open_sgilog32()`.
    SGI Log 32bit (LUV) decode from the chained filter.
    Decodes lines of w pixels to 8bpc rgb.
    """
    return _mupdf.ll_fz_open_sgilog32(chain, w)

def ll_fz_open_tar_archive(filename):
    r"""
    Low-level wrapper for `::fz_open_tar_archive()`.
    Open a tar archive file.

    An exception is thrown if the file is not a tar archive as
    indicated by the presence of a tar signature.

    filename: a path to a tar archive file as it would be given to
    open(2).
    """
    return _mupdf.ll_fz_open_tar_archive(filename)

def ll_fz_open_tar_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_tar_archive_with_stream()`.
    Open a tar archive stream.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.

    An exception is thrown if the stream is not a tar archive as
    indicated by the presence of a tar signature.

    """
    return _mupdf.ll_fz_open_tar_archive_with_stream(file)

def ll_fz_open_thunder(chain, w):
    r"""
    Low-level wrapper for `::fz_open_thunder()`.
    4bit greyscale Thunderscan decoding from the chained filter.
    Decodes lines of w pixels to 8bpp greyscale.
    """
    return _mupdf.ll_fz_open_thunder(chain, w)

def ll_fz_open_zip_archive(path):
    r"""
    Low-level wrapper for `::fz_open_zip_archive()`.
    Open a zip archive file.

    An exception is thrown if the file is not a zip archive as
    indicated by the presence of a zip signature.

    filename: a path to a zip archive file as it would be given to
    open(2).
    """
    return _mupdf.ll_fz_open_zip_archive(path)

def ll_fz_open_zip_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_zip_archive_with_stream()`.
    Open a zip archive stream.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.

    An exception is thrown if the stream is not a zip archive as
    indicated by the presence of a zip signature.

    """
    return _mupdf.ll_fz_open_zip_archive_with_stream(file)

def ll_fz_opt_from_list(opt, optlist):
    r"""
    Low-level wrapper for `::fz_opt_from_list()`.
    Return the index of a (case-insensitive) option within an optlist.

    For instance for optlist = "Foo|Bar|Baz", and  opt = "bar",
    this would return 1.

    If the optlist ends with "|*" then that is a catch all case and
    matches all options allowing the caller to process it itself.
    fz_optarg will be set to point to the option, and the return
    value will be the index of the '*' option within that list.

    If an optlist entry ends with ':' (e.g. "Foo:") then that option
    may have suboptions appended to it (for example "JPG:80") and
    fz_optarg will be set to point at "80". Otherwise fz_optarg will
    be set to NULL.

    In the event of no-match found, prints an error and returns -1.
    """
    return _mupdf.ll_fz_opt_from_list(opt, optlist)

def ll_fz_option_eq(a, b):
    r"""
    Low-level wrapper for `::fz_option_eq()`.
    Check to see if an option, a, from a string matches a reference
    option, b.

    (i.e. a could be 'foo' or 'foo,bar...' etc, but b can only be
    'foo'.)
    """
    return _mupdf.ll_fz_option_eq(a, b)

def ll_fz_outline_glyph(font, gid, ctm):
    r"""
    Low-level wrapper for `::fz_outline_glyph()`.
    Look a glyph up from a font, and return the outline of the
    glyph using the given transform.

    The caller owns the returned path, and so is responsible for
    ensuring that it eventually gets dropped.
    """
    return _mupdf.ll_fz_outline_glyph(font, gid, ctm)

def ll_fz_outline_iterator_delete(iter):
    r"""
    Low-level wrapper for `::fz_outline_iterator_delete()`.
    Delete the current item.

    This implicitly moves us to the 'next' item, and the return code is as for fz_outline_iterator_next.
    """
    return _mupdf.ll_fz_outline_iterator_delete(iter)

def ll_fz_outline_iterator_down(iter):
    r"""Low-level wrapper for `::fz_outline_iterator_down()`."""
    return _mupdf.ll_fz_outline_iterator_down(iter)

def ll_fz_outline_iterator_from_outline(outline):
    r"""Low-level wrapper for `::fz_outline_iterator_from_outline()`."""
    return _mupdf.ll_fz_outline_iterator_from_outline(outline)

def ll_fz_outline_iterator_insert(iter, item):
    r"""
    Low-level wrapper for `::fz_outline_iterator_insert()`.
    Call to insert a new item BEFORE the current point.

    Ownership of pointers are retained by the caller. The item data will be copied.

    After an insert, we do not change where we are pointing.
    The return code is the same as for next, it indicates the current iterator position.

    Note that for PDF documents at least, the is_open field is ignored. All childless
    nodes are considered closed by PDF, hence (given every newly inserted node is
    childless by definition) all new nodes are inserted with is_open == false.
    """
    return _mupdf.ll_fz_outline_iterator_insert(iter, item)

def ll_fz_outline_iterator_item(iter):
    r"""
    Low-level wrapper for `::fz_outline_iterator_item()`.
    Call to get the current outline item.

    Can return NULL. The item is only valid until the next call.
    """
    return _mupdf.ll_fz_outline_iterator_item(iter)

def ll_fz_outline_iterator_next(iter):
    r"""
    Low-level wrapper for `::fz_outline_iterator_next()`.
    Calls to move the iterator position.

    A negative return value means we could not move as requested. Otherwise:
    0 = the final position has a valid item.
    1 = not a valid item, but we can insert an item here.
    """
    return _mupdf.ll_fz_outline_iterator_next(iter)

def ll_fz_outline_iterator_prev(iter):
    r"""Low-level wrapper for `::fz_outline_iterator_prev()`."""
    return _mupdf.ll_fz_outline_iterator_prev(iter)

def ll_fz_outline_iterator_up(iter):
    r"""Low-level wrapper for `::fz_outline_iterator_up()`."""
    return _mupdf.ll_fz_outline_iterator_up(iter)

def ll_fz_outline_iterator_update(iter, item):
    r"""
    Low-level wrapper for `::fz_outline_iterator_update()`.
    Update the current item properties according to the given item.
    """
    return _mupdf.ll_fz_outline_iterator_update(iter, item)

def ll_fz_output_accelerator(doc, accel):
    r"""
    Low-level wrapper for `::fz_output_accelerator()`.
    Output accelerator data for the document to a given output
    stream.
    """
    return _mupdf.ll_fz_output_accelerator(doc, accel)

def ll_fz_output_supports_stream(out):
    r"""
    Low-level wrapper for `::fz_output_supports_stream()`.
    Query whether a given fz_output supports fz_stream_from_output.
    """
    return _mupdf.ll_fz_output_supports_stream(out)

def ll_fz_output_xml(out, item, level):
    r"""
    Low-level wrapper for `::fz_output_xml()`.
    Pretty-print an XML tree to given output.
    """
    return _mupdf.ll_fz_output_xml(out, item, level)

def ll_fz_pack_path(pack, path):
    r"""
    Low-level wrapper for `::fz_pack_path()`.
    Pack a path into the given block.
    To minimise the size of paths, this function allows them to be
    packed into a buffer with other information. Paths can be used
    interchangeably regardless of how they are packed.

    pack: Pointer to a block of data to pack the path into. Should
    be aligned by the caller to the same alignment as required for
    a fz_path pointer.

    path: The path to pack.

    Returns the number of bytes within the block used. Callers can
    access the packed path data by casting the value of pack on
    entry to be a fz_path *.

    Throws exceptions on failure to allocate.

    Implementation details: Paths can be 'unpacked', 'flat', or
    'open'. Standard paths, as created are 'unpacked'. Paths
    will be packed as 'flat', unless they are too large
    (where large indicates that they exceed some private
    implementation defined limits, currently including having
    more than 256 coordinates or commands).

    Large paths are 'open' packed as a header into the given block,
    plus pointers to other data blocks.

    Users should not have to care about whether paths are 'open'
    or 'flat' packed. Simply pack a path (if required), and then
    forget about the details.
    """
    return _mupdf.ll_fz_pack_path(pack, path)

def ll_fz_packed_path_size(path):
    r"""
    Low-level wrapper for `::fz_packed_path_size()`.
    Return the number of bytes required to pack a path.
    """
    return _mupdf.ll_fz_packed_path_size(path)

def ll_fz_page_label(page, buf, size):
    r"""
    Low-level wrapper for `::fz_page_label()`.
    Get page label for a given page.
    """
    return _mupdf.ll_fz_page_label(page, buf, size)

def ll_fz_page_number_from_location(doc, loc):
    r"""
    Low-level wrapper for `::fz_page_number_from_location()`.
    Converts from chapter+page to page number. This may cause many
    chapters to be laid out in order to calculate the number of
    pages within those chapters.
    """
    return _mupdf.ll_fz_page_number_from_location(doc, loc)

def ll_fz_page_presentation(page, transition, duration):
    r"""
     Low-level wrapper for `::fz_page_presentation()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_page_presentation(::fz_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`

    	Get the presentation details for a given page.

    	transition: A pointer to a transition struct to fill out.

    	duration: A pointer to a place to set the page duration in
    	seconds. Will be set to 0 if no transition is specified for the
    	page.

    	Returns: a pointer to the transition structure, or NULL if there
    	is no transition specified for the page.
    """
    return _mupdf.ll_fz_page_presentation(page, transition, duration)

def ll_fz_page_separations(page):
    r"""
    Low-level wrapper for `::fz_page_separations()`.
    Get the separations details for a page.
    This will be NULL, unless the format specifically supports
    separations (such as PDF files). May be NULL even
    so, if there are no separations on a page.

    Returns a reference that must be dropped.
    """
    return _mupdf.ll_fz_page_separations(page)

def ll_fz_page_uses_overprint(page):
    r"""
    Low-level wrapper for `::fz_page_uses_overprint()`.
    Query if a given page requires overprint.
    """
    return _mupdf.ll_fz_page_uses_overprint(page)

def ll_fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache):
    r"""
     Low-level wrapper for `::fz_paint_shade()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_paint_shade(::fz_shade *shade, ::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` =>

    	Render a shade to a given pixmap.

    	shade: The shade to paint.

    	override_cs: NULL, or colorspace to override the shades
    	inbuilt colorspace.

    	ctm: The transform to apply.

    	dest: The pixmap to render into.

    	color_params: The color rendering settings

    	bbox: Pointer to a bounding box to limit the rendering
    	of the shade.

    	eop: NULL, or pointer to overprint bitmap.

    	cache: *cache is used to cache color information. If *cache is NULL it
    	is set to point to a new fz_shade_color_cache. If cache is NULL it is
    	ignored.
    """
    return _mupdf.ll_fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache)

def ll_fz_parse_draw_options(options, string):
    r"""
    Low-level wrapper for `::fz_parse_draw_options()`.
    Parse draw device options from a comma separated key-value string.
    """
    return _mupdf.ll_fz_parse_draw_options(options, string)

def ll_fz_parse_page_range(s, a, b, n):
    r"""
     Low-level wrapper for `::fz_parse_page_range()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_parse_page_range(const char *s, int n)` => `(const char *, int a, int b)`
    """
    return _mupdf.ll_fz_parse_page_range(s, a, b, n)

def ll_fz_parse_pcl_options(opts, args):
    r"""
    Low-level wrapper for `::fz_parse_pcl_options()`.
    Parse PCL options.

    Currently defined options and values are as follows:

    	preset=X	Either "generic" or one of the presets as for fz_pcl_preset.
    	spacing=0	No vertical spacing capability
    	spacing=1	PCL 3 spacing (<ESC>*p+<n>Y)
    	spacing=2	PCL 4 spacing (<ESC>*b<n>Y)
    	spacing=3	PCL 5 spacing (<ESC>*b<n>Y and clear seed row)
    	mode2		Disable/Enable mode 2 graphics compression
    	mode3		Disable/Enable mode 3 graphics compression
    	eog_reset	End of graphics (<ESC>*rB) resets all parameters
    	has_duplex	Duplex supported (<ESC>&l<duplex>S)
    	has_papersize	Papersize setting supported (<ESC>&l<sizecode>A)
    	has_copies	Number of copies supported (<ESC>&l<copies>X)
    	is_ljet4pjl	Disable/Enable HP 4PJL model-specific output
    	is_oce9050	Disable/Enable Oce 9050 model-specific output
    """
    return _mupdf.ll_fz_parse_pcl_options(opts, args)

def ll_fz_parse_pclm_options(opts, args):
    r"""
    Low-level wrapper for `::fz_parse_pclm_options()`.
    Parse PCLm options.

    Currently defined options and values are as follows:

    	compression=none: No compression
    	compression=flate: Flate compression
    	strip-height=n: Strip height (default 16)
    """
    return _mupdf.ll_fz_parse_pclm_options(opts, args)

def ll_fz_parse_pdfocr_options(opts, args):
    r"""
    Low-level wrapper for `::fz_parse_pdfocr_options()`.
    Parse PDFOCR options.

    Currently defined options and values are as follows:

    	compression=none: No compression
    	compression=flate: Flate compression
    	strip-height=n: Strip height (default 16)
    	ocr-language=<lang>: OCR Language (default eng)
    	ocr-datadir=<datadir>: OCR data path (default rely on TESSDATA_PREFIX)
    """
    return _mupdf.ll_fz_parse_pdfocr_options(opts, args)

def ll_fz_parse_stext_options(opts, string):
    r"""
    Low-level wrapper for `::fz_parse_stext_options()`.
    Parse stext device options from a comma separated key-value
    string.
    """
    return _mupdf.ll_fz_parse_stext_options(opts, string)

def ll_fz_parse_xml(buf, preserve_white):
    r"""
    Low-level wrapper for `::fz_parse_xml()`.
    Parse the contents of buffer into a tree of xml nodes.

    preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.ll_fz_parse_xml(buf, preserve_white)

def ll_fz_parse_xml_archive_entry(dir, filename, preserve_white):
    r"""
    Low-level wrapper for `::fz_parse_xml_archive_entry()`.
    Parse the contents of an archive entry into a tree of xml nodes.

    preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.ll_fz_parse_xml_archive_entry(dir, filename, preserve_white)

def ll_fz_parse_xml_from_html5(buf):
    r"""
    Low-level wrapper for `::fz_parse_xml_from_html5()`.
    Parse the contents of a buffer into a tree of XML nodes,
    using the HTML5 parsing algorithm.
    """
    return _mupdf.ll_fz_parse_xml_from_html5(buf)

def ll_fz_parse_xml_stream(stream, preserve_white):
    r"""
    Low-level wrapper for `::fz_parse_xml_stream()`.
    Parse the contents of buffer into a tree of xml nodes.

    preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.ll_fz_parse_xml_stream(stream, preserve_white)

def ll_fz_pcl_preset(opts, preset):
    r"""
    Low-level wrapper for `::fz_pcl_preset()`.
    Initialize PCL option struct for a given preset.

    Currently defined presets include:

    	generic	Generic PCL printer
    	ljet4	HP DeskJet
    	dj500	HP DeskJet 500
    	fs600	Kyocera FS-600
    	lj	HP LaserJet, HP LaserJet Plus
    	lj2	HP LaserJet IIp, HP LaserJet IId
    	lj3	HP LaserJet III
    	lj3d	HP LaserJet IIId
    	lj4	HP LaserJet 4
    	lj4pl	HP LaserJet 4 PL
    	lj4d	HP LaserJet 4d
    	lp2563b	HP 2563B line printer
    	oce9050	Oce 9050 Line printer
    """
    return _mupdf.ll_fz_pcl_preset(opts, preset)

def ll_fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg):
    r"""
    Low-level wrapper for `::fz_pdfocr_band_writer_set_progress()`.
    Set the progress callback for a pdfocr bandwriter.
    """
    return _mupdf.ll_fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg)

def ll_fz_pdfocr_writer_set_progress(writer, progress, arg_3):
    r"""Low-level wrapper for `::fz_pdfocr_writer_set_progress()`."""
    return _mupdf.ll_fz_pdfocr_writer_set_progress(writer, progress, arg_3)

def ll_fz_peek_byte(stm):
    r"""
    Low-level wrapper for `::fz_peek_byte()`.
    Peek at the next byte in a stream.

    stm: The stream to peek at.

    Returns -1 for EOF, or the next byte that will be read.
    """
    return _mupdf.ll_fz_peek_byte(stm)

def ll_fz_pixmap_alpha(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_alpha()`.
    Return the number of alpha planes in a pixmap.

    Returns the number of alphas. Does not throw exceptions.
    """
    return _mupdf.ll_fz_pixmap_alpha(pix)

def ll_fz_pixmap_bbox(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_bbox()`.
    Return the bounding box for a pixmap.
    """
    return _mupdf.ll_fz_pixmap_bbox(pix)

def ll_fz_pixmap_colorants(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_colorants()`.
    Return the number of colorants in a pixmap.

    Returns the number of colorants (components, less any spots and
    alpha).
    """
    return _mupdf.ll_fz_pixmap_colorants(pix)

def ll_fz_pixmap_colorspace(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_colorspace()`.
    Return the colorspace of a pixmap

    Returns colorspace.
    """
    return _mupdf.ll_fz_pixmap_colorspace(pix)

def ll_fz_pixmap_components(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_components()`.
    Return the number of components in a pixmap.

    Returns the number of components (including spots and alpha).
    """
    return _mupdf.ll_fz_pixmap_components(pix)

def ll_fz_pixmap_height(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_height()`.
    Return the height of the pixmap in pixels.
    """
    return _mupdf.ll_fz_pixmap_height(pix)

def ll_fz_pixmap_image_tile(cimg):
    r"""
    Low-level wrapper for `::fz_pixmap_image_tile()`.
    Retrieve the underlying fz_pixmap for an image.

    Returns a pointer to the underlying fz_pixmap for an image,
    or NULL if this image is not based upon an fz_pixmap.

    No reference is returned. Lifespan is limited to that of
    the image itself. If required, use fz_keep_pixmap to take
    a reference to keep it longer.
    """
    return _mupdf.ll_fz_pixmap_image_tile(cimg)

def ll_fz_pixmap_samples(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_samples()`.
    Returns a pointer to the pixel data of a pixmap.

    Returns the pointer.
    """
    return _mupdf.ll_fz_pixmap_samples(pix)

def ll_fz_pixmap_samples_int(pixmap):
    r"""Low-level wrapper for `::fz_pixmap_samples_int()`."""
    return _mupdf.ll_fz_pixmap_samples_int(pixmap)

def ll_fz_pixmap_size(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_size()`.
    Return sizeof fz_pixmap plus size of data, in bytes.
    """
    return _mupdf.ll_fz_pixmap_size(pix)

def ll_fz_pixmap_spots(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_spots()`.
    Return the number of spots in a pixmap.

    Returns the number of spots (components, less colorants and
    alpha). Does not throw exceptions.
    """
    return _mupdf.ll_fz_pixmap_spots(pix)

def ll_fz_pixmap_stride(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_stride()`.
    Return the number of bytes in a row in the pixmap.
    """
    return _mupdf.ll_fz_pixmap_stride(pix)

def ll_fz_pixmap_width(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_width()`.
    Return the width of the pixmap in pixels.
    """
    return _mupdf.ll_fz_pixmap_width(pix)

def ll_fz_pixmap_x(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_x()`.
    Return the x value of the pixmap in pixels.
    """
    return _mupdf.ll_fz_pixmap_x(pix)

def ll_fz_pixmap_y(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_y()`.
    Return the y value of the pixmap in pixels.
    """
    return _mupdf.ll_fz_pixmap_y(pix)

def ll_fz_place_story(story, where, filled):
    r"""Low-level wrapper for `::fz_place_story()`."""
    return _mupdf.ll_fz_place_story(story, where, filled)

def ll_fz_place_story_flags(story, where, filled, flags):
    r"""Low-level wrapper for `::fz_place_story_flags()`."""
    return _mupdf.ll_fz_place_story_flags(story, where, filled, flags)

def ll_fz_pool_alloc(pool, size):
    r"""
    Low-level wrapper for `::fz_pool_alloc()`.
    Allocate a block of size bytes from the pool.
    """
    return _mupdf.ll_fz_pool_alloc(pool, size)

def ll_fz_pool_size(pool):
    r"""
    Low-level wrapper for `::fz_pool_size()`.
    The current size of the pool.

    The number of bytes of storage currently allocated to the pool.
    This is the total of the storage used for the blocks making
    up the pool, rather then total of the allocated blocks so far,
    so it will increase in 'lumps'.
    from the pool, then the pool size may still be X
    """
    return _mupdf.ll_fz_pool_size(pool)

def ll_fz_pool_strdup(pool, s):
    r"""
    Low-level wrapper for `::fz_pool_strdup()`.
    strdup equivalent allocating from the pool.
    """
    return _mupdf.ll_fz_pool_strdup(pool, s)

def ll_fz_pop_clip(dev):
    r"""Low-level wrapper for `::fz_pop_clip()`."""
    return _mupdf.ll_fz_pop_clip(dev)

def ll_fz_post_scale(m, sx, sy):
    r"""
    Low-level wrapper for `::fz_post_scale()`.
    Scale a matrix by postmultiplication.

    m: Pointer to the matrix to scale

    sx, sy: Scaling factors along the X- and Y-axes. A scaling
    factor of 1.0 will not cause any scaling along the relevant
    axis.

    Returns m (updated).
    """
    return _mupdf.ll_fz_post_scale(m, sx, sy)

def ll_fz_pre_rotate(m, degrees):
    r"""
    Low-level wrapper for `::fz_pre_rotate()`.
    Rotate a transformation by premultiplying.

    The premultiplied matrix is of the form
    [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

    m: Pointer to matrix to premultiply.

    degrees: Degrees of counter clockwise rotation. Values less
    than zero and greater than 360 are handled as expected.

    Returns m (updated).
    """
    return _mupdf.ll_fz_pre_rotate(m, degrees)

def ll_fz_pre_scale(m, sx, sy):
    r"""
    Low-level wrapper for `::fz_pre_scale()`.
    Scale a matrix by premultiplication.

    m: Pointer to the matrix to scale

    sx, sy: Scaling factors along the X- and Y-axes. A scaling
    factor of 1.0 will not cause any scaling along the relevant
    axis.

    Returns m (updated).
    """
    return _mupdf.ll_fz_pre_scale(m, sx, sy)

def ll_fz_pre_shear(m, sx, sy):
    r"""
    Low-level wrapper for `::fz_pre_shear()`.
    Premultiply a matrix with a shearing matrix.

    The shearing matrix is of the form [ 1 sy sx 1 0 0 ].

    m: pointer to matrix to premultiply

    sx, sy: Shearing factors. A shearing factor of 0.0 will not
    cause any shearing along the relevant axis.

    Returns m (updated).
    """
    return _mupdf.ll_fz_pre_shear(m, sx, sy)

def ll_fz_pre_translate(m, tx, ty):
    r"""
    Low-level wrapper for `::fz_pre_translate()`.
    Translate a matrix by premultiplication.

    m: The matrix to translate

    tx, ty: Translation distances along the X- and Y-axes. A
    translation of 0 will not cause any translation along the
    relevant axis.

    Returns m.
    """
    return _mupdf.ll_fz_pre_translate(m, tx, ty)

def ll_fz_prepare_t3_glyph(font, gid):
    r"""
    Low-level wrapper for `::fz_prepare_t3_glyph()`.
    Force a type3 font to cache the displaylist for a given glyph
    id.

    This caching can involve reading the underlying file, so must
    happen ahead of time, so we aren't suddenly forced to read the
    file while playing a displaylist back.
    """
    return _mupdf.ll_fz_prepare_t3_glyph(font, gid)

def ll_fz_previous_page(doc, loc):
    r"""
    Low-level wrapper for `::fz_previous_page()`.
    Function to get the location of the previous page (allowing for
    the end of chapters etc). If already at the start of the
    document, returns the current page.
    """
    return _mupdf.ll_fz_previous_page(doc, loc)

def ll_fz_print_stext_header_as_html(out):
    r"""Low-level wrapper for `::fz_print_stext_header_as_html()`."""
    return _mupdf.ll_fz_print_stext_header_as_html(out)

def ll_fz_print_stext_header_as_xhtml(out):
    r"""Low-level wrapper for `::fz_print_stext_header_as_xhtml()`."""
    return _mupdf.ll_fz_print_stext_header_as_xhtml(out)

def ll_fz_print_stext_page_as_html(out, page, id):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_html()`.
    Output structured text to a file in HTML (visual) format.
    """
    return _mupdf.ll_fz_print_stext_page_as_html(out, page, id)

def ll_fz_print_stext_page_as_json(out, page, scale):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_json()`.
    Output structured text to a file in JSON format.
    """
    return _mupdf.ll_fz_print_stext_page_as_json(out, page, scale)

def ll_fz_print_stext_page_as_text(out, page):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_text()`.
    Output structured text to a file in plain-text UTF-8 format.
    """
    return _mupdf.ll_fz_print_stext_page_as_text(out, page)

def ll_fz_print_stext_page_as_xhtml(out, page, id):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_xhtml()`.
    Output structured text to a file in XHTML (semantic) format.
    """
    return _mupdf.ll_fz_print_stext_page_as_xhtml(out, page, id)

def ll_fz_print_stext_page_as_xml(out, page, id):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_xml()`.
    Output structured text to a file in XML format.
    """
    return _mupdf.ll_fz_print_stext_page_as_xml(out, page, id)

def ll_fz_print_stext_trailer_as_html(out):
    r"""Low-level wrapper for `::fz_print_stext_trailer_as_html()`."""
    return _mupdf.ll_fz_print_stext_trailer_as_html(out)

def ll_fz_print_stext_trailer_as_xhtml(out):
    r"""Low-level wrapper for `::fz_print_stext_trailer_as_xhtml()`."""
    return _mupdf.ll_fz_print_stext_trailer_as_xhtml(out)

def ll_fz_process_opened_pages(doc, process_openend_page, state):
    r"""
    Low-level wrapper for `::fz_process_opened_pages()`.
    Iterates over all opened pages of the document, calling the
    provided callback for each page for processing. If the callback
    returns non-NULL then the iteration stops and that value is returned
    to the called of fz_process_opened_pages().

    The state pointer provided to fz_process_opened_pages() is
    passed on to the callback but is owned by the caller.

    Returns the first non-NULL value returned by the callback,
    or NULL if the callback returned NULL for all opened pages.
    """
    return _mupdf.ll_fz_process_opened_pages(doc, process_openend_page, state)

def ll_fz_process_shade(shade, ctm, scissor, prepare, process, process_arg):
    r"""
    Low-level wrapper for `::fz_process_shade()`.
    Process a shade, using supplied callback functions. This
    decomposes the shading to a mesh (even ones that are not
    natively meshes, such as linear or radial shadings), and
    processes triangles from those meshes.

    shade: The shade to process.

    ctm: The transform to use

    prepare: Callback function to 'prepare' each vertex.
    This function is passed an array of floats, and populates
    a fz_vertex structure.

    process: This function is passed 3 pointers to vertex
    structures, and actually performs the processing (typically
    filling the area between the vertexes).

    process_arg: An opaque argument passed through from caller
    to callback functions.
    """
    return _mupdf.ll_fz_process_shade(shade, ctm, scissor, prepare, process, process_arg)

def ll_fz_ptr_heap_insert(heap, v, HEAP_CMP):
    r"""Low-level wrapper for `::fz_ptr_heap_insert()`."""
    return _mupdf.ll_fz_ptr_heap_insert(heap, v, HEAP_CMP)

def ll_fz_ptr_heap_sort(heap, HEAP_CMP):
    r"""Low-level wrapper for `::fz_ptr_heap_sort()`."""
    return _mupdf.ll_fz_ptr_heap_sort(heap, HEAP_CMP)

def ll_fz_ptr_heap_uniq(heap, HEAP_CMP):
    r"""Low-level wrapper for `::fz_ptr_heap_uniq()`."""
    return _mupdf.ll_fz_ptr_heap_uniq(heap, HEAP_CMP)

def ll_fz_purge_glyph_cache():
    r"""
    Low-level wrapper for `::fz_purge_glyph_cache()`.
    Purge all the glyphs from the cache.
    """
    return _mupdf.ll_fz_purge_glyph_cache()

def ll_fz_quad_from_rect(r):
    r"""
    Low-level wrapper for `::fz_quad_from_rect()`.
    Convert a rect to a quad (losslessly).
    """
    return _mupdf.ll_fz_quad_from_rect(r)

def ll_fz_quadto(path, x0, y0, x1, y1):
    r"""
    Low-level wrapper for `::fz_quadto()`.
    Append a 'quadto' command to an open path. (For a
    quadratic bezier).

    path: The path to modify.

    x0, y0: The control coordinates for the quadratic curve.

    x1, y1: The end coordinates for the quadratic curve.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_quadto(path, x0, y0, x1, y1)

def ll_fz_read(stm, data, len):
    r"""
    Low-level wrapper for `::fz_read()`.
    Read from a stream into a given data block.

    stm: The stream to read from.

    data: The data block to read into.

    len: The length of the data block (in bytes).

    Returns the number of bytes read. May throw exceptions.
    """
    return _mupdf.ll_fz_read(stm, data, len)

def ll_fz_read_all(stm, initial):
    r"""
    Low-level wrapper for `::fz_read_all()`.
    Read all of a stream into a buffer.

    stm: The stream to read from

    initial: Suggested initial size for the buffer.

    Returns a buffer created from reading from the stream. May throw
    exceptions on failure to allocate.
    """
    return _mupdf.ll_fz_read_all(stm, initial)

def ll_fz_read_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_read_archive_entry()`.
    Reads all bytes in an archive entry
    into a buffer.

    name: Entry name to look for, this must be an exact match to
    the entry name in the archive.

    Throws an exception if a matching entry cannot be found.
    """
    return _mupdf.ll_fz_read_archive_entry(arch, name)

def ll_fz_read_best(stm, initial, truncated, worst_case):
    r"""
     Low-level wrapper for `::fz_read_best()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_read_best(::fz_stream *stm, size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`

    	Attempt to read a stream into a buffer. If truncated
    	is NULL behaves as fz_read_all, sets a truncated flag in case of
    	error.

    	stm: The stream to read from.

    	initial: Suggested initial size for the buffer.

    	truncated: Flag to store success/failure indication in.

    	worst_case: 0 for unknown, otherwise an upper bound for the
    	size of the stream.

    	Returns a buffer created from reading from the stream.
    """
    return _mupdf.ll_fz_read_best(stm, initial, truncated, worst_case)

def ll_fz_read_bits(stm, n):
    r"""
    Low-level wrapper for `::fz_read_bits()`.
    Read the next n bits from a stream (assumed to
    be packed most significant bit first).

    stm: The stream to read from.

    n: The number of bits to read, between 1 and 8*sizeof(int)
    inclusive.

    Returns -1 for EOF, or the required number of bits.
    """
    return _mupdf.ll_fz_read_bits(stm, n)

def ll_fz_read_byte(stm):
    r"""
    Low-level wrapper for `::fz_read_byte()`.
    Read the next byte from a stream.

    stm: The stream t read from.

    Returns -1 for end of stream, or the next byte. May
    throw exceptions.
    """
    return _mupdf.ll_fz_read_byte(stm)

def ll_fz_read_file(filename):
    r"""
    Low-level wrapper for `::fz_read_file()`.
    Read all the contents of a file into a buffer.
    """
    return _mupdf.ll_fz_read_file(filename)

def ll_fz_read_float(stm):
    r"""Low-level wrapper for `::fz_read_float()`."""
    return _mupdf.ll_fz_read_float(stm)

def ll_fz_read_float_le(stm):
    r"""Low-level wrapper for `::fz_read_float_le()`."""
    return _mupdf.ll_fz_read_float_le(stm)

def ll_fz_read_int16(stm):
    r"""Low-level wrapper for `::fz_read_int16()`."""
    return _mupdf.ll_fz_read_int16(stm)

def ll_fz_read_int16_le(stm):
    r"""Low-level wrapper for `::fz_read_int16_le()`."""
    return _mupdf.ll_fz_read_int16_le(stm)

def ll_fz_read_int32(stm):
    r"""Low-level wrapper for `::fz_read_int32()`."""
    return _mupdf.ll_fz_read_int32(stm)

def ll_fz_read_int32_le(stm):
    r"""Low-level wrapper for `::fz_read_int32_le()`."""
    return _mupdf.ll_fz_read_int32_le(stm)

def ll_fz_read_int64(stm):
    r"""Low-level wrapper for `::fz_read_int64()`."""
    return _mupdf.ll_fz_read_int64(stm)

def ll_fz_read_int64_le(stm):
    r"""Low-level wrapper for `::fz_read_int64_le()`."""
    return _mupdf.ll_fz_read_int64_le(stm)

def ll_fz_read_line(stm, buf, max):
    r"""
    Low-level wrapper for `::fz_read_line()`.
    Read a line from stream into the buffer until either a
    terminating newline or EOF, which it replaces with a null byte
    ('').

    Returns buf on success, and NULL when end of file occurs while
    no characters have been read.
    """
    return _mupdf.ll_fz_read_line(stm, buf, max)

def ll_fz_read_rbits(stm, n):
    r"""
    Low-level wrapper for `::fz_read_rbits()`.
    Read the next n bits from a stream (assumed to
    be packed least significant bit first).

    stm: The stream to read from.

    n: The number of bits to read, between 1 and 8*sizeof(int)
    inclusive.

    Returns (unsigned int)-1 for EOF, or the required number of bits.
    """
    return _mupdf.ll_fz_read_rbits(stm, n)

def ll_fz_read_rune(_in):
    r"""
    Low-level wrapper for `::fz_read_rune()`.
    Read a utf-8 rune from a stream.

    In the event of encountering badly formatted utf-8 codes
    (such as a leading code with an unexpected number of following
    codes) no error/exception is given, but undefined values may be
    returned.
    """
    return _mupdf.ll_fz_read_rune(_in)

def ll_fz_read_string(stm, buffer, len):
    r"""
    Low-level wrapper for `::fz_read_string()`.
    Read a null terminated string from the stream into
    a buffer of a given length. The buffer will be null terminated.
    Throws on failure (including the failure to fit the entire
    string including the terminator into the buffer).
    """
    return _mupdf.ll_fz_read_string(stm, buffer, len)

def ll_fz_read_uint16(stm):
    r"""
    Low-level wrapper for `::fz_read_uint16()`.
    fz_read_[u]int(16|24|32|64)(_le)?

    Read a 16/32/64 bit signed/unsigned integer from stream,
    in big or little-endian byte orders.

    Throws an exception if EOF is encountered.
    """
    return _mupdf.ll_fz_read_uint16(stm)

def ll_fz_read_uint16_le(stm):
    r"""Low-level wrapper for `::fz_read_uint16_le()`."""
    return _mupdf.ll_fz_read_uint16_le(stm)

def ll_fz_read_uint24(stm):
    r"""Low-level wrapper for `::fz_read_uint24()`."""
    return _mupdf.ll_fz_read_uint24(stm)

def ll_fz_read_uint24_le(stm):
    r"""Low-level wrapper for `::fz_read_uint24_le()`."""
    return _mupdf.ll_fz_read_uint24_le(stm)

def ll_fz_read_uint32(stm):
    r"""Low-level wrapper for `::fz_read_uint32()`."""
    return _mupdf.ll_fz_read_uint32(stm)

def ll_fz_read_uint32_le(stm):
    r"""Low-level wrapper for `::fz_read_uint32_le()`."""
    return _mupdf.ll_fz_read_uint32_le(stm)

def ll_fz_read_uint64(stm):
    r"""Low-level wrapper for `::fz_read_uint64()`."""
    return _mupdf.ll_fz_read_uint64(stm)

def ll_fz_read_uint64_le(stm):
    r"""Low-level wrapper for `::fz_read_uint64_le()`."""
    return _mupdf.ll_fz_read_uint64_le(stm)

def ll_fz_read_utf16_be(stm):
    r"""Low-level wrapper for `::fz_read_utf16_be()`."""
    return _mupdf.ll_fz_read_utf16_be(stm)

def ll_fz_read_utf16_le(stm):
    r"""
    Low-level wrapper for `::fz_read_utf16_le()`.
    Read a utf-16 rune from a stream. (little endian and
    big endian respectively).

    In the event of encountering badly formatted utf-16 codes
    (mismatched surrogates) no error/exception is given, but
    undefined values may be returned.
    """
    return _mupdf.ll_fz_read_utf16_le(stm)

def ll_fz_realloc(p, size):
    r"""
    Low-level wrapper for `::fz_realloc()`.
    Reallocates a block of memory to given size. Existing contents
    up to min(old_size,new_size) are maintained. The rest of the
    block is uninitialised.

    fz_realloc(ctx, NULL, size) behaves like fz_malloc(ctx, size).

    fz_realloc(ctx, p, 0); behaves like fz_free(ctx, p).

    Throws exception in the event of failure to allocate.
    """
    return _mupdf.ll_fz_realloc(p, size)

def ll_fz_realloc_no_throw(p, size):
    r"""
    Low-level wrapper for `::fz_realloc_no_throw()`.
    fz_realloc equivalent that returns NULL rather than throwing
    exceptions.
    """
    return _mupdf.ll_fz_realloc_no_throw(p, size)

def ll_fz_realpath(path, resolved_path):
    r"""
    Low-level wrapper for `::fz_realpath()`.
    Resolve a path to an absolute file name.
    The resolved path buffer must be of at least PATH_MAX size.
    """
    return _mupdf.ll_fz_realpath(path, resolved_path)

def ll_fz_recognize_document(magic):
    r"""
    Low-level wrapper for `::fz_recognize_document()`.
    Given a magic find a document handler that can handle a
    document of this type.

    magic: Can be a filename extension (including initial period) or
    a mimetype.
    """
    return _mupdf.ll_fz_recognize_document(magic)

def ll_fz_recognize_document_content(filename):
    r"""
    Low-level wrapper for `::fz_recognize_document_content()`.
    Given a filename find a document handler that can handle a
    document of this type.

    filename: The filename of the document. This will be opened and sampled
    to check data.
    """
    return _mupdf.ll_fz_recognize_document_content(filename)

def ll_fz_recognize_document_stream_and_dir_content(stream, dir, magic):
    r"""
    Low-level wrapper for `::fz_recognize_document_stream_and_dir_content()`.
    Given a magic find a document handler that can handle a
    document of this type.

    stream: the file stream to sample. May be NULL if the document is
    a directory.

    dir: an fz_archive representing the directory from which the
    stream was opened (or NULL).

    magic: Can be a filename extension (including initial period) or
    a mimetype.
    """
    return _mupdf.ll_fz_recognize_document_stream_and_dir_content(stream, dir, magic)

def ll_fz_recognize_document_stream_content(stream, magic):
    r"""
    Low-level wrapper for `::fz_recognize_document_stream_content()`.
    Given a magic find a document handler that can handle a
    document of this type.

    stream: the file stream to sample. May be NULL if the document is
    a directory.

    magic: Can be a filename extension (including initial period) or
    a mimetype.
    """
    return _mupdf.ll_fz_recognize_document_stream_content(stream, magic)

def ll_fz_recognize_image_format(p):
    r"""
    Low-level wrapper for `::fz_recognize_image_format()`.
    Recognise image format strings in the first 8 bytes from image
    data.
    """
    return _mupdf.ll_fz_recognize_image_format(p)

def ll_fz_rect_from_irect(bbox):
    r"""
    Low-level wrapper for `::fz_rect_from_irect()`.
    Convert a bbox into a rect.

    For our purposes, a rect can represent all the values we meet in
    a bbox, so nothing can go wrong.

    rect: A place to store the generated rectangle.

    bbox: The bbox to convert.

    Returns rect (updated).
    """
    return _mupdf.ll_fz_rect_from_irect(bbox)

def ll_fz_rect_from_quad(q):
    r"""
    Low-level wrapper for `::fz_rect_from_quad()`.
    Convert a quad to the smallest rect that covers it.
    """
    return _mupdf.ll_fz_rect_from_quad(q)

def ll_fz_rectto(path, x0, y0, x1, y1):
    r"""
    Low-level wrapper for `::fz_rectto()`.
    Append a 'rectto' command to an open path.

    The rectangle is equivalent to:
    	moveto x0 y0
    	lineto x1 y0
    	lineto x1 y1
    	lineto x0 y1
    	closepath

    path: The path to modify.

    x0, y0: First corner of the rectangle.

    x1, y1: Second corner of the rectangle.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_rectto(path, x0, y0, x1, y1)

def ll_fz_register_archive_handler(handler):
    r"""Low-level wrapper for `::fz_register_archive_handler()`."""
    return _mupdf.ll_fz_register_archive_handler(handler)

def ll_fz_register_document_handler(handler):
    r"""
    Low-level wrapper for `::fz_register_document_handler()`.
    Register a handler for a document type.

    handler: The handler to register. This must live on for the duration of the
    use of this handler. It will be passed back to the handler for calls so
    the caller can use it to retrieve state.
    """
    return _mupdf.ll_fz_register_document_handler(handler)

def ll_fz_register_document_handlers():
    r"""
    Low-level wrapper for `::fz_register_document_handlers()`.
    Register handlers for all the standard document types supported in
    this build.
    """
    return _mupdf.ll_fz_register_document_handlers()

def ll_fz_remove_item(drop, key, type):
    r"""
    Low-level wrapper for `::fz_remove_item()`.
    Remove an item from the store.

    If an item indexed by the given key exists in the store, remove
    it.

    drop: The function used to free the value (to ensure we get a
    value of the correct type).

    key: The key used to find the item to remove.

    type: Functions used to manipulate the key.
    """
    return _mupdf.ll_fz_remove_item(drop, key, type)

def ll_fz_render_flags(dev, set, clear):
    r"""Low-level wrapper for `::fz_render_flags()`."""
    return _mupdf.ll_fz_render_flags(dev, set, clear)

def ll_fz_render_glyph_pixmap(font, gid, ctm, scissor, aa):
    r"""
    Low-level wrapper for `::fz_render_glyph_pixmap()`.
    Create a pixmap containing a rendered glyph.

    Lookup gid from font, clip it with scissor, and rendering it
    with aa bits of antialiasing into a new pixmap.

    The caller takes ownership of the pixmap and so must free it.

    Note: This function is no longer used for normal rendering
    operations, and is kept around just because we use it in the
    app. It should be considered "at risk" of removal from the API.
    """
    return _mupdf.ll_fz_render_glyph_pixmap(font, gid, ctm, scissor, aa)

def ll_fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs):
    r"""
    Low-level wrapper for `::fz_render_t3_glyph_direct()`.
    Nasty PDF interpreter specific hernia, required to allow the
    interpreter to replay glyphs from a type3 font directly into
    the target device.

    This is only used in exceptional circumstances (such as type3
    glyphs that inherit current graphics state, or nested type3
    glyphs).
    """
    return _mupdf.ll_fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs)

def ll_fz_rendering_intent_name(ri):
    r"""
    Low-level wrapper for `::fz_rendering_intent_name()`.
    Map from enumerated rendering intent to string.

    The returned string is static and therefore must not be freed.
    """
    return _mupdf.ll_fz_rendering_intent_name(ri)

def ll_fz_report_error():
    r"""Low-level wrapper for `::fz_report_error()`."""
    return _mupdf.ll_fz_report_error()

def ll_fz_reset_output(arg_1):
    r"""
    Low-level wrapper for `::fz_reset_output()`.
    Reset a closed output stream. Returns state to
    (broadly) that which it was in when opened. Not
    all outputs can be reset, so this may throw an
    exception.
    """
    return _mupdf.ll_fz_reset_output(arg_1)

def ll_fz_reset_story(story):
    r"""Low-level wrapper for `::fz_reset_story()`."""
    return _mupdf.ll_fz_reset_story(story)

def ll_fz_resize_buffer(buf, capacity):
    r"""
    Low-level wrapper for `::fz_resize_buffer()`.
    Ensure that a buffer has a given capacity,
    truncating data if required.

    capacity: The desired capacity for the buffer. If the current
    size of the buffer contents is smaller than capacity, it is
    truncated.
    """
    return _mupdf.ll_fz_resize_buffer(buf, capacity)

def ll_fz_resolve_link(doc, uri, xp, yp):
    r"""
     Low-level wrapper for `::fz_resolve_link()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_resolve_link(::fz_document *doc, const char *uri)` => `(fz_location, float xp, float yp)`

    	Resolve an internal link to a page number.

    	xp, yp: Pointer to store coordinate of destination on the page.

    	Returns (-1,-1) if the URI cannot be resolved.
    """
    return _mupdf.ll_fz_resolve_link(doc, uri, xp, yp)

def ll_fz_resolve_link_dest(doc, uri):
    r"""
    Low-level wrapper for `::fz_resolve_link_dest()`.
    Resolve an internal link to a page number, location, and possible viewing parameters.

    Returns location (-1,-1) if the URI cannot be resolved.
    """
    return _mupdf.ll_fz_resolve_link_dest(doc, uri)

def ll_fz_rethrow():
    r"""Low-level wrapper for `::fz_rethrow()`."""
    return _mupdf.ll_fz_rethrow()

def ll_fz_rethrow_if(errcode):
    r"""
    Low-level wrapper for `::fz_rethrow_if()`.
    Within an fz_catch() block, rethrow the current exception
    if the errcode of the current exception matches.

    This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.ll_fz_rethrow_if(errcode)

def ll_fz_rethrow_unless(errcode):
    r"""Low-level wrapper for `::fz_rethrow_unless()`."""
    return _mupdf.ll_fz_rethrow_unless(errcode)

def ll_fz_rotate(degrees):
    r"""
    Low-level wrapper for `::fz_rotate()`.
    Create a rotation matrix.

    The returned matrix is of the form
    [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

    m: Pointer to place to store matrix

    degrees: Degrees of counter clockwise rotation. Values less
    than zero and greater than 360 are handled as expected.

    Returns m.
    """
    return _mupdf.ll_fz_rotate(degrees)

def ll_fz_round_rect(rect):
    r"""
    Low-level wrapper for `::fz_round_rect()`.
    Round rectangle coordinates.

    Coordinates in a bounding box are integers, so rounding of the
    rects coordinates takes place. The top left corner is rounded
    upwards and left while the bottom right corner is rounded
    downwards and to the right.

    This differs from fz_irect_from_rect, in that fz_irect_from_rect
    slavishly follows the numbers (i.e any slight over/under
    calculations can cause whole extra pixels to be added).
    fz_round_rect allows for a small amount of rounding error when
    calculating the bbox.
    """
    return _mupdf.ll_fz_round_rect(rect)

def ll_fz_run_display_list(list, dev, ctm, scissor, cookie):
    r"""
    Low-level wrapper for `::fz_run_display_list()`.
    (Re)-run a display list through a device.

    list: A display list, created by fz_new_display_list and
    populated with objects from a page by running fz_run_page on a
    device obtained from fz_new_list_device.

    ctm: Transform to apply to display list contents. May include
    for example scaling and rotation, see fz_scale, fz_rotate and
    fz_concat. Set to fz_identity if no transformation is desired.

    scissor: Only the part of the contents of the display list
    visible within this area will be considered when the list is
    run through the device. This does not imply for tile objects
    contained in the display list.

    cookie: Communication mechanism between caller and library
    running the page. Intended for multi-threaded applications,
    while single-threaded applications set cookie to NULL. The
    caller may abort an ongoing page run. Cookie also communicates
    progress information back to the caller. The fields inside
    cookie are continually updated while the page is being run.
    """
    return _mupdf.ll_fz_run_display_list(list, dev, ctm, scissor, cookie)

def ll_fz_run_document_structure(doc, dev, cookie):
    r"""
    Low-level wrapper for `::fz_run_document_structure()`.
    Run the document structure through a device.

    doc: Document in question.

    dev: Device obtained from fz_new_*_device.

    cookie: Communication mechanism between caller and library.
    Intended for multi-threaded applications, while
    single-threaded applications set cookie to NULL. The
    caller may abort an ongoing rendering of a page. Cookie also
    communicates progress information back to the caller. The
    fields inside cookie are continually updated while the page is
    rendering.
    """
    return _mupdf.ll_fz_run_document_structure(doc, dev, cookie)

def ll_fz_run_page(page, dev, transform, cookie):
    r"""
    Low-level wrapper for `::fz_run_page()`.
    Run a page through a device.

    page: Page obtained from fz_load_page.

    dev: Device obtained from fz_new_*_device.

    transform: Transform to apply to page. May include for example
    scaling and rotation, see fz_scale, fz_rotate and fz_concat.
    Set to fz_identity if no transformation is desired.

    cookie: Communication mechanism between caller and library
    rendering the page. Intended for multi-threaded applications,
    while single-threaded applications set cookie to NULL. The
    caller may abort an ongoing rendering of a page. Cookie also
    communicates progress information back to the caller. The
    fields inside cookie are continually updated while the page is
    rendering.
    """
    return _mupdf.ll_fz_run_page(page, dev, transform, cookie)

def ll_fz_run_page_annots(page, dev, transform, cookie):
    r"""
    Low-level wrapper for `::fz_run_page_annots()`.
    Run the annotations on a page through a device.
    """
    return _mupdf.ll_fz_run_page_annots(page, dev, transform, cookie)

def ll_fz_run_page_contents(page, dev, transform, cookie):
    r"""
    Low-level wrapper for `::fz_run_page_contents()`.
    Run a page through a device. Just the main
    page content, without the annotations, if any.

    page: Page obtained from fz_load_page.

    dev: Device obtained from fz_new_*_device.

    transform: Transform to apply to page. May include for example
    scaling and rotation, see fz_scale, fz_rotate and fz_concat.
    Set to fz_identity if no transformation is desired.

    cookie: Communication mechanism between caller and library
    rendering the page. Intended for multi-threaded applications,
    while single-threaded applications set cookie to NULL. The
    caller may abort an ongoing rendering of a page. Cookie also
    communicates progress information back to the caller. The
    fields inside cookie are continually updated while the page is
    rendering.
    """
    return _mupdf.ll_fz_run_page_contents(page, dev, transform, cookie)

def ll_fz_run_page_widgets(page, dev, transform, cookie):
    r"""
    Low-level wrapper for `::fz_run_page_widgets()`.
    Run the widgets on a page through a device.
    """
    return _mupdf.ll_fz_run_page_widgets(page, dev, transform, cookie)

def ll_fz_run_t3_glyph(font, gid, trm, dev):
    r"""
    Low-level wrapper for `::fz_run_t3_glyph()`.
    Run a glyph from a Type3 font to
    a given device.

    font: The font to find the glyph in.

    gid: The glyph to run.

    trm: The transform to apply.

    dev: The device to render onto.
    """
    return _mupdf.ll_fz_run_t3_glyph(font, gid, trm, dev)

def ll_fz_runeidx(str, p):
    r"""
    Low-level wrapper for `::fz_runeidx()`.
    Compute the index of a rune in a string.

    str: Pointer to beginning of a string.

    p: Pointer to a char in str.

    Returns the index of the rune pointed to by p in str.
    """
    return _mupdf.ll_fz_runeidx(str, p)

def ll_fz_runelen(rune):
    r"""
    Low-level wrapper for `::fz_runelen()`.
    Count how many chars are required to represent a rune.

    rune: The rune to encode.

    Returns the number of bytes required to represent this run in
    UTF8.
    """
    return _mupdf.ll_fz_runelen(rune)

def ll_fz_runeptr(str, idx):
    r"""
    Low-level wrapper for `::fz_runeptr()`.
    Obtain a pointer to the char representing the rune
    at a given index.

    str: Pointer to beginning of a string.

    idx: Index of a rune to return a char pointer to.

    Returns a pointer to the char where the desired rune starts,
    or NULL if the string ends before the index is reached.
    """
    return _mupdf.ll_fz_runeptr(str, idx)

def ll_fz_runetochar(str, rune):
    r"""
    Low-level wrapper for `::fz_runetochar()`.
    UTF8 encode a rune to a sequence of chars.

    str: Pointer to a place to put the UTF8 encoded character.

    rune: Pointer to a 'rune'.

    Returns the number of bytes the rune took to output.
    """
    return _mupdf.ll_fz_runetochar(str, rune)

def ll_fz_samples_get(pixmap, offset):
    r"""
     Low-level wrapper for `::fz_samples_get()`.
    Provides simple (but slow) access to pixmap data from Python and C#.
    """
    return _mupdf.ll_fz_samples_get(pixmap, offset)

def ll_fz_samples_set(pixmap, offset, value):
    r"""
     Low-level wrapper for `::fz_samples_set()`.
    Provides simple (but slow) write access to pixmap data from Python and
    C#.
    """
    return _mupdf.ll_fz_samples_set(pixmap, offset, value)

def ll_fz_save_accelerator(doc, accel):
    r"""
    Low-level wrapper for `::fz_save_accelerator()`.
    Save accelerator data for the document to a given file.
    """
    return _mupdf.ll_fz_save_accelerator(doc, accel)

def ll_fz_save_bitmap_as_pbm(bitmap, filename):
    r"""
    Low-level wrapper for `::fz_save_bitmap_as_pbm()`.
    Save a bitmap as a pbm.
    """
    return _mupdf.ll_fz_save_bitmap_as_pbm(bitmap, filename)

def ll_fz_save_bitmap_as_pcl(bitmap, filename, append, pcl):
    r"""
    Low-level wrapper for `::fz_save_bitmap_as_pcl()`.
    Save a bitmap as mono PCL.
    """
    return _mupdf.ll_fz_save_bitmap_as_pcl(bitmap, filename, append, pcl)

def ll_fz_save_bitmap_as_pkm(bitmap, filename):
    r"""
    Low-level wrapper for `::fz_save_bitmap_as_pkm()`.
    Save a CMYK bitmap as a pkm.
    """
    return _mupdf.ll_fz_save_bitmap_as_pkm(bitmap, filename)

def ll_fz_save_bitmap_as_pwg(bitmap, filename, append, pwg):
    r"""
    Low-level wrapper for `::fz_save_bitmap_as_pwg()`.
    Save a bitmap as a PWG.
    """
    return _mupdf.ll_fz_save_bitmap_as_pwg(bitmap, filename, append, pwg)

def ll_fz_save_buffer(buf, filename):
    r"""
    Low-level wrapper for `::fz_save_buffer()`.
    Save the contents of a buffer to a file.
    """
    return _mupdf.ll_fz_save_buffer(buf, filename)

def ll_fz_save_pixmap_as_jpeg(pixmap, filename, quality):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_jpeg()`.
    Save a pixmap as a JPEG.
    """
    return _mupdf.ll_fz_save_pixmap_as_jpeg(pixmap, filename, quality)

def ll_fz_save_pixmap_as_jpx(pixmap, filename, q):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_jpx()`.
    Save pixmap data as JP2K with no subsampling.

    quality = 100 = lossless
    otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
    """
    return _mupdf.ll_fz_save_pixmap_as_jpx(pixmap, filename, q)

def ll_fz_save_pixmap_as_pam(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pam()`.
    Save a pixmap as a pnm (greyscale, rgb or cmyk, with or without
    alpha).
    """
    return _mupdf.ll_fz_save_pixmap_as_pam(pixmap, filename)

def ll_fz_save_pixmap_as_pbm(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pbm()`.
    Save a pixmap as a pbm. (Performing halftoning).
    """
    return _mupdf.ll_fz_save_pixmap_as_pbm(pixmap, filename)

def ll_fz_save_pixmap_as_pcl(pixmap, filename, append, pcl):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pcl()`.
    Save an (RGB) pixmap as color PCL.
    """
    return _mupdf.ll_fz_save_pixmap_as_pcl(pixmap, filename, append, pcl)

def ll_fz_save_pixmap_as_pclm(pixmap, filename, append, options):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pclm()`.
    Save a (Greyscale or RGB) pixmap as pclm.
    """
    return _mupdf.ll_fz_save_pixmap_as_pclm(pixmap, filename, append, options)

def ll_fz_save_pixmap_as_pdfocr(pixmap, filename, append, options):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pdfocr()`.
    Save a (Greyscale or RGB) pixmap as pdfocr.
    """
    return _mupdf.ll_fz_save_pixmap_as_pdfocr(pixmap, filename, append, options)

def ll_fz_save_pixmap_as_pkm(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pkm()`.
    Save a CMYK pixmap as a pkm. (Performing halftoning).
    """
    return _mupdf.ll_fz_save_pixmap_as_pkm(pixmap, filename)

def ll_fz_save_pixmap_as_png(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_png()`.
    Save a (Greyscale or RGB) pixmap as a png.
    """
    return _mupdf.ll_fz_save_pixmap_as_png(pixmap, filename)

def ll_fz_save_pixmap_as_pnm(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pnm()`.
    Save a pixmap as a pnm (greyscale or rgb, no alpha).
    """
    return _mupdf.ll_fz_save_pixmap_as_pnm(pixmap, filename)

def ll_fz_save_pixmap_as_ps(pixmap, filename, append):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_ps()`.
    Save a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
    """
    return _mupdf.ll_fz_save_pixmap_as_ps(pixmap, filename, append)

def ll_fz_save_pixmap_as_psd(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_psd()`.
    Save a pixmap as a PSD file.
    """
    return _mupdf.ll_fz_save_pixmap_as_psd(pixmap, filename)

def ll_fz_save_pixmap_as_pwg(pixmap, filename, append, pwg):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pwg()`.
    Save a pixmap as a PWG.
    """
    return _mupdf.ll_fz_save_pixmap_as_pwg(pixmap, filename, append, pwg)

def ll_fz_save_xml(root, path, indented):
    r"""
    Low-level wrapper for `::fz_save_xml()`.
    As for fz_write_xml, but direct to a file.
    """
    return _mupdf.ll_fz_save_xml(root, path, indented)

def ll_fz_scale(sx, sy):
    r"""
    Low-level wrapper for `::fz_scale()`.
    Create a scaling matrix.

    The returned matrix is of the form [ sx 0 0 sy 0 0 ].

    m: Pointer to the matrix to populate

    sx, sy: Scaling factors along the X- and Y-axes. A scaling
    factor of 1.0 will not cause any scaling along the relevant
    axis.

    Returns m.
    """
    return _mupdf.ll_fz_scale(sx, sy)

def ll_fz_scale_pixmap(src, x, y, w, h, clip):
    r"""Low-level wrapper for `::fz_scale_pixmap()`."""
    return _mupdf.ll_fz_scale_pixmap(src, x, y, w, h, clip)

def ll_fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_chapter_page_number()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_chapter_page_number(::fz_document *doc, int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.ll_fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_search_chapter_page_number_cb(doc, chapter, page, needle, cb, opaque):
    r"""Low-level wrapper for `::fz_search_chapter_page_number_cb()`."""
    return _mupdf.ll_fz_search_chapter_page_number_cb(doc, chapter, page, needle, cb, opaque)

def ll_fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_display_list()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_display_list(::fz_display_list *list, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.ll_fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_search_display_list_cb(list, needle, cb, opaque):
    r"""Low-level wrapper for `::fz_search_display_list_cb()`."""
    return _mupdf.ll_fz_search_display_list_cb(list, needle, cb, opaque)

def ll_fz_search_page(page, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_page()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_page(::fz_page *page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

    	Search for the 'needle' text on the page.
    	Record the hits in the hit_bbox array and return the number of
    	hits. Will stop looking once it has filled hit_max rectangles.
    """
    return _mupdf.ll_fz_search_page(page, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_search_page2(doc, number, needle, hit_max):
    r"""
     Low-level wrapper for `::fz_search_page2()`.
    C++ alternative to fz_search_page() that returns information in a std::vector.
    """
    return _mupdf.ll_fz_search_page2(doc, number, needle, hit_max)

def ll_fz_search_page_cb(page, needle, cb, opaque):
    r"""
    Low-level wrapper for `::fz_search_page_cb()`.
    Search for the 'needle' text on the page.
    """
    return _mupdf.ll_fz_search_page_cb(page, needle, cb, opaque)

def ll_fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_page_number()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_page_number(::fz_document *doc, int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.ll_fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_search_page_number_cb(doc, number, needle, cb, opaque):
    r"""Low-level wrapper for `::fz_search_page_number_cb()`."""
    return _mupdf.ll_fz_search_page_number_cb(doc, number, needle, cb, opaque)

def ll_fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_stext_page()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_stext_page(::fz_stext_page *text, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

    	Search for occurrence of 'needle' in text page.

    	Return the number of quads and store hit quads in the passed in
    	array.

    	NOTE: This is an experimental interface and subject to change
    	without notice.
    """
    return _mupdf.ll_fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_search_stext_page_cb(text, needle, cb, opaque):
    r"""
    Low-level wrapper for `::fz_search_stext_page_cb()`.
    Search for occurrence of 'needle' in text page.

    Call callback once for each hit. This callback will receive
    (potentially) multiple quads for each hit.

    Returns the number of hits - note that this is potentially
    different from (i.e. is not greater than) the number of quads
    as returned by the non callback API.

    NOTE: This is an experimental interface and subject to change
    without notice.
    """
    return _mupdf.ll_fz_search_stext_page_cb(text, needle, cb, opaque)

def ll_fz_seek(stm, offset, whence):
    r"""
    Low-level wrapper for `::fz_seek()`.
    Seek within a stream.

    stm: The stream to seek within.

    offset: The offset to seek to.

    whence: From where the offset is measured (see fseek).
    SEEK_SET - start of stream.
    SEEK_CUR - current position.
    SEEK_END - end of stream.

    """
    return _mupdf.ll_fz_seek(stm, offset, whence)

def ll_fz_seek_output(out, off, whence):
    r"""
    Low-level wrapper for `::fz_seek_output()`.
    Seek to the specified file position.
    See fseek for arguments.

    Throw an error on unseekable outputs.
    """
    return _mupdf.ll_fz_seek_output(out, off, whence)

def ll_fz_segment_stext_page(page):
    r"""
    Low-level wrapper for `::fz_segment_stext_page()`.
    Perform segmentation analysis on an (unstructured) page to look for
    recursive subdivisions.

    Essentially this code attempts to split the page horizontally and/or
    vertically repeatedly into smaller and smaller "segments" (divisions).

    Returns 0 if no changes were made to the document.

    This is experimental code, and may change (or be removed) in future
    versions!
    """
    return _mupdf.ll_fz_segment_stext_page(page)

def ll_fz_separation_current_behavior(sep, separation):
    r"""
    Low-level wrapper for `::fz_separation_current_behavior()`.
    Test for the current behavior of a separation.
    """
    return _mupdf.ll_fz_separation_current_behavior(sep, separation)

def ll_fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params):
    r"""
     Low-level wrapper for `::fz_separation_equivalent()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_separation_equivalent(const ::fz_separations *seps, int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color

    	Get the equivalent separation color in a given colorspace.
    """
    return _mupdf.ll_fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params)

def ll_fz_separation_name(sep, separation):
    r"""Low-level wrapper for `::fz_separation_name()`."""
    return _mupdf.ll_fz_separation_name(sep, separation)

def ll_fz_set_aa_level(bits):
    r"""
    Low-level wrapper for `::fz_set_aa_level()`.
    Set the number of bits of antialiasing we should
    use (for both text and graphics).

    bits: The number of bits of antialiasing to use (values are
    clamped to within the 0 to 8 range).
    """
    return _mupdf.ll_fz_set_aa_level(bits)

def ll_fz_set_compressed_image_buffer(cimg, buf):
    r"""Low-level wrapper for `::fz_set_compressed_image_buffer()`."""
    return _mupdf.ll_fz_set_compressed_image_buffer(cimg, buf)

def ll_fz_set_default_cmyk(default_cs, cs):
    r"""Low-level wrapper for `::fz_set_default_cmyk()`."""
    return _mupdf.ll_fz_set_default_cmyk(default_cs, cs)

def ll_fz_set_default_colorspaces(dev, default_cs):
    r"""Low-level wrapper for `::fz_set_default_colorspaces()`."""
    return _mupdf.ll_fz_set_default_colorspaces(dev, default_cs)

def ll_fz_set_default_gray(default_cs, cs):
    r"""
    Low-level wrapper for `::fz_set_default_gray()`.
    Set new defaults within the default colorspace structure.

    New references are taken to the new default, and references to
    the old defaults dropped.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_set_default_gray(default_cs, cs)

def ll_fz_set_default_output_intent(default_cs, cs):
    r"""Low-level wrapper for `::fz_set_default_output_intent()`."""
    return _mupdf.ll_fz_set_default_output_intent(default_cs, cs)

def ll_fz_set_default_rgb(default_cs, cs):
    r"""Low-level wrapper for `::fz_set_default_rgb()`."""
    return _mupdf.ll_fz_set_default_rgb(default_cs, cs)

def ll_fz_set_error_callback(error_cb, user):
    r"""
    Low-level wrapper for `::fz_set_error_callback()`.
    Set the error callback. This will be called as part of the
    exception handling.

    The callback must not throw exceptions!
    """
    return _mupdf.ll_fz_set_error_callback(error_cb, user)

def ll_fz_set_font_bbox(font, xmin, ymin, xmax, ymax):
    r"""
    Low-level wrapper for `::fz_set_font_bbox()`.
    Set the font bbox.

    font: The font to set the bbox for.

    xmin, ymin, xmax, ymax: The bounding box.
    """
    return _mupdf.ll_fz_set_font_bbox(font, xmin, ymin, xmax, ymax)

def ll_fz_set_font_embedding(font, embed):
    r"""
    Low-level wrapper for `::fz_set_font_embedding()`.
    Control whether a given font should be embedded or not when writing.
    """
    return _mupdf.ll_fz_set_font_embedding(font, embed)

def ll_fz_set_graphics_aa_level(bits):
    r"""
    Low-level wrapper for `::fz_set_graphics_aa_level()`.
    Set the number of bits of antialiasing we
    should use for graphics.

    bits: The number of bits of antialiasing to use (values are
    clamped to within the 0 to 8 range).
    """
    return _mupdf.ll_fz_set_graphics_aa_level(bits)

def ll_fz_set_graphics_min_line_width(min_line_width):
    r"""
    Low-level wrapper for `::fz_set_graphics_min_line_width()`.
    Set the minimum line width to be
    used for stroked lines.

    min_line_width: The minimum line width to use (in pixels).
    """
    return _mupdf.ll_fz_set_graphics_min_line_width(min_line_width)

def ll_fz_set_link_rect(link, rect):
    r"""Low-level wrapper for `::fz_set_link_rect()`."""
    return _mupdf.ll_fz_set_link_rect(link, rect)

def ll_fz_set_link_uri(link, uri):
    r"""Low-level wrapper for `::fz_set_link_uri()`."""
    return _mupdf.ll_fz_set_link_uri(link, uri)

def ll_fz_set_metadata(doc, key, value):
    r"""Low-level wrapper for `::fz_set_metadata()`."""
    return _mupdf.ll_fz_set_metadata(doc, key, value)

def ll_fz_set_pixmap_image_tile(cimg, pix):
    r"""Low-level wrapper for `::fz_set_pixmap_image_tile()`."""
    return _mupdf.ll_fz_set_pixmap_image_tile(cimg, pix)

def ll_fz_set_pixmap_resolution(pix, xres, yres):
    r"""
    Low-level wrapper for `::fz_set_pixmap_resolution()`.
    Set the pixels per inch resolution of the pixmap.
    """
    return _mupdf.ll_fz_set_pixmap_resolution(pix, xres, yres)

def ll_fz_set_separation_behavior(sep, separation, behavior):
    r"""
    Low-level wrapper for `::fz_set_separation_behavior()`.
    Control the rendering of a given separation.
    """
    return _mupdf.ll_fz_set_separation_behavior(sep, separation, behavior)

def ll_fz_set_stddbg(out):
    r"""
    Low-level wrapper for `::fz_set_stddbg()`.
    Set the output stream to be used for fz_stddbg. Set to NULL to
    reset to default (stderr).
    """
    return _mupdf.ll_fz_set_stddbg(out)

def ll_fz_set_text_aa_level(bits):
    r"""
    Low-level wrapper for `::fz_set_text_aa_level()`.
    Set the number of bits of antialiasing we
    should use for text.

    bits: The number of bits of antialiasing to use (values are
    clamped to within the 0 to 8 range).
    """
    return _mupdf.ll_fz_set_text_aa_level(bits)

def ll_fz_set_use_document_css(use):
    r"""
    Low-level wrapper for `::fz_set_use_document_css()`.
    Toggle whether to respect document styles in HTML and EPUB.
    """
    return _mupdf.ll_fz_set_use_document_css(use)

def ll_fz_set_user_context(user):
    r"""
    Low-level wrapper for `::fz_set_user_context()`.
    Set the user field in the context.

    NULL initially, this field can be set to any opaque value
    required by the user. It is copied on clones.
    """
    return _mupdf.ll_fz_set_user_context(user)

def ll_fz_set_user_css(text):
    r"""
    Low-level wrapper for `::fz_set_user_css()`.
    Set the user stylesheet source text for use with HTML and EPUB.
    """
    return _mupdf.ll_fz_set_user_css(text)

def ll_fz_set_warning_callback(warning_cb, user):
    r"""
    Low-level wrapper for `::fz_set_warning_callback()`.
    Set the warning callback. This will be called as part of the
    exception handling.

    The callback must not throw exceptions!
    """
    return _mupdf.ll_fz_set_warning_callback(warning_cb, user)

def ll_fz_sha256_final(state, digest):
    r"""
    Low-level wrapper for `::fz_sha256_final()`.
    MD5 finalization. Ends an MD5 message-digest operation, writing
    the message digest and zeroizing the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha256_final(state, digest)

def ll_fz_sha256_init(state):
    r"""
    Low-level wrapper for `::fz_sha256_init()`.
    SHA256 initialization. Begins an SHA256 operation, initialising
    the supplied context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha256_init(state)

def ll_fz_sha256_update(state, input, inlen):
    r"""
    Low-level wrapper for `::fz_sha256_update()`.
    SHA256 block update operation. Continues an SHA256 message-
    digest operation, processing another message block, and updating
    the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha256_update(state, input, inlen)

def ll_fz_sha384_final(state, digest):
    r"""
    Low-level wrapper for `::fz_sha384_final()`.
    SHA384 finalization. Ends an SHA384 message-digest operation,
    writing the message digest and zeroizing the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha384_final(state, digest)

def ll_fz_sha384_init(state):
    r"""
    Low-level wrapper for `::fz_sha384_init()`.
    SHA384 initialization. Begins an SHA384 operation, initialising
    the supplied context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha384_init(state)

def ll_fz_sha384_update(state, input, inlen):
    r"""
    Low-level wrapper for `::fz_sha384_update()`.
    SHA384 block update operation. Continues an SHA384 message-
    digest operation, processing another message block, and updating
    the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha384_update(state, input, inlen)

def ll_fz_sha512_final(state, digest):
    r"""
    Low-level wrapper for `::fz_sha512_final()`.
    SHA512 finalization. Ends an SHA512 message-digest operation,
    writing the message digest and zeroizing the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha512_final(state, digest)

def ll_fz_sha512_init(state):
    r"""
    Low-level wrapper for `::fz_sha512_init()`.
    SHA512 initialization. Begins an SHA512 operation, initialising
    the supplied context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha512_init(state)

def ll_fz_sha512_update(state, input, inlen):
    r"""
    Low-level wrapper for `::fz_sha512_update()`.
    SHA512 block update operation. Continues an SHA512 message-
    digest operation, processing another message block, and updating
    the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha512_update(state, input, inlen)

def ll_fz_shear(sx, sy):
    r"""
    Low-level wrapper for `::fz_shear()`.
    Create a shearing matrix.

    The returned matrix is of the form [ 1 sy sx 1 0 0 ].

    m: pointer to place to store returned matrix

    sx, sy: Shearing factors. A shearing factor of 0.0 will not
    cause any shearing along the relevant axis.

    Returns m.
    """
    return _mupdf.ll_fz_shear(sx, sy)

def ll_fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language):
    r"""
    Low-level wrapper for `::fz_show_glyph()`.
    Add a glyph/unicode value to a text object.

    text: Text object to add to.

    font: The font the glyph should be added in.

    trm: The transform to use for the glyph.

    glyph: The glyph id to add.

    unicode: The unicode character for the glyph.

    cid: The CJK CID value or raw character code.

    wmode: 1 for vertical mode, 0 for horizontal.

    bidi_level: The bidirectional level for this glyph.

    markup_dir: The direction of the text as specified in the
    markup.

    language: The language in use (if known, 0 otherwise)
    (e.g. FZ_LANG_zh_Hans).

    Throws exception on failure to allocate.
    """
    return _mupdf.ll_fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language)

def ll_fz_show_glyph_aux(text, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang):
    r"""Low-level wrapper for `::fz_show_glyph_aux()`."""
    return _mupdf.ll_fz_show_glyph_aux(text, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang)

def ll_fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language):
    r"""
    Low-level wrapper for `::fz_show_string()`.
    Add a UTF8 string to a text object.

    text: Text object to add to.

    font: The font the string should be added in.

    trm: The transform to use.

    s: The utf-8 string to add.

    wmode: 1 for vertical mode, 0 for horizontal.

    bidi_level: The bidirectional level for this glyph.

    markup_dir: The direction of the text as specified in the markup.

    language: The language in use (if known, 0 otherwise)
    	(e.g. FZ_LANG_zh_Hans).

    Returns the transform updated with the advance width of the
    string.
    """
    return _mupdf.ll_fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language)

def ll_fz_shrink_store(percent):
    r"""
    Low-level wrapper for `::fz_shrink_store()`.
    Evict items from the store until the total size of
    the objects in the store is reduced to a given percentage of its
    current size.

    percent: %age of current size to reduce the store to.

    Returns non zero if we managed to free enough memory, zero
    otherwise.
    """
    return _mupdf.ll_fz_shrink_store(percent)

def ll_fz_skew_detect(pixmap):
    r"""Low-level wrapper for `::fz_skew_detect()`."""
    return _mupdf.ll_fz_skew_detect(pixmap)

def ll_fz_skip(stm, len):
    r"""
    Low-level wrapper for `::fz_skip()`.
    Read from a stream discarding data.

    stm: The stream to read from.

    len: The number of bytes to read.

    Returns the number of bytes read. May throw exceptions.
    """
    return _mupdf.ll_fz_skip(stm, len)

def ll_fz_skip_space(stm):
    r"""
    Low-level wrapper for `::fz_skip_space()`.
    Skip over whitespace (bytes <= 32) in a stream.
    """
    return _mupdf.ll_fz_skip_space(stm)

def ll_fz_skip_string(stm, str):
    r"""
    Low-level wrapper for `::fz_skip_string()`.
    Skip over a given string in a stream. Return 0 if successfully
    skipped, non-zero otherwise. As many characters will be skipped
    over as matched in the string.
    """
    return _mupdf.ll_fz_skip_string(stm, str)

def ll_fz_slice_buffer(buf, start, end):
    r"""
    Low-level wrapper for `::fz_slice_buffer()`.
    Create a new buffer with a (subset of) the data from the buffer.

    start: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

    end: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

    """
    return _mupdf.ll_fz_slice_buffer(buf, start, end)

def ll_fz_snap_selection(page, ap, bp, mode):
    r"""Low-level wrapper for `::fz_snap_selection()`."""
    return _mupdf.ll_fz_snap_selection(page, ap, bp, mode)

def ll_fz_start_throw_on_repair():
    r"""Low-level wrapper for `::fz_start_throw_on_repair()`."""
    return _mupdf.ll_fz_start_throw_on_repair()

def ll_fz_stat_ctime(path):
    r"""Low-level wrapper for `::fz_stat_ctime()`."""
    return _mupdf.ll_fz_stat_ctime(path)

def ll_fz_stat_mtime(path):
    r"""Low-level wrapper for `::fz_stat_mtime()`."""
    return _mupdf.ll_fz_stat_mtime(path)

def ll_fz_stddbg():
    r"""
    Low-level wrapper for `::fz_stddbg()`.
    Retrieve an fz_output for the default debugging stream. On
    Windows this will be OutputDebugString for non-console apps.
    Otherwise, it is always fz_stderr.

    Optionally may be fz_dropped when finished with.
    """
    return _mupdf.ll_fz_stddbg()

def ll_fz_stderr():
    r"""
    Low-level wrapper for `::fz_stderr()`.
    Retrieve an fz_output that directs to stdout.

    Optionally may be fz_dropped when finished with.
    """
    return _mupdf.ll_fz_stderr()

def ll_fz_stdout():
    r"""
    Low-level wrapper for `::fz_stdout()`.
    Retrieve an fz_output that directs to stdout.

    Optionally may be fz_dropped when finished with.
    """
    return _mupdf.ll_fz_stdout()

def ll_fz_store_item(key, val, itemsize, type):
    r"""
    Low-level wrapper for `::fz_store_item()`.
    Add an item to the store.

    Add an item into the store, returning NULL for success. If an
    item with the same key is found in the store, then our item will
    not be inserted, and the function will return a pointer to that
    value instead. This function takes its own reference to val, as
    required (i.e. the caller maintains ownership of its own
    reference).

    key: The key used to index the item.

    val: The value to store.

    itemsize: The size in bytes of the value (as counted towards the
    store size).

    type: Functions used to manipulate the key.
    """
    return _mupdf.ll_fz_store_item(key, val, itemsize, type)

def ll_fz_store_scavenge(size, phase):
    r"""
     Low-level wrapper for `::fz_store_scavenge()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_store_scavenge(size_t size)` => `(int, int phase)`

    	Internal function used as part of the scavenging
    	allocator; when we fail to allocate memory, before returning a
    	failure to the caller, we try to scavenge space within the store
    	by evicting at least 'size' bytes. The allocator then retries.

    	size: The number of bytes we are trying to have free.

    	phase: What phase of the scavenge we are in. Updated on exit.

    	Returns non zero if we managed to free any memory.
    """
    return _mupdf.ll_fz_store_scavenge(size, phase)

def ll_fz_store_scavenge_external(size, phase):
    r"""
     Low-level wrapper for `::fz_store_scavenge_external()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_store_scavenge_external(size_t size)` => `(int, int phase)`

    	External function for callers to use
    	to scavenge while trying allocations.

    	size: The number of bytes we are trying to have free.

    	phase: What phase of the scavenge we are in. Updated on exit.

    	Returns non zero if we managed to free any memory.
    """
    return _mupdf.ll_fz_store_scavenge_external(size, phase)

def ll_fz_story_document(story):
    r"""Low-level wrapper for `::fz_story_document()`."""
    return _mupdf.ll_fz_story_document(story)

def ll_fz_story_positions(story, cb, arg):
    r"""Low-level wrapper for `::fz_story_positions()`."""
    return _mupdf.ll_fz_story_positions(story, cb, arg)

def ll_fz_story_warnings(story):
    r"""Low-level wrapper for `::fz_story_warnings()`."""
    return _mupdf.ll_fz_story_warnings(story)

def ll_fz_strcasecmp(a, b):
    r"""
    Low-level wrapper for `::fz_strcasecmp()`.
    Case insensitive (ASCII only) string comparison.
    """
    return _mupdf.ll_fz_strcasecmp(a, b)

def ll_fz_strdup(s):
    r"""
    Low-level wrapper for `::fz_strdup()`.
    Portable strdup implementation, using fz allocators.
    """
    return _mupdf.ll_fz_strdup(s)

def ll_fz_stream_filename(stm):
    r"""
    Low-level wrapper for `::fz_stream_filename()`.
    Return the filename (UTF-8 encoded) from which a stream was opened.

    Returns NULL if the filename is not available (or the stream was
    opened from a source other than a file).
    """
    return _mupdf.ll_fz_stream_filename(stm)

def ll_fz_stream_from_output(arg_1):
    r"""
    Low-level wrapper for `::fz_stream_from_output()`.
    Obtain the fz_output in the form of a fz_stream.

    This allows data to be read back from some forms of fz_output
    object. When finished reading, the fz_stream should be released
    by calling fz_drop_stream. Until the fz_stream is dropped, no
    further operations should be performed on the fz_output object.
    """
    return _mupdf.ll_fz_stream_from_output(arg_1)

def ll_fz_string_from_box_type(box):
    r"""Low-level wrapper for `::fz_string_from_box_type()`."""
    return _mupdf.ll_fz_string_from_box_type(box)

def ll_fz_string_from_buffer(buf):
    r"""
    Low-level wrapper for `::fz_string_from_buffer()`.
    Ensure that a buffer's data ends in a
    0 byte, and return a pointer to it.
    """
    return _mupdf.ll_fz_string_from_buffer(buf)

def ll_fz_string_from_text_language(str, lang):
    r"""
    Low-level wrapper for `::fz_string_from_text_language()`.
    Recover ISO 639 (639-{1,2,3,5}) language specification
    strings losslessly from a 15 bit fz_text_language code.

    No validation is carried out. See note above.
    """
    return _mupdf.ll_fz_string_from_text_language(str, lang)

def ll_fz_string_from_text_language2(lang):
    r"""
     Low-level wrapper for `::fz_string_from_text_language2()`.
    C++ alternative to fz_string_from_text_language() that returns information in a std::string.
    """
    return _mupdf.ll_fz_string_from_text_language2(lang)

def ll_fz_strlcat(dst, src, n):
    r"""
    Low-level wrapper for `::fz_strlcat()`.
    Concatenate 2 strings, with a maximum length.

    dst: pointer to first string in a buffer of n bytes.

    src: pointer to string to concatenate.

    n: Size (in bytes) of buffer that dst is in.

    Returns the real length that a concatenated dst + src would have
    been (not including terminator).
    """
    return _mupdf.ll_fz_strlcat(dst, src, n)

def ll_fz_strlcpy(dst, src, n):
    r"""
    Low-level wrapper for `::fz_strlcpy()`.
    Copy at most n-1 chars of a string into a destination
    buffer with null termination, returning the real length of the
    initial string (excluding terminator).

    dst: Destination buffer, at least n bytes long.

    src: C string (non-NULL).

    n: Size of dst buffer in bytes.

    Returns the length (excluding terminator) of src.
    """
    return _mupdf.ll_fz_strlcpy(dst, src, n)

def ll_fz_strncasecmp(a, b, n):
    r"""Low-level wrapper for `::fz_strncasecmp()`."""
    return _mupdf.ll_fz_strncasecmp(a, b, n)

def ll_fz_strnlen(s, maxlen):
    r"""
    Low-level wrapper for `::fz_strnlen()`.
    Return strlen(s), if that is less than maxlen, or maxlen if
    there is no null byte ('') among the first maxlen bytes.
    """
    return _mupdf.ll_fz_strnlen(s, maxlen)

def ll_fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params):
    r"""Low-level wrapper for `::fz_stroke_path()`."""
    return _mupdf.ll_fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params)

def ll_fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params):
    r"""Low-level wrapper for `::fz_stroke_text()`."""
    return _mupdf.ll_fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params)

def ll_fz_strsep(stringp, delim):
    r"""
     Low-level wrapper for `::fz_strsep()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_strsep(const char *delim)` => `(char *, char *stringp)`

    	Given a pointer to a C string (or a pointer to NULL) break
    	it at the first occurrence of a delimiter char (from a given
    	set).

    	stringp: Pointer to a C string pointer (or NULL). Updated on
    	exit to point to the first char of the string after the
    	delimiter that was found. The string pointed to by stringp will
    	be corrupted by this call (as the found delimiter will be
    	overwritten by 0).

    	delim: A C string of acceptable delimiter characters.

    	Returns a pointer to a C string containing the chars of stringp
    	up to the first delimiter char (or the end of the string), or
    	NULL.
    """
    return _mupdf.ll_fz_strsep(stringp, delim)

def ll_fz_strtof(s, es):
    r"""
     Low-level wrapper for `::fz_strtof()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_strtof(const char *s)` => `(float, char *es)`

    	Locale-independent decimal to binary conversion. On overflow
    	return (-)INFINITY and set errno to ERANGE. On underflow return
    	0 and set errno to ERANGE. Special inputs (case insensitive):
    	"NAN", "INF" or "INFINITY".
    """
    return _mupdf.ll_fz_strtof(s, es)

def ll_fz_structure_from_string(str):
    r"""Low-level wrapper for `::fz_structure_from_string()`."""
    return _mupdf.ll_fz_structure_from_string(str)

def ll_fz_structure_to_string(type):
    r"""Low-level wrapper for `::fz_structure_to_string()`."""
    return _mupdf.ll_fz_structure_to_string(type)

def ll_fz_subpixel_adjust(ctm, subpix_ctm, qe, qf):
    r"""
    Low-level wrapper for `::fz_subpixel_adjust()`.
    Perform subpixel quantisation and adjustment on a glyph matrix.

    ctm: On entry, the desired 'ideal' transformation for a glyph.
    On exit, adjusted to a (very similar) transformation quantised
    for subpixel caching.

    subpix_ctm: Initialised by the routine to the transform that
    should be used to render the glyph.

    qe, qf: which subpixel position we quantised to.

    Returns: the size of the glyph.

    Note: This is currently only exposed for use in our app. It
    should be considered "at risk" of removal from the API.
    """
    return _mupdf.ll_fz_subpixel_adjust(ctm, subpix_ctm, qe, qf)

def ll_fz_subsample_pixmap(tile, factor):
    r"""Low-level wrapper for `::fz_subsample_pixmap()`."""
    return _mupdf.ll_fz_subsample_pixmap(tile, factor)

def ll_fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont):
    r"""
     Low-level wrapper for `::fz_subset_cff_for_gids()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_subset_cff_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
    """
    return _mupdf.ll_fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont)

def ll_fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont):
    r"""
     Low-level wrapper for `::fz_subset_ttf_for_gids()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_subset_ttf_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
    """
    return _mupdf.ll_fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont)

def ll_fz_sync_bits(stm):
    r"""
    Low-level wrapper for `::fz_sync_bits()`.
    Called after reading bits to tell the stream
    that we are about to return to reading bytewise. Resyncs
    the stream to whole byte boundaries.
    """
    return _mupdf.ll_fz_sync_bits(stm)

def ll_fz_tell(stm):
    r"""
    Low-level wrapper for `::fz_tell()`.
    return the current reading position within a stream
    """
    return _mupdf.ll_fz_tell(stm)

def ll_fz_tell_output(out):
    r"""
    Low-level wrapper for `::fz_tell_output()`.
    Return the current file position.

    Throw an error on untellable outputs.
    """
    return _mupdf.ll_fz_tell_output(out)

def ll_fz_terminate_buffer(buf):
    r"""
    Low-level wrapper for `::fz_terminate_buffer()`.
    Zero-terminate buffer in order to use as a C string.

    This byte is invisible and does not affect the length of the
    buffer as returned by fz_buffer_storage. The zero byte is
    written *after* the data, and subsequent writes will overwrite
    the terminating byte.

    Subsequent changes to the size of the buffer (such as by
    fz_buffer_trim, fz_buffer_grow, fz_resize_buffer, etc) may
    invalidate this.
    """
    return _mupdf.ll_fz_terminate_buffer(buf)

def ll_fz_text_aa_level():
    r"""
    Low-level wrapper for `::fz_text_aa_level()`.
    Get the number of bits of antialiasing we are
    using for text. Between 0 and 8.
    """
    return _mupdf.ll_fz_text_aa_level()

def ll_fz_text_language_from_string(str):
    r"""
    Low-level wrapper for `::fz_text_language_from_string()`.
    Convert ISO 639 (639-{1,2,3,5}) language specification
    strings losslessly to a 15 bit fz_text_language code.

    No validation is carried out. Obviously invalid (out
    of spec) codes will be mapped to FZ_LANG_UNSET, but
    well-formed (but undefined) codes will be blithely
    accepted.
    """
    return _mupdf.ll_fz_text_language_from_string(str)

def ll_fz_tint_pixmap(pix, black, white):
    r"""
    Low-level wrapper for `::fz_tint_pixmap()`.
    Tint all the pixels in an RGB, BGR, or Gray pixmap.

    black: Map black to this hexadecimal RGB color.

    white: Map white to this hexadecimal RGB color.
    """
    return _mupdf.ll_fz_tint_pixmap(pix, black, white)

def ll_fz_tolower(c):
    r"""
    Low-level wrapper for `::fz_tolower()`.
    Unicode aware tolower and toupper functions.
    """
    return _mupdf.ll_fz_tolower(c)

def ll_fz_toupper(c):
    r"""Low-level wrapper for `::fz_toupper()`."""
    return _mupdf.ll_fz_toupper(c)

def ll_fz_transform_page(mediabox, resolution, rotate):
    r"""
    Low-level wrapper for `::fz_transform_page()`.
    Create transform matrix to draw page
    at a given resolution and rotation. Adjusts the scaling
    factors so that the page covers whole number of
    pixels and adjust the page origin to be at 0,0.
    """
    return _mupdf.ll_fz_transform_page(mediabox, resolution, rotate)

def ll_fz_transform_path(path, transform):
    r"""
    Low-level wrapper for `::fz_transform_path()`.
    Transform a path by a given
    matrix.

    path: The path to modify (must not be a packed path).

    transform: The transform to apply.

    Throws exceptions if the path is packed, or on failure
    to allocate.
    """
    return _mupdf.ll_fz_transform_path(path, transform)

def ll_fz_transform_point(point, m):
    r"""
    Low-level wrapper for `::fz_transform_point()`.
    Apply a transformation to a point.

    transform: Transformation matrix to apply. See fz_concat,
    fz_scale, fz_rotate and fz_translate for how to create a
    matrix.

    point: Pointer to point to update.

    Returns transform (unchanged).
    """
    return _mupdf.ll_fz_transform_point(point, m)

def ll_fz_transform_point_xy(x, y, m):
    r"""Low-level wrapper for `::fz_transform_point_xy()`."""
    return _mupdf.ll_fz_transform_point_xy(x, y, m)

def ll_fz_transform_quad(q, m):
    r"""
    Low-level wrapper for `::fz_transform_quad()`.
    Transform a quad by a matrix.
    """
    return _mupdf.ll_fz_transform_quad(q, m)

def ll_fz_transform_rect(rect, m):
    r"""
    Low-level wrapper for `::fz_transform_rect()`.
    Apply a transform to a rectangle.

    After the four corner points of the axis-aligned rectangle
    have been transformed it may not longer be axis-aligned. So a
    new axis-aligned rectangle is created covering at least the
    area of the transformed rectangle.

    transform: Transformation matrix to apply. See fz_concat,
    fz_scale and fz_rotate for how to create a matrix.

    rect: Rectangle to be transformed. The two special cases
    fz_empty_rect and fz_infinite_rect, may be used but are
    returned unchanged as expected.
    """
    return _mupdf.ll_fz_transform_rect(rect, m)

def ll_fz_transform_vector(vector, m):
    r"""
    Low-level wrapper for `::fz_transform_vector()`.
    Apply a transformation to a vector.

    transform: Transformation matrix to apply. See fz_concat,
    fz_scale and fz_rotate for how to create a matrix. Any
    translation will be ignored.

    vector: Pointer to vector to update.
    """
    return _mupdf.ll_fz_transform_vector(vector, m)

def ll_fz_translate(tx, ty):
    r"""
    Low-level wrapper for `::fz_translate()`.
    Create a translation matrix.

    The returned matrix is of the form [ 1 0 0 1 tx ty ].

    m: A place to store the created matrix.

    tx, ty: Translation distances along the X- and Y-axes. A
    translation of 0 will not cause any translation along the
    relevant axis.

    Returns m.
    """
    return _mupdf.ll_fz_translate(tx, ty)

def ll_fz_translate_irect(a, xoff, yoff):
    r"""Low-level wrapper for `::fz_translate_irect()`."""
    return _mupdf.ll_fz_translate_irect(a, xoff, yoff)

def ll_fz_translate_rect(a, xoff, yoff):
    r"""
    Low-level wrapper for `::fz_translate_rect()`.
    Translate bounding box.

    Translate a bbox by a given x and y offset. Allows for overflow.
    """
    return _mupdf.ll_fz_translate_rect(a, xoff, yoff)

def ll_fz_tree_archive_add_buffer(arch_, name, buf):
    r"""
    Low-level wrapper for `::fz_tree_archive_add_buffer()`.
    Add a named buffer to an existing tree archive.

    The tree will take a new reference to the buffer. Ownership
    is not transferred.
    """
    return _mupdf.ll_fz_tree_archive_add_buffer(arch_, name, buf)

def ll_fz_tree_archive_add_data(arch_, name, data, size):
    r"""
    Low-level wrapper for `::fz_tree_archive_add_data()`.
    Add a named block of data to an existing tree archive.

    The data will be copied into a buffer, and so the caller
    may free it as soon as this returns.
    """
    return _mupdf.ll_fz_tree_archive_add_data(arch_, name, data, size)

def ll_fz_tree_insert(root, key, value):
    r"""
    Low-level wrapper for `::fz_tree_insert()`.
    Insert a new key/value pair and rebalance the tree.
    Return the new root of the tree after inserting and rebalancing.
    May be called with a NULL root to create a new tree.

    No data is copied into the tree structure; key and value are
    merely kept as pointers.
    """
    return _mupdf.ll_fz_tree_insert(root, key, value)

def ll_fz_tree_lookup(node, key):
    r"""
    Low-level wrapper for `::fz_tree_lookup()`.
    Look for the value of a node in the tree with the given key.

    Simple pointer equivalence is used for key.

    Returns NULL for no match.
    """
    return _mupdf.ll_fz_tree_lookup(node, key)

def ll_fz_trim_buffer(buf):
    r"""
    Low-level wrapper for `::fz_trim_buffer()`.
    Trim wasted capacity from a buffer by resizing internal memory.
    """
    return _mupdf.ll_fz_trim_buffer(buf)

def ll_fz_trim_path(path):
    r"""
    Low-level wrapper for `::fz_trim_path()`.
    Minimise the internal storage used by a path.

    As paths are constructed, the internal buffers
    grow. To avoid repeated reallocations they
    grow with some spare space. Once a path has
    been fully constructed, this call allows the
    excess space to be trimmed.
    """
    return _mupdf.ll_fz_trim_path(path)

def ll_fz_truncate_output(arg_1):
    r"""
    Low-level wrapper for `::fz_truncate_output()`.
    Truncate the output at the current position.

    This allows output streams which have seeked back from the end
    of their storage to be truncated at the current point.
    """
    return _mupdf.ll_fz_truncate_output(arg_1)

def ll_fz_try_invert_matrix(inv, src):
    r"""
    Low-level wrapper for `::fz_try_invert_matrix()`.
    Attempt to create an inverse matrix.

    inv: Place to store inverse matrix.

    src: Matrix to invert. A degenerate matrix, where the
    determinant is equal to zero, can not be inverted.

    Returns 1 if matrix is degenerate (singular), or 0 otherwise.
    """
    return _mupdf.ll_fz_try_invert_matrix(inv, src)

def ll_fz_try_open_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_try_open_archive_entry()`.
    Opens an archive entry as a stream.

    Returns NULL if a matching entry cannot be found, otherwise
    behaves exactly as fz_open_archive_entry.
    """
    return _mupdf.ll_fz_try_open_archive_entry(arch, name)

def ll_fz_try_open_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_try_open_archive_with_stream()`.
    Open zip or tar archive stream.

    Does the same as fz_open_archive_with_stream, but will not throw
    an error in the event of failing to recognise the format. Will
    still throw errors in other cases though!
    """
    return _mupdf.ll_fz_try_open_archive_with_stream(file)

def ll_fz_try_open_file(name):
    r"""
    Low-level wrapper for `::fz_try_open_file()`.
    Open the named file and wrap it in a stream.

    Does the same as fz_open_file, but in the event the file
    does not open, it will return NULL rather than throw an
    exception.
    """
    return _mupdf.ll_fz_try_open_file(name)

def ll_fz_try_parse_xml_archive_entry(dir, filename, preserve_white):
    r"""
    Low-level wrapper for `::fz_try_parse_xml_archive_entry()`.
    Try and parse the contents of an archive entry into a tree of xml nodes.

    preserve_white: whether to keep or delete all-whitespace nodes.

    Will return NULL if the archive entry can't be found. Otherwise behaves
    the same as fz_parse_xml_archive_entry. May throw exceptions.
    """
    return _mupdf.ll_fz_try_parse_xml_archive_entry(dir, filename, preserve_white)

def ll_fz_try_read_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_try_read_archive_entry()`.
    Reads all bytes in an archive entry
    into a buffer.

    name: Entry name to look for, this must be an exact match to
    the entry name in the archive.

    Returns NULL if a matching entry cannot be found. Otherwise behaves
    the same as fz_read_archive_entry. Exceptions may be thrown.
    """
    return _mupdf.ll_fz_try_read_archive_entry(arch, name)

def ll_fz_try_read_file(filename):
    r"""
    Low-level wrapper for `::fz_try_read_file()`.
    Read all the contents of a file into a buffer.

    Returns NULL if the file does not exist, otherwise
    behaves exactly as fz_read_file.
    """
    return _mupdf.ll_fz_try_read_file(filename)

def ll_fz_tune_image_decode(image_decode, arg):
    r"""
    Low-level wrapper for `::fz_tune_image_decode()`.
    Set the tuning function to use for
    image decode.

    image_decode: Function to use.

    arg: Opaque argument to be passed to tuning function.
    """
    return _mupdf.ll_fz_tune_image_decode(image_decode, arg)

def ll_fz_tune_image_scale(image_scale, arg):
    r"""
    Low-level wrapper for `::fz_tune_image_scale()`.
    Set the tuning function to use for
    image scaling.

    image_scale: Function to use.

    arg: Opaque argument to be passed to tuning function.
    """
    return _mupdf.ll_fz_tune_image_scale(image_scale, arg)

def ll_fz_unicode_from_glyph_name(name):
    r"""Low-level wrapper for `::fz_unicode_from_glyph_name()`."""
    return _mupdf.ll_fz_unicode_from_glyph_name(name)

def ll_fz_unicode_from_glyph_name_strict(name):
    r"""Low-level wrapper for `::fz_unicode_from_glyph_name_strict()`."""
    return _mupdf.ll_fz_unicode_from_glyph_name_strict(name)

def ll_fz_union_rect(a, b):
    r"""
    Low-level wrapper for `::fz_union_rect()`.
    Compute union of two rectangles.

    Given two rectangles, update the first to be the smallest
    axis-aligned rectangle that encompasses both given rectangles.
    If either rectangle is infinite then the union is also infinite.
    If either rectangle is empty then the union is simply the
    non-empty rectangle. Should both rectangles be empty, then the
    union is also empty.
    """
    return _mupdf.ll_fz_union_rect(a, b)

def ll_fz_unlock(lock):
    r"""
    Low-level wrapper for `::fz_unlock()`.
    Unlock one of the user supplied mutexes.
    """
    return _mupdf.ll_fz_unlock(lock)

def ll_fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip):
    r"""Low-level wrapper for `::fz_unpack_stream()`."""
    return _mupdf.ll_fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip)

def ll_fz_unread_byte(stm):
    r"""
    Low-level wrapper for `::fz_unread_byte()`.
    Unread the single last byte successfully
    read from a stream. Do not call this without having
    successfully read a byte.

    stm: The stream to operate upon.
    """
    return _mupdf.ll_fz_unread_byte(stm)

def ll_fz_unshare_stroke_state(shared):
    r"""
    Low-level wrapper for `::fz_unshare_stroke_state()`.
    Given a reference to a (possibly) shared stroke_state structure,
    return a reference to an equivalent stroke_state structure
    that is guaranteed to be unshared (i.e. one that can
    safely be modified).

    shared: The reference to a (possibly) shared structure
    to unshare. Ownership of this reference is passed in
    to this function, even in the case of exceptions being
    thrown.

    Exceptions may be thrown in the event of failure to
    allocate if required.
    """
    return _mupdf.ll_fz_unshare_stroke_state(shared)

def ll_fz_unshare_stroke_state_with_dash_len(shared, len):
    r"""
    Low-level wrapper for `::fz_unshare_stroke_state_with_dash_len()`.
    Given a reference to a (possibly) shared stroke_state structure,
    return a reference to a stroke_state structure (with room for a
    given amount of dash data) that is guaranteed to be unshared
    (i.e. one that can safely be modified).

    shared: The reference to a (possibly) shared structure
    to unshare. Ownership of this reference is passed in
    to this function, even in the case of exceptions being
    thrown.

    Exceptions may be thrown in the event of failure to
    allocate if required.
    """
    return _mupdf.ll_fz_unshare_stroke_state_with_dash_len(shared, len)

def ll_fz_urldecode(url):
    r"""
    Low-level wrapper for `::fz_urldecode()`.
    Like fz_decode_uri_component but in-place.
    """
    return _mupdf.ll_fz_urldecode(url)

def ll_fz_use_document_css():
    r"""
    Low-level wrapper for `::fz_use_document_css()`.
    Return whether to respect document styles in HTML and EPUB.
    """
    return _mupdf.ll_fz_use_document_css()

def ll_fz_user_context():
    r"""
    Low-level wrapper for `::fz_user_context()`.
    Read the user field from the context.
    """
    return _mupdf.ll_fz_user_context()

def ll_fz_user_css():
    r"""
    Low-level wrapper for `::fz_user_css()`.
    Get the user stylesheet source text.
    """
    return _mupdf.ll_fz_user_css()

def ll_fz_utflen(s):
    r"""
    Low-level wrapper for `::fz_utflen()`.
    Count how many runes the UTF-8 encoded string
    consists of.

    s: The UTF-8 encoded, NUL-terminated text string.

    Returns the number of runes in the string.
    """
    return _mupdf.ll_fz_utflen(s)

def ll_fz_var_imp(arg_0):
    r"""Low-level wrapper for `::fz_var_imp()`."""
    return _mupdf.ll_fz_var_imp(arg_0)

def ll_fz_walk_path(path, walker, arg):
    r"""
    Low-level wrapper for `::fz_walk_path()`.
    Walk the segments of a path, calling the
    appropriate callback function from a given set for each
    segment of the path.

    path: The path to walk.

    walker: The set of callback functions to use. The first
    4 callback pointers in the set must be non-NULL. The
    subsequent ones can either be supplied, or can be left
    as NULL, in which case the top 4 functions will be
    called as appropriate to simulate them.

    arg: An opaque argument passed in to each callback.

    Exceptions will only be thrown if the underlying callback
    functions throw them.
    """
    return _mupdf.ll_fz_walk_path(path, walker, arg)

def ll_fz_warn(*args):
    r"""Low-level wrapper for `::fz_warn()`."""
    return _mupdf.ll_fz_warn(*args)

def ll_fz_warning_callback(user):
    r"""
     Low-level wrapper for `::fz_warning_callback()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_warning_callback()` => `(fz_warning_cb *, void *user)`

    	Retrieve the currently set warning callback, or NULL if none
    	has been set. Optionally, if user is non-NULL, the user pointer
    	given when the warning callback was set is also passed back to
    	the caller.
    """
    return _mupdf.ll_fz_warning_callback(user)

def ll_fz_warp_pixmap(src, points, width, height):
    r"""Low-level wrapper for `::fz_warp_pixmap()`."""
    return _mupdf.ll_fz_warp_pixmap(src, points, width, height)

def ll_fz_windows_1250_from_unicode(u):
    r"""Low-level wrapper for `::fz_windows_1250_from_unicode()`."""
    return _mupdf.ll_fz_windows_1250_from_unicode(u)

def ll_fz_windows_1251_from_unicode(u):
    r"""Low-level wrapper for `::fz_windows_1251_from_unicode()`."""
    return _mupdf.ll_fz_windows_1251_from_unicode(u)

def ll_fz_windows_1252_from_unicode(u):
    r"""Low-level wrapper for `::fz_windows_1252_from_unicode()`."""
    return _mupdf.ll_fz_windows_1252_from_unicode(u)

def ll_fz_write_band(writer, stride, band_height, samples):
    r"""
    Low-level wrapper for `::fz_write_band()`.
    Cause a band writer to write the next band
    of data for an image.

    stride: The byte offset from the first byte of the data
    for a pixel to the first byte of the data for the same pixel
    on the row below.

    band_height: The number of lines in this band.

    samples: Pointer to first byte of the data.
    """
    return _mupdf.ll_fz_write_band(writer, stride, band_height, samples)

def ll_fz_write_base64(out, data, size, newline):
    r"""
    Low-level wrapper for `::fz_write_base64()`.
    Write a base64 encoded data block, optionally with periodic
    newlines.
    """
    return _mupdf.ll_fz_write_base64(out, data, size, newline)

def ll_fz_write_base64_buffer(out, data, newline):
    r"""
    Low-level wrapper for `::fz_write_base64_buffer()`.
    Write a base64 encoded fz_buffer, optionally with periodic
    newlines.
    """
    return _mupdf.ll_fz_write_base64_buffer(out, data, newline)

def ll_fz_write_bitmap_as_pbm(out, bitmap):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pbm()`.
    Write a bitmap as a pbm.
    """
    return _mupdf.ll_fz_write_bitmap_as_pbm(out, bitmap)

def ll_fz_write_bitmap_as_pcl(out, bitmap, pcl):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pcl()`.
    Write a bitmap as mono PCL.
    """
    return _mupdf.ll_fz_write_bitmap_as_pcl(out, bitmap, pcl)

def ll_fz_write_bitmap_as_pkm(out, bitmap):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pkm()`.
    Write a CMYK bitmap as a pkm.
    """
    return _mupdf.ll_fz_write_bitmap_as_pkm(out, bitmap)

def ll_fz_write_bitmap_as_pwg(out, bitmap, pwg):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pwg()`.
    Write a bitmap as a PWG.
    """
    return _mupdf.ll_fz_write_bitmap_as_pwg(out, bitmap, pwg)

def ll_fz_write_bitmap_as_pwg_page(out, bitmap, pwg):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pwg_page()`.
    Write a bitmap as a PWG page.

    Caller should provide a file header by calling
    fz_write_pwg_file_header, but can then write several pages to
    the same file.
    """
    return _mupdf.ll_fz_write_bitmap_as_pwg_page(out, bitmap, pwg)

def ll_fz_write_bits(out, data, num_bits):
    r"""
    Low-level wrapper for `::fz_write_bits()`.
    Write num_bits of data to the end of the output stream, assumed to be packed
    most significant bits first.
    """
    return _mupdf.ll_fz_write_bits(out, data, num_bits)

def ll_fz_write_bits_sync(out):
    r"""
    Low-level wrapper for `::fz_write_bits_sync()`.
    Sync to byte boundary after writing bits.
    """
    return _mupdf.ll_fz_write_bits_sync(out)

def ll_fz_write_buffer(out, data):
    r"""Low-level wrapper for `::fz_write_buffer()`."""
    return _mupdf.ll_fz_write_buffer(out, data)

def ll_fz_write_byte(out, x):
    r"""Low-level wrapper for `::fz_write_byte()`."""
    return _mupdf.ll_fz_write_byte(out, x)

def ll_fz_write_char(out, x):
    r"""Low-level wrapper for `::fz_write_char()`."""
    return _mupdf.ll_fz_write_char(out, x)

def ll_fz_write_data(out, data, size):
    r"""
    Low-level wrapper for `::fz_write_data()`.
    Write data to output.

    data: Pointer to data to write.
    size: Size of data to write in bytes.
    """
    return _mupdf.ll_fz_write_data(out, data, size)

def ll_fz_write_document(wri, doc):
    r"""
    Low-level wrapper for `::fz_write_document()`.
    Convenience function to feed all the pages of a document to
    fz_begin_page/fz_run_page/fz_end_page.
    """
    return _mupdf.ll_fz_write_document(wri, doc)

def ll_fz_write_float_be(out, f):
    r"""Low-level wrapper for `::fz_write_float_be()`."""
    return _mupdf.ll_fz_write_float_be(out, f)

def ll_fz_write_float_le(out, f):
    r"""Low-level wrapper for `::fz_write_float_le()`."""
    return _mupdf.ll_fz_write_float_le(out, f)

def ll_fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps):
    r"""
    Low-level wrapper for `::fz_write_header()`.
    Cause a band writer to write the header for
    a banded image with the given properties/dimensions etc. This
    also configures the bandwriter for the format of the data to be
    passed in future calls.

    w, h: Width and Height of the entire page.

    n: Number of components (including spots and alphas).

    alpha: Number of alpha components.

    xres, yres: X and Y resolutions in dpi.

    cs: Colorspace (NULL for bitmaps)

    seps: Separation details (or NULL).
    """
    return _mupdf.ll_fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps)

def ll_fz_write_image_as_data_uri(out, image):
    r"""
    Low-level wrapper for `::fz_write_image_as_data_uri()`.
    Write image as a data URI (for HTML and SVG output).
    """
    return _mupdf.ll_fz_write_image_as_data_uri(out, image)

def ll_fz_write_int16_be(out, x):
    r"""Low-level wrapper for `::fz_write_int16_be()`."""
    return _mupdf.ll_fz_write_int16_be(out, x)

def ll_fz_write_int16_le(out, x):
    r"""Low-level wrapper for `::fz_write_int16_le()`."""
    return _mupdf.ll_fz_write_int16_le(out, x)

def ll_fz_write_int32_be(out, x):
    r"""
    Low-level wrapper for `::fz_write_int32_be()`.
    Write different sized data to an output stream.
    """
    return _mupdf.ll_fz_write_int32_be(out, x)

def ll_fz_write_int32_le(out, x):
    r"""Low-level wrapper for `::fz_write_int32_le()`."""
    return _mupdf.ll_fz_write_int32_le(out, x)

def ll_fz_write_pixmap_as_data_uri(out, pixmap):
    r"""Low-level wrapper for `::fz_write_pixmap_as_data_uri()`."""
    return _mupdf.ll_fz_write_pixmap_as_data_uri(out, pixmap)

def ll_fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_jpeg()`.
    Write a pixmap as a JPEG.
    """
    return _mupdf.ll_fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk)

def ll_fz_write_pixmap_as_jpx(out, pix, quality):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_jpx()`.
    Pixmap data as JP2K with no subsampling.

    quality = 100 = lossless
    otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
    """
    return _mupdf.ll_fz_write_pixmap_as_jpx(out, pix, quality)

def ll_fz_write_pixmap_as_pam(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pam()`.
    Write a pixmap as a pnm (greyscale, rgb or cmyk, with or without
    alpha).
    """
    return _mupdf.ll_fz_write_pixmap_as_pam(out, pixmap)

def ll_fz_write_pixmap_as_pcl(out, pixmap, pcl):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pcl()`.
    Write an (RGB) pixmap as color PCL.
    """
    return _mupdf.ll_fz_write_pixmap_as_pcl(out, pixmap, pcl)

def ll_fz_write_pixmap_as_pclm(out, pixmap, options):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pclm()`.
    Write a (Greyscale or RGB) pixmap as pclm.
    """
    return _mupdf.ll_fz_write_pixmap_as_pclm(out, pixmap, options)

def ll_fz_write_pixmap_as_pdfocr(out, pixmap, options):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pdfocr()`.
    Write a (Greyscale or RGB) pixmap as pdfocr.
    """
    return _mupdf.ll_fz_write_pixmap_as_pdfocr(out, pixmap, options)

def ll_fz_write_pixmap_as_png(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_png()`.
    Write a (Greyscale or RGB) pixmap as a png.
    """
    return _mupdf.ll_fz_write_pixmap_as_png(out, pixmap)

def ll_fz_write_pixmap_as_pnm(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pnm()`.
    Write a pixmap as a pnm (greyscale or rgb, no alpha).
    """
    return _mupdf.ll_fz_write_pixmap_as_pnm(out, pixmap)

def ll_fz_write_pixmap_as_ps(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_ps()`.
    Write a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
    """
    return _mupdf.ll_fz_write_pixmap_as_ps(out, pixmap)

def ll_fz_write_pixmap_as_psd(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_psd()`.
    Write a pixmap as a PSD file.
    """
    return _mupdf.ll_fz_write_pixmap_as_psd(out, pixmap)

def ll_fz_write_pixmap_as_pwg(out, pixmap, pwg):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pwg()`.
    Write a pixmap as a PWG.
    """
    return _mupdf.ll_fz_write_pixmap_as_pwg(out, pixmap, pwg)

def ll_fz_write_pixmap_as_pwg_page(out, pixmap, pwg):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pwg_page()`.
    Write a pixmap as a PWG page.

    Caller should provide a file header by calling
    fz_write_pwg_file_header, but can then write several pages to
    the same file.
    """
    return _mupdf.ll_fz_write_pixmap_as_pwg_page(out, pixmap, pwg)

def ll_fz_write_ps_file_header(out):
    r"""
    Low-level wrapper for `::fz_write_ps_file_header()`.
    Write the file level header for ps band writer output.
    """
    return _mupdf.ll_fz_write_ps_file_header(out)

def ll_fz_write_ps_file_trailer(out, pages):
    r"""
    Low-level wrapper for `::fz_write_ps_file_trailer()`.
    Write the file level trailer for ps band writer output.
    """
    return _mupdf.ll_fz_write_ps_file_trailer(out, pages)

def ll_fz_write_pwg_file_header(out):
    r"""
    Low-level wrapper for `::fz_write_pwg_file_header()`.
    Output the file header to a pwg stream, ready for pages to follow it.
    """
    return _mupdf.ll_fz_write_pwg_file_header(out)

def ll_fz_write_rune(out, rune):
    r"""
    Low-level wrapper for `::fz_write_rune()`.
    Write a UTF-8 encoded unicode character.
    """
    return _mupdf.ll_fz_write_rune(out, rune)

def ll_fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir):
    r"""Low-level wrapper for `::fz_write_stabilized_story()`."""
    return _mupdf.ll_fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir)

def ll_fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref):
    r"""Low-level wrapper for `::fz_write_story()`."""
    return _mupdf.ll_fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref)

def ll_fz_write_stream(out, _in):
    r"""
    Low-level wrapper for `::fz_write_stream()`.
    Copy the stream contents to the output.
    """
    return _mupdf.ll_fz_write_stream(out, _in)

def ll_fz_write_string(out, s):
    r"""
    Low-level wrapper for `::fz_write_string()`.
    Write a string. Does not write zero terminator.
    """
    return _mupdf.ll_fz_write_string(out, s)

def ll_fz_write_uint16_be(out, x):
    r"""Low-level wrapper for `::fz_write_uint16_be()`."""
    return _mupdf.ll_fz_write_uint16_be(out, x)

def ll_fz_write_uint16_le(out, x):
    r"""Low-level wrapper for `::fz_write_uint16_le()`."""
    return _mupdf.ll_fz_write_uint16_le(out, x)

def ll_fz_write_uint32_be(out, x):
    r"""Low-level wrapper for `::fz_write_uint32_be()`."""
    return _mupdf.ll_fz_write_uint32_be(out, x)

def ll_fz_write_uint32_le(out, x):
    r"""Low-level wrapper for `::fz_write_uint32_le()`."""
    return _mupdf.ll_fz_write_uint32_le(out, x)

def ll_fz_write_xml(root, out, indented):
    r"""
    Low-level wrapper for `::fz_write_xml()`.
    Write our xml structure out to an xml stream.

    Properly formatted XML is only allowed to have a single top-level node
    under which everything must sit. Our structures allow for multiple
    top level nodes. If required, we will output an extra 'ROOT' node
    at the top so that the xml is well-formed.

    If 'indented' is non-zero then additional whitespace will be added to
    make the XML easier to read in a text editor. It will NOT be properly
    compliant.
    """
    return _mupdf.ll_fz_write_xml(root, out, indented)

def ll_fz_write_zip_entry(zip, name, buf, compress):
    r"""
    Low-level wrapper for `::fz_write_zip_entry()`.
    Given a buffer of data, (optionally) compress it, and add it to
    the zip file with the given name.
    """
    return _mupdf.ll_fz_write_zip_entry(zip, name, buf, compress)

def ll_fz_xml_add_att(pool, node, key, val):
    r"""
    Low-level wrapper for `::fz_xml_add_att()`.
    Add an attribute to an XML node.
    """
    return _mupdf.ll_fz_xml_add_att(pool, node, key, val)

def ll_fz_xml_att(item, att):
    r"""
    Low-level wrapper for `::fz_xml_att()`.
    Return the value of an attribute of an XML node.
    NULL if the attribute doesn't exist.
    """
    return _mupdf.ll_fz_xml_att(item, att)

def ll_fz_xml_att_alt(item, one, two):
    r"""
    Low-level wrapper for `::fz_xml_att_alt()`.
    Return the value of an attribute of an XML node.
    If the first attribute doesn't exist, try the second.
    NULL if neither attribute exists.
    """
    return _mupdf.ll_fz_xml_att_alt(item, one, two)

def ll_fz_xml_att_eq(item, name, match):
    r"""
    Low-level wrapper for `::fz_xml_att_eq()`.
    Check for a matching attribute on an XML node.

    If the node has the requested attribute (name), and the value
    matches (match) then return 1. Otherwise, 0.
    """
    return _mupdf.ll_fz_xml_att_eq(item, name, match)

def ll_fz_xml_down(item):
    r"""
    Low-level wrapper for `::fz_xml_down()`.
    Return first child of XML node.
    """
    return _mupdf.ll_fz_xml_down(item)

def ll_fz_xml_find(item, tag):
    r"""
    Low-level wrapper for `::fz_xml_find()`.
    Search the siblings of XML nodes starting with item looking for
    the first with the given tag.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find(item, tag)

def ll_fz_xml_find_dfs(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_dfs()`.
    Perform a depth first search from item, returning the first
    child that matches the given tag (or any tag if tag is NULL),
    with the given attribute (if att is non NULL), that matches
    match (if match is non NULL).
    """
    return _mupdf.ll_fz_xml_find_dfs(item, tag, att, match)

def ll_fz_xml_find_dfs_top(item, tag, att, match, top):
    r"""
    Low-level wrapper for `::fz_xml_find_dfs_top()`.
    Perform a depth first search from item, returning the first
    child that matches the given tag (or any tag if tag is NULL),
    with the given attribute (if att is non NULL), that matches
    match (if match is non NULL). The search stops if it ever
    reaches the top of the tree, or the declared 'top' item.
    """
    return _mupdf.ll_fz_xml_find_dfs_top(item, tag, att, match, top)

def ll_fz_xml_find_down(item, tag):
    r"""
    Low-level wrapper for `::fz_xml_find_down()`.
    Search the siblings of XML nodes starting with the first child
    of item looking for the first with the given tag.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_down(item, tag)

def ll_fz_xml_find_down_match(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_down_match()`.
    Search the siblings of XML nodes starting with the first child
    of item looking for the first with the given tag (or any tag if
    tag is NULL), and with a matching attribute.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_down_match(item, tag, att, match)

def ll_fz_xml_find_match(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_match()`.
    Search the siblings of XML nodes starting with item looking for
    the first with the given tag (or any tag if tag is NULL), and
    with a matching attribute.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_match(item, tag, att, match)

def ll_fz_xml_find_next(item, tag):
    r"""
    Low-level wrapper for `::fz_xml_find_next()`.
    Search the siblings of XML nodes starting with the first sibling
    of item looking for the first with the given tag.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_next(item, tag)

def ll_fz_xml_find_next_dfs(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_next_dfs()`.
    Perform a depth first search onwards from item, returning the first
    child that matches the given tag (or any tag if tag is NULL),
    with the given attribute (if att is non NULL), that matches
    match (if match is non NULL).
    """
    return _mupdf.ll_fz_xml_find_next_dfs(item, tag, att, match)

def ll_fz_xml_find_next_dfs_top(item, tag, att, match, top):
    r"""
    Low-level wrapper for `::fz_xml_find_next_dfs_top()`.
    Perform a depth first search onwards from item, returning the first
    child that matches the given tag (or any tag if tag is NULL),
    with the given attribute (if att is non NULL), that matches
    match (if match is non NULL). The search stops if it ever reaches
    the top of the tree, or the declared 'top' item.
    """
    return _mupdf.ll_fz_xml_find_next_dfs_top(item, tag, att, match, top)

def ll_fz_xml_find_next_match(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_next_match()`.
    Search the siblings of XML nodes starting with the first sibling
    of item looking for the first with the given tag (or any tag if tag
    is NULL), and with a matching attribute.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_next_match(item, tag, att, match)

def ll_fz_xml_is_tag(item, name):
    r"""
    Low-level wrapper for `::fz_xml_is_tag()`.
    Return true if the tag name matches.
    """
    return _mupdf.ll_fz_xml_is_tag(item, name)

def ll_fz_xml_next(item):
    r"""
    Low-level wrapper for `::fz_xml_next()`.
    Return next sibling of XML node.
    """
    return _mupdf.ll_fz_xml_next(item)

def ll_fz_xml_prev(item):
    r"""
    Low-level wrapper for `::fz_xml_prev()`.
    Return previous sibling of XML node.
    """
    return _mupdf.ll_fz_xml_prev(item)

def ll_fz_xml_root(xml):
    r"""
    Low-level wrapper for `::fz_xml_root()`.
    Return the topmost XML node of a document.
    """
    return _mupdf.ll_fz_xml_root(xml)

def ll_fz_xml_tag(item):
    r"""
    Low-level wrapper for `::fz_xml_tag()`.
    Return tag of XML node. Return NULL for text nodes.
    """
    return _mupdf.ll_fz_xml_tag(item)

def ll_fz_xml_text(item):
    r"""
    Low-level wrapper for `::fz_xml_text()`.
    Return the text content of an XML node.
    Return NULL if the node is a tag.
    """
    return _mupdf.ll_fz_xml_text(item)

def ll_fz_xml_up(item):
    r"""
    Low-level wrapper for `::fz_xml_up()`.
    Return parent of XML node.
    """
    return _mupdf.ll_fz_xml_up(item)

def ll_pdf_abandon_operation(doc):
    r"""Low-level wrapper for `::pdf_abandon_operation()`."""
    return _mupdf.ll_pdf_abandon_operation(doc)

def ll_pdf_access_alert_event(evt):
    r"""Low-level wrapper for `::pdf_access_alert_event()`."""
    return _mupdf.ll_pdf_access_alert_event(evt)

def ll_pdf_access_exec_menu_item_event(evt):
    r"""Low-level wrapper for `::pdf_access_exec_menu_item_event()`."""
    return _mupdf.ll_pdf_access_exec_menu_item_event(evt)

def ll_pdf_access_launch_url_event(evt):
    r"""Low-level wrapper for `::pdf_access_launch_url_event()`."""
    return _mupdf.ll_pdf_access_launch_url_event(evt)

def ll_pdf_access_mail_doc_event(evt):
    r"""Low-level wrapper for `::pdf_access_mail_doc_event()`."""
    return _mupdf.ll_pdf_access_mail_doc_event(evt)

def ll_pdf_add_annot_border_dash_item(annot, length):
    r"""Low-level wrapper for `::pdf_add_annot_border_dash_item()`."""
    return _mupdf.ll_pdf_add_annot_border_dash_item(annot, length)

def ll_pdf_add_annot_ink_list(annot, n, stroke):
    r"""Low-level wrapper for `::pdf_add_annot_ink_list()`."""
    return _mupdf.ll_pdf_add_annot_ink_list(annot, n, stroke)

def ll_pdf_add_annot_ink_list_stroke(annot):
    r"""Low-level wrapper for `::pdf_add_annot_ink_list_stroke()`."""
    return _mupdf.ll_pdf_add_annot_ink_list_stroke(annot)

def ll_pdf_add_annot_ink_list_stroke_vertex(annot, p):
    r"""Low-level wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`."""
    return _mupdf.ll_pdf_add_annot_ink_list_stroke_vertex(annot, p)

def ll_pdf_add_annot_quad_point(annot, quad):
    r"""Low-level wrapper for `::pdf_add_annot_quad_point()`."""
    return _mupdf.ll_pdf_add_annot_quad_point(annot, quad)

def ll_pdf_add_annot_vertex(annot, p):
    r"""Low-level wrapper for `::pdf_add_annot_vertex()`."""
    return _mupdf.ll_pdf_add_annot_vertex(annot, p)

def ll_pdf_add_cid_font(doc, font):
    r"""Low-level wrapper for `::pdf_add_cid_font()`."""
    return _mupdf.ll_pdf_add_cid_font(doc, font)

def ll_pdf_add_cjk_font(doc, font, script, wmode, serif):
    r"""Low-level wrapper for `::pdf_add_cjk_font()`."""
    return _mupdf.ll_pdf_add_cjk_font(doc, font, script, wmode, serif)

def ll_pdf_add_codespace(cmap, low, high, n):
    r"""Low-level wrapper for `::pdf_add_codespace()`."""
    return _mupdf.ll_pdf_add_codespace(cmap, low, high, n)

def ll_pdf_add_embedded_file(doc, filename, mimetype, contents, created, modifed, add_checksum):
    r"""Low-level wrapper for `::pdf_add_embedded_file()`."""
    return _mupdf.ll_pdf_add_embedded_file(doc, filename, mimetype, contents, created, modifed, add_checksum)

def ll_pdf_add_hmtx(font, lo, hi, w):
    r"""Low-level wrapper for `::pdf_add_hmtx()`."""
    return _mupdf.ll_pdf_add_hmtx(font, lo, hi, w)

def ll_pdf_add_image(doc, image):
    r"""Low-level wrapper for `::pdf_add_image()`."""
    return _mupdf.ll_pdf_add_image(doc, image)

def ll_pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj):
    r"""Low-level wrapper for `::pdf_add_journal_fragment()`."""
    return _mupdf.ll_pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj)

def ll_pdf_add_new_array(doc, initial):
    r"""Low-level wrapper for `::pdf_add_new_array()`."""
    return _mupdf.ll_pdf_add_new_array(doc, initial)

def ll_pdf_add_new_dict(doc, initial):
    r"""Low-level wrapper for `::pdf_add_new_dict()`."""
    return _mupdf.ll_pdf_add_new_dict(doc, initial)

def ll_pdf_add_object(doc, obj):
    r"""Low-level wrapper for `::pdf_add_object()`."""
    return _mupdf.ll_pdf_add_object(doc, obj)

def ll_pdf_add_object_drop(doc, obj):
    r"""Low-level wrapper for `::pdf_add_object_drop()`."""
    return _mupdf.ll_pdf_add_object_drop(doc, obj)

def ll_pdf_add_page(doc, mediabox, rotate, resources, contents):
    r"""Low-level wrapper for `::pdf_add_page()`."""
    return _mupdf.ll_pdf_add_page(doc, mediabox, rotate, resources, contents)

def ll_pdf_add_simple_font(doc, font, encoding):
    r"""Low-level wrapper for `::pdf_add_simple_font()`."""
    return _mupdf.ll_pdf_add_simple_font(doc, font, encoding)

def ll_pdf_add_stream(doc, buf, obj, compressed):
    r"""Low-level wrapper for `::pdf_add_stream()`."""
    return _mupdf.ll_pdf_add_stream(doc, buf, obj, compressed)

def ll_pdf_add_substitute_font(doc, font):
    r"""Low-level wrapper for `::pdf_add_substitute_font()`."""
    return _mupdf.ll_pdf_add_substitute_font(doc, font)

def ll_pdf_add_vmtx(font, lo, hi, x, y, w):
    r"""Low-level wrapper for `::pdf_add_vmtx()`."""
    return _mupdf.ll_pdf_add_vmtx(font, lo, hi, x, y, w)

def ll_pdf_annot_MK_BC(annot, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_MK_BC()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_MK_BC(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.ll_pdf_annot_MK_BC(annot, n, color)

def ll_pdf_annot_MK_BC_rgb(annot, rgb):
    r"""Low-level wrapper for `::pdf_annot_MK_BC_rgb()`."""
    return _mupdf.ll_pdf_annot_MK_BC_rgb(annot, rgb)

def ll_pdf_annot_MK_BG(annot, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_MK_BG()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_MK_BG(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.ll_pdf_annot_MK_BG(annot, n, color)

def ll_pdf_annot_MK_BG_rgb(annot, rgb):
    r"""Low-level wrapper for `::pdf_annot_MK_BG_rgb()`."""
    return _mupdf.ll_pdf_annot_MK_BG_rgb(annot, rgb)

def ll_pdf_annot_active(annot):
    r"""Low-level wrapper for `::pdf_annot_active()`."""
    return _mupdf.ll_pdf_annot_active(annot)

def ll_pdf_annot_ap(annot):
    r"""Low-level wrapper for `::pdf_annot_ap()`."""
    return _mupdf.ll_pdf_annot_ap(annot)

def ll_pdf_annot_author(annot):
    r"""Low-level wrapper for `::pdf_annot_author()`."""
    return _mupdf.ll_pdf_annot_author(annot)

def ll_pdf_annot_border(annot):
    r"""Low-level wrapper for `::pdf_annot_border()`."""
    return _mupdf.ll_pdf_annot_border(annot)

def ll_pdf_annot_border_dash_count(annot):
    r"""Low-level wrapper for `::pdf_annot_border_dash_count()`."""
    return _mupdf.ll_pdf_annot_border_dash_count(annot)

def ll_pdf_annot_border_dash_item(annot, i):
    r"""Low-level wrapper for `::pdf_annot_border_dash_item()`."""
    return _mupdf.ll_pdf_annot_border_dash_item(annot, i)

def ll_pdf_annot_border_effect(annot):
    r"""Low-level wrapper for `::pdf_annot_border_effect()`."""
    return _mupdf.ll_pdf_annot_border_effect(annot)

def ll_pdf_annot_border_effect_intensity(annot):
    r"""Low-level wrapper for `::pdf_annot_border_effect_intensity()`."""
    return _mupdf.ll_pdf_annot_border_effect_intensity(annot)

def ll_pdf_annot_border_style(annot):
    r"""Low-level wrapper for `::pdf_annot_border_style()`."""
    return _mupdf.ll_pdf_annot_border_style(annot)

def ll_pdf_annot_border_width(annot):
    r"""Low-level wrapper for `::pdf_annot_border_width()`."""
    return _mupdf.ll_pdf_annot_border_width(annot)

def ll_pdf_annot_callout_line(annot, callout, n):
    r"""
     Low-level wrapper for `::pdf_annot_callout_line()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_callout_line(::pdf_annot *annot, ::fz_point callout[3])` => int n
    """
    return _mupdf.ll_pdf_annot_callout_line(annot, callout, n)

def ll_pdf_annot_callout_point(annot):
    r"""Low-level wrapper for `::pdf_annot_callout_point()`."""
    return _mupdf.ll_pdf_annot_callout_point(annot)

def ll_pdf_annot_callout_style(annot):
    r"""Low-level wrapper for `::pdf_annot_callout_style()`."""
    return _mupdf.ll_pdf_annot_callout_style(annot)

def ll_pdf_annot_color(annot, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_color(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.ll_pdf_annot_color(annot, n, color)

def ll_pdf_annot_contents(annot):
    r"""Low-level wrapper for `::pdf_annot_contents()`."""
    return _mupdf.ll_pdf_annot_contents(annot)

def ll_pdf_annot_creation_date(annot):
    r"""Low-level wrapper for `::pdf_annot_creation_date()`."""
    return _mupdf.ll_pdf_annot_creation_date(annot)

def ll_pdf_annot_default_appearance(annot, font, size, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_default_appearance()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_default_appearance(::pdf_annot *annot, float color[4])` => `(const char *font, float size, int n)`
    """
    return _mupdf.ll_pdf_annot_default_appearance(annot, font, size, n, color)

def ll_pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, size, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_default_appearance_unmapped()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_default_appearance_unmapped(::pdf_annot *annot, char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
    """
    return _mupdf.ll_pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, size, n, color)

def ll_pdf_annot_ensure_local_xref(annot):
    r"""Low-level wrapper for `::pdf_annot_ensure_local_xref()`."""
    return _mupdf.ll_pdf_annot_ensure_local_xref(annot)

def ll_pdf_annot_event_blur(annot):
    r"""Low-level wrapper for `::pdf_annot_event_blur()`."""
    return _mupdf.ll_pdf_annot_event_blur(annot)

def ll_pdf_annot_event_down(annot):
    r"""Low-level wrapper for `::pdf_annot_event_down()`."""
    return _mupdf.ll_pdf_annot_event_down(annot)

def ll_pdf_annot_event_enter(annot):
    r"""Low-level wrapper for `::pdf_annot_event_enter()`."""
    return _mupdf.ll_pdf_annot_event_enter(annot)

def ll_pdf_annot_event_exit(annot):
    r"""Low-level wrapper for `::pdf_annot_event_exit()`."""
    return _mupdf.ll_pdf_annot_event_exit(annot)

def ll_pdf_annot_event_focus(annot):
    r"""Low-level wrapper for `::pdf_annot_event_focus()`."""
    return _mupdf.ll_pdf_annot_event_focus(annot)

def ll_pdf_annot_event_page_close(annot):
    r"""Low-level wrapper for `::pdf_annot_event_page_close()`."""
    return _mupdf.ll_pdf_annot_event_page_close(annot)

def ll_pdf_annot_event_page_invisible(annot):
    r"""Low-level wrapper for `::pdf_annot_event_page_invisible()`."""
    return _mupdf.ll_pdf_annot_event_page_invisible(annot)

def ll_pdf_annot_event_page_open(annot):
    r"""Low-level wrapper for `::pdf_annot_event_page_open()`."""
    return _mupdf.ll_pdf_annot_event_page_open(annot)

def ll_pdf_annot_event_page_visible(annot):
    r"""Low-level wrapper for `::pdf_annot_event_page_visible()`."""
    return _mupdf.ll_pdf_annot_event_page_visible(annot)

def ll_pdf_annot_event_up(annot):
    r"""Low-level wrapper for `::pdf_annot_event_up()`."""
    return _mupdf.ll_pdf_annot_event_up(annot)

def ll_pdf_annot_field_event_keystroke(doc, annot, evt):
    r"""Low-level wrapper for `::pdf_annot_field_event_keystroke()`."""
    return _mupdf.ll_pdf_annot_field_event_keystroke(doc, annot, evt)

def ll_pdf_annot_field_flags(annot):
    r"""Low-level wrapper for `::pdf_annot_field_flags()`."""
    return _mupdf.ll_pdf_annot_field_flags(annot)

def ll_pdf_annot_field_label(widget):
    r"""Low-level wrapper for `::pdf_annot_field_label()`."""
    return _mupdf.ll_pdf_annot_field_label(widget)

def ll_pdf_annot_field_value(annot):
    r"""Low-level wrapper for `::pdf_annot_field_value()`."""
    return _mupdf.ll_pdf_annot_field_value(annot)

def ll_pdf_annot_filespec(annot):
    r"""Low-level wrapper for `::pdf_annot_filespec()`."""
    return _mupdf.ll_pdf_annot_filespec(annot)

def ll_pdf_annot_flags(annot):
    r"""Low-level wrapper for `::pdf_annot_flags()`."""
    return _mupdf.ll_pdf_annot_flags(annot)

def ll_pdf_annot_has_author(annot):
    r"""Low-level wrapper for `::pdf_annot_has_author()`."""
    return _mupdf.ll_pdf_annot_has_author(annot)

def ll_pdf_annot_has_border(annot):
    r"""Low-level wrapper for `::pdf_annot_has_border()`."""
    return _mupdf.ll_pdf_annot_has_border(annot)

def ll_pdf_annot_has_border_effect(annot):
    r"""Low-level wrapper for `::pdf_annot_has_border_effect()`."""
    return _mupdf.ll_pdf_annot_has_border_effect(annot)

def ll_pdf_annot_has_callout(annot):
    r"""Low-level wrapper for `::pdf_annot_has_callout()`."""
    return _mupdf.ll_pdf_annot_has_callout(annot)

def ll_pdf_annot_has_filespec(annot):
    r"""Low-level wrapper for `::pdf_annot_has_filespec()`."""
    return _mupdf.ll_pdf_annot_has_filespec(annot)

def ll_pdf_annot_has_icon_name(annot):
    r"""Low-level wrapper for `::pdf_annot_has_icon_name()`."""
    return _mupdf.ll_pdf_annot_has_icon_name(annot)

def ll_pdf_annot_has_ink_list(annot):
    r"""Low-level wrapper for `::pdf_annot_has_ink_list()`."""
    return _mupdf.ll_pdf_annot_has_ink_list(annot)

def ll_pdf_annot_has_intent(annot):
    r"""Low-level wrapper for `::pdf_annot_has_intent()`."""
    return _mupdf.ll_pdf_annot_has_intent(annot)

def ll_pdf_annot_has_interior_color(annot):
    r"""Low-level wrapper for `::pdf_annot_has_interior_color()`."""
    return _mupdf.ll_pdf_annot_has_interior_color(annot)

def ll_pdf_annot_has_line(annot):
    r"""Low-level wrapper for `::pdf_annot_has_line()`."""
    return _mupdf.ll_pdf_annot_has_line(annot)

def ll_pdf_annot_has_line_ending_styles(annot):
    r"""Low-level wrapper for `::pdf_annot_has_line_ending_styles()`."""
    return _mupdf.ll_pdf_annot_has_line_ending_styles(annot)

def ll_pdf_annot_has_open(annot):
    r"""Low-level wrapper for `::pdf_annot_has_open()`."""
    return _mupdf.ll_pdf_annot_has_open(annot)

def ll_pdf_annot_has_popup(annot):
    r"""Low-level wrapper for `::pdf_annot_has_popup()`."""
    return _mupdf.ll_pdf_annot_has_popup(annot)

def ll_pdf_annot_has_quad_points(annot):
    r"""Low-level wrapper for `::pdf_annot_has_quad_points()`."""
    return _mupdf.ll_pdf_annot_has_quad_points(annot)

def ll_pdf_annot_has_quadding(annot):
    r"""Low-level wrapper for `::pdf_annot_has_quadding()`."""
    return _mupdf.ll_pdf_annot_has_quadding(annot)

def ll_pdf_annot_has_rect(annot):
    r"""Low-level wrapper for `::pdf_annot_has_rect()`."""
    return _mupdf.ll_pdf_annot_has_rect(annot)

def ll_pdf_annot_has_vertices(annot):
    r"""Low-level wrapper for `::pdf_annot_has_vertices()`."""
    return _mupdf.ll_pdf_annot_has_vertices(annot)

def ll_pdf_annot_hidden_for_editing(annot):
    r"""Low-level wrapper for `::pdf_annot_hidden_for_editing()`."""
    return _mupdf.ll_pdf_annot_hidden_for_editing(annot)

def ll_pdf_annot_hot(annot):
    r"""Low-level wrapper for `::pdf_annot_hot()`."""
    return _mupdf.ll_pdf_annot_hot(annot)

def ll_pdf_annot_icon_name(annot):
    r"""Low-level wrapper for `::pdf_annot_icon_name()`."""
    return _mupdf.ll_pdf_annot_icon_name(annot)

def ll_pdf_annot_ink_list_count(annot):
    r"""Low-level wrapper for `::pdf_annot_ink_list_count()`."""
    return _mupdf.ll_pdf_annot_ink_list_count(annot)

def ll_pdf_annot_ink_list_stroke_count(annot, i):
    r"""Low-level wrapper for `::pdf_annot_ink_list_stroke_count()`."""
    return _mupdf.ll_pdf_annot_ink_list_stroke_count(annot, i)

def ll_pdf_annot_ink_list_stroke_vertex(annot, i, k):
    r"""Low-level wrapper for `::pdf_annot_ink_list_stroke_vertex()`."""
    return _mupdf.ll_pdf_annot_ink_list_stroke_vertex(annot, i, k)

def ll_pdf_annot_intent(annot):
    r"""Low-level wrapper for `::pdf_annot_intent()`."""
    return _mupdf.ll_pdf_annot_intent(annot)

def ll_pdf_annot_interior_color(annot, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_interior_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_interior_color(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.ll_pdf_annot_interior_color(annot, n, color)

def ll_pdf_annot_is_open(annot):
    r"""Low-level wrapper for `::pdf_annot_is_open()`."""
    return _mupdf.ll_pdf_annot_is_open(annot)

def ll_pdf_annot_is_standard_stamp(annot):
    r"""Low-level wrapper for `::pdf_annot_is_standard_stamp()`."""
    return _mupdf.ll_pdf_annot_is_standard_stamp(annot)

def ll_pdf_annot_language(annot):
    r"""Low-level wrapper for `::pdf_annot_language()`."""
    return _mupdf.ll_pdf_annot_language(annot)

def ll_pdf_annot_line(annot, a, b):
    r"""Low-level wrapper for `::pdf_annot_line()`."""
    return _mupdf.ll_pdf_annot_line(annot, a, b)

def ll_pdf_annot_line_caption(annot):
    r"""Low-level wrapper for `::pdf_annot_line_caption()`."""
    return _mupdf.ll_pdf_annot_line_caption(annot)

def ll_pdf_annot_line_caption_offset(annot):
    r"""Low-level wrapper for `::pdf_annot_line_caption_offset()`."""
    return _mupdf.ll_pdf_annot_line_caption_offset(annot)

def ll_pdf_annot_line_end_style(annot):
    r"""Low-level wrapper for `::pdf_annot_line_end_style()`."""
    return _mupdf.ll_pdf_annot_line_end_style(annot)

def ll_pdf_annot_line_ending_styles(annot, start_style, end_style):
    r"""
     Low-level wrapper for `::pdf_annot_line_ending_styles()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_line_ending_styles(::pdf_annot *annot)` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
    """
    return _mupdf.ll_pdf_annot_line_ending_styles(annot, start_style, end_style)

def ll_pdf_annot_line_leader(annot):
    r"""Low-level wrapper for `::pdf_annot_line_leader()`."""
    return _mupdf.ll_pdf_annot_line_leader(annot)

def ll_pdf_annot_line_leader_extension(annot):
    r"""Low-level wrapper for `::pdf_annot_line_leader_extension()`."""
    return _mupdf.ll_pdf_annot_line_leader_extension(annot)

def ll_pdf_annot_line_leader_offset(annot):
    r"""Low-level wrapper for `::pdf_annot_line_leader_offset()`."""
    return _mupdf.ll_pdf_annot_line_leader_offset(annot)

def ll_pdf_annot_line_start_style(annot):
    r"""Low-level wrapper for `::pdf_annot_line_start_style()`."""
    return _mupdf.ll_pdf_annot_line_start_style(annot)

def ll_pdf_annot_modification_date(annot):
    r"""Low-level wrapper for `::pdf_annot_modification_date()`."""
    return _mupdf.ll_pdf_annot_modification_date(annot)

def ll_pdf_annot_needs_resynthesis(annot):
    r"""Low-level wrapper for `::pdf_annot_needs_resynthesis()`."""
    return _mupdf.ll_pdf_annot_needs_resynthesis(annot)

def ll_pdf_annot_obj(annot):
    r"""Low-level wrapper for `::pdf_annot_obj()`."""
    return _mupdf.ll_pdf_annot_obj(annot)

def ll_pdf_annot_opacity(annot):
    r"""Low-level wrapper for `::pdf_annot_opacity()`."""
    return _mupdf.ll_pdf_annot_opacity(annot)

def ll_pdf_annot_page(annot):
    r"""Low-level wrapper for `::pdf_annot_page()`."""
    return _mupdf.ll_pdf_annot_page(annot)

def ll_pdf_annot_pop_and_discard_local_xref(annot):
    r"""Low-level wrapper for `::pdf_annot_pop_and_discard_local_xref()`."""
    return _mupdf.ll_pdf_annot_pop_and_discard_local_xref(annot)

def ll_pdf_annot_pop_local_xref(annot):
    r"""Low-level wrapper for `::pdf_annot_pop_local_xref()`."""
    return _mupdf.ll_pdf_annot_pop_local_xref(annot)

def ll_pdf_annot_popup(annot):
    r"""Low-level wrapper for `::pdf_annot_popup()`."""
    return _mupdf.ll_pdf_annot_popup(annot)

def ll_pdf_annot_push_local_xref(annot):
    r"""Low-level wrapper for `::pdf_annot_push_local_xref()`."""
    return _mupdf.ll_pdf_annot_push_local_xref(annot)

def ll_pdf_annot_quad_point(annot, i):
    r"""Low-level wrapper for `::pdf_annot_quad_point()`."""
    return _mupdf.ll_pdf_annot_quad_point(annot, i)

def ll_pdf_annot_quad_point_count(annot):
    r"""Low-level wrapper for `::pdf_annot_quad_point_count()`."""
    return _mupdf.ll_pdf_annot_quad_point_count(annot)

def ll_pdf_annot_quadding(annot):
    r"""Low-level wrapper for `::pdf_annot_quadding()`."""
    return _mupdf.ll_pdf_annot_quadding(annot)

def ll_pdf_annot_rect(annot):
    r"""Low-level wrapper for `::pdf_annot_rect()`."""
    return _mupdf.ll_pdf_annot_rect(annot)

def ll_pdf_annot_request_resynthesis(annot):
    r"""Low-level wrapper for `::pdf_annot_request_resynthesis()`."""
    return _mupdf.ll_pdf_annot_request_resynthesis(annot)

def ll_pdf_annot_request_synthesis(annot):
    r"""Low-level wrapper for `::pdf_annot_request_synthesis()`."""
    return _mupdf.ll_pdf_annot_request_synthesis(annot)

def ll_pdf_annot_transform(annot):
    r"""Low-level wrapper for `::pdf_annot_transform()`."""
    return _mupdf.ll_pdf_annot_transform(annot)

def ll_pdf_annot_type(annot):
    r"""Low-level wrapper for `::pdf_annot_type()`."""
    return _mupdf.ll_pdf_annot_type(annot)

def ll_pdf_annot_type_from_string(subtype):
    r"""Low-level wrapper for `::pdf_annot_type_from_string()`."""
    return _mupdf.ll_pdf_annot_type_from_string(subtype)

def ll_pdf_annot_vertex(annot, i):
    r"""Low-level wrapper for `::pdf_annot_vertex()`."""
    return _mupdf.ll_pdf_annot_vertex(annot, i)

def ll_pdf_annot_vertex_count(annot):
    r"""Low-level wrapper for `::pdf_annot_vertex_count()`."""
    return _mupdf.ll_pdf_annot_vertex_count(annot)

def ll_pdf_append_explicit_dest_to_uri(url, dest):
    r"""Low-level wrapper for `::pdf_append_explicit_dest_to_uri()`."""
    return _mupdf.ll_pdf_append_explicit_dest_to_uri(url, dest)

def ll_pdf_append_named_dest_to_uri(url, name):
    r"""Low-level wrapper for `::pdf_append_named_dest_to_uri()`."""
    return _mupdf.ll_pdf_append_named_dest_to_uri(url, name)

def ll_pdf_append_token(buf, tok, lex):
    r"""Low-level wrapper for `::pdf_append_token()`."""
    return _mupdf.ll_pdf_append_token(buf, tok, lex)

def ll_pdf_apply_redaction(annot, opts):
    r"""Low-level wrapper for `::pdf_apply_redaction()`."""
    return _mupdf.ll_pdf_apply_redaction(annot, opts)

def ll_pdf_array_contains(array, obj):
    r"""Low-level wrapper for `::pdf_array_contains()`."""
    return _mupdf.ll_pdf_array_contains(array, obj)

def ll_pdf_array_delete(array, index):
    r"""Low-level wrapper for `::pdf_array_delete()`."""
    return _mupdf.ll_pdf_array_delete(array, index)

def ll_pdf_array_find(array, obj):
    r"""Low-level wrapper for `::pdf_array_find()`."""
    return _mupdf.ll_pdf_array_find(array, obj)

def ll_pdf_array_get(array, i):
    r"""Low-level wrapper for `::pdf_array_get()`."""
    return _mupdf.ll_pdf_array_get(array, i)

def ll_pdf_array_get_bool(array, index):
    r"""Low-level wrapper for `::pdf_array_get_bool()`."""
    return _mupdf.ll_pdf_array_get_bool(array, index)

def ll_pdf_array_get_int(array, index):
    r"""Low-level wrapper for `::pdf_array_get_int()`."""
    return _mupdf.ll_pdf_array_get_int(array, index)

def ll_pdf_array_get_matrix(array, index):
    r"""Low-level wrapper for `::pdf_array_get_matrix()`."""
    return _mupdf.ll_pdf_array_get_matrix(array, index)

def ll_pdf_array_get_name(array, index):
    r"""Low-level wrapper for `::pdf_array_get_name()`."""
    return _mupdf.ll_pdf_array_get_name(array, index)

def ll_pdf_array_get_real(array, index):
    r"""Low-level wrapper for `::pdf_array_get_real()`."""
    return _mupdf.ll_pdf_array_get_real(array, index)

def ll_pdf_array_get_rect(array, index):
    r"""Low-level wrapper for `::pdf_array_get_rect()`."""
    return _mupdf.ll_pdf_array_get_rect(array, index)

def ll_pdf_array_get_string(array, index, sizep):
    r"""
     Low-level wrapper for `::pdf_array_get_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_array_get_string(::pdf_obj *array, int index)` => `(const char *, size_t sizep)`
    """
    return _mupdf.ll_pdf_array_get_string(array, index, sizep)

def ll_pdf_array_get_text_string(array, index):
    r"""Low-level wrapper for `::pdf_array_get_text_string()`."""
    return _mupdf.ll_pdf_array_get_text_string(array, index)

def ll_pdf_array_insert(array, obj, index):
    r"""Low-level wrapper for `::pdf_array_insert()`."""
    return _mupdf.ll_pdf_array_insert(array, obj, index)

def ll_pdf_array_insert_drop(array, obj, index):
    r"""Low-level wrapper for `::pdf_array_insert_drop()`."""
    return _mupdf.ll_pdf_array_insert_drop(array, obj, index)

def ll_pdf_array_len(array):
    r"""Low-level wrapper for `::pdf_array_len()`."""
    return _mupdf.ll_pdf_array_len(array)

def ll_pdf_array_push(array, obj):
    r"""Low-level wrapper for `::pdf_array_push()`."""
    return _mupdf.ll_pdf_array_push(array, obj)

def ll_pdf_array_push_array(array, initial):
    r"""Low-level wrapper for `::pdf_array_push_array()`."""
    return _mupdf.ll_pdf_array_push_array(array, initial)

def ll_pdf_array_push_bool(array, x):
    r"""Low-level wrapper for `::pdf_array_push_bool()`."""
    return _mupdf.ll_pdf_array_push_bool(array, x)

def ll_pdf_array_push_dict(array, initial):
    r"""Low-level wrapper for `::pdf_array_push_dict()`."""
    return _mupdf.ll_pdf_array_push_dict(array, initial)

def ll_pdf_array_push_drop(array, obj):
    r"""Low-level wrapper for `::pdf_array_push_drop()`."""
    return _mupdf.ll_pdf_array_push_drop(array, obj)

def ll_pdf_array_push_int(array, x):
    r"""Low-level wrapper for `::pdf_array_push_int()`."""
    return _mupdf.ll_pdf_array_push_int(array, x)

def ll_pdf_array_push_name(array, x):
    r"""Low-level wrapper for `::pdf_array_push_name()`."""
    return _mupdf.ll_pdf_array_push_name(array, x)

def ll_pdf_array_push_real(array, x):
    r"""Low-level wrapper for `::pdf_array_push_real()`."""
    return _mupdf.ll_pdf_array_push_real(array, x)

def ll_pdf_array_push_string(array, x, n):
    r"""Low-level wrapper for `::pdf_array_push_string()`."""
    return _mupdf.ll_pdf_array_push_string(array, x, n)

def ll_pdf_array_push_text_string(array, x):
    r"""Low-level wrapper for `::pdf_array_push_text_string()`."""
    return _mupdf.ll_pdf_array_push_text_string(array, x)

def ll_pdf_array_put(array, i, obj):
    r"""Low-level wrapper for `::pdf_array_put()`."""
    return _mupdf.ll_pdf_array_put(array, i, obj)

def ll_pdf_array_put_array(array, i, initial):
    r"""Low-level wrapper for `::pdf_array_put_array()`."""
    return _mupdf.ll_pdf_array_put_array(array, i, initial)

def ll_pdf_array_put_bool(array, i, x):
    r"""Low-level wrapper for `::pdf_array_put_bool()`."""
    return _mupdf.ll_pdf_array_put_bool(array, i, x)

def ll_pdf_array_put_dict(array, i, initial):
    r"""Low-level wrapper for `::pdf_array_put_dict()`."""
    return _mupdf.ll_pdf_array_put_dict(array, i, initial)

def ll_pdf_array_put_drop(array, i, obj):
    r"""Low-level wrapper for `::pdf_array_put_drop()`."""
    return _mupdf.ll_pdf_array_put_drop(array, i, obj)

def ll_pdf_array_put_int(array, i, x):
    r"""Low-level wrapper for `::pdf_array_put_int()`."""
    return _mupdf.ll_pdf_array_put_int(array, i, x)

def ll_pdf_array_put_name(array, i, x):
    r"""Low-level wrapper for `::pdf_array_put_name()`."""
    return _mupdf.ll_pdf_array_put_name(array, i, x)

def ll_pdf_array_put_real(array, i, x):
    r"""Low-level wrapper for `::pdf_array_put_real()`."""
    return _mupdf.ll_pdf_array_put_real(array, i, x)

def ll_pdf_array_put_string(array, i, x, n):
    r"""Low-level wrapper for `::pdf_array_put_string()`."""
    return _mupdf.ll_pdf_array_put_string(array, i, x, n)

def ll_pdf_array_put_text_string(array, i, x):
    r"""Low-level wrapper for `::pdf_array_put_text_string()`."""
    return _mupdf.ll_pdf_array_put_text_string(array, i, x)

def ll_pdf_authenticate_password(doc, pw):
    r"""Low-level wrapper for `::pdf_authenticate_password()`."""
    return _mupdf.ll_pdf_authenticate_password(doc, pw)

def ll_pdf_bake_document(doc, bake_annots, bake_widgets):
    r"""Low-level wrapper for `::pdf_bake_document()`."""
    return _mupdf.ll_pdf_bake_document(doc, bake_annots, bake_widgets)

def ll_pdf_begin_implicit_operation(doc):
    r"""Low-level wrapper for `::pdf_begin_implicit_operation()`."""
    return _mupdf.ll_pdf_begin_implicit_operation(doc)

def ll_pdf_begin_operation(doc, operation):
    r"""Low-level wrapper for `::pdf_begin_operation()`."""
    return _mupdf.ll_pdf_begin_operation(doc, operation)

def ll_pdf_bound_annot(annot):
    r"""Low-level wrapper for `::pdf_bound_annot()`."""
    return _mupdf.ll_pdf_bound_annot(annot)

def ll_pdf_bound_page(page, box):
    r"""Low-level wrapper for `::pdf_bound_page()`."""
    return _mupdf.ll_pdf_bound_page(page, box)

def ll_pdf_bound_widget(widget):
    r"""Low-level wrapper for `::pdf_bound_widget()`."""
    return _mupdf.ll_pdf_bound_widget(widget)

def ll_pdf_button_field_on_state(field):
    r"""Low-level wrapper for `::pdf_button_field_on_state()`."""
    return _mupdf.ll_pdf_button_field_on_state(field)

def ll_pdf_cache_object(doc, num):
    r"""
    Low-level wrapper for `::pdf_cache_object()`.
    Retrieve the pdf_xref_entry for a given object.

    This can cause xref reorganisations (solidifications etc) due to
    repairs, so all held pdf_xref_entries should be considered
    invalid after this call (other than the returned one).
    """
    return _mupdf.ll_pdf_cache_object(doc, num)

def ll_pdf_calculate_form(doc):
    r"""Low-level wrapper for `::pdf_calculate_form()`."""
    return _mupdf.ll_pdf_calculate_form(doc)

def ll_pdf_can_be_saved_incrementally(doc):
    r"""Low-level wrapper for `::pdf_can_be_saved_incrementally()`."""
    return _mupdf.ll_pdf_can_be_saved_incrementally(doc)

def ll_pdf_can_redo(doc):
    r"""Low-level wrapper for `::pdf_can_redo()`."""
    return _mupdf.ll_pdf_can_redo(doc)

def ll_pdf_can_undo(doc):
    r"""Low-level wrapper for `::pdf_can_undo()`."""
    return _mupdf.ll_pdf_can_undo(doc)

def ll_pdf_check_certificate(verifier, doc, signature):
    r"""Low-level wrapper for `::pdf_check_certificate()`."""
    return _mupdf.ll_pdf_check_certificate(verifier, doc, signature)

def ll_pdf_check_digest(verifier, doc, signature):
    r"""Low-level wrapper for `::pdf_check_digest()`."""
    return _mupdf.ll_pdf_check_digest(verifier, doc, signature)

def ll_pdf_check_widget_certificate(verifier, widget):
    r"""Low-level wrapper for `::pdf_check_widget_certificate()`."""
    return _mupdf.ll_pdf_check_widget_certificate(verifier, widget)

def ll_pdf_check_widget_digest(verifier, widget):
    r"""Low-level wrapper for `::pdf_check_widget_digest()`."""
    return _mupdf.ll_pdf_check_widget_digest(verifier, widget)

def ll_pdf_choice_field_option(field, exportval, i):
    r"""Low-level wrapper for `::pdf_choice_field_option()`."""
    return _mupdf.ll_pdf_choice_field_option(field, exportval, i)

def ll_pdf_choice_field_option_count(field):
    r"""Low-level wrapper for `::pdf_choice_field_option_count()`."""
    return _mupdf.ll_pdf_choice_field_option_count(field)

def ll_pdf_choice_widget_is_multiselect(tw):
    r"""Low-level wrapper for `::pdf_choice_widget_is_multiselect()`."""
    return _mupdf.ll_pdf_choice_widget_is_multiselect(tw)

def ll_pdf_choice_widget_options(tw, exportval, opts):
    r"""Low-level wrapper for `::pdf_choice_widget_options()`."""
    return _mupdf.ll_pdf_choice_widget_options(tw, exportval, opts)

def ll_pdf_choice_widget_options2(tw, exportval):
    r"""
     Low-level wrapper for `::pdf_choice_widget_options2()`.  Swig-friendly wrapper for pdf_choice_widget_options(), returns the
    options directly in a vector.
    """
    return _mupdf.ll_pdf_choice_widget_options2(tw, exportval)

def ll_pdf_choice_widget_set_value(tw, n, opts):
    r"""Low-level wrapper for `::pdf_choice_widget_set_value()`."""
    return _mupdf.ll_pdf_choice_widget_set_value(tw, n, opts)

def ll_pdf_choice_widget_value(tw, opts):
    r"""Low-level wrapper for `::pdf_choice_widget_value()`."""
    return _mupdf.ll_pdf_choice_widget_value(tw, opts)

def ll_pdf_clean_file(infile, outfile, password, opts, retainlen):
    r"""Low-level wrapper for `::pdf_clean_file()`."""
    return _mupdf.ll_pdf_clean_file(infile, outfile, password, opts, retainlen)

def ll_pdf_clean_font_name(fontname):
    r"""Low-level wrapper for `::pdf_clean_font_name()`."""
    return _mupdf.ll_pdf_clean_font_name(fontname)

def ll_pdf_clean_obj(obj):
    r"""Low-level wrapper for `::pdf_clean_obj()`."""
    return _mupdf.ll_pdf_clean_obj(obj)

def ll_pdf_clear_annot_border_dash(annot):
    r"""Low-level wrapper for `::pdf_clear_annot_border_dash()`."""
    return _mupdf.ll_pdf_clear_annot_border_dash(annot)

def ll_pdf_clear_annot_ink_list(annot):
    r"""Low-level wrapper for `::pdf_clear_annot_ink_list()`."""
    return _mupdf.ll_pdf_clear_annot_ink_list(annot)

def ll_pdf_clear_annot_quad_points(annot):
    r"""Low-level wrapper for `::pdf_clear_annot_quad_points()`."""
    return _mupdf.ll_pdf_clear_annot_quad_points(annot)

def ll_pdf_clear_annot_vertices(annot):
    r"""Low-level wrapper for `::pdf_clear_annot_vertices()`."""
    return _mupdf.ll_pdf_clear_annot_vertices(annot)

def ll_pdf_clear_signature(widget):
    r"""Low-level wrapper for `::pdf_clear_signature()`."""
    return _mupdf.ll_pdf_clear_signature(widget)

def ll_pdf_clear_xref(doc):
    r"""Low-level wrapper for `::pdf_clear_xref()`."""
    return _mupdf.ll_pdf_clear_xref(doc)

def ll_pdf_clear_xref_to_mark(doc):
    r"""Low-level wrapper for `::pdf_clear_xref_to_mark()`."""
    return _mupdf.ll_pdf_clear_xref_to_mark(doc)

def ll_pdf_close_processor(proc):
    r"""Low-level wrapper for `::pdf_close_processor()`."""
    return _mupdf.ll_pdf_close_processor(proc)

def ll_pdf_cmap_size(cmap):
    r"""Low-level wrapper for `::pdf_cmap_size()`."""
    return _mupdf.ll_pdf_cmap_size(cmap)

def ll_pdf_cmap_wmode(cmap):
    r"""Low-level wrapper for `::pdf_cmap_wmode()`."""
    return _mupdf.ll_pdf_cmap_wmode(cmap)

def ll_pdf_copy_array(array):
    r"""Low-level wrapper for `::pdf_copy_array()`."""
    return _mupdf.ll_pdf_copy_array(array)

def ll_pdf_copy_dict(dict):
    r"""Low-level wrapper for `::pdf_copy_dict()`."""
    return _mupdf.ll_pdf_copy_dict(dict)

def ll_pdf_count_document_associated_files(doc):
    r"""Low-level wrapper for `::pdf_count_document_associated_files()`."""
    return _mupdf.ll_pdf_count_document_associated_files(doc)

def ll_pdf_count_layer_config_ui(doc):
    r"""Low-level wrapper for `::pdf_count_layer_config_ui()`."""
    return _mupdf.ll_pdf_count_layer_config_ui(doc)

def ll_pdf_count_layer_configs(doc):
    r"""Low-level wrapper for `::pdf_count_layer_configs()`."""
    return _mupdf.ll_pdf_count_layer_configs(doc)

def ll_pdf_count_layers(doc):
    r"""Low-level wrapper for `::pdf_count_layers()`."""
    return _mupdf.ll_pdf_count_layers(doc)

def ll_pdf_count_objects(doc):
    r"""Low-level wrapper for `::pdf_count_objects()`."""
    return _mupdf.ll_pdf_count_objects(doc)

def ll_pdf_count_page_associated_files(page):
    r"""Low-level wrapper for `::pdf_count_page_associated_files()`."""
    return _mupdf.ll_pdf_count_page_associated_files(page)

def ll_pdf_count_pages(doc):
    r"""Low-level wrapper for `::pdf_count_pages()`."""
    return _mupdf.ll_pdf_count_pages(doc)

def ll_pdf_count_pages_imp(doc, chapter):
    r"""Low-level wrapper for `::pdf_count_pages_imp()`."""
    return _mupdf.ll_pdf_count_pages_imp(doc, chapter)

def ll_pdf_count_q_balance(doc, res, stm, prepend, append):
    r"""
     Low-level wrapper for `::pdf_count_q_balance()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_count_q_balance(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
    """
    return _mupdf.ll_pdf_count_q_balance(doc, res, stm, prepend, append)

def ll_pdf_count_signatures(doc):
    r"""Low-level wrapper for `::pdf_count_signatures()`."""
    return _mupdf.ll_pdf_count_signatures(doc)

def ll_pdf_count_unsaved_versions(doc):
    r"""Low-level wrapper for `::pdf_count_unsaved_versions()`."""
    return _mupdf.ll_pdf_count_unsaved_versions(doc)

def ll_pdf_count_versions(doc):
    r"""Low-level wrapper for `::pdf_count_versions()`."""
    return _mupdf.ll_pdf_count_versions(doc)

def ll_pdf_create_annot(page, type):
    r"""Low-level wrapper for `::pdf_create_annot()`."""
    return _mupdf.ll_pdf_create_annot(page, type)

def ll_pdf_create_annot_raw(page, type):
    r"""Low-level wrapper for `::pdf_create_annot_raw()`."""
    return _mupdf.ll_pdf_create_annot_raw(page, type)

def ll_pdf_create_document():
    r"""Low-level wrapper for `::pdf_create_document()`."""
    return _mupdf.ll_pdf_create_document()

def ll_pdf_create_field_name(doc, prefix, buf, len):
    r"""Low-level wrapper for `::pdf_create_field_name()`."""
    return _mupdf.ll_pdf_create_field_name(doc, prefix, buf, len)

def ll_pdf_create_link(page, bbox, uri):
    r"""Low-level wrapper for `::pdf_create_link()`."""
    return _mupdf.ll_pdf_create_link(page, bbox, uri)

def ll_pdf_create_object(doc):
    r"""Low-level wrapper for `::pdf_create_object()`."""
    return _mupdf.ll_pdf_create_object(doc)

def ll_pdf_create_signature_widget(page, name):
    r"""Low-level wrapper for `::pdf_create_signature_widget()`."""
    return _mupdf.ll_pdf_create_signature_widget(page, name)

def ll_pdf_crypt_encrypt_metadata(crypt):
    r"""Low-level wrapper for `::pdf_crypt_encrypt_metadata()`."""
    return _mupdf.ll_pdf_crypt_encrypt_metadata(crypt)

def ll_pdf_crypt_key(crypt):
    r"""Low-level wrapper for `::pdf_crypt_key()`."""
    return _mupdf.ll_pdf_crypt_key(crypt)

def ll_pdf_crypt_length(crypt):
    r"""Low-level wrapper for `::pdf_crypt_length()`."""
    return _mupdf.ll_pdf_crypt_length(crypt)

def ll_pdf_crypt_method(crypt):
    r"""Low-level wrapper for `::pdf_crypt_method()`."""
    return _mupdf.ll_pdf_crypt_method(crypt)

def ll_pdf_crypt_obj(crypt, obj, num, gen):
    r"""Low-level wrapper for `::pdf_crypt_obj()`."""
    return _mupdf.ll_pdf_crypt_obj(crypt, obj, num, gen)

def ll_pdf_crypt_owner_encryption(crypt):
    r"""Low-level wrapper for `::pdf_crypt_owner_encryption()`."""
    return _mupdf.ll_pdf_crypt_owner_encryption(crypt)

def ll_pdf_crypt_owner_password(crypt):
    r"""Low-level wrapper for `::pdf_crypt_owner_password()`."""
    return _mupdf.ll_pdf_crypt_owner_password(crypt)

def ll_pdf_crypt_permissions(crypt):
    r"""Low-level wrapper for `::pdf_crypt_permissions()`."""
    return _mupdf.ll_pdf_crypt_permissions(crypt)

def ll_pdf_crypt_permissions_encryption(crypt):
    r"""Low-level wrapper for `::pdf_crypt_permissions_encryption()`."""
    return _mupdf.ll_pdf_crypt_permissions_encryption(crypt)

def ll_pdf_crypt_revision(crypt):
    r"""Low-level wrapper for `::pdf_crypt_revision()`."""
    return _mupdf.ll_pdf_crypt_revision(crypt)

def ll_pdf_crypt_stream_method(crypt):
    r"""Low-level wrapper for `::pdf_crypt_stream_method()`."""
    return _mupdf.ll_pdf_crypt_stream_method(crypt)

def ll_pdf_crypt_string_method(crypt):
    r"""Low-level wrapper for `::pdf_crypt_string_method()`."""
    return _mupdf.ll_pdf_crypt_string_method(crypt)

def ll_pdf_crypt_user_encryption(crypt):
    r"""Low-level wrapper for `::pdf_crypt_user_encryption()`."""
    return _mupdf.ll_pdf_crypt_user_encryption(crypt)

def ll_pdf_crypt_user_password(crypt):
    r"""Low-level wrapper for `::pdf_crypt_user_password()`."""
    return _mupdf.ll_pdf_crypt_user_password(crypt)

def ll_pdf_crypt_version(crypt):
    r"""Low-level wrapper for `::pdf_crypt_version()`."""
    return _mupdf.ll_pdf_crypt_version(crypt)

def ll_pdf_cycle(here, prev, obj):
    r"""Low-level wrapper for `::pdf_cycle()`."""
    return _mupdf.ll_pdf_cycle(here, prev, obj)

def ll_pdf_debug_doc_changes(doc):
    r"""Low-level wrapper for `::pdf_debug_doc_changes()`."""
    return _mupdf.ll_pdf_debug_doc_changes(doc)

def ll_pdf_debug_obj(obj):
    r"""Low-level wrapper for `::pdf_debug_obj()`."""
    return _mupdf.ll_pdf_debug_obj(obj)

def ll_pdf_debug_ref(obj):
    r"""Low-level wrapper for `::pdf_debug_ref()`."""
    return _mupdf.ll_pdf_debug_ref(obj)

def ll_pdf_decode_cmap(cmap, s, e, cpt):
    r"""
     Low-level wrapper for `::pdf_decode_cmap()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_decode_cmap(::pdf_cmap *cmap, unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
    """
    return _mupdf.ll_pdf_decode_cmap(cmap, s, e, cpt)

def ll_pdf_deep_copy_obj(obj):
    r"""Low-level wrapper for `::pdf_deep_copy_obj()`."""
    return _mupdf.ll_pdf_deep_copy_obj(obj)

def ll_pdf_delete_annot(page, annot):
    r"""Low-level wrapper for `::pdf_delete_annot()`."""
    return _mupdf.ll_pdf_delete_annot(page, annot)

def ll_pdf_delete_link(page, link):
    r"""Low-level wrapper for `::pdf_delete_link()`."""
    return _mupdf.ll_pdf_delete_link(page, link)

def ll_pdf_delete_object(doc, num):
    r"""Low-level wrapper for `::pdf_delete_object()`."""
    return _mupdf.ll_pdf_delete_object(doc, num)

def ll_pdf_delete_page(doc, number):
    r"""Low-level wrapper for `::pdf_delete_page()`."""
    return _mupdf.ll_pdf_delete_page(doc, number)

def ll_pdf_delete_page_labels(doc, index):
    r"""Low-level wrapper for `::pdf_delete_page_labels()`."""
    return _mupdf.ll_pdf_delete_page_labels(doc, index)

def ll_pdf_delete_page_range(doc, start, end):
    r"""Low-level wrapper for `::pdf_delete_page_range()`."""
    return _mupdf.ll_pdf_delete_page_range(doc, start, end)

def ll_pdf_deselect_layer_config_ui(doc, ui):
    r"""Low-level wrapper for `::pdf_deselect_layer_config_ui()`."""
    return _mupdf.ll_pdf_deselect_layer_config_ui(doc, ui)

def ll_pdf_deserialise_journal(doc, stm):
    r"""Low-level wrapper for `::pdf_deserialise_journal()`."""
    return _mupdf.ll_pdf_deserialise_journal(doc, stm)

def ll_pdf_dict_del(dict, key):
    r"""Low-level wrapper for `::pdf_dict_del()`."""
    return _mupdf.ll_pdf_dict_del(dict, key)

def ll_pdf_dict_dels(dict, key):
    r"""Low-level wrapper for `::pdf_dict_dels()`."""
    return _mupdf.ll_pdf_dict_dels(dict, key)

def ll_pdf_dict_get(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get()`."""
    return _mupdf.ll_pdf_dict_get(dict, key)

def ll_pdf_dict_get_bool(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_bool()`."""
    return _mupdf.ll_pdf_dict_get_bool(dict, key)

def ll_pdf_dict_get_bool_default(dict, key, _def):
    r"""Low-level wrapper for `::pdf_dict_get_bool_default()`."""
    return _mupdf.ll_pdf_dict_get_bool_default(dict, key, _def)

def ll_pdf_dict_get_date(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_date()`."""
    return _mupdf.ll_pdf_dict_get_date(dict, key)

def ll_pdf_dict_get_inheritable(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable()`."""
    return _mupdf.ll_pdf_dict_get_inheritable(dict, key)

def ll_pdf_dict_get_inheritable_bool(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable_bool()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_bool(dict, key)

def ll_pdf_dict_get_inheritable_date(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable_date()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_date(dict, key)

def ll_pdf_dict_get_inheritable_int(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable_int()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_int(dict, key)

def ll_pdf_dict_get_inheritable_int64(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable_int64()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_int64(dict, key)

def ll_pdf_dict_get_inheritable_matrix(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable_matrix()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_matrix(dict, key)

def ll_pdf_dict_get_inheritable_name(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable_name()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_name(dict, key)

def ll_pdf_dict_get_inheritable_real(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable_real()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_real(dict, key)

def ll_pdf_dict_get_inheritable_rect(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable_rect()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_rect(dict, key)

def ll_pdf_dict_get_inheritable_string(dict, key, sizep):
    r"""
     Low-level wrapper for `::pdf_dict_get_inheritable_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_dict_get_inheritable_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
    """
    return _mupdf.ll_pdf_dict_get_inheritable_string(dict, key, sizep)

def ll_pdf_dict_get_inheritable_text_string(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_inheritable_text_string()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_text_string(dict, key)

def ll_pdf_dict_get_int(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_int()`."""
    return _mupdf.ll_pdf_dict_get_int(dict, key)

def ll_pdf_dict_get_int64(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_int64()`."""
    return _mupdf.ll_pdf_dict_get_int64(dict, key)

def ll_pdf_dict_get_int_default(dict, key, _def):
    r"""Low-level wrapper for `::pdf_dict_get_int_default()`."""
    return _mupdf.ll_pdf_dict_get_int_default(dict, key, _def)

def ll_pdf_dict_get_key(dict, idx):
    r"""Low-level wrapper for `::pdf_dict_get_key()`."""
    return _mupdf.ll_pdf_dict_get_key(dict, idx)

def ll_pdf_dict_get_matrix(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_matrix()`."""
    return _mupdf.ll_pdf_dict_get_matrix(dict, key)

def ll_pdf_dict_get_name(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_name()`."""
    return _mupdf.ll_pdf_dict_get_name(dict, key)

def ll_pdf_dict_get_point(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_point()`."""
    return _mupdf.ll_pdf_dict_get_point(dict, key)

def ll_pdf_dict_get_put_drop(dict, key, val, old_val):
    r"""
     Low-level wrapper for `::pdf_dict_get_put_drop()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_dict_get_put_drop(::pdf_obj *dict, ::pdf_obj *key, ::pdf_obj *val, ::pdf_obj **old_val)` =>
    """
    return _mupdf.ll_pdf_dict_get_put_drop(dict, key, val, old_val)

def ll_pdf_dict_get_real(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_real()`."""
    return _mupdf.ll_pdf_dict_get_real(dict, key)

def ll_pdf_dict_get_real_default(dict, key, _def):
    r"""Low-level wrapper for `::pdf_dict_get_real_default()`."""
    return _mupdf.ll_pdf_dict_get_real_default(dict, key, _def)

def ll_pdf_dict_get_rect(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_rect()`."""
    return _mupdf.ll_pdf_dict_get_rect(dict, key)

def ll_pdf_dict_get_string(dict, key, sizep):
    r"""
     Low-level wrapper for `::pdf_dict_get_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_dict_get_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
    """
    return _mupdf.ll_pdf_dict_get_string(dict, key, sizep)

def ll_pdf_dict_get_text_string(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_text_string()`."""
    return _mupdf.ll_pdf_dict_get_text_string(dict, key)

def ll_pdf_dict_get_text_string_opt(dict, key):
    r"""Low-level wrapper for `::pdf_dict_get_text_string_opt()`."""
    return _mupdf.ll_pdf_dict_get_text_string_opt(dict, key)

def ll_pdf_dict_get_val(dict, idx):
    r"""Low-level wrapper for `::pdf_dict_get_val()`."""
    return _mupdf.ll_pdf_dict_get_val(dict, idx)

def ll_pdf_dict_geta(dict, key, abbrev):
    r"""Low-level wrapper for `::pdf_dict_geta()`."""
    return _mupdf.ll_pdf_dict_geta(dict, key, abbrev)

def ll_pdf_dict_getp(dict, path):
    r"""Low-level wrapper for `::pdf_dict_getp()`."""
    return _mupdf.ll_pdf_dict_getp(dict, path)

def ll_pdf_dict_getp_inheritable(dict, path):
    r"""Low-level wrapper for `::pdf_dict_getp_inheritable()`."""
    return _mupdf.ll_pdf_dict_getp_inheritable(dict, path)

def ll_pdf_dict_gets(dict, key):
    r"""Low-level wrapper for `::pdf_dict_gets()`."""
    return _mupdf.ll_pdf_dict_gets(dict, key)

def ll_pdf_dict_gets_inheritable(dict, key):
    r"""Low-level wrapper for `::pdf_dict_gets_inheritable()`."""
    return _mupdf.ll_pdf_dict_gets_inheritable(dict, key)

def ll_pdf_dict_getsa(dict, key, abbrev):
    r"""Low-level wrapper for `::pdf_dict_getsa()`."""
    return _mupdf.ll_pdf_dict_getsa(dict, key, abbrev)

def ll_pdf_dict_len(dict):
    r"""Low-level wrapper for `::pdf_dict_len()`."""
    return _mupdf.ll_pdf_dict_len(dict)

def ll_pdf_dict_put(dict, key, val):
    r"""Low-level wrapper for `::pdf_dict_put()`."""
    return _mupdf.ll_pdf_dict_put(dict, key, val)

def ll_pdf_dict_put_array(dict, key, initial):
    r"""Low-level wrapper for `::pdf_dict_put_array()`."""
    return _mupdf.ll_pdf_dict_put_array(dict, key, initial)

def ll_pdf_dict_put_bool(dict, key, x):
    r"""Low-level wrapper for `::pdf_dict_put_bool()`."""
    return _mupdf.ll_pdf_dict_put_bool(dict, key, x)

def ll_pdf_dict_put_date(dict, key, time):
    r"""Low-level wrapper for `::pdf_dict_put_date()`."""
    return _mupdf.ll_pdf_dict_put_date(dict, key, time)

def ll_pdf_dict_put_dict(dict, key, initial):
    r"""Low-level wrapper for `::pdf_dict_put_dict()`."""
    return _mupdf.ll_pdf_dict_put_dict(dict, key, initial)

def ll_pdf_dict_put_drop(dict, key, val):
    r"""Low-level wrapper for `::pdf_dict_put_drop()`."""
    return _mupdf.ll_pdf_dict_put_drop(dict, key, val)

def ll_pdf_dict_put_indirect(dict, key, num):
    r"""Low-level wrapper for `::pdf_dict_put_indirect()`."""
    return _mupdf.ll_pdf_dict_put_indirect(dict, key, num)

def ll_pdf_dict_put_int(dict, key, x):
    r"""Low-level wrapper for `::pdf_dict_put_int()`."""
    return _mupdf.ll_pdf_dict_put_int(dict, key, x)

def ll_pdf_dict_put_matrix(dict, key, x):
    r"""Low-level wrapper for `::pdf_dict_put_matrix()`."""
    return _mupdf.ll_pdf_dict_put_matrix(dict, key, x)

def ll_pdf_dict_put_name(dict, key, x):
    r"""Low-level wrapper for `::pdf_dict_put_name()`."""
    return _mupdf.ll_pdf_dict_put_name(dict, key, x)

def ll_pdf_dict_put_point(dict, key, x):
    r"""Low-level wrapper for `::pdf_dict_put_point()`."""
    return _mupdf.ll_pdf_dict_put_point(dict, key, x)

def ll_pdf_dict_put_real(dict, key, x):
    r"""Low-level wrapper for `::pdf_dict_put_real()`."""
    return _mupdf.ll_pdf_dict_put_real(dict, key, x)

def ll_pdf_dict_put_rect(dict, key, x):
    r"""Low-level wrapper for `::pdf_dict_put_rect()`."""
    return _mupdf.ll_pdf_dict_put_rect(dict, key, x)

def ll_pdf_dict_put_string(dict, key, x, n):
    r"""Low-level wrapper for `::pdf_dict_put_string()`."""
    return _mupdf.ll_pdf_dict_put_string(dict, key, x, n)

def ll_pdf_dict_put_text_string(dict, key, x):
    r"""Low-level wrapper for `::pdf_dict_put_text_string()`."""
    return _mupdf.ll_pdf_dict_put_text_string(dict, key, x)

def ll_pdf_dict_put_val_null(obj, idx):
    r"""Low-level wrapper for `::pdf_dict_put_val_null()`."""
    return _mupdf.ll_pdf_dict_put_val_null(obj, idx)

def ll_pdf_dict_putp(dict, path, val):
    r"""Low-level wrapper for `::pdf_dict_putp()`."""
    return _mupdf.ll_pdf_dict_putp(dict, path, val)

def ll_pdf_dict_putp_drop(dict, path, val):
    r"""Low-level wrapper for `::pdf_dict_putp_drop()`."""
    return _mupdf.ll_pdf_dict_putp_drop(dict, path, val)

def ll_pdf_dict_puts(dict, key, val):
    r"""Low-level wrapper for `::pdf_dict_puts()`."""
    return _mupdf.ll_pdf_dict_puts(dict, key, val)

def ll_pdf_dict_puts_dict(dict, key, initial):
    r"""Low-level wrapper for `::pdf_dict_puts_dict()`."""
    return _mupdf.ll_pdf_dict_puts_dict(dict, key, initial)

def ll_pdf_dict_puts_drop(dict, key, val):
    r"""Low-level wrapper for `::pdf_dict_puts_drop()`."""
    return _mupdf.ll_pdf_dict_puts_drop(dict, key, val)

def ll_pdf_dirty_annot(annot):
    r"""Low-level wrapper for `::pdf_dirty_annot()`."""
    return _mupdf.ll_pdf_dirty_annot(annot)

def ll_pdf_dirty_obj(obj):
    r"""Low-level wrapper for `::pdf_dirty_obj()`."""
    return _mupdf.ll_pdf_dirty_obj(obj)

def ll_pdf_disable_js(doc):
    r"""Low-level wrapper for `::pdf_disable_js()`."""
    return _mupdf.ll_pdf_disable_js(doc)

def ll_pdf_discard_journal(journal):
    r"""Low-level wrapper for `::pdf_discard_journal()`."""
    return _mupdf.ll_pdf_discard_journal(journal)

def ll_pdf_doc_was_linearized(doc):
    r"""Low-level wrapper for `::pdf_doc_was_linearized()`."""
    return _mupdf.ll_pdf_doc_was_linearized(doc)

def ll_pdf_document_associated_file(doc, idx):
    r"""Low-level wrapper for `::pdf_document_associated_file()`."""
    return _mupdf.ll_pdf_document_associated_file(doc, idx)

def ll_pdf_document_event_did_print(doc):
    r"""Low-level wrapper for `::pdf_document_event_did_print()`."""
    return _mupdf.ll_pdf_document_event_did_print(doc)

def ll_pdf_document_event_did_save(doc):
    r"""Low-level wrapper for `::pdf_document_event_did_save()`."""
    return _mupdf.ll_pdf_document_event_did_save(doc)

def ll_pdf_document_event_will_close(doc):
    r"""Low-level wrapper for `::pdf_document_event_will_close()`."""
    return _mupdf.ll_pdf_document_event_will_close(doc)

def ll_pdf_document_event_will_print(doc):
    r"""Low-level wrapper for `::pdf_document_event_will_print()`."""
    return _mupdf.ll_pdf_document_event_will_print(doc)

def ll_pdf_document_event_will_save(doc):
    r"""Low-level wrapper for `::pdf_document_event_will_save()`."""
    return _mupdf.ll_pdf_document_event_will_save(doc)

def ll_pdf_document_from_fz_document(ptr):
    r"""Low-level wrapper for `::pdf_document_from_fz_document()`."""
    return _mupdf.ll_pdf_document_from_fz_document(ptr)

def ll_pdf_document_language(doc):
    r"""Low-level wrapper for `::pdf_document_language()`."""
    return _mupdf.ll_pdf_document_language(doc)

def ll_pdf_document_output_intent(doc):
    r"""Low-level wrapper for `::pdf_document_output_intent()`."""
    return _mupdf.ll_pdf_document_output_intent(doc)

def ll_pdf_document_permissions(doc):
    r"""Low-level wrapper for `::pdf_document_permissions()`."""
    return _mupdf.ll_pdf_document_permissions(doc)

def ll_pdf_drop_annot(annot):
    r"""Low-level wrapper for `::pdf_drop_annot()`."""
    return _mupdf.ll_pdf_drop_annot(annot)

def ll_pdf_drop_cmap(cmap):
    r"""Low-level wrapper for `::pdf_drop_cmap()`."""
    return _mupdf.ll_pdf_drop_cmap(cmap)

def ll_pdf_drop_cmap_imp(cmap):
    r"""Low-level wrapper for `::pdf_drop_cmap_imp()`."""
    return _mupdf.ll_pdf_drop_cmap_imp(cmap)

def ll_pdf_drop_crypt(crypt):
    r"""Low-level wrapper for `::pdf_drop_crypt()`."""
    return _mupdf.ll_pdf_drop_crypt(crypt)

def ll_pdf_drop_document(doc):
    r"""Low-level wrapper for `::pdf_drop_document()`."""
    return _mupdf.ll_pdf_drop_document(doc)

def ll_pdf_drop_font(font):
    r"""Low-level wrapper for `::pdf_drop_font()`."""
    return _mupdf.ll_pdf_drop_font(font)

def ll_pdf_drop_function(func):
    r"""Low-level wrapper for `::pdf_drop_function()`."""
    return _mupdf.ll_pdf_drop_function(func)

def ll_pdf_drop_graft_map(map):
    r"""Low-level wrapper for `::pdf_drop_graft_map()`."""
    return _mupdf.ll_pdf_drop_graft_map(map)

def ll_pdf_drop_journal(journal):
    r"""Low-level wrapper for `::pdf_drop_journal()`."""
    return _mupdf.ll_pdf_drop_journal(journal)

def ll_pdf_drop_js(js):
    r"""Low-level wrapper for `::pdf_drop_js()`."""
    return _mupdf.ll_pdf_drop_js(js)

def ll_pdf_drop_local_xref(xref):
    r"""Low-level wrapper for `::pdf_drop_local_xref()`."""
    return _mupdf.ll_pdf_drop_local_xref(xref)

def ll_pdf_drop_local_xref_and_resources(doc):
    r"""Low-level wrapper for `::pdf_drop_local_xref_and_resources()`."""
    return _mupdf.ll_pdf_drop_local_xref_and_resources(doc)

def ll_pdf_drop_locked_fields(locked):
    r"""Low-level wrapper for `::pdf_drop_locked_fields()`."""
    return _mupdf.ll_pdf_drop_locked_fields(locked)

def ll_pdf_drop_mark_bits(marks):
    r"""Low-level wrapper for `::pdf_drop_mark_bits()`."""
    return _mupdf.ll_pdf_drop_mark_bits(marks)

def ll_pdf_drop_obj(obj):
    r"""Low-level wrapper for `::pdf_drop_obj()`."""
    return _mupdf.ll_pdf_drop_obj(obj)

def ll_pdf_drop_ocg(doc):
    r"""Low-level wrapper for `::pdf_drop_ocg()`."""
    return _mupdf.ll_pdf_drop_ocg(doc)

def ll_pdf_drop_page(page):
    r"""Low-level wrapper for `::pdf_drop_page()`."""
    return _mupdf.ll_pdf_drop_page(page)

def ll_pdf_drop_page_tree(doc):
    r"""Low-level wrapper for `::pdf_drop_page_tree()`."""
    return _mupdf.ll_pdf_drop_page_tree(doc)

def ll_pdf_drop_page_tree_internal(doc):
    r"""Low-level wrapper for `::pdf_drop_page_tree_internal()`."""
    return _mupdf.ll_pdf_drop_page_tree_internal(doc)

def ll_pdf_drop_pattern(pat):
    r"""Low-level wrapper for `::pdf_drop_pattern()`."""
    return _mupdf.ll_pdf_drop_pattern(pat)

def ll_pdf_drop_processor(proc):
    r"""Low-level wrapper for `::pdf_drop_processor()`."""
    return _mupdf.ll_pdf_drop_processor(proc)

def ll_pdf_drop_resource_tables(doc):
    r"""Low-level wrapper for `::pdf_drop_resource_tables()`."""
    return _mupdf.ll_pdf_drop_resource_tables(doc)

def ll_pdf_drop_signer(signer):
    r"""Low-level wrapper for `::pdf_drop_signer()`."""
    return _mupdf.ll_pdf_drop_signer(signer)

def ll_pdf_drop_singleton_obj(obj):
    r"""Low-level wrapper for `::pdf_drop_singleton_obj()`."""
    return _mupdf.ll_pdf_drop_singleton_obj(obj)

def ll_pdf_drop_verifier(verifier):
    r"""Low-level wrapper for `::pdf_drop_verifier()`."""
    return _mupdf.ll_pdf_drop_verifier(verifier)

def ll_pdf_drop_widget(widget):
    r"""Low-level wrapper for `::pdf_drop_widget()`."""
    return _mupdf.ll_pdf_drop_widget(widget)

def ll_pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue):
    r"""
     Low-level wrapper for `::pdf_edit_text_field_value()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_edit_text_field_value(::pdf_annot *widget, const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
    """
    return _mupdf.ll_pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue)

def ll_pdf_empty_store(doc):
    r"""Low-level wrapper for `::pdf_empty_store()`."""
    return _mupdf.ll_pdf_empty_store(doc)

def ll_pdf_enable_journal(doc):
    r"""Low-level wrapper for `::pdf_enable_journal()`."""
    return _mupdf.ll_pdf_enable_journal(doc)

def ll_pdf_enable_js(doc):
    r"""Low-level wrapper for `::pdf_enable_js()`."""
    return _mupdf.ll_pdf_enable_js(doc)

def ll_pdf_enable_layer(doc, layer, enabled):
    r"""Low-level wrapper for `::pdf_enable_layer()`."""
    return _mupdf.ll_pdf_enable_layer(doc, layer, enabled)

def ll_pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n):
    r"""Low-level wrapper for `::pdf_encrypt_data()`."""
    return _mupdf.ll_pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n)

def ll_pdf_encrypted_len(crypt, num, gen, len):
    r"""Low-level wrapper for `::pdf_encrypted_len()`."""
    return _mupdf.ll_pdf_encrypted_len(crypt, num, gen, len)

def ll_pdf_end_hmtx(font):
    r"""Low-level wrapper for `::pdf_end_hmtx()`."""
    return _mupdf.ll_pdf_end_hmtx(font)

def ll_pdf_end_operation(doc):
    r"""Low-level wrapper for `::pdf_end_operation()`."""
    return _mupdf.ll_pdf_end_operation(doc)

def ll_pdf_end_vmtx(font):
    r"""Low-level wrapper for `::pdf_end_vmtx()`."""
    return _mupdf.ll_pdf_end_vmtx(font)

def ll_pdf_ensure_solid_xref(doc, num):
    r"""Low-level wrapper for `::pdf_ensure_solid_xref()`."""
    return _mupdf.ll_pdf_ensure_solid_xref(doc, num)

def ll_pdf_eval_function(func, _in, inlen, out, outlen):
    r"""
     Low-level wrapper for `::pdf_eval_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_eval_function(::pdf_function *func, const float *in, int inlen, int outlen)` => float out
    """
    return _mupdf.ll_pdf_eval_function(func, _in, inlen, out, outlen)

def ll_pdf_event_issue_alert(doc, evt):
    r"""Low-level wrapper for `::pdf_event_issue_alert()`."""
    return _mupdf.ll_pdf_event_issue_alert(doc, evt)

def ll_pdf_event_issue_exec_menu_item(doc, item):
    r"""Low-level wrapper for `::pdf_event_issue_exec_menu_item()`."""
    return _mupdf.ll_pdf_event_issue_exec_menu_item(doc, item)

def ll_pdf_event_issue_launch_url(doc, url, new_frame):
    r"""Low-level wrapper for `::pdf_event_issue_launch_url()`."""
    return _mupdf.ll_pdf_event_issue_launch_url(doc, url, new_frame)

def ll_pdf_event_issue_mail_doc(doc, evt):
    r"""Low-level wrapper for `::pdf_event_issue_mail_doc()`."""
    return _mupdf.ll_pdf_event_issue_mail_doc(doc, evt)

def ll_pdf_event_issue_print(doc):
    r"""Low-level wrapper for `::pdf_event_issue_print()`."""
    return _mupdf.ll_pdf_event_issue_print(doc)

def ll_pdf_field_border_style(field):
    r"""Low-level wrapper for `::pdf_field_border_style()`."""
    return _mupdf.ll_pdf_field_border_style(field)

def ll_pdf_field_display(field):
    r"""Low-level wrapper for `::pdf_field_display()`."""
    return _mupdf.ll_pdf_field_display(field)

def ll_pdf_field_event_calculate(doc, field):
    r"""Low-level wrapper for `::pdf_field_event_calculate()`."""
    return _mupdf.ll_pdf_field_event_calculate(doc, field)

def ll_pdf_field_event_format(doc, field):
    r"""Low-level wrapper for `::pdf_field_event_format()`."""
    return _mupdf.ll_pdf_field_event_format(doc, field)

def ll_pdf_field_event_keystroke(doc, field, evt):
    r"""Low-level wrapper for `::pdf_field_event_keystroke()`."""
    return _mupdf.ll_pdf_field_event_keystroke(doc, field, evt)

def ll_pdf_field_event_validate(doc, field, value, newvalue):
    r"""
     Low-level wrapper for `::pdf_field_event_validate()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_field_event_validate(::pdf_document *doc, ::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
    """
    return _mupdf.ll_pdf_field_event_validate(doc, field, value, newvalue)

def ll_pdf_field_flags(field):
    r"""Low-level wrapper for `::pdf_field_flags()`."""
    return _mupdf.ll_pdf_field_flags(field)

def ll_pdf_field_label(field):
    r"""Low-level wrapper for `::pdf_field_label()`."""
    return _mupdf.ll_pdf_field_label(field)

def ll_pdf_field_reset(doc, field):
    r"""Low-level wrapper for `::pdf_field_reset()`."""
    return _mupdf.ll_pdf_field_reset(doc, field)

def ll_pdf_field_set_border_style(field, text):
    r"""Low-level wrapper for `::pdf_field_set_border_style()`."""
    return _mupdf.ll_pdf_field_set_border_style(field, text)

def ll_pdf_field_set_button_caption(field, text):
    r"""Low-level wrapper for `::pdf_field_set_button_caption()`."""
    return _mupdf.ll_pdf_field_set_button_caption(field, text)

def ll_pdf_field_set_display(field, d):
    r"""Low-level wrapper for `::pdf_field_set_display()`."""
    return _mupdf.ll_pdf_field_set_display(field, d)

def ll_pdf_field_set_fill_color(field, col):
    r"""Low-level wrapper for `::pdf_field_set_fill_color()`."""
    return _mupdf.ll_pdf_field_set_fill_color(field, col)

def ll_pdf_field_set_text_color(field, col):
    r"""Low-level wrapper for `::pdf_field_set_text_color()`."""
    return _mupdf.ll_pdf_field_set_text_color(field, col)

def ll_pdf_field_type(field):
    r"""Low-level wrapper for `::pdf_field_type()`."""
    return _mupdf.ll_pdf_field_type(field)

def ll_pdf_field_type_string(field):
    r"""Low-level wrapper for `::pdf_field_type_string()`."""
    return _mupdf.ll_pdf_field_type_string(field)

def ll_pdf_field_value(field):
    r"""Low-level wrapper for `::pdf_field_value()`."""
    return _mupdf.ll_pdf_field_value(field)

def ll_pdf_filter_annot_contents(doc, annot, options):
    r"""Low-level wrapper for `::pdf_filter_annot_contents()`."""
    return _mupdf.ll_pdf_filter_annot_contents(doc, annot, options)

def ll_pdf_filter_page_contents(doc, page, options):
    r"""Low-level wrapper for `::pdf_filter_page_contents()`."""
    return _mupdf.ll_pdf_filter_page_contents(doc, page, options)

def ll_pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up):
    r"""Low-level wrapper for `::pdf_filter_xobject_instance()`."""
    return _mupdf.ll_pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up)

def ll_pdf_find_font_resource(doc, type, encoding, item, key):
    r"""Low-level wrapper for `::pdf_find_font_resource()`."""
    return _mupdf.ll_pdf_find_font_resource(doc, type, encoding, item, key)

def ll_pdf_find_item(drop, key):
    r"""Low-level wrapper for `::pdf_find_item()`."""
    return _mupdf.ll_pdf_find_item(drop, key)

def ll_pdf_find_locked_fields(doc, version):
    r"""Low-level wrapper for `::pdf_find_locked_fields()`."""
    return _mupdf.ll_pdf_find_locked_fields(doc, version)

def ll_pdf_find_locked_fields_for_sig(doc, sig):
    r"""Low-level wrapper for `::pdf_find_locked_fields_for_sig()`."""
    return _mupdf.ll_pdf_find_locked_fields_for_sig(doc, sig)

def ll_pdf_find_version_for_obj(doc, obj):
    r"""Low-level wrapper for `::pdf_find_version_for_obj()`."""
    return _mupdf.ll_pdf_find_version_for_obj(doc, obj)

def ll_pdf_first_annot(page):
    r"""Low-level wrapper for `::pdf_first_annot()`."""
    return _mupdf.ll_pdf_first_annot(page)

def ll_pdf_first_widget(page):
    r"""Low-level wrapper for `::pdf_first_widget()`."""
    return _mupdf.ll_pdf_first_widget(page)

def ll_pdf_flatten_inheritable_page_items(page):
    r"""Low-level wrapper for `::pdf_flatten_inheritable_page_items()`."""
    return _mupdf.ll_pdf_flatten_inheritable_page_items(page)

def ll_pdf_font_cid_to_gid(fontdesc, cid):
    r"""Low-level wrapper for `::pdf_font_cid_to_gid()`."""
    return _mupdf.ll_pdf_font_cid_to_gid(fontdesc, cid)

def ll_pdf_font_writing_supported(font):
    r"""Low-level wrapper for `::pdf_font_writing_supported()`."""
    return _mupdf.ll_pdf_font_writing_supported(font)

def ll_pdf_forget_xref(doc):
    r"""Low-level wrapper for `::pdf_forget_xref()`."""
    return _mupdf.ll_pdf_forget_xref(doc)

def ll_pdf_format_date(time, s, n):
    r"""Low-level wrapper for `::pdf_format_date()`."""
    return _mupdf.ll_pdf_format_date(time, s, n)

def ll_pdf_format_write_options(buffer, buffer_len, opts):
    r"""Low-level wrapper for `::pdf_format_write_options()`."""
    return _mupdf.ll_pdf_format_write_options(buffer, buffer_len, opts)

def ll_pdf_function_size(func):
    r"""Low-level wrapper for `::pdf_function_size()`."""
    return _mupdf.ll_pdf_function_size(func)

def ll_pdf_get_bound_document(obj):
    r"""Low-level wrapper for `::pdf_get_bound_document()`."""
    return _mupdf.ll_pdf_get_bound_document(obj)

def ll_pdf_get_doc_event_callback_data(doc):
    r"""Low-level wrapper for `::pdf_get_doc_event_callback_data()`."""
    return _mupdf.ll_pdf_get_doc_event_callback_data(doc)

def ll_pdf_get_embedded_file_params(fs, out):
    r"""Low-level wrapper for `::pdf_get_embedded_file_params()`."""
    return _mupdf.ll_pdf_get_embedded_file_params(fs, out)

def ll_pdf_get_filespec_params(fs, out):
    r"""Low-level wrapper for `::pdf_get_filespec_params()`."""
    return _mupdf.ll_pdf_get_filespec_params(fs, out)

def ll_pdf_get_incremental_xref_entry(doc, i):
    r"""Low-level wrapper for `::pdf_get_incremental_xref_entry()`."""
    return _mupdf.ll_pdf_get_incremental_xref_entry(doc, i)

def ll_pdf_get_indirect_document(obj):
    r"""Low-level wrapper for `::pdf_get_indirect_document()`."""
    return _mupdf.ll_pdf_get_indirect_document(obj)

def ll_pdf_get_populating_xref_entry(doc, i):
    r"""Low-level wrapper for `::pdf_get_populating_xref_entry()`."""
    return _mupdf.ll_pdf_get_populating_xref_entry(doc, i)

def ll_pdf_get_widget_editing_state(widget):
    r"""Low-level wrapper for `::pdf_get_widget_editing_state()`."""
    return _mupdf.ll_pdf_get_widget_editing_state(widget)

def ll_pdf_get_xref_entry(doc, i):
    r"""Low-level wrapper for `::pdf_get_xref_entry()`."""
    return _mupdf.ll_pdf_get_xref_entry(doc, i)

def ll_pdf_get_xref_entry_no_change(doc, i):
    r"""Low-level wrapper for `::pdf_get_xref_entry_no_change()`."""
    return _mupdf.ll_pdf_get_xref_entry_no_change(doc, i)

def ll_pdf_get_xref_entry_no_null(doc, i):
    r"""Low-level wrapper for `::pdf_get_xref_entry_no_null()`."""
    return _mupdf.ll_pdf_get_xref_entry_no_null(doc, i)

def ll_pdf_graft_mapped_object(map, obj):
    r"""Low-level wrapper for `::pdf_graft_mapped_object()`."""
    return _mupdf.ll_pdf_graft_mapped_object(map, obj)

def ll_pdf_graft_mapped_page(map, page_to, src, page_from):
    r"""Low-level wrapper for `::pdf_graft_mapped_page()`."""
    return _mupdf.ll_pdf_graft_mapped_page(map, page_to, src, page_from)

def ll_pdf_graft_object(dst, obj):
    r"""Low-level wrapper for `::pdf_graft_object()`."""
    return _mupdf.ll_pdf_graft_object(dst, obj)

def ll_pdf_graft_page(dst, page_to, src, page_from):
    r"""Low-level wrapper for `::pdf_graft_page()`."""
    return _mupdf.ll_pdf_graft_page(dst, page_to, src, page_from)

def ll_pdf_has_permission(doc, p):
    r"""Low-level wrapper for `::pdf_has_permission()`."""
    return _mupdf.ll_pdf_has_permission(doc, p)

def ll_pdf_has_unsaved_changes(doc):
    r"""Low-level wrapper for `::pdf_has_unsaved_changes()`."""
    return _mupdf.ll_pdf_has_unsaved_changes(doc)

def ll_pdf_has_unsaved_sigs(doc):
    r"""Low-level wrapper for `::pdf_has_unsaved_sigs()`."""
    return _mupdf.ll_pdf_has_unsaved_sigs(doc)

def ll_pdf_incremental_change_since_signing_widget(widget):
    r"""Low-level wrapper for `::pdf_incremental_change_since_signing_widget()`."""
    return _mupdf.ll_pdf_incremental_change_since_signing_widget(widget)

def ll_pdf_insert_font_resource(doc, key, obj):
    r"""Low-level wrapper for `::pdf_insert_font_resource()`."""
    return _mupdf.ll_pdf_insert_font_resource(doc, key, obj)

def ll_pdf_insert_page(doc, at, page):
    r"""Low-level wrapper for `::pdf_insert_page()`."""
    return _mupdf.ll_pdf_insert_page(doc, at, page)

def ll_pdf_intent_from_name(obj):
    r"""Low-level wrapper for `::pdf_intent_from_name()`."""
    return _mupdf.ll_pdf_intent_from_name(obj)

def ll_pdf_intent_from_string(str):
    r"""Low-level wrapper for `::pdf_intent_from_string()`."""
    return _mupdf.ll_pdf_intent_from_string(str)

def ll_pdf_invalidate_xfa(doc):
    r"""Low-level wrapper for `::pdf_invalidate_xfa()`."""
    return _mupdf.ll_pdf_invalidate_xfa(doc)

def ll_pdf_is_array(obj):
    r"""Low-level wrapper for `::pdf_is_array()`."""
    return _mupdf.ll_pdf_is_array(obj)

def ll_pdf_is_bool(obj):
    r"""Low-level wrapper for `::pdf_is_bool()`."""
    return _mupdf.ll_pdf_is_bool(obj)

def ll_pdf_is_dict(obj):
    r"""Low-level wrapper for `::pdf_is_dict()`."""
    return _mupdf.ll_pdf_is_dict(obj)

def ll_pdf_is_embedded_file(fs):
    r"""Low-level wrapper for `::pdf_is_embedded_file()`."""
    return _mupdf.ll_pdf_is_embedded_file(fs)

def ll_pdf_is_field_locked(locked, name):
    r"""Low-level wrapper for `::pdf_is_field_locked()`."""
    return _mupdf.ll_pdf_is_field_locked(locked, name)

def ll_pdf_is_filespec(fs):
    r"""Low-level wrapper for `::pdf_is_filespec()`."""
    return _mupdf.ll_pdf_is_filespec(fs)

def ll_pdf_is_indirect(obj):
    r"""Low-level wrapper for `::pdf_is_indirect()`."""
    return _mupdf.ll_pdf_is_indirect(obj)

def ll_pdf_is_int(obj):
    r"""Low-level wrapper for `::pdf_is_int()`."""
    return _mupdf.ll_pdf_is_int(obj)

def ll_pdf_is_jpx_image(dict):
    r"""Low-level wrapper for `::pdf_is_jpx_image()`."""
    return _mupdf.ll_pdf_is_jpx_image(dict)

def ll_pdf_is_local_object(doc, obj):
    r"""Low-level wrapper for `::pdf_is_local_object()`."""
    return _mupdf.ll_pdf_is_local_object(doc, obj)

def ll_pdf_is_name(obj):
    r"""Low-level wrapper for `::pdf_is_name()`."""
    return _mupdf.ll_pdf_is_name(obj)

def ll_pdf_is_null(obj):
    r"""Low-level wrapper for `::pdf_is_null()`."""
    return _mupdf.ll_pdf_is_null(obj)

def ll_pdf_is_number(obj):
    r"""Low-level wrapper for `::pdf_is_number()`."""
    return _mupdf.ll_pdf_is_number(obj)

def ll_pdf_is_ocg_hidden(doc, rdb, usage, ocg):
    r"""Low-level wrapper for `::pdf_is_ocg_hidden()`."""
    return _mupdf.ll_pdf_is_ocg_hidden(doc, rdb, usage, ocg)

def ll_pdf_is_real(obj):
    r"""Low-level wrapper for `::pdf_is_real()`."""
    return _mupdf.ll_pdf_is_real(obj)

def ll_pdf_is_stream(obj):
    r"""Low-level wrapper for `::pdf_is_stream()`."""
    return _mupdf.ll_pdf_is_stream(obj)

def ll_pdf_is_string(obj):
    r"""Low-level wrapper for `::pdf_is_string()`."""
    return _mupdf.ll_pdf_is_string(obj)

def ll_pdf_is_tint_colorspace(cs):
    r"""Low-level wrapper for `::pdf_is_tint_colorspace()`."""
    return _mupdf.ll_pdf_is_tint_colorspace(cs)

def ll_pdf_js_event_init(js, target, value, willCommit):
    r"""Low-level wrapper for `::pdf_js_event_init()`."""
    return _mupdf.ll_pdf_js_event_init(js, target, value, willCommit)

def ll_pdf_js_event_init_keystroke(js, target, evt):
    r"""Low-level wrapper for `::pdf_js_event_init_keystroke()`."""
    return _mupdf.ll_pdf_js_event_init_keystroke(js, target, evt)

def ll_pdf_js_event_result(js):
    r"""Low-level wrapper for `::pdf_js_event_result()`."""
    return _mupdf.ll_pdf_js_event_result(js)

def ll_pdf_js_event_result_keystroke(js, evt):
    r"""Low-level wrapper for `::pdf_js_event_result_keystroke()`."""
    return _mupdf.ll_pdf_js_event_result_keystroke(js, evt)

def ll_pdf_js_event_result_validate(js, newvalue):
    r"""
     Low-level wrapper for `::pdf_js_event_result_validate()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_js_event_result_validate(::pdf_js *js)` => `(int, char *newvalue)`
    """
    return _mupdf.ll_pdf_js_event_result_validate(js, newvalue)

def ll_pdf_js_event_value(js):
    r"""Low-level wrapper for `::pdf_js_event_value()`."""
    return _mupdf.ll_pdf_js_event_value(js)

def ll_pdf_js_execute(js, name, code, result):
    r"""
     Low-level wrapper for `::pdf_js_execute()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_js_execute(::pdf_js *js, const char *name, const char *code)` => char *result
    """
    return _mupdf.ll_pdf_js_execute(js, name, code, result)

def ll_pdf_js_get_console(doc):
    r"""Low-level wrapper for `::pdf_js_get_console()`."""
    return _mupdf.ll_pdf_js_get_console(doc)

def ll_pdf_js_set_console(doc, console, user):
    r"""Low-level wrapper for `::pdf_js_set_console()`."""
    return _mupdf.ll_pdf_js_set_console(doc, console, user)

def ll_pdf_js_supported(doc):
    r"""Low-level wrapper for `::pdf_js_supported()`."""
    return _mupdf.ll_pdf_js_supported(doc)

def ll_pdf_keep_annot(annot):
    r"""Low-level wrapper for `::pdf_keep_annot()`."""
    return _mupdf.ll_pdf_keep_annot(annot)

def ll_pdf_keep_cmap(cmap):
    r"""Low-level wrapper for `::pdf_keep_cmap()`."""
    return _mupdf.ll_pdf_keep_cmap(cmap)

def ll_pdf_keep_document(doc):
    r"""Low-level wrapper for `::pdf_keep_document()`."""
    return _mupdf.ll_pdf_keep_document(doc)

def ll_pdf_keep_font(fontdesc):
    r"""Low-level wrapper for `::pdf_keep_font()`."""
    return _mupdf.ll_pdf_keep_font(fontdesc)

def ll_pdf_keep_function(func):
    r"""Low-level wrapper for `::pdf_keep_function()`."""
    return _mupdf.ll_pdf_keep_function(func)

def ll_pdf_keep_graft_map(map):
    r"""Low-level wrapper for `::pdf_keep_graft_map()`."""
    return _mupdf.ll_pdf_keep_graft_map(map)

def ll_pdf_keep_obj(obj):
    r"""Low-level wrapper for `::pdf_keep_obj()`."""
    return _mupdf.ll_pdf_keep_obj(obj)

def ll_pdf_keep_page(page):
    r"""Low-level wrapper for `::pdf_keep_page()`."""
    return _mupdf.ll_pdf_keep_page(page)

def ll_pdf_keep_pattern(pat):
    r"""Low-level wrapper for `::pdf_keep_pattern()`."""
    return _mupdf.ll_pdf_keep_pattern(pat)

def ll_pdf_keep_processor(proc):
    r"""Low-level wrapper for `::pdf_keep_processor()`."""
    return _mupdf.ll_pdf_keep_processor(proc)

def ll_pdf_keep_widget(widget):
    r"""Low-level wrapper for `::pdf_keep_widget()`."""
    return _mupdf.ll_pdf_keep_widget(widget)

def ll_pdf_layer_config_info(doc, config_num, info):
    r"""Low-level wrapper for `::pdf_layer_config_info()`."""
    return _mupdf.ll_pdf_layer_config_info(doc, config_num, info)

def ll_pdf_layer_config_ui_info(doc, ui, info):
    r"""Low-level wrapper for `::pdf_layer_config_ui_info()`."""
    return _mupdf.ll_pdf_layer_config_ui_info(doc, ui, info)

def ll_pdf_layer_is_enabled(doc, layer):
    r"""Low-level wrapper for `::pdf_layer_is_enabled()`."""
    return _mupdf.ll_pdf_layer_is_enabled(doc, layer)

def ll_pdf_layer_name(doc, layer):
    r"""Low-level wrapper for `::pdf_layer_name()`."""
    return _mupdf.ll_pdf_layer_name(doc, layer)

def ll_pdf_layout_fit_text(font, lang, str, bounds):
    r"""Low-level wrapper for `::pdf_layout_fit_text()`."""
    return _mupdf.ll_pdf_layout_fit_text(font, lang, str, bounds)

def ll_pdf_layout_text_widget(annot):
    r"""Low-level wrapper for `::pdf_layout_text_widget()`."""
    return _mupdf.ll_pdf_layout_text_widget(annot)

def ll_pdf_lex(f, lexbuf):
    r"""Low-level wrapper for `::pdf_lex()`."""
    return _mupdf.ll_pdf_lex(f, lexbuf)

def ll_pdf_lex_no_string(f, lexbuf):
    r"""Low-level wrapper for `::pdf_lex_no_string()`."""
    return _mupdf.ll_pdf_lex_no_string(f, lexbuf)

def ll_pdf_lexbuf_fin(lexbuf):
    r"""Low-level wrapper for `::pdf_lexbuf_fin()`."""
    return _mupdf.ll_pdf_lexbuf_fin(lexbuf)

def ll_pdf_lexbuf_grow(lexbuf):
    r"""Low-level wrapper for `::pdf_lexbuf_grow()`."""
    return _mupdf.ll_pdf_lexbuf_grow(lexbuf)

def ll_pdf_lexbuf_init(lexbuf, size):
    r"""Low-level wrapper for `::pdf_lexbuf_init()`."""
    return _mupdf.ll_pdf_lexbuf_init(lexbuf, size)

def ll_pdf_line_ending_from_name(end):
    r"""Low-level wrapper for `::pdf_line_ending_from_name()`."""
    return _mupdf.ll_pdf_line_ending_from_name(end)

def ll_pdf_line_ending_from_string(end):
    r"""Low-level wrapper for `::pdf_line_ending_from_string()`."""
    return _mupdf.ll_pdf_line_ending_from_string(end)

def ll_pdf_load_builtin_cmap(name):
    r"""Low-level wrapper for `::pdf_load_builtin_cmap()`."""
    return _mupdf.ll_pdf_load_builtin_cmap(name)

def ll_pdf_load_cmap(file):
    r"""Low-level wrapper for `::pdf_load_cmap()`."""
    return _mupdf.ll_pdf_load_cmap(file)

def ll_pdf_load_colorspace(obj):
    r"""Low-level wrapper for `::pdf_load_colorspace()`."""
    return _mupdf.ll_pdf_load_colorspace(obj)

def ll_pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image):
    r"""Low-level wrapper for `::pdf_load_compressed_inline_image()`."""
    return _mupdf.ll_pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image)

def ll_pdf_load_compressed_stream(doc, num, worst_case):
    r"""Low-level wrapper for `::pdf_load_compressed_stream()`."""
    return _mupdf.ll_pdf_load_compressed_stream(doc, num, worst_case)

def ll_pdf_load_default_colorspaces(doc, page):
    r"""Low-level wrapper for `::pdf_load_default_colorspaces()`."""
    return _mupdf.ll_pdf_load_default_colorspaces(doc, page)

def ll_pdf_load_embedded_cmap(doc, ref):
    r"""Low-level wrapper for `::pdf_load_embedded_cmap()`."""
    return _mupdf.ll_pdf_load_embedded_cmap(doc, ref)

def ll_pdf_load_embedded_file_contents(fs):
    r"""Low-level wrapper for `::pdf_load_embedded_file_contents()`."""
    return _mupdf.ll_pdf_load_embedded_file_contents(fs)

def ll_pdf_load_encoding(estrings, encoding):
    r"""
     Low-level wrapper for `::pdf_load_encoding()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_load_encoding(const char *encoding)` => const char *estrings
    """
    return _mupdf.ll_pdf_load_encoding(estrings, encoding)

def ll_pdf_load_field_name(field):
    r"""Low-level wrapper for `::pdf_load_field_name()`."""
    return _mupdf.ll_pdf_load_field_name(field)

def ll_pdf_load_field_name2(field):
    r"""Alternative to `ll_pdf_load_field_name()` that returns a std::string."""
    return _mupdf.ll_pdf_load_field_name2(field)

def ll_pdf_load_font(doc, rdb, obj):
    r"""Low-level wrapper for `::pdf_load_font()`."""
    return _mupdf.ll_pdf_load_font(doc, rdb, obj)

def ll_pdf_load_function(ref, _in, out):
    r"""Low-level wrapper for `::pdf_load_function()`."""
    return _mupdf.ll_pdf_load_function(ref, _in, out)

def ll_pdf_load_hail_mary_font(doc):
    r"""Low-level wrapper for `::pdf_load_hail_mary_font()`."""
    return _mupdf.ll_pdf_load_hail_mary_font(doc)

def ll_pdf_load_image(doc, obj):
    r"""Low-level wrapper for `::pdf_load_image()`."""
    return _mupdf.ll_pdf_load_image(doc, obj)

def ll_pdf_load_inline_image(doc, rdb, dict, file):
    r"""Low-level wrapper for `::pdf_load_inline_image()`."""
    return _mupdf.ll_pdf_load_inline_image(doc, rdb, dict, file)

def ll_pdf_load_journal(doc, filename):
    r"""Low-level wrapper for `::pdf_load_journal()`."""
    return _mupdf.ll_pdf_load_journal(doc, filename)

def ll_pdf_load_link_annots(arg_1, arg_2, annots, pagenum, page_ctm):
    r"""Low-level wrapper for `::pdf_load_link_annots()`."""
    return _mupdf.ll_pdf_load_link_annots(arg_1, arg_2, annots, pagenum, page_ctm)

def ll_pdf_load_links(page):
    r"""Low-level wrapper for `::pdf_load_links()`."""
    return _mupdf.ll_pdf_load_links(page)

def ll_pdf_load_name_tree(doc, which):
    r"""Low-level wrapper for `::pdf_load_name_tree()`."""
    return _mupdf.ll_pdf_load_name_tree(doc, which)

def ll_pdf_load_object(doc, num):
    r"""
    Low-level wrapper for `::pdf_load_object()`.
    Load a given object.

    This can cause xref reorganisations (solidifications etc) due to
    repairs, so all held pdf_xref_entries should be considered
    invalid after this call (other than the returned one).
    """
    return _mupdf.ll_pdf_load_object(doc, num)

def ll_pdf_load_outline(doc):
    r"""Low-level wrapper for `::pdf_load_outline()`."""
    return _mupdf.ll_pdf_load_outline(doc)

def ll_pdf_load_page(doc, number):
    r"""Low-level wrapper for `::pdf_load_page()`."""
    return _mupdf.ll_pdf_load_page(doc, number)

def ll_pdf_load_page_imp(doc, chapter, number):
    r"""Low-level wrapper for `::pdf_load_page_imp()`."""
    return _mupdf.ll_pdf_load_page_imp(doc, chapter, number)

def ll_pdf_load_page_tree(doc):
    r"""Low-level wrapper for `::pdf_load_page_tree()`."""
    return _mupdf.ll_pdf_load_page_tree(doc)

def ll_pdf_load_pattern(doc, obj):
    r"""Low-level wrapper for `::pdf_load_pattern()`."""
    return _mupdf.ll_pdf_load_pattern(doc, obj)

def ll_pdf_load_raw_stream(ref):
    r"""Low-level wrapper for `::pdf_load_raw_stream()`."""
    return _mupdf.ll_pdf_load_raw_stream(ref)

def ll_pdf_load_raw_stream_number(doc, num):
    r"""Low-level wrapper for `::pdf_load_raw_stream_number()`."""
    return _mupdf.ll_pdf_load_raw_stream_number(doc, num)

def ll_pdf_load_shading(doc, obj):
    r"""Low-level wrapper for `::pdf_load_shading()`."""
    return _mupdf.ll_pdf_load_shading(doc, obj)

def ll_pdf_load_stream(ref):
    r"""Low-level wrapper for `::pdf_load_stream()`."""
    return _mupdf.ll_pdf_load_stream(ref)

def ll_pdf_load_stream_number(doc, num):
    r"""Low-level wrapper for `::pdf_load_stream_number()`."""
    return _mupdf.ll_pdf_load_stream_number(doc, num)

def ll_pdf_load_stream_or_string_as_utf8(src):
    r"""Low-level wrapper for `::pdf_load_stream_or_string_as_utf8()`."""
    return _mupdf.ll_pdf_load_stream_or_string_as_utf8(src)

def ll_pdf_load_system_cmap(name):
    r"""Low-level wrapper for `::pdf_load_system_cmap()`."""
    return _mupdf.ll_pdf_load_system_cmap(name)

def ll_pdf_load_to_unicode(doc, font, strings, collection, cmapstm):
    r"""
     Low-level wrapper for `::pdf_load_to_unicode()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_load_to_unicode(::pdf_document *doc, ::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
    """
    return _mupdf.ll_pdf_load_to_unicode(doc, font, strings, collection, cmapstm)

def ll_pdf_load_type3_font(doc, rdb, obj):
    r"""Low-level wrapper for `::pdf_load_type3_font()`."""
    return _mupdf.ll_pdf_load_type3_font(doc, rdb, obj)

def ll_pdf_load_type3_glyphs(doc, fontdesc):
    r"""Low-level wrapper for `::pdf_load_type3_glyphs()`."""
    return _mupdf.ll_pdf_load_type3_glyphs(doc, fontdesc)

def ll_pdf_load_unencrypted_object(doc, num):
    r"""Low-level wrapper for `::pdf_load_unencrypted_object()`."""
    return _mupdf.ll_pdf_load_unencrypted_object(doc, num)

def ll_pdf_lookup_cmap(cmap, cpt):
    r"""Low-level wrapper for `::pdf_lookup_cmap()`."""
    return _mupdf.ll_pdf_lookup_cmap(cmap, cpt)

def ll_pdf_lookup_cmap_full(cmap, cpt, out):
    r"""
     Low-level wrapper for `::pdf_lookup_cmap_full()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_lookup_cmap_full(::pdf_cmap *cmap, unsigned int cpt)` => `(int, int out)`
    """
    return _mupdf.ll_pdf_lookup_cmap_full(cmap, cpt, out)

def ll_pdf_lookup_dest(doc, needle):
    r"""Low-level wrapper for `::pdf_lookup_dest()`."""
    return _mupdf.ll_pdf_lookup_dest(doc, needle)

def ll_pdf_lookup_field(form, name):
    r"""Low-level wrapper for `::pdf_lookup_field()`."""
    return _mupdf.ll_pdf_lookup_field(form, name)

def ll_pdf_lookup_hmtx(font, cid):
    r"""Low-level wrapper for `::pdf_lookup_hmtx()`."""
    return _mupdf.ll_pdf_lookup_hmtx(font, cid)

def ll_pdf_lookup_metadata(doc, key, ptr, size):
    r"""Low-level wrapper for `::pdf_lookup_metadata()`."""
    return _mupdf.ll_pdf_lookup_metadata(doc, key, ptr, size)

def ll_pdf_lookup_metadata2(doc, key):
    r"""
     Low-level wrapper for `::pdf_lookup_metadata2()`.
    C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
    or calls `fz_throw()` if not found.
    """
    return _mupdf.ll_pdf_lookup_metadata2(doc, key)

def ll_pdf_lookup_name(doc, which, needle):
    r"""Low-level wrapper for `::pdf_lookup_name()`."""
    return _mupdf.ll_pdf_lookup_name(doc, which, needle)

def ll_pdf_lookup_number(root, needle):
    r"""Low-level wrapper for `::pdf_lookup_number()`."""
    return _mupdf.ll_pdf_lookup_number(root, needle)

def ll_pdf_lookup_page_loc(doc, needle, parentp, indexp):
    r"""
     Low-level wrapper for `::pdf_lookup_page_loc()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_lookup_page_loc(::pdf_document *doc, int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
    """
    return _mupdf.ll_pdf_lookup_page_loc(doc, needle, parentp, indexp)

def ll_pdf_lookup_page_number(doc, pageobj):
    r"""Low-level wrapper for `::pdf_lookup_page_number()`."""
    return _mupdf.ll_pdf_lookup_page_number(doc, pageobj)

def ll_pdf_lookup_page_obj(doc, needle):
    r"""Low-level wrapper for `::pdf_lookup_page_obj()`."""
    return _mupdf.ll_pdf_lookup_page_obj(doc, needle)

def ll_pdf_lookup_substitute_font(mono, serif, bold, italic, len):
    r"""
     Low-level wrapper for `::pdf_lookup_substitute_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_lookup_substitute_font(int mono, int serif, int bold, int italic)` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_pdf_lookup_substitute_font(mono, serif, bold, italic, len)

def ll_pdf_lookup_vmtx(font, cid):
    r"""Low-level wrapper for `::pdf_lookup_vmtx()`."""
    return _mupdf.ll_pdf_lookup_vmtx(font, cid)

def ll_pdf_map_one_to_many(cmap, one, many, len):
    r"""
     Low-level wrapper for `::pdf_map_one_to_many()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_map_one_to_many(::pdf_cmap *cmap, unsigned int one, size_t len)` => int many
    """
    return _mupdf.ll_pdf_map_one_to_many(cmap, one, many, len)

def ll_pdf_map_range_to_range(cmap, srclo, srchi, dstlo):
    r"""Low-level wrapper for `::pdf_map_range_to_range()`."""
    return _mupdf.ll_pdf_map_range_to_range(cmap, srclo, srchi, dstlo)

def ll_pdf_mark_bits_reset(marks):
    r"""Low-level wrapper for `::pdf_mark_bits_reset()`."""
    return _mupdf.ll_pdf_mark_bits_reset(marks)

def ll_pdf_mark_bits_set(marks, obj):
    r"""Low-level wrapper for `::pdf_mark_bits_set()`."""
    return _mupdf.ll_pdf_mark_bits_set(marks, obj)

def ll_pdf_mark_list_check(list, obj):
    r"""Low-level wrapper for `::pdf_mark_list_check()`."""
    return _mupdf.ll_pdf_mark_list_check(list, obj)

def ll_pdf_mark_list_free(list):
    r"""Low-level wrapper for `::pdf_mark_list_free()`."""
    return _mupdf.ll_pdf_mark_list_free(list)

def ll_pdf_mark_list_init(list):
    r"""Low-level wrapper for `::pdf_mark_list_init()`."""
    return _mupdf.ll_pdf_mark_list_init(list)

def ll_pdf_mark_list_pop(list):
    r"""Low-level wrapper for `::pdf_mark_list_pop()`."""
    return _mupdf.ll_pdf_mark_list_pop(list)

def ll_pdf_mark_list_push(list, obj):
    r"""Low-level wrapper for `::pdf_mark_list_push()`."""
    return _mupdf.ll_pdf_mark_list_push(list, obj)

def ll_pdf_mark_obj(obj):
    r"""Low-level wrapper for `::pdf_mark_obj()`."""
    return _mupdf.ll_pdf_mark_obj(obj)

def ll_pdf_mark_xref(doc):
    r"""Low-level wrapper for `::pdf_mark_xref()`."""
    return _mupdf.ll_pdf_mark_xref(doc)

def ll_pdf_metadata(doc):
    r"""Low-level wrapper for `::pdf_metadata()`."""
    return _mupdf.ll_pdf_metadata(doc)

def ll_pdf_minimize_document(doc):
    r"""Low-level wrapper for `::pdf_minimize_document()`."""
    return _mupdf.ll_pdf_minimize_document(doc)

def ll_pdf_name_eq(a, b):
    r"""Low-level wrapper for `::pdf_name_eq()`."""
    return _mupdf.ll_pdf_name_eq(a, b)

def ll_pdf_name_from_intent(intent):
    r"""Low-level wrapper for `::pdf_name_from_intent()`."""
    return _mupdf.ll_pdf_name_from_intent(intent)

def ll_pdf_name_from_line_ending(end):
    r"""Low-level wrapper for `::pdf_name_from_line_ending()`."""
    return _mupdf.ll_pdf_name_from_line_ending(end)

def ll_pdf_needs_password(doc):
    r"""Low-level wrapper for `::pdf_needs_password()`."""
    return _mupdf.ll_pdf_needs_password(doc)

def ll_pdf_new_action_from_link(doc, uri):
    r"""Low-level wrapper for `::pdf_new_action_from_link()`."""
    return _mupdf.ll_pdf_new_action_from_link(doc, uri)

def ll_pdf_new_array(doc, initialcap):
    r"""Low-level wrapper for `::pdf_new_array()`."""
    return _mupdf.ll_pdf_new_array(doc, initialcap)

def ll_pdf_new_buffer_processor(buffer, ahxencode, newlines):
    r"""Low-level wrapper for `::pdf_new_buffer_processor()`."""
    return _mupdf.ll_pdf_new_buffer_processor(buffer, ahxencode, newlines)

def ll_pdf_new_cmap():
    r"""Low-level wrapper for `::pdf_new_cmap()`."""
    return _mupdf.ll_pdf_new_cmap()

def ll_pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts):
    r"""Low-level wrapper for `::pdf_new_color_filter()`."""
    return _mupdf.ll_pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts)

def ll_pdf_new_crypt(enc, id):
    r"""Low-level wrapper for `::pdf_new_crypt()`."""
    return _mupdf.ll_pdf_new_crypt(enc, id)

def ll_pdf_new_date(doc, time):
    r"""Low-level wrapper for `::pdf_new_date()`."""
    return _mupdf.ll_pdf_new_date(doc, time)

def ll_pdf_new_dest_from_link(doc, uri, is_remote):
    r"""Low-level wrapper for `::pdf_new_dest_from_link()`."""
    return _mupdf.ll_pdf_new_dest_from_link(doc, uri, is_remote)

def ll_pdf_new_dict(doc, initialcap):
    r"""Low-level wrapper for `::pdf_new_dict()`."""
    return _mupdf.ll_pdf_new_dict(doc, initialcap)

def ll_pdf_new_display_list_from_annot(annot):
    r"""Low-level wrapper for `::pdf_new_display_list_from_annot()`."""
    return _mupdf.ll_pdf_new_display_list_from_annot(annot)

def ll_pdf_new_encrypt(opwd_utf8, upwd_utf8, id, permissions, algorithm):
    r"""Low-level wrapper for `::pdf_new_encrypt()`."""
    return _mupdf.ll_pdf_new_encrypt(opwd_utf8, upwd_utf8, id, permissions, algorithm)

def ll_pdf_new_font_desc():
    r"""Low-level wrapper for `::pdf_new_font_desc()`."""
    return _mupdf.ll_pdf_new_font_desc()

def ll_pdf_new_graft_map(dst):
    r"""Low-level wrapper for `::pdf_new_graft_map()`."""
    return _mupdf.ll_pdf_new_graft_map(dst)

def ll_pdf_new_identity_cmap(wmode, bytes):
    r"""Low-level wrapper for `::pdf_new_identity_cmap()`."""
    return _mupdf.ll_pdf_new_identity_cmap(wmode, bytes)

def ll_pdf_new_indirect(doc, num, gen):
    r"""Low-level wrapper for `::pdf_new_indirect()`."""
    return _mupdf.ll_pdf_new_indirect(doc, num, gen)

def ll_pdf_new_int(i):
    r"""Low-level wrapper for `::pdf_new_int()`."""
    return _mupdf.ll_pdf_new_int(i)

def ll_pdf_new_link(page, rect, uri, obj):
    r"""Low-level wrapper for `::pdf_new_link()`."""
    return _mupdf.ll_pdf_new_link(page, rect, uri, obj)

def ll_pdf_new_local_xref(doc):
    r"""Low-level wrapper for `::pdf_new_local_xref()`."""
    return _mupdf.ll_pdf_new_local_xref(doc)

def ll_pdf_new_mark_bits(doc):
    r"""Low-level wrapper for `::pdf_new_mark_bits()`."""
    return _mupdf.ll_pdf_new_mark_bits(doc)

def ll_pdf_new_matrix(doc, mtx):
    r"""Low-level wrapper for `::pdf_new_matrix()`."""
    return _mupdf.ll_pdf_new_matrix(doc, mtx)

def ll_pdf_new_name(str):
    r"""Low-level wrapper for `::pdf_new_name()`."""
    return _mupdf.ll_pdf_new_name(str)

def ll_pdf_new_outline_iterator(doc):
    r"""Low-level wrapper for `::pdf_new_outline_iterator()`."""
    return _mupdf.ll_pdf_new_outline_iterator(doc)

def ll_pdf_new_output_processor(out, ahxencode, newlines):
    r"""Low-level wrapper for `::pdf_new_output_processor()`."""
    return _mupdf.ll_pdf_new_output_processor(out, ahxencode, newlines)

def ll_pdf_new_pdf_device(doc, topctm, resources, contents):
    r"""Low-level wrapper for `::pdf_new_pdf_device()`."""
    return _mupdf.ll_pdf_new_pdf_device(doc, topctm, resources, contents)

def ll_pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha):
    r"""Low-level wrapper for `::pdf_new_pixmap_from_annot()`."""
    return _mupdf.ll_pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha)

def ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
    r"""Low-level wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`."""
    return _mupdf.ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

def ll_pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box):
    r"""Low-level wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`."""
    return _mupdf.ll_pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box)

def ll_pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
    r"""Low-level wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
    return _mupdf.ll_pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

def ll_pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box):
    r"""Low-level wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
    return _mupdf.ll_pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box)

def ll_pdf_new_point(doc, point):
    r"""Low-level wrapper for `::pdf_new_point()`."""
    return _mupdf.ll_pdf_new_point(doc, point)

def ll_pdf_new_processor(size):
    r"""Low-level wrapper for `::pdf_new_processor()`."""
    return _mupdf.ll_pdf_new_processor(size)

def ll_pdf_new_real(f):
    r"""Low-level wrapper for `::pdf_new_real()`."""
    return _mupdf.ll_pdf_new_real(f)

def ll_pdf_new_rect(doc, rect):
    r"""Low-level wrapper for `::pdf_new_rect()`."""
    return _mupdf.ll_pdf_new_rect(doc, rect)

def ll_pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie):
    r"""Low-level wrapper for `::pdf_new_run_processor()`."""
    return _mupdf.ll_pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie)

def ll_pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts):
    r"""Low-level wrapper for `::pdf_new_sanitize_filter()`."""
    return _mupdf.ll_pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts)

def ll_pdf_new_stext_page_from_annot(annot, options):
    r"""Low-level wrapper for `::pdf_new_stext_page_from_annot()`."""
    return _mupdf.ll_pdf_new_stext_page_from_annot(annot, options)

def ll_pdf_new_string(str, len):
    r"""Low-level wrapper for `::pdf_new_string()`."""
    return _mupdf.ll_pdf_new_string(str, len)

def ll_pdf_new_text_string(s):
    r"""Low-level wrapper for `::pdf_new_text_string()`."""
    return _mupdf.ll_pdf_new_text_string(s)

def ll_pdf_new_uri_from_explicit_dest(dest):
    r"""Low-level wrapper for `::pdf_new_uri_from_explicit_dest()`."""
    return _mupdf.ll_pdf_new_uri_from_explicit_dest(dest)

def ll_pdf_new_uri_from_path_and_explicit_dest(path, dest):
    r"""Low-level wrapper for `::pdf_new_uri_from_path_and_explicit_dest()`."""
    return _mupdf.ll_pdf_new_uri_from_path_and_explicit_dest(path, dest)

def ll_pdf_new_uri_from_path_and_named_dest(path, name):
    r"""Low-level wrapper for `::pdf_new_uri_from_path_and_named_dest()`."""
    return _mupdf.ll_pdf_new_uri_from_path_and_named_dest(path, name)

def ll_pdf_new_utf8_from_pdf_stream_obj(src):
    r"""Low-level wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`."""
    return _mupdf.ll_pdf_new_utf8_from_pdf_stream_obj(src)

def ll_pdf_new_utf8_from_pdf_string(srcptr, srclen):
    r"""Low-level wrapper for `::pdf_new_utf8_from_pdf_string()`."""
    return _mupdf.ll_pdf_new_utf8_from_pdf_string(srcptr, srclen)

def ll_pdf_new_utf8_from_pdf_string_obj(src):
    r"""Low-level wrapper for `::pdf_new_utf8_from_pdf_string_obj()`."""
    return _mupdf.ll_pdf_new_utf8_from_pdf_string_obj(src)

def ll_pdf_new_xobject(doc, bbox, matrix, res, buffer):
    r"""Low-level wrapper for `::pdf_new_xobject()`."""
    return _mupdf.ll_pdf_new_xobject(doc, bbox, matrix, res, buffer)

def ll_pdf_next_annot(annot):
    r"""Low-level wrapper for `::pdf_next_annot()`."""
    return _mupdf.ll_pdf_next_annot(annot)

def ll_pdf_next_widget(previous):
    r"""Low-level wrapper for `::pdf_next_widget()`."""
    return _mupdf.ll_pdf_next_widget(previous)

def ll_pdf_nuke_annots(page):
    r"""Low-level wrapper for `::pdf_nuke_annots()`."""
    return _mupdf.ll_pdf_nuke_annots(page)

def ll_pdf_nuke_links(page):
    r"""Low-level wrapper for `::pdf_nuke_links()`."""
    return _mupdf.ll_pdf_nuke_links(page)

def ll_pdf_nuke_page(page):
    r"""Low-level wrapper for `::pdf_nuke_page()`."""
    return _mupdf.ll_pdf_nuke_page(page)

def ll_pdf_obj_is_dirty(obj):
    r"""Low-level wrapper for `::pdf_obj_is_dirty()`."""
    return _mupdf.ll_pdf_obj_is_dirty(obj)

def ll_pdf_obj_is_incremental(obj):
    r"""Low-level wrapper for `::pdf_obj_is_incremental()`."""
    return _mupdf.ll_pdf_obj_is_incremental(obj)

def ll_pdf_obj_marked(obj):
    r"""Low-level wrapper for `::pdf_obj_marked()`."""
    return _mupdf.ll_pdf_obj_marked(obj)

def ll_pdf_obj_memo(obj, bit, memo):
    r"""
     Low-level wrapper for `::pdf_obj_memo()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_obj_memo(::pdf_obj *obj, int bit)` => `(int, int memo)`
    """
    return _mupdf.ll_pdf_obj_memo(obj, bit, memo)

def ll_pdf_obj_num_is_stream(doc, num):
    r"""Low-level wrapper for `::pdf_obj_num_is_stream()`."""
    return _mupdf.ll_pdf_obj_num_is_stream(doc, num)

def ll_pdf_obj_parent_num(obj):
    r"""Low-level wrapper for `::pdf_obj_parent_num()`."""
    return _mupdf.ll_pdf_obj_parent_num(obj)

def ll_pdf_obj_refs(ref):
    r"""Low-level wrapper for `::pdf_obj_refs()`."""
    return _mupdf.ll_pdf_obj_refs(ref)

def ll_pdf_objcmp(a, b):
    r"""Low-level wrapper for `::pdf_objcmp()`."""
    return _mupdf.ll_pdf_objcmp(a, b)

def ll_pdf_objcmp_deep(a, b):
    r"""Low-level wrapper for `::pdf_objcmp_deep()`."""
    return _mupdf.ll_pdf_objcmp_deep(a, b)

def ll_pdf_objcmp_resolve(a, b):
    r"""Low-level wrapper for `::pdf_objcmp_resolve()`."""
    return _mupdf.ll_pdf_objcmp_resolve(a, b)

def ll_pdf_open_contents_stream(doc, obj):
    r"""Low-level wrapper for `::pdf_open_contents_stream()`."""
    return _mupdf.ll_pdf_open_contents_stream(doc, obj)

def ll_pdf_open_crypt(chain, crypt, num, gen):
    r"""Low-level wrapper for `::pdf_open_crypt()`."""
    return _mupdf.ll_pdf_open_crypt(chain, crypt, num, gen)

def ll_pdf_open_crypt_with_filter(chain, crypt, name, num, gen):
    r"""Low-level wrapper for `::pdf_open_crypt_with_filter()`."""
    return _mupdf.ll_pdf_open_crypt_with_filter(chain, crypt, name, num, gen)

def ll_pdf_open_document(filename):
    r"""Low-level wrapper for `::pdf_open_document()`."""
    return _mupdf.ll_pdf_open_document(filename)

def ll_pdf_open_document_with_stream(file):
    r"""Low-level wrapper for `::pdf_open_document_with_stream()`."""
    return _mupdf.ll_pdf_open_document_with_stream(file)

def ll_pdf_open_inline_stream(doc, stmobj, length, chain, params):
    r"""Low-level wrapper for `::pdf_open_inline_stream()`."""
    return _mupdf.ll_pdf_open_inline_stream(doc, stmobj, length, chain, params)

def ll_pdf_open_raw_stream(ref):
    r"""Low-level wrapper for `::pdf_open_raw_stream()`."""
    return _mupdf.ll_pdf_open_raw_stream(ref)

def ll_pdf_open_raw_stream_number(doc, num):
    r"""Low-level wrapper for `::pdf_open_raw_stream_number()`."""
    return _mupdf.ll_pdf_open_raw_stream_number(doc, num)

def ll_pdf_open_stream(ref):
    r"""Low-level wrapper for `::pdf_open_stream()`."""
    return _mupdf.ll_pdf_open_stream(ref)

def ll_pdf_open_stream_number(doc, num):
    r"""Low-level wrapper for `::pdf_open_stream_number()`."""
    return _mupdf.ll_pdf_open_stream_number(doc, num)

def ll_pdf_open_stream_with_offset(doc, num, dict, stm_ofs):
    r"""Low-level wrapper for `::pdf_open_stream_with_offset()`."""
    return _mupdf.ll_pdf_open_stream_with_offset(doc, num, dict, stm_ofs)

def ll_pdf_page_associated_file(page, idx):
    r"""Low-level wrapper for `::pdf_page_associated_file()`."""
    return _mupdf.ll_pdf_page_associated_file(page, idx)

def ll_pdf_page_contents(page):
    r"""Low-level wrapper for `::pdf_page_contents()`."""
    return _mupdf.ll_pdf_page_contents(page)

def ll_pdf_page_event_close(page):
    r"""Low-level wrapper for `::pdf_page_event_close()`."""
    return _mupdf.ll_pdf_page_event_close(page)

def ll_pdf_page_event_open(page):
    r"""Low-level wrapper for `::pdf_page_event_open()`."""
    return _mupdf.ll_pdf_page_event_open(page)

def ll_pdf_page_from_fz_page(ptr):
    r"""Low-level wrapper for `::pdf_page_from_fz_page()`."""
    return _mupdf.ll_pdf_page_from_fz_page(ptr)

def ll_pdf_page_group(page):
    r"""Low-level wrapper for `::pdf_page_group()`."""
    return _mupdf.ll_pdf_page_group(page)

def ll_pdf_page_has_transparency(page):
    r"""Low-level wrapper for `::pdf_page_has_transparency()`."""
    return _mupdf.ll_pdf_page_has_transparency(page)

def ll_pdf_page_label(doc, page, buf, size):
    r"""Low-level wrapper for `::pdf_page_label()`."""
    return _mupdf.ll_pdf_page_label(doc, page, buf, size)

def ll_pdf_page_label_imp(doc, chapter, page, buf, size):
    r"""Low-level wrapper for `::pdf_page_label_imp()`."""
    return _mupdf.ll_pdf_page_label_imp(doc, chapter, page, buf, size)

def ll_pdf_page_obj_transform(pageobj, outbox, outctm):
    r"""Low-level wrapper for `::pdf_page_obj_transform()`."""
    return _mupdf.ll_pdf_page_obj_transform(pageobj, outbox, outctm)

def ll_pdf_page_obj_transform_box(pageobj, outbox, out, box):
    r"""Low-level wrapper for `::pdf_page_obj_transform_box()`."""
    return _mupdf.ll_pdf_page_obj_transform_box(pageobj, outbox, out, box)

def ll_pdf_page_presentation(page, transition, duration):
    r"""
     Low-level wrapper for `::pdf_page_presentation()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_page_presentation(::pdf_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
    """
    return _mupdf.ll_pdf_page_presentation(page, transition, duration)

def ll_pdf_page_resources(page):
    r"""Low-level wrapper for `::pdf_page_resources()`."""
    return _mupdf.ll_pdf_page_resources(page)

def ll_pdf_page_separations(page):
    r"""Low-level wrapper for `::pdf_page_separations()`."""
    return _mupdf.ll_pdf_page_separations(page)

def ll_pdf_page_transform(page, mediabox, ctm):
    r"""Low-level wrapper for `::pdf_page_transform()`."""
    return _mupdf.ll_pdf_page_transform(page, mediabox, ctm)

def ll_pdf_page_transform_box(page, mediabox, ctm, box):
    r"""Low-level wrapper for `::pdf_page_transform_box()`."""
    return _mupdf.ll_pdf_page_transform_box(page, mediabox, ctm, box)

def ll_pdf_page_write(doc, mediabox, presources, pcontents):
    r"""
     Low-level wrapper for `::pdf_page_write()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_page_write(::pdf_document *doc, ::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
    """
    return _mupdf.ll_pdf_page_write(doc, mediabox, presources, pcontents)

def ll_pdf_parse_array(doc, f, buf):
    r"""Low-level wrapper for `::pdf_parse_array()`."""
    return _mupdf.ll_pdf_parse_array(doc, f, buf)

def ll_pdf_parse_date(s):
    r"""Low-level wrapper for `::pdf_parse_date()`."""
    return _mupdf.ll_pdf_parse_date(s)

def ll_pdf_parse_default_appearance(da, font, size, n, color):
    r"""
     Low-level wrapper for `::pdf_parse_default_appearance()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_parse_default_appearance(const char *da, float color[4])` => `(const char *font, float size, int n)`
    """
    return _mupdf.ll_pdf_parse_default_appearance(da, font, size, n, color)

def ll_pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, size, n, color):
    r"""
     Low-level wrapper for `::pdf_parse_default_appearance_unmapped()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_parse_default_appearance_unmapped(const char *da, char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
    """
    return _mupdf.ll_pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, size, n, color)

def ll_pdf_parse_dict(doc, f, buf):
    r"""Low-level wrapper for `::pdf_parse_dict()`."""
    return _mupdf.ll_pdf_parse_dict(doc, f, buf)

def ll_pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair):
    r"""
     Low-level wrapper for `::pdf_parse_ind_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_parse_ind_obj(::pdf_document *doc, ::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
    """
    return _mupdf.ll_pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair)

def ll_pdf_parse_journal_obj(doc, stm, onum, ostm, newobj):
    r"""
     Low-level wrapper for `::pdf_parse_journal_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_parse_journal_obj(::pdf_document *doc, ::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
    """
    return _mupdf.ll_pdf_parse_journal_obj(doc, stm, onum, ostm, newobj)

def ll_pdf_parse_stm_obj(doc, f, buf):
    r"""Low-level wrapper for `::pdf_parse_stm_obj()`."""
    return _mupdf.ll_pdf_parse_stm_obj(doc, f, buf)

def ll_pdf_parse_write_options(opts, args):
    r"""Low-level wrapper for `::pdf_parse_write_options()`."""
    return _mupdf.ll_pdf_parse_write_options(opts, args)

def ll_pdf_pin_document(obj):
    r"""Low-level wrapper for `::pdf_pin_document()`."""
    return _mupdf.ll_pdf_pin_document(obj)

def ll_pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location):
    r"""Low-level wrapper for `::pdf_preview_signature_as_display_list()`."""
    return _mupdf.ll_pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location)

def ll_pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location):
    r"""Low-level wrapper for `::pdf_preview_signature_as_pixmap()`."""
    return _mupdf.ll_pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location)

def ll_pdf_print_crypt(out, crypt):
    r"""Low-level wrapper for `::pdf_print_crypt()`."""
    return _mupdf.ll_pdf_print_crypt(out, crypt)

def ll_pdf_print_default_appearance(buf, nbuf, font, size, n, color):
    r"""Low-level wrapper for `::pdf_print_default_appearance()`."""
    return _mupdf.ll_pdf_print_default_appearance(buf, nbuf, font, size, n, color)

def ll_pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep):
    r"""
     Low-level wrapper for `::pdf_print_encrypted_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_print_encrypted_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
    """
    return _mupdf.ll_pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep)

def ll_pdf_print_font(out, fontdesc):
    r"""Low-level wrapper for `::pdf_print_font()`."""
    return _mupdf.ll_pdf_print_font(out, fontdesc)

def ll_pdf_print_obj(out, obj, tight, ascii):
    r"""Low-level wrapper for `::pdf_print_obj()`."""
    return _mupdf.ll_pdf_print_obj(out, obj, tight, ascii)

def ll_pdf_process_annot(proc, annot, cookie):
    r"""Low-level wrapper for `::pdf_process_annot()`."""
    return _mupdf.ll_pdf_process_annot(proc, annot, cookie)

def ll_pdf_process_contents(proc, doc, res, stm, cookie, out_res):
    r"""
     Low-level wrapper for `::pdf_process_contents()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_process_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` =>
    """
    return _mupdf.ll_pdf_process_contents(proc, doc, res, stm, cookie, out_res)

def ll_pdf_process_glyph(proc, doc, resources, contents):
    r"""Low-level wrapper for `::pdf_process_glyph()`."""
    return _mupdf.ll_pdf_process_glyph(proc, doc, resources, contents)

def ll_pdf_process_raw_contents(proc, doc, rdb, stmobj, cookie):
    r"""Low-level wrapper for `::pdf_process_raw_contents()`."""
    return _mupdf.ll_pdf_process_raw_contents(proc, doc, rdb, stmobj, cookie)

def ll_pdf_processor_pop_resources(proc):
    r"""Low-level wrapper for `::pdf_processor_pop_resources()`."""
    return _mupdf.ll_pdf_processor_pop_resources(proc)

def ll_pdf_processor_push_resources(proc, res):
    r"""Low-level wrapper for `::pdf_processor_push_resources()`."""
    return _mupdf.ll_pdf_processor_push_resources(proc, res)

def ll_pdf_progressive_advance(doc, pagenum):
    r"""Low-level wrapper for `::pdf_progressive_advance()`."""
    return _mupdf.ll_pdf_progressive_advance(doc, pagenum)

def ll_pdf_purge_local_font_resources(doc):
    r"""Low-level wrapper for `::pdf_purge_local_font_resources()`."""
    return _mupdf.ll_pdf_purge_local_font_resources(doc)

def ll_pdf_purge_locals_from_store(doc):
    r"""Low-level wrapper for `::pdf_purge_locals_from_store()`."""
    return _mupdf.ll_pdf_purge_locals_from_store(doc)

def ll_pdf_purge_object_from_store(doc, num):
    r"""Low-level wrapper for `::pdf_purge_object_from_store()`."""
    return _mupdf.ll_pdf_purge_object_from_store(doc, num)

def ll_pdf_read_journal(doc, stm):
    r"""Low-level wrapper for `::pdf_read_journal()`."""
    return _mupdf.ll_pdf_read_journal(doc, stm)

def ll_pdf_read_ocg(doc):
    r"""Low-level wrapper for `::pdf_read_ocg()`."""
    return _mupdf.ll_pdf_read_ocg(doc)

def ll_pdf_rearrange_pages(doc, count, pages, structure):
    r"""Low-level wrapper for `::pdf_rearrange_pages()`."""
    return _mupdf.ll_pdf_rearrange_pages(doc, count, pages, structure)

def ll_pdf_rearrange_pages2(doc, pages, structure):
    r"""Low-level wrapper for `::pdf_rearrange_pages2()`.  Swig-friendly wrapper for pdf_rearrange_pages()."""
    return _mupdf.ll_pdf_rearrange_pages2(doc, pages, structure)

def ll_pdf_recolor_page(doc, pagenum, opts):
    r"""Low-level wrapper for `::pdf_recolor_page()`."""
    return _mupdf.ll_pdf_recolor_page(doc, pagenum, opts)

def ll_pdf_recolor_shade(shade, reshade, opaque):
    r"""
    Low-level wrapper for `::pdf_recolor_shade()`.
    Recolor a shade.
    """
    return _mupdf.ll_pdf_recolor_shade(shade, reshade, opaque)

def ll_pdf_redact_page(doc, page, opts):
    r"""Low-level wrapper for `::pdf_redact_page()`."""
    return _mupdf.ll_pdf_redact_page(doc, page, opts)

def ll_pdf_redo(doc):
    r"""Low-level wrapper for `::pdf_redo()`."""
    return _mupdf.ll_pdf_redo(doc)

def ll_pdf_remove_item(drop, key):
    r"""Low-level wrapper for `::pdf_remove_item()`."""
    return _mupdf.ll_pdf_remove_item(drop, key)

def ll_pdf_remove_output_intents(doc):
    r"""Low-level wrapper for `::pdf_remove_output_intents()`."""
    return _mupdf.ll_pdf_remove_output_intents(doc)

def ll_pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root):
    r"""
     Low-level wrapper for `::pdf_repair_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_repair_obj(::pdf_document *doc, ::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
    """
    return _mupdf.ll_pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root)

def ll_pdf_repair_obj_stms(doc):
    r"""Low-level wrapper for `::pdf_repair_obj_stms()`."""
    return _mupdf.ll_pdf_repair_obj_stms(doc)

def ll_pdf_repair_trailer(doc):
    r"""Low-level wrapper for `::pdf_repair_trailer()`."""
    return _mupdf.ll_pdf_repair_trailer(doc)

def ll_pdf_repair_xref(doc):
    r"""Low-level wrapper for `::pdf_repair_xref()`."""
    return _mupdf.ll_pdf_repair_xref(doc)

def ll_pdf_replace_xref(doc, entries, n):
    r"""Low-level wrapper for `::pdf_replace_xref()`."""
    return _mupdf.ll_pdf_replace_xref(doc, entries, n)

def ll_pdf_reset_form(doc, fields, exclude):
    r"""Low-level wrapper for `::pdf_reset_form()`."""
    return _mupdf.ll_pdf_reset_form(doc, fields, exclude)

def ll_pdf_reset_processor(proc):
    r"""Low-level wrapper for `::pdf_reset_processor()`."""
    return _mupdf.ll_pdf_reset_processor(proc)

def ll_pdf_resolve_indirect(ref):
    r"""
    Low-level wrapper for `::pdf_resolve_indirect()`.
    Resolve an indirect object (or chain of objects).

    This can cause xref reorganisations (solidifications etc) due to
    repairs, so all held pdf_xref_entries should be considered
    invalid after this call (other than the returned one).
    """
    return _mupdf.ll_pdf_resolve_indirect(ref)

def ll_pdf_resolve_indirect_chain(ref):
    r"""Low-level wrapper for `::pdf_resolve_indirect_chain()`."""
    return _mupdf.ll_pdf_resolve_indirect_chain(ref)

def ll_pdf_resolve_link(doc, uri, xp, yp):
    r"""
     Low-level wrapper for `::pdf_resolve_link()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_resolve_link(::pdf_document *doc, const char *uri)` => `(int, float xp, float yp)`
    """
    return _mupdf.ll_pdf_resolve_link(doc, uri, xp, yp)

def ll_pdf_resolve_link_dest(doc, uri):
    r"""Low-level wrapper for `::pdf_resolve_link_dest()`."""
    return _mupdf.ll_pdf_resolve_link_dest(doc, uri)

def ll_pdf_rewrite_images(doc, opts):
    r"""Low-level wrapper for `::pdf_rewrite_images()`."""
    return _mupdf.ll_pdf_rewrite_images(doc, opts)

def ll_pdf_run_annot(annot, dev, ctm, cookie):
    r"""Low-level wrapper for `::pdf_run_annot()`."""
    return _mupdf.ll_pdf_run_annot(annot, dev, ctm, cookie)

def ll_pdf_run_document_structure(doc, dev, cookie):
    r"""Low-level wrapper for `::pdf_run_document_structure()`."""
    return _mupdf.ll_pdf_run_document_structure(doc, dev, cookie)

def ll_pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs):
    r"""Low-level wrapper for `::pdf_run_glyph()`."""
    return _mupdf.ll_pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs)

def ll_pdf_run_page(page, dev, ctm, cookie):
    r"""Low-level wrapper for `::pdf_run_page()`."""
    return _mupdf.ll_pdf_run_page(page, dev, ctm, cookie)

def ll_pdf_run_page_annots(page, dev, ctm, cookie):
    r"""Low-level wrapper for `::pdf_run_page_annots()`."""
    return _mupdf.ll_pdf_run_page_annots(page, dev, ctm, cookie)

def ll_pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie):
    r"""Low-level wrapper for `::pdf_run_page_annots_with_usage()`."""
    return _mupdf.ll_pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie)

def ll_pdf_run_page_contents(page, dev, ctm, cookie):
    r"""Low-level wrapper for `::pdf_run_page_contents()`."""
    return _mupdf.ll_pdf_run_page_contents(page, dev, ctm, cookie)

def ll_pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie):
    r"""Low-level wrapper for `::pdf_run_page_contents_with_usage()`."""
    return _mupdf.ll_pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie)

def ll_pdf_run_page_widgets(page, dev, ctm, cookie):
    r"""Low-level wrapper for `::pdf_run_page_widgets()`."""
    return _mupdf.ll_pdf_run_page_widgets(page, dev, ctm, cookie)

def ll_pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie):
    r"""Low-level wrapper for `::pdf_run_page_widgets_with_usage()`."""
    return _mupdf.ll_pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie)

def ll_pdf_run_page_with_usage(page, dev, ctm, usage, cookie):
    r"""Low-level wrapper for `::pdf_run_page_with_usage()`."""
    return _mupdf.ll_pdf_run_page_with_usage(page, dev, ctm, usage, cookie)

def ll_pdf_sample_shade_function(samples, n, funcs, func, t0, t1):
    r"""
     Low-level wrapper for `::pdf_sample_shade_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_sample_shade_function(int n, int funcs, ::pdf_function **func, float t0, float t1)` => `(float samples)`
    """
    return _mupdf.ll_pdf_sample_shade_function(samples, n, funcs, func, t0, t1)

def ll_pdf_save_document(doc, filename, opts):
    r"""Low-level wrapper for `::pdf_save_document()`."""
    return _mupdf.ll_pdf_save_document(doc, filename, opts)

def ll_pdf_save_journal(doc, filename):
    r"""Low-level wrapper for `::pdf_save_journal()`."""
    return _mupdf.ll_pdf_save_journal(doc, filename)

def ll_pdf_save_snapshot(doc, filename):
    r"""Low-level wrapper for `::pdf_save_snapshot()`."""
    return _mupdf.ll_pdf_save_snapshot(doc, filename)

def ll_pdf_select_layer_config(doc, config_num):
    r"""Low-level wrapper for `::pdf_select_layer_config()`."""
    return _mupdf.ll_pdf_select_layer_config(doc, config_num)

def ll_pdf_select_layer_config_ui(doc, ui):
    r"""Low-level wrapper for `::pdf_select_layer_config_ui()`."""
    return _mupdf.ll_pdf_select_layer_config_ui(doc, ui)

def ll_pdf_serialise_journal(doc, out):
    r"""Low-level wrapper for `::pdf_serialise_journal()`."""
    return _mupdf.ll_pdf_serialise_journal(doc, out)

def ll_pdf_set_annot_active(annot, active):
    r"""Low-level wrapper for `::pdf_set_annot_active()`."""
    return _mupdf.ll_pdf_set_annot_active(annot, active)

def ll_pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents):
    r"""Low-level wrapper for `::pdf_set_annot_appearance()`."""
    return _mupdf.ll_pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents)

def ll_pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list):
    r"""Low-level wrapper for `::pdf_set_annot_appearance_from_display_list()`."""
    return _mupdf.ll_pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list)

def ll_pdf_set_annot_author(annot, author):
    r"""Low-level wrapper for `::pdf_set_annot_author()`."""
    return _mupdf.ll_pdf_set_annot_author(annot, author)

def ll_pdf_set_annot_border(annot, width):
    r"""Low-level wrapper for `::pdf_set_annot_border()`."""
    return _mupdf.ll_pdf_set_annot_border(annot, width)

def ll_pdf_set_annot_border_effect(annot, effect):
    r"""Low-level wrapper for `::pdf_set_annot_border_effect()`."""
    return _mupdf.ll_pdf_set_annot_border_effect(annot, effect)

def ll_pdf_set_annot_border_effect_intensity(annot, intensity):
    r"""Low-level wrapper for `::pdf_set_annot_border_effect_intensity()`."""
    return _mupdf.ll_pdf_set_annot_border_effect_intensity(annot, intensity)

def ll_pdf_set_annot_border_style(annot, style):
    r"""Low-level wrapper for `::pdf_set_annot_border_style()`."""
    return _mupdf.ll_pdf_set_annot_border_style(annot, style)

def ll_pdf_set_annot_border_width(annot, width):
    r"""Low-level wrapper for `::pdf_set_annot_border_width()`."""
    return _mupdf.ll_pdf_set_annot_border_width(annot, width)

def ll_pdf_set_annot_callout_line(annot, callout, n):
    r"""Low-level wrapper for `::pdf_set_annot_callout_line()`."""
    return _mupdf.ll_pdf_set_annot_callout_line(annot, callout, n)

def ll_pdf_set_annot_callout_line2(annot, callout):
    r"""Low-level wrapper for `::pdf_set_annot_callout_line2()`.  SWIG-friendly wrapper for pdf_set_annot_callout_line()."""
    return _mupdf.ll_pdf_set_annot_callout_line2(annot, callout)

def ll_pdf_set_annot_callout_point(annot, p):
    r"""Low-level wrapper for `::pdf_set_annot_callout_point()`."""
    return _mupdf.ll_pdf_set_annot_callout_point(annot, p)

def ll_pdf_set_annot_callout_style(annot, style):
    r"""Low-level wrapper for `::pdf_set_annot_callout_style()`."""
    return _mupdf.ll_pdf_set_annot_callout_style(annot, style)

def ll_pdf_set_annot_color(annot, n, color):
    r"""Low-level wrapper for `::pdf_set_annot_color()`."""
    return _mupdf.ll_pdf_set_annot_color(annot, n, color)

def ll_pdf_set_annot_contents(annot, text):
    r"""Low-level wrapper for `::pdf_set_annot_contents()`."""
    return _mupdf.ll_pdf_set_annot_contents(annot, text)

def ll_pdf_set_annot_creation_date(annot, time):
    r"""Low-level wrapper for `::pdf_set_annot_creation_date()`."""
    return _mupdf.ll_pdf_set_annot_creation_date(annot, time)

def ll_pdf_set_annot_default_appearance(annot, font, size, n, color):
    r"""Low-level wrapper for `::pdf_set_annot_default_appearance()`."""
    return _mupdf.ll_pdf_set_annot_default_appearance(annot, font, size, n, color)

def ll_pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events):
    r"""Low-level wrapper for `::pdf_set_annot_field_value()`."""
    return _mupdf.ll_pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events)

def ll_pdf_set_annot_filespec(annot, obj):
    r"""Low-level wrapper for `::pdf_set_annot_filespec()`."""
    return _mupdf.ll_pdf_set_annot_filespec(annot, obj)

def ll_pdf_set_annot_flags(annot, flags):
    r"""Low-level wrapper for `::pdf_set_annot_flags()`."""
    return _mupdf.ll_pdf_set_annot_flags(annot, flags)

def ll_pdf_set_annot_hidden_for_editing(annot, hidden):
    r"""Low-level wrapper for `::pdf_set_annot_hidden_for_editing()`."""
    return _mupdf.ll_pdf_set_annot_hidden_for_editing(annot, hidden)

def ll_pdf_set_annot_hot(annot, hot):
    r"""Low-level wrapper for `::pdf_set_annot_hot()`."""
    return _mupdf.ll_pdf_set_annot_hot(annot, hot)

def ll_pdf_set_annot_icon_name(annot, name):
    r"""Low-level wrapper for `::pdf_set_annot_icon_name()`."""
    return _mupdf.ll_pdf_set_annot_icon_name(annot, name)

def ll_pdf_set_annot_ink_list(annot, n, count, v):
    r"""Low-level wrapper for `::pdf_set_annot_ink_list()`."""
    return _mupdf.ll_pdf_set_annot_ink_list(annot, n, count, v)

def ll_pdf_set_annot_intent(annot, it):
    r"""Low-level wrapper for `::pdf_set_annot_intent()`."""
    return _mupdf.ll_pdf_set_annot_intent(annot, it)

def ll_pdf_set_annot_interior_color(annot, n, color):
    r"""Low-level wrapper for `::pdf_set_annot_interior_color()`."""
    return _mupdf.ll_pdf_set_annot_interior_color(annot, n, color)

def ll_pdf_set_annot_is_open(annot, is_open):
    r"""Low-level wrapper for `::pdf_set_annot_is_open()`."""
    return _mupdf.ll_pdf_set_annot_is_open(annot, is_open)

def ll_pdf_set_annot_language(annot, lang):
    r"""Low-level wrapper for `::pdf_set_annot_language()`."""
    return _mupdf.ll_pdf_set_annot_language(annot, lang)

def ll_pdf_set_annot_line(annot, a, b):
    r"""Low-level wrapper for `::pdf_set_annot_line()`."""
    return _mupdf.ll_pdf_set_annot_line(annot, a, b)

def ll_pdf_set_annot_line_caption(annot, cap):
    r"""Low-level wrapper for `::pdf_set_annot_line_caption()`."""
    return _mupdf.ll_pdf_set_annot_line_caption(annot, cap)

def ll_pdf_set_annot_line_caption_offset(annot, offset):
    r"""Low-level wrapper for `::pdf_set_annot_line_caption_offset()`."""
    return _mupdf.ll_pdf_set_annot_line_caption_offset(annot, offset)

def ll_pdf_set_annot_line_end_style(annot, e):
    r"""Low-level wrapper for `::pdf_set_annot_line_end_style()`."""
    return _mupdf.ll_pdf_set_annot_line_end_style(annot, e)

def ll_pdf_set_annot_line_ending_styles(annot, start_style, end_style):
    r"""Low-level wrapper for `::pdf_set_annot_line_ending_styles()`."""
    return _mupdf.ll_pdf_set_annot_line_ending_styles(annot, start_style, end_style)

def ll_pdf_set_annot_line_leader(annot, ll):
    r"""Low-level wrapper for `::pdf_set_annot_line_leader()`."""
    return _mupdf.ll_pdf_set_annot_line_leader(annot, ll)

def ll_pdf_set_annot_line_leader_extension(annot, lle):
    r"""Low-level wrapper for `::pdf_set_annot_line_leader_extension()`."""
    return _mupdf.ll_pdf_set_annot_line_leader_extension(annot, lle)

def ll_pdf_set_annot_line_leader_offset(annot, llo):
    r"""Low-level wrapper for `::pdf_set_annot_line_leader_offset()`."""
    return _mupdf.ll_pdf_set_annot_line_leader_offset(annot, llo)

def ll_pdf_set_annot_line_start_style(annot, s):
    r"""Low-level wrapper for `::pdf_set_annot_line_start_style()`."""
    return _mupdf.ll_pdf_set_annot_line_start_style(annot, s)

def ll_pdf_set_annot_modification_date(annot, time):
    r"""Low-level wrapper for `::pdf_set_annot_modification_date()`."""
    return _mupdf.ll_pdf_set_annot_modification_date(annot, time)

def ll_pdf_set_annot_opacity(annot, opacity):
    r"""Low-level wrapper for `::pdf_set_annot_opacity()`."""
    return _mupdf.ll_pdf_set_annot_opacity(annot, opacity)

def ll_pdf_set_annot_popup(annot, rect):
    r"""Low-level wrapper for `::pdf_set_annot_popup()`."""
    return _mupdf.ll_pdf_set_annot_popup(annot, rect)

def ll_pdf_set_annot_quad_points(annot, n, qv):
    r"""Low-level wrapper for `::pdf_set_annot_quad_points()`."""
    return _mupdf.ll_pdf_set_annot_quad_points(annot, n, qv)

def ll_pdf_set_annot_quadding(annot, q):
    r"""Low-level wrapper for `::pdf_set_annot_quadding()`."""
    return _mupdf.ll_pdf_set_annot_quadding(annot, q)

def ll_pdf_set_annot_rect(annot, rect):
    r"""Low-level wrapper for `::pdf_set_annot_rect()`."""
    return _mupdf.ll_pdf_set_annot_rect(annot, rect)

def ll_pdf_set_annot_resynthesised(annot):
    r"""Low-level wrapper for `::pdf_set_annot_resynthesised()`."""
    return _mupdf.ll_pdf_set_annot_resynthesised(annot)

def ll_pdf_set_annot_stamp_image(annot, image):
    r"""Low-level wrapper for `::pdf_set_annot_stamp_image()`."""
    return _mupdf.ll_pdf_set_annot_stamp_image(annot, image)

def ll_pdf_set_annot_vertex(annot, i, p):
    r"""Low-level wrapper for `::pdf_set_annot_vertex()`."""
    return _mupdf.ll_pdf_set_annot_vertex(annot, i, p)

def ll_pdf_set_annot_vertices(annot, n, v):
    r"""Low-level wrapper for `::pdf_set_annot_vertices()`."""
    return _mupdf.ll_pdf_set_annot_vertices(annot, n, v)

def ll_pdf_set_choice_field_value(widget, value):
    r"""Low-level wrapper for `::pdf_set_choice_field_value()`."""
    return _mupdf.ll_pdf_set_choice_field_value(widget, value)

def ll_pdf_set_cmap_wmode(cmap, wmode):
    r"""Low-level wrapper for `::pdf_set_cmap_wmode()`."""
    return _mupdf.ll_pdf_set_cmap_wmode(cmap, wmode)

def ll_pdf_set_default_hmtx(font, w):
    r"""Low-level wrapper for `::pdf_set_default_hmtx()`."""
    return _mupdf.ll_pdf_set_default_hmtx(font, w)

def ll_pdf_set_default_vmtx(font, y, w):
    r"""Low-level wrapper for `::pdf_set_default_vmtx()`."""
    return _mupdf.ll_pdf_set_default_vmtx(font, y, w)

def ll_pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data):
    r"""Low-level wrapper for `::pdf_set_doc_event_callback()`."""
    return _mupdf.ll_pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data)

def ll_pdf_set_document_language(doc, lang):
    r"""Low-level wrapper for `::pdf_set_document_language()`."""
    return _mupdf.ll_pdf_set_document_language(doc, lang)

def ll_pdf_set_field_value(doc, field, text, ignore_trigger_events):
    r"""Low-level wrapper for `::pdf_set_field_value()`."""
    return _mupdf.ll_pdf_set_field_value(doc, field, text, ignore_trigger_events)

def ll_pdf_set_font_wmode(font, wmode):
    r"""Low-level wrapper for `::pdf_set_font_wmode()`."""
    return _mupdf.ll_pdf_set_font_wmode(font, wmode)

def ll_pdf_set_int(obj, i):
    r"""Low-level wrapper for `::pdf_set_int()`."""
    return _mupdf.ll_pdf_set_int(obj, i)

def ll_pdf_set_layer_config_as_default(doc):
    r"""Low-level wrapper for `::pdf_set_layer_config_as_default()`."""
    return _mupdf.ll_pdf_set_layer_config_as_default(doc)

def ll_pdf_set_obj_memo(obj, bit, memo):
    r"""Low-level wrapper for `::pdf_set_obj_memo()`."""
    return _mupdf.ll_pdf_set_obj_memo(obj, bit, memo)

def ll_pdf_set_obj_parent(obj, num):
    r"""Low-level wrapper for `::pdf_set_obj_parent()`."""
    return _mupdf.ll_pdf_set_obj_parent(obj, num)

def ll_pdf_set_page_box(page, box, rect):
    r"""Low-level wrapper for `::pdf_set_page_box()`."""
    return _mupdf.ll_pdf_set_page_box(page, box, rect)

def ll_pdf_set_page_labels(doc, index, style, prefix, start):
    r"""Low-level wrapper for `::pdf_set_page_labels()`."""
    return _mupdf.ll_pdf_set_page_labels(doc, index, style, prefix, start)

def ll_pdf_set_populating_xref_trailer(doc, trailer):
    r"""Low-level wrapper for `::pdf_set_populating_xref_trailer()`."""
    return _mupdf.ll_pdf_set_populating_xref_trailer(doc, trailer)

def ll_pdf_set_str_len(obj, newlen):
    r"""Low-level wrapper for `::pdf_set_str_len()`."""
    return _mupdf.ll_pdf_set_str_len(obj, newlen)

def ll_pdf_set_text_field_value(widget, value):
    r"""Low-level wrapper for `::pdf_set_text_field_value()`."""
    return _mupdf.ll_pdf_set_text_field_value(widget, value)

def ll_pdf_set_usecmap(cmap, usecmap):
    r"""Low-level wrapper for `::pdf_set_usecmap()`."""
    return _mupdf.ll_pdf_set_usecmap(cmap, usecmap)

def ll_pdf_set_widget_editing_state(widget, editing):
    r"""Low-level wrapper for `::pdf_set_widget_editing_state()`."""
    return _mupdf.ll_pdf_set_widget_editing_state(widget, editing)

def ll_pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location):
    r"""Low-level wrapper for `::pdf_sign_signature()`."""
    return _mupdf.ll_pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location)

def ll_pdf_sign_signature_with_appearance(widget, signer, date, disp_list):
    r"""Low-level wrapper for `::pdf_sign_signature_with_appearance()`."""
    return _mupdf.ll_pdf_sign_signature_with_appearance(widget, signer, date, disp_list)

def ll_pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo):
    r"""Low-level wrapper for `::pdf_signature_appearance_signed()`."""
    return _mupdf.ll_pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo)

def ll_pdf_signature_appearance_unsigned(rect, lang):
    r"""Low-level wrapper for `::pdf_signature_appearance_unsigned()`."""
    return _mupdf.ll_pdf_signature_appearance_unsigned(rect, lang)

def ll_pdf_signature_byte_range(doc, signature, byte_range):
    r"""Low-level wrapper for `::pdf_signature_byte_range()`."""
    return _mupdf.ll_pdf_signature_byte_range(doc, signature, byte_range)

def ll_pdf_signature_contents(doc, signature, contents):
    r"""
     Low-level wrapper for `::pdf_signature_contents()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_signature_contents(::pdf_document *doc, ::pdf_obj *signature)` => `(size_t, char *contents)`
    """
    return _mupdf.ll_pdf_signature_contents(doc, signature, contents)

def ll_pdf_signature_drop_distinguished_name(name):
    r"""Low-level wrapper for `::pdf_signature_drop_distinguished_name()`."""
    return _mupdf.ll_pdf_signature_drop_distinguished_name(name)

def ll_pdf_signature_error_description(err):
    r"""Low-level wrapper for `::pdf_signature_error_description()`."""
    return _mupdf.ll_pdf_signature_error_description(err)

def ll_pdf_signature_format_distinguished_name(name):
    r"""Low-level wrapper for `::pdf_signature_format_distinguished_name()`."""
    return _mupdf.ll_pdf_signature_format_distinguished_name(name)

def ll_pdf_signature_get_signatory(verifier, doc, signature):
    r"""Low-level wrapper for `::pdf_signature_get_signatory()`."""
    return _mupdf.ll_pdf_signature_get_signatory(verifier, doc, signature)

def ll_pdf_signature_get_widget_signatory(verifier, widget):
    r"""Low-level wrapper for `::pdf_signature_get_widget_signatory()`."""
    return _mupdf.ll_pdf_signature_get_widget_signatory(verifier, widget)

def ll_pdf_signature_hash_bytes(doc, signature):
    r"""Low-level wrapper for `::pdf_signature_hash_bytes()`."""
    return _mupdf.ll_pdf_signature_hash_bytes(doc, signature)

def ll_pdf_signature_incremental_change_since_signing(doc, signature):
    r"""Low-level wrapper for `::pdf_signature_incremental_change_since_signing()`."""
    return _mupdf.ll_pdf_signature_incremental_change_since_signing(doc, signature)

def ll_pdf_signature_info(name, dn, reason, location, date, include_labels):
    r"""Low-level wrapper for `::pdf_signature_info()`."""
    return _mupdf.ll_pdf_signature_info(name, dn, reason, location, date, include_labels)

def ll_pdf_signature_is_signed(doc, field):
    r"""Low-level wrapper for `::pdf_signature_is_signed()`."""
    return _mupdf.ll_pdf_signature_is_signed(doc, field)

def ll_pdf_signature_set_value(doc, field, signer, stime):
    r"""Low-level wrapper for `::pdf_signature_set_value()`."""
    return _mupdf.ll_pdf_signature_set_value(doc, field, signer, stime)

def ll_pdf_sort_cmap(cmap):
    r"""Low-level wrapper for `::pdf_sort_cmap()`."""
    return _mupdf.ll_pdf_sort_cmap(cmap)

def ll_pdf_sort_dict(dict):
    r"""Low-level wrapper for `::pdf_sort_dict()`."""
    return _mupdf.ll_pdf_sort_dict(dict)

def ll_pdf_specifics(doc):
    r"""Low-level wrapper for `::pdf_specifics()`."""
    return _mupdf.ll_pdf_specifics(doc)

def ll_pdf_sprint_obj(buf, cap, len, obj, tight, ascii):
    r"""
     Low-level wrapper for `::pdf_sprint_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_sprint_obj(char *buf, size_t cap, ::pdf_obj *obj, int tight, int ascii)` => `(char *, size_t len)`
    """
    return _mupdf.ll_pdf_sprint_obj(buf, cap, len, obj, tight, ascii)

def ll_pdf_store_item(key, val, itemsize):
    r"""Low-level wrapper for `::pdf_store_item()`."""
    return _mupdf.ll_pdf_store_item(key, val, itemsize)

def ll_pdf_string_from_annot_type(type):
    r"""Low-level wrapper for `::pdf_string_from_annot_type()`."""
    return _mupdf.ll_pdf_string_from_annot_type(type)

def ll_pdf_string_from_intent(intent):
    r"""Low-level wrapper for `::pdf_string_from_intent()`."""
    return _mupdf.ll_pdf_string_from_intent(intent)

def ll_pdf_string_from_line_ending(end):
    r"""Low-level wrapper for `::pdf_string_from_line_ending()`."""
    return _mupdf.ll_pdf_string_from_line_ending(end)

def ll_pdf_structure_type(role_map, tag):
    r"""Low-level wrapper for `::pdf_structure_type()`."""
    return _mupdf.ll_pdf_structure_type(role_map, tag)

def ll_pdf_subset_fonts(doc, pages_len, pages):
    r"""Low-level wrapper for `::pdf_subset_fonts()`."""
    return _mupdf.ll_pdf_subset_fonts(doc, pages_len, pages)

def ll_pdf_subset_fonts2(doc, pages):
    r"""Low-level wrapper for `::pdf_subset_fonts2()`.  Swig-friendly wrapper for pdf_subset_fonts()."""
    return _mupdf.ll_pdf_subset_fonts2(doc, pages)

def ll_pdf_sync_annots(page):
    r"""Low-level wrapper for `::pdf_sync_annots()`."""
    return _mupdf.ll_pdf_sync_annots(page)

def ll_pdf_sync_links(page):
    r"""Low-level wrapper for `::pdf_sync_links()`."""
    return _mupdf.ll_pdf_sync_links(page)

def ll_pdf_sync_open_pages(doc):
    r"""Low-level wrapper for `::pdf_sync_open_pages()`."""
    return _mupdf.ll_pdf_sync_open_pages(doc)

def ll_pdf_sync_page(page):
    r"""Low-level wrapper for `::pdf_sync_page()`."""
    return _mupdf.ll_pdf_sync_page(page)

def ll_pdf_text_widget_format(tw):
    r"""Low-level wrapper for `::pdf_text_widget_format()`."""
    return _mupdf.ll_pdf_text_widget_format(tw)

def ll_pdf_text_widget_max_len(tw):
    r"""Low-level wrapper for `::pdf_text_widget_max_len()`."""
    return _mupdf.ll_pdf_text_widget_max_len(tw)

def ll_pdf_to_bool(obj):
    r"""Low-level wrapper for `::pdf_to_bool()`."""
    return _mupdf.ll_pdf_to_bool(obj)

def ll_pdf_to_bool_default(obj, _def):
    r"""Low-level wrapper for `::pdf_to_bool_default()`."""
    return _mupdf.ll_pdf_to_bool_default(obj, _def)

def ll_pdf_to_date(time):
    r"""Low-level wrapper for `::pdf_to_date()`."""
    return _mupdf.ll_pdf_to_date(time)

def ll_pdf_to_gen(obj):
    r"""Low-level wrapper for `::pdf_to_gen()`."""
    return _mupdf.ll_pdf_to_gen(obj)

def ll_pdf_to_int(obj):
    r"""Low-level wrapper for `::pdf_to_int()`."""
    return _mupdf.ll_pdf_to_int(obj)

def ll_pdf_to_int64(obj):
    r"""Low-level wrapper for `::pdf_to_int64()`."""
    return _mupdf.ll_pdf_to_int64(obj)

def ll_pdf_to_int_default(obj, _def):
    r"""Low-level wrapper for `::pdf_to_int_default()`."""
    return _mupdf.ll_pdf_to_int_default(obj, _def)

def ll_pdf_to_matrix(array):
    r"""Low-level wrapper for `::pdf_to_matrix()`."""
    return _mupdf.ll_pdf_to_matrix(array)

def ll_pdf_to_name(obj):
    r"""Low-level wrapper for `::pdf_to_name()`."""
    return _mupdf.ll_pdf_to_name(obj)

def ll_pdf_to_num(obj):
    r"""Low-level wrapper for `::pdf_to_num()`."""
    return _mupdf.ll_pdf_to_num(obj)

def ll_pdf_to_point(array, offset):
    r"""Low-level wrapper for `::pdf_to_point()`."""
    return _mupdf.ll_pdf_to_point(array, offset)

def ll_pdf_to_quad(array, offset):
    r"""Low-level wrapper for `::pdf_to_quad()`."""
    return _mupdf.ll_pdf_to_quad(array, offset)

def ll_pdf_to_real(obj):
    r"""Low-level wrapper for `::pdf_to_real()`."""
    return _mupdf.ll_pdf_to_real(obj)

def ll_pdf_to_real_default(obj, _def):
    r"""Low-level wrapper for `::pdf_to_real_default()`."""
    return _mupdf.ll_pdf_to_real_default(obj, _def)

def ll_pdf_to_rect(array):
    r"""Low-level wrapper for `::pdf_to_rect()`."""
    return _mupdf.ll_pdf_to_rect(array)

def ll_pdf_to_str_buf(obj):
    r"""Low-level wrapper for `::pdf_to_str_buf()`."""
    return _mupdf.ll_pdf_to_str_buf(obj)

def ll_pdf_to_str_len(obj):
    r"""Low-level wrapper for `::pdf_to_str_len()`."""
    return _mupdf.ll_pdf_to_str_len(obj)

def ll_pdf_to_string(obj, sizep):
    r"""
     Low-level wrapper for `::pdf_to_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_to_string(::pdf_obj *obj)` => `(const char *, size_t sizep)`
    """
    return _mupdf.ll_pdf_to_string(obj, sizep)

def ll_pdf_to_text_string(obj):
    r"""Low-level wrapper for `::pdf_to_text_string()`."""
    return _mupdf.ll_pdf_to_text_string(obj)

def ll_pdf_toggle_layer_config_ui(doc, ui):
    r"""Low-level wrapper for `::pdf_toggle_layer_config_ui()`."""
    return _mupdf.ll_pdf_toggle_layer_config_ui(doc, ui)

def ll_pdf_toggle_widget(widget):
    r"""Low-level wrapper for `::pdf_toggle_widget()`."""
    return _mupdf.ll_pdf_toggle_widget(widget)

def ll_pdf_tos_get_text(tos):
    r"""Low-level wrapper for `::pdf_tos_get_text()`."""
    return _mupdf.ll_pdf_tos_get_text(tos)

def ll_pdf_tos_make_trm(tos, text, fontdesc, cid, trm, adv):
    r"""
     Low-level wrapper for `::pdf_tos_make_trm()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_tos_make_trm(::pdf_text_object_state *tos, ::pdf_text_state *text, ::pdf_font_desc *fontdesc, int cid, ::fz_matrix *trm)` => `(int, float adv)`
    """
    return _mupdf.ll_pdf_tos_make_trm(tos, text, fontdesc, cid, trm, adv)

def ll_pdf_tos_move_after_char(tos):
    r"""Low-level wrapper for `::pdf_tos_move_after_char()`."""
    return _mupdf.ll_pdf_tos_move_after_char(tos)

def ll_pdf_tos_newline(tos, leading):
    r"""Low-level wrapper for `::pdf_tos_newline()`."""
    return _mupdf.ll_pdf_tos_newline(tos, leading)

def ll_pdf_tos_reset(tos, render):
    r"""Low-level wrapper for `::pdf_tos_reset()`."""
    return _mupdf.ll_pdf_tos_reset(tos, render)

def ll_pdf_tos_restore(tos, save):
    r"""Low-level wrapper for `::pdf_tos_restore()`."""
    return _mupdf.ll_pdf_tos_restore(tos, save)

def ll_pdf_tos_save(tos, save):
    r"""Low-level wrapper for `::pdf_tos_save()`."""
    return _mupdf.ll_pdf_tos_save(tos, save)

def ll_pdf_tos_set_matrix(tos, a, b, c, d, e, f):
    r"""Low-level wrapper for `::pdf_tos_set_matrix()`."""
    return _mupdf.ll_pdf_tos_set_matrix(tos, a, b, c, d, e, f)

def ll_pdf_tos_translate(tos, tx, ty):
    r"""Low-level wrapper for `::pdf_tos_translate()`."""
    return _mupdf.ll_pdf_tos_translate(tos, tx, ty)

def ll_pdf_trailer(doc):
    r"""Low-level wrapper for `::pdf_trailer()`."""
    return _mupdf.ll_pdf_trailer(doc)

def ll_pdf_undo(doc):
    r"""Low-level wrapper for `::pdf_undo()`."""
    return _mupdf.ll_pdf_undo(doc)

def ll_pdf_undoredo_state(doc, steps):
    r"""
     Low-level wrapper for `::pdf_undoredo_state()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_undoredo_state(::pdf_document *doc)` => `(int, int steps)`
    """
    return _mupdf.ll_pdf_undoredo_state(doc, steps)

def ll_pdf_undoredo_step(doc, step):
    r"""Low-level wrapper for `::pdf_undoredo_step()`."""
    return _mupdf.ll_pdf_undoredo_step(doc, step)

def ll_pdf_unmark_obj(obj):
    r"""Low-level wrapper for `::pdf_unmark_obj()`."""
    return _mupdf.ll_pdf_unmark_obj(obj)

def ll_pdf_update_annot(annot):
    r"""Low-level wrapper for `::pdf_update_annot()`."""
    return _mupdf.ll_pdf_update_annot(annot)

def ll_pdf_update_default_colorspaces(old_cs, res):
    r"""Low-level wrapper for `::pdf_update_default_colorspaces()`."""
    return _mupdf.ll_pdf_update_default_colorspaces(old_cs, res)

def ll_pdf_update_object(doc, num, obj):
    r"""Low-level wrapper for `::pdf_update_object()`."""
    return _mupdf.ll_pdf_update_object(doc, num, obj)

def ll_pdf_update_page(page):
    r"""Low-level wrapper for `::pdf_update_page()`."""
    return _mupdf.ll_pdf_update_page(page)

def ll_pdf_update_stream(doc, ref, buf, compressed):
    r"""Low-level wrapper for `::pdf_update_stream()`."""
    return _mupdf.ll_pdf_update_stream(doc, ref, buf, compressed)

def ll_pdf_update_widget(widget):
    r"""Low-level wrapper for `::pdf_update_widget()`."""
    return _mupdf.ll_pdf_update_widget(widget)

def ll_pdf_update_xobject(doc, xobj, bbox, mat, res, buffer):
    r"""Low-level wrapper for `::pdf_update_xobject()`."""
    return _mupdf.ll_pdf_update_xobject(doc, xobj, bbox, mat, res, buffer)

def ll_pdf_validate_change_history(doc):
    r"""Low-level wrapper for `::pdf_validate_change_history()`."""
    return _mupdf.ll_pdf_validate_change_history(doc)

def ll_pdf_validate_changes(doc, version):
    r"""Low-level wrapper for `::pdf_validate_changes()`."""
    return _mupdf.ll_pdf_validate_changes(doc, version)

def ll_pdf_validate_signature(widget):
    r"""Low-level wrapper for `::pdf_validate_signature()`."""
    return _mupdf.ll_pdf_validate_signature(widget)

def ll_pdf_verify_embedded_file_checksum(fs):
    r"""Low-level wrapper for `::pdf_verify_embedded_file_checksum()`."""
    return _mupdf.ll_pdf_verify_embedded_file_checksum(fs)

def ll_pdf_version(doc):
    r"""Low-level wrapper for `::pdf_version()`."""
    return _mupdf.ll_pdf_version(doc)

def ll_pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values):
    r"""
     Low-level wrapper for `::pdf_walk_tree()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_walk_tree(::pdf_obj *tree, ::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
    """
    return _mupdf.ll_pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values)

def ll_pdf_was_pure_xfa(doc):
    r"""Low-level wrapper for `::pdf_was_pure_xfa()`."""
    return _mupdf.ll_pdf_was_pure_xfa(doc)

def ll_pdf_was_repaired(doc):
    r"""Low-level wrapper for `::pdf_was_repaired()`."""
    return _mupdf.ll_pdf_was_repaired(doc)

def ll_pdf_widget_is_readonly(widget):
    r"""Low-level wrapper for `::pdf_widget_is_readonly()`."""
    return _mupdf.ll_pdf_widget_is_readonly(widget)

def ll_pdf_widget_is_signed(widget):
    r"""Low-level wrapper for `::pdf_widget_is_signed()`."""
    return _mupdf.ll_pdf_widget_is_signed(widget)

def ll_pdf_widget_type(widget):
    r"""Low-level wrapper for `::pdf_widget_type()`."""
    return _mupdf.ll_pdf_widget_type(widget)

def ll_pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer):
    r"""Low-level wrapper for `::pdf_write_digest()`."""
    return _mupdf.ll_pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer)

def ll_pdf_write_document(doc, out, opts):
    r"""Low-level wrapper for `::pdf_write_document()`."""
    return _mupdf.ll_pdf_write_document(doc, out, opts)

def ll_pdf_write_journal(doc, out):
    r"""Low-level wrapper for `::pdf_write_journal()`."""
    return _mupdf.ll_pdf_write_journal(doc, out)

def ll_pdf_write_snapshot(doc, out):
    r"""Low-level wrapper for `::pdf_write_snapshot()`."""
    return _mupdf.ll_pdf_write_snapshot(doc, out)

def ll_pdf_xobject_bbox(xobj):
    r"""Low-level wrapper for `::pdf_xobject_bbox()`."""
    return _mupdf.ll_pdf_xobject_bbox(xobj)

def ll_pdf_xobject_colorspace(xobj):
    r"""Low-level wrapper for `::pdf_xobject_colorspace()`."""
    return _mupdf.ll_pdf_xobject_colorspace(xobj)

def ll_pdf_xobject_isolated(xobj):
    r"""Low-level wrapper for `::pdf_xobject_isolated()`."""
    return _mupdf.ll_pdf_xobject_isolated(xobj)

def ll_pdf_xobject_knockout(xobj):
    r"""Low-level wrapper for `::pdf_xobject_knockout()`."""
    return _mupdf.ll_pdf_xobject_knockout(xobj)

def ll_pdf_xobject_matrix(xobj):
    r"""Low-level wrapper for `::pdf_xobject_matrix()`."""
    return _mupdf.ll_pdf_xobject_matrix(xobj)

def ll_pdf_xobject_resources(xobj):
    r"""Low-level wrapper for `::pdf_xobject_resources()`."""
    return _mupdf.ll_pdf_xobject_resources(xobj)

def ll_pdf_xobject_transparency(xobj):
    r"""Low-level wrapper for `::pdf_xobject_transparency()`."""
    return _mupdf.ll_pdf_xobject_transparency(xobj)

def ll_pdf_xref_ensure_incremental_object(doc, num):
    r"""Low-level wrapper for `::pdf_xref_ensure_incremental_object()`."""
    return _mupdf.ll_pdf_xref_ensure_incremental_object(doc, num)

def ll_pdf_xref_ensure_local_object(doc, num):
    r"""Low-level wrapper for `::pdf_xref_ensure_local_object()`."""
    return _mupdf.ll_pdf_xref_ensure_local_object(doc, num)

def ll_pdf_xref_entry_map(doc, fn, arg):
    r"""Low-level wrapper for `::pdf_xref_entry_map()`."""
    return _mupdf.ll_pdf_xref_entry_map(doc, fn, arg)

def ll_pdf_xref_is_incremental(doc, num):
    r"""Low-level wrapper for `::pdf_xref_is_incremental()`."""
    return _mupdf.ll_pdf_xref_is_incremental(doc, num)

def ll_pdf_xref_len(doc):
    r"""Low-level wrapper for `::pdf_xref_len()`."""
    return _mupdf.ll_pdf_xref_len(doc)

def ll_pdf_xref_obj_is_unsaved_signature(doc, obj):
    r"""Low-level wrapper for `::pdf_xref_obj_is_unsaved_signature()`."""
    return _mupdf.ll_pdf_xref_obj_is_unsaved_signature(doc, obj)

def ll_pdf_xref_remove_unsaved_signature(doc, field):
    r"""Low-level wrapper for `::pdf_xref_remove_unsaved_signature()`."""
    return _mupdf.ll_pdf_xref_remove_unsaved_signature(doc, field)

def ll_pdf_xref_store_unsaved_signature(doc, field, signer):
    r"""Low-level wrapper for `::pdf_xref_store_unsaved_signature()`."""
    return _mupdf.ll_pdf_xref_store_unsaved_signature(doc, field, signer)

def ll_pdf_zugferd_profile(doc, version):
    r"""
     Low-level wrapper for `::pdf_zugferd_profile()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_zugferd_profile(::pdf_document *doc)` => `(enum pdf_zugferd_profile, float version)`
    """
    return _mupdf.ll_pdf_zugferd_profile(doc, version)

def ll_pdf_zugferd_profile_to_string(profile):
    r"""Low-level wrapper for `::pdf_zugferd_profile_to_string()`."""
    return _mupdf.ll_pdf_zugferd_profile_to_string(profile)

def ll_pdf_zugferd_xml(doc):
    r"""Low-level wrapper for `::pdf_zugferd_xml()`."""
    return _mupdf.ll_pdf_zugferd_xml(doc)

def to_string_fz_aa_context(s):
    r"""Returns string containing a fz_aa_context's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_aa_context(s)

def to_string_fz_color_params(s):
    r"""Returns string containing a fz_color_params's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_color_params(s)

def to_string_fz_cookie(s):
    r"""Returns string containing a fz_cookie's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_cookie(s)

def to_string_fz_draw_options(s):
    r"""Returns string containing a fz_draw_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_draw_options(s)

def to_string_fz_install_load_system_font_funcs_args(s):
    r"""Returns string containing a fz_install_load_system_font_funcs_args's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_install_load_system_font_funcs_args(s)

def to_string_fz_irect(s):
    r"""Returns string containing a fz_irect's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_irect(s)

def to_string_fz_location(s):
    r"""Returns string containing a fz_location's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_location(s)

def to_string_fz_matrix(s):
    r"""Returns string containing a fz_matrix's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_matrix(s)

def to_string_fz_md5(s):
    r"""Returns string containing a fz_md5's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_md5(s)

def to_string_fz_outline_item(s):
    r"""Returns string containing a fz_outline_item's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_outline_item(s)

def to_string_fz_pdfocr_options(s):
    r"""Returns string containing a fz_pdfocr_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_pdfocr_options(s)

def to_string_fz_point(s):
    r"""Returns string containing a fz_point's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_point(s)

def to_string_fz_pwg_options(s):
    r"""Returns string containing a fz_pwg_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_pwg_options(s)

def to_string_fz_quad(s):
    r"""Returns string containing a fz_quad's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_quad(s)

def to_string_fz_rect(s):
    r"""Returns string containing a fz_rect's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_rect(s)

def to_string_fz_stext_options(s):
    r"""Returns string containing a fz_stext_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_stext_options(s)

def to_string_fz_story_element_position(s):
    r"""Returns string containing a fz_story_element_position's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_story_element_position(s)

def to_string_fz_transition(s):
    r"""Returns string containing a fz_transition's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_transition(s)

def to_string_pdf_clean_options(s):
    r"""Returns string containing a pdf_clean_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_clean_options(s)

def to_string_pdf_filter_factory(s):
    r"""Returns string containing a pdf_filter_factory's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_filter_factory(s)

def to_string_pdf_filter_options(s):
    r"""Returns string containing a pdf_filter_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_filter_options(s)

def to_string_pdf_image_rewriter_options(s):
    r"""Returns string containing a pdf_image_rewriter_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_image_rewriter_options(s)

def to_string_pdf_layer_config(s):
    r"""Returns string containing a pdf_layer_config's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_layer_config(s)

def to_string_pdf_layer_config_ui(s):
    r"""Returns string containing a pdf_layer_config_ui's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_layer_config_ui(s)

def to_string_pdf_recolor_options(s):
    r"""Returns string containing a pdf_recolor_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_recolor_options(s)

def to_string_pdf_redact_options(s):
    r"""Returns string containing a pdf_redact_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_redact_options(s)

def to_string_pdf_sanitize_filter_options(s):
    r"""Returns string containing a pdf_sanitize_filter_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_sanitize_filter_options(s)

def to_string_pdf_write_options(s):
    r"""Returns string containing a pdf_write_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_write_options(s)

def to_string(*args):
    r"""
    *Overload 1:*
     Returns string containing a fz_aa_context's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 2:*
     Returns string containing a fz_color_params's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 3:*
     Returns string containing a fz_cookie's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 4:*
     Returns string containing a fz_draw_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 5:*
     Returns string containing a fz_install_load_system_font_funcs_args's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 6:*
     Returns string containing a fz_irect's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 7:*
     Returns string containing a fz_location's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 8:*
     Returns string containing a fz_matrix's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 9:*
     Returns string containing a fz_md5's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 10:*
     Returns string containing a fz_outline_item's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 11:*
     Returns string containing a fz_pdfocr_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 12:*
     Returns string containing a fz_point's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 13:*
     Returns string containing a fz_pwg_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 14:*
     Returns string containing a fz_quad's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 15:*
     Returns string containing a fz_rect's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 16:*
     Returns string containing a fz_stext_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 17:*
     Returns string containing a fz_story_element_position's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 18:*
     Returns string containing a fz_transition's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 19:*
     Returns string containing a pdf_clean_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 20:*
     Returns string containing a pdf_filter_factory's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 21:*
     Returns string containing a pdf_filter_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 22:*
     Returns string containing a pdf_image_rewriter_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 23:*
     Returns string containing a pdf_layer_config's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 24:*
     Returns string containing a pdf_layer_config_ui's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 25:*
     Returns string containing a pdf_recolor_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 26:*
     Returns string containing a pdf_redact_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 27:*
     Returns string containing a pdf_sanitize_filter_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 28:*
     Returns string containing a pdf_write_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).
    """
    return _mupdf.to_string(*args)

def reinit_singlethreaded():
    r"""
     Reinitializes the MuPDF context for single-threaded use, which
    is slightly faster when calling code is single threaded.

    This should be called before any other use of MuPDF.
    """
    return _mupdf.reinit_singlethreaded()
class FzAaContext(object):
    r"""Wrapper class for struct `fz_aa_context`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_aa_context`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_aa_context`.
        """
        _mupdf.FzAaContext_swiginit(self, _mupdf.new_FzAaContext(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzAaContext_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzAaContext
    hscale = property(_mupdf.FzAaContext_hscale_get, _mupdf.FzAaContext_hscale_set)
    vscale = property(_mupdf.FzAaContext_vscale_get, _mupdf.FzAaContext_vscale_set)
    scale = property(_mupdf.FzAaContext_scale_get, _mupdf.FzAaContext_scale_set)
    bits = property(_mupdf.FzAaContext_bits_get, _mupdf.FzAaContext_bits_set)
    text_bits = property(_mupdf.FzAaContext_text_bits_get, _mupdf.FzAaContext_text_bits_set)
    min_line_width = property(_mupdf.FzAaContext_min_line_width_get, _mupdf.FzAaContext_min_line_width_set)
    s_num_instances = property(_mupdf.FzAaContext_s_num_instances_get, _mupdf.FzAaContext_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzAaContext_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzAaContext___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzAaContext___ne__(self, rhs)

# Register FzAaContext in _mupdf:
_mupdf.FzAaContext_swigregister(FzAaContext)
metadata_keys = cvar.metadata_keys

class FzAes(object):
    r"""
    Wrapper class for struct `fz_aes`. Not copyable or assignable.
    Structure definitions are public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_aes_crypt_cbc(self, mode, length, iv, input, output):
        r"""
        Class-aware wrapper for `::fz_aes_crypt_cbc()`.
        	AES block processing. Encrypts or Decrypts (according to mode,
        	which must match what was initially set up) length bytes (which
        	must be a multiple of 16), using (and modifying) the insertion
        	vector iv, reading from input, and writing to output.

        	Never throws an exception.
        """
        return _mupdf.FzAes_fz_aes_crypt_cbc(self, mode, length, iv, input, output)

    def fz_aes_setkey_dec(self, key, keysize):
        r"""
        Class-aware wrapper for `::fz_aes_setkey_dec()`.
        	AES decryption intialisation. Fills in the supplied context
        	and prepares for decryption using the given key.

        	Returns non-zero for error (key size other than 128/192/256).

        	Never throws an exception.
        """
        return _mupdf.FzAes_fz_aes_setkey_dec(self, key, keysize)

    def fz_aes_setkey_enc(self, key, keysize):
        r"""
        Class-aware wrapper for `::fz_aes_setkey_enc()`.
        	AES encryption intialisation. Fills in the supplied context
        	and prepares for encryption using the given key.

        	Returns non-zero for error (key size other than 128/192/256).

        	Never throws an exception.
        """
        return _mupdf.FzAes_fz_aes_setkey_enc(self, key, keysize)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_aes`.
        """
        _mupdf.FzAes_swiginit(self, _mupdf.new_FzAes(*args))
    __swig_destroy__ = _mupdf.delete_FzAes

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzAes_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzAes___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzAes_m_internal_get, _mupdf.FzAes_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzAes_s_num_instances_get, _mupdf.FzAes_s_num_instances_set)

# Register FzAes in _mupdf:
_mupdf.FzAes_swigregister(FzAes)
class FzAllocContext(object):
    r"""
    Wrapper class for struct `fz_alloc_context`. Not copyable or assignable.
    Allocator structure; holds callbacks and private data pointer.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_alloc_context`.
        """
        _mupdf.FzAllocContext_swiginit(self, _mupdf.new_FzAllocContext(*args))
    __swig_destroy__ = _mupdf.delete_FzAllocContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzAllocContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzAllocContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzAllocContext_m_internal_get, _mupdf.FzAllocContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzAllocContext_s_num_instances_get, _mupdf.FzAllocContext_s_num_instances_set)

# Register FzAllocContext in _mupdf:
_mupdf.FzAllocContext_swigregister(FzAllocContext)
class FzArc4(object):
    r"""
    Wrapper class for struct `fz_arc4`. Not copyable or assignable.
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_arc4_encrypt(self, dest, src, len):
        r"""
        Class-aware wrapper for `::fz_arc4_encrypt()`.
        	RC4 block encrypt operation; encrypt src into dst (both of
        	length len) updating the RC4 state as we go.

        	Never throws an exception.
        """
        return _mupdf.FzArc4_fz_arc4_encrypt(self, dest, src, len)

    def fz_arc4_final(self):
        r"""
        Class-aware wrapper for `::fz_arc4_final()`.
        	RC4 finalization. Zero the context.

        	Never throws an exception.
        """
        return _mupdf.FzArc4_fz_arc4_final(self)

    def fz_arc4_init(self, key, len):
        r"""
        Class-aware wrapper for `::fz_arc4_init()`.
        	RC4 initialization. Begins an RC4 operation, writing a new
        	context.

        	Never throws an exception.
        """
        return _mupdf.FzArc4_fz_arc4_init(self, key, len)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_arc4`.
        """
        _mupdf.FzArc4_swiginit(self, _mupdf.new_FzArc4(*args))
    __swig_destroy__ = _mupdf.delete_FzArc4

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzArc4_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzArc4___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzArc4_m_internal_get, _mupdf.FzArc4_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzArc4_s_num_instances_get, _mupdf.FzArc4_s_num_instances_set)

# Register FzArc4 in _mupdf:
_mupdf.FzArc4_swigregister(FzArc4)
class FzArchive(object):
    r"""
    Wrapper class for struct `fz_archive`.
    fz_archive:

    fz_archive provides methods for accessing "archive" files.
    An archive file is a conceptual entity that contains multiple
    files, which can be counted, enumerated, and read.

    Implementations of fz_archive based upon directories, zip
    and tar files are included.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_archive_format(self):
        r"""
        Class-aware wrapper for `::fz_archive_format()`.
        	Return a pointer to a string describing the format of the
        	archive.

        	The lifetime of the string is unspecified (in current
        	implementations the string will persist until the archive
        	is closed, but this is not guaranteed).
        """
        return _mupdf.FzArchive_fz_archive_format(self)

    def fz_count_archive_entries(self):
        r"""
        Class-aware wrapper for `::fz_count_archive_entries()`.
        	Number of entries in archive.

        	Will always return a value >= 0.

        	May throw an exception if this type of archive cannot count the
        	entries (such as a directory).
        """
        return _mupdf.FzArchive_fz_count_archive_entries(self)

    def fz_has_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_has_archive_entry()`.
        	Check if entry by given name exists.

        	If named entry does not exist 0 will be returned, if it does
        	exist 1 is returned.

        	name: Entry name to look for, this must be an exact match to
        	the entry name in the archive.
        """
        return _mupdf.FzArchive_fz_has_archive_entry(self, name)

    def fz_list_archive_entry(self, idx):
        r"""
        Class-aware wrapper for `::fz_list_archive_entry()`.
        	Get listed name of entry position idx.

        	idx: Must be a value >= 0 < return value from
        	fz_count_archive_entries. If not in range NULL will be
        	returned.

        	May throw an exception if this type of archive cannot list the
        	entries (such as a directory).
        """
        return _mupdf.FzArchive_fz_list_archive_entry(self, idx)

    def fz_mount_multi_archive(self, sub, path):
        r"""
        Class-aware wrapper for `::fz_mount_multi_archive()`.
        	Add an archive to the set of archives handled by a multi
        	archive.

        	If path is NULL, then the archive contents will appear at the
        	top level, otherwise, the archives contents will appear prefixed
        	by path.
        """
        return _mupdf.FzArchive_fz_mount_multi_archive(self, sub, path)

    def fz_open_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_open_archive_entry()`.
        	Opens an archive entry as a stream.

        	name: Entry name to look for, this must be an exact match to
        	the entry name in the archive.

        	Throws an exception if a matching entry cannot be found.
        """
        return _mupdf.FzArchive_fz_open_archive_entry(self, name)

    def fz_parse_xml_archive_entry(self, filename, preserve_white):
        r"""
        Class-aware wrapper for `::fz_parse_xml_archive_entry()`.
        	Parse the contents of an archive entry into a tree of xml nodes.

        	preserve_white: whether to keep or delete all-whitespace nodes.
        """
        return _mupdf.FzArchive_fz_parse_xml_archive_entry(self, filename, preserve_white)

    def fz_read_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_read_archive_entry()`.
        	Reads all bytes in an archive entry
        	into a buffer.

        	name: Entry name to look for, this must be an exact match to
        	the entry name in the archive.

        	Throws an exception if a matching entry cannot be found.
        """
        return _mupdf.FzArchive_fz_read_archive_entry(self, name)

    def fz_tree_archive_add_buffer(self, name, buf):
        r"""
        Class-aware wrapper for `::fz_tree_archive_add_buffer()`.
        	Add a named buffer to an existing tree archive.

        	The tree will take a new reference to the buffer. Ownership
        	is not transferred.
        """
        return _mupdf.FzArchive_fz_tree_archive_add_buffer(self, name, buf)

    def fz_tree_archive_add_data(self, name, data, size):
        r"""
        Class-aware wrapper for `::fz_tree_archive_add_data()`.
        	Add a named block of data to an existing tree archive.

        	The data will be copied into a buffer, and so the caller
        	may free it as soon as this returns.
        """
        return _mupdf.FzArchive_fz_tree_archive_add_data(self, name, data, size)

    def fz_try_open_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_try_open_archive_entry()`.
        	Opens an archive entry as a stream.

        	Returns NULL if a matching entry cannot be found, otherwise
        	behaves exactly as fz_open_archive_entry.
        """
        return _mupdf.FzArchive_fz_try_open_archive_entry(self, name)

    def fz_try_parse_xml_archive_entry(self, filename, preserve_white):
        r"""
        Class-aware wrapper for `::fz_try_parse_xml_archive_entry()`.
        	Try and parse the contents of an archive entry into a tree of xml nodes.

        	preserve_white: whether to keep or delete all-whitespace nodes.

        	Will return NULL if the archive entry can't be found. Otherwise behaves
        	the same as fz_parse_xml_archive_entry. May throw exceptions.
        """
        return _mupdf.FzArchive_fz_try_parse_xml_archive_entry(self, filename, preserve_white)

    def fz_try_read_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_try_read_archive_entry()`.
        	Reads all bytes in an archive entry
        	into a buffer.

        	name: Entry name to look for, this must be an exact match to
        	the entry name in the archive.

        	Returns NULL if a matching entry cannot be found. Otherwise behaves
        	the same as fz_read_archive_entry. Exceptions may be thrown.
        """
        return _mupdf.FzArchive_fz_try_read_archive_entry(self, name)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_archive_of_size()`.

        |

        *Overload 2:*
         Constructor using `fz_new_multi_archive()`.
        		Create a new multi archive (initially empty).


        |

        *Overload 3:*
         Constructor using `fz_new_tree_archive()`.
        		Create an archive that holds named buffers.

        		tree can either be a preformed tree with fz_buffers as values,
        		or it can be NULL for an empty tree.


        |

        *Overload 4:*
         Copy constructor using `fz_keep_archive()`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_archive`.
        """
        _mupdf.FzArchive_swiginit(self, _mupdf.new_FzArchive(*args))
    __swig_destroy__ = _mupdf.delete_FzArchive

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzArchive_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzArchive___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzArchive_m_internal_get, _mupdf.FzArchive_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzArchive_s_num_instances_get, _mupdf.FzArchive_s_num_instances_set)

# Register FzArchive in _mupdf:
_mupdf.FzArchive_swigregister(FzArchive)
class FzArchiveHandler(object):
    r"""Wrapper class for struct `fz_archive_handler`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_register_archive_handler(self):
        r"""Class-aware wrapper for `::fz_register_archive_handler()`."""
        return _mupdf.FzArchiveHandler_fz_register_archive_handler(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_archive_handler`.
        """
        _mupdf.FzArchiveHandler_swiginit(self, _mupdf.new_FzArchiveHandler(*args))
    __swig_destroy__ = _mupdf.delete_FzArchiveHandler

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzArchiveHandler_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzArchiveHandler___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzArchiveHandler_m_internal_get, _mupdf.FzArchiveHandler_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzArchiveHandler_s_num_instances_get, _mupdf.FzArchiveHandler_s_num_instances_set)

# Register FzArchiveHandler in _mupdf:
_mupdf.FzArchiveHandler_swigregister(FzArchiveHandler)
class FzArchiveHandlerContext(object):
    r"""Wrapper class for struct `fz_archive_handler_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_archive_handler_context`.
        """
        _mupdf.FzArchiveHandlerContext_swiginit(self, _mupdf.new_FzArchiveHandlerContext(*args))
    __swig_destroy__ = _mupdf.delete_FzArchiveHandlerContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzArchiveHandlerContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzArchiveHandlerContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzArchiveHandlerContext_m_internal_get, _mupdf.FzArchiveHandlerContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzArchiveHandlerContext_s_num_instances_get, _mupdf.FzArchiveHandlerContext_s_num_instances_set)

# Register FzArchiveHandlerContext in _mupdf:
_mupdf.FzArchiveHandlerContext_swigregister(FzArchiveHandlerContext)
class FzBandWriter(object):
    r"""
    Wrapper class for struct `fz_band_writer`. Not copyable or assignable.
    fz_band_writer
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MONO = _mupdf.FzBandWriter_MONO
    COLOR = _mupdf.FzBandWriter_COLOR
    PNG = _mupdf.FzBandWriter_PNG
    PNM = _mupdf.FzBandWriter_PNM
    PAM = _mupdf.FzBandWriter_PAM
    PBM = _mupdf.FzBandWriter_PBM
    PKM = _mupdf.FzBandWriter_PKM
    PS = _mupdf.FzBandWriter_PS
    PSD = _mupdf.FzBandWriter_PSD

    def fz_close_band_writer(self):
        r"""
        Class-aware wrapper for `::fz_close_band_writer()`.
        	Finishes up the output and closes the band writer. After this
        	call no more headers or bands may be written.
        """
        return _mupdf.FzBandWriter_fz_close_band_writer(self)

    def fz_pdfocr_band_writer_set_progress(self, progress_fn, progress_arg):
        r"""
        Class-aware wrapper for `::fz_pdfocr_band_writer_set_progress()`.
        	Set the progress callback for a pdfocr bandwriter.
        """
        return _mupdf.FzBandWriter_fz_pdfocr_band_writer_set_progress(self, progress_fn, progress_arg)

    def fz_write_band(self, stride, band_height, samples):
        r"""
        Class-aware wrapper for `::fz_write_band()`.
        	Cause a band writer to write the next band
        	of data for an image.

        	stride: The byte offset from the first byte of the data
        	for a pixel to the first byte of the data for the same pixel
        	on the row below.

        	band_height: The number of lines in this band.

        	samples: Pointer to first byte of the data.
        """
        return _mupdf.FzBandWriter_fz_write_band(self, stride, band_height, samples)

    def fz_write_header(self, w, h, n, alpha, xres, yres, pagenum, cs, seps):
        r"""
        Class-aware wrapper for `::fz_write_header()`.
        	Cause a band writer to write the header for
        	a banded image with the given properties/dimensions etc. This
        	also configures the bandwriter for the format of the data to be
        	passed in future calls.

        	w, h: Width and Height of the entire page.

        	n: Number of components (including spots and alphas).

        	alpha: Number of alpha components.

        	xres, yres: X and Y resolutions in dpi.

        	cs: Colorspace (NULL for bitmaps)

        	seps: Separation details (or NULL).
        """
        return _mupdf.FzBandWriter_fz_write_header(self, w, h, n, alpha, xres, yres, pagenum, cs, seps)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_band_writer_of_size()`.

        |

        *Overload 2:*
         Constructor using `fz_new_color_pcl_band_writer()`.
        		Create a new band writer, outputing color pcl.
        	 Constructor using `fz_new_mono_pcl_band_writer()`.
        		Create a new band writer, outputing monochrome pcl.


        |

        *Overload 3:*
         Constructor using `fz_new_mono_pwg_band_writer()`.
        		Create a new monochrome pwg band writer.


        |

        *Overload 4:*
         Constructor using `fz_new_pam_band_writer()`.
        		Create a band writer targetting pnm (greyscale, rgb or cmyk,
        		with or without alpha).
        	 Constructor using `fz_new_pbm_band_writer()`.
        		Create a new band writer, targetting pbm.
        	 Constructor using `fz_new_pclm_band_writer()`.
        		Create a new band writer, outputing pclm


        |

        *Overload 5:*
         Constructor using `fz_new_pdfocr_band_writer()`.
        		Create a new band writer, outputing pdfocr.

        		Ownership of output stays with the caller, the band writer
        		borrows the reference. The caller must keep the output around
        		for the duration of the band writer, and then close/drop as
        		appropriate.


        |

        *Overload 6:*
         Constructor using `fz_new_pkm_band_writer()`.
        		Create a new pkm band writer for CMYK pixmaps.
        	 Constructor using `fz_new_png_band_writer()`.
        		Create a new png band writer (greyscale or RGB, with or without
        		alpha).


        |

        *Overload 7:*
         Constructor using `fz_new_pnm_band_writer()`.
        		Create a band writer targetting pnm (greyscale or rgb, no
        		alpha).
        	 Constructor using `fz_new_ps_band_writer()`.
        		Create a postscript band writer for gray, rgb, or cmyk, no
        		alpha.
        	 Constructor using `fz_new_psd_band_writer()`.
        		Open a PSD band writer.
        	 Constructor using `fz_new_pwg_band_writer()`.
        		Create a new color pwg band writer.
        	 Constructor using fz_new_mono_pcl_band_writer() or fz_new_color_pcl_band_writer().

        |

        *Overload 8:*
         Constructor using fz_new_p*_band_writer().

        |

        *Overload 9:*
         Constructor using fz_new_mono_pwg_band_writer() or fz_new_pwg_band_writer().

        |

        *Overload 10:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 11:*
         Constructor using raw copy of pre-existing `::fz_band_writer`.
        """
        _mupdf.FzBandWriter_swiginit(self, _mupdf.new_FzBandWriter(*args))
    __swig_destroy__ = _mupdf.delete_FzBandWriter

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzBandWriter_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzBandWriter___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzBandWriter_m_internal_get, _mupdf.FzBandWriter_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzBandWriter_s_num_instances_get, _mupdf.FzBandWriter_s_num_instances_set)

# Register FzBandWriter in _mupdf:
_mupdf.FzBandWriter_swigregister(FzBandWriter)
class FzBitmap(object):
    r"""
    Wrapper class for struct `fz_bitmap`.
    Bitmaps have 1 bit per component. Only used for creating
    halftoned versions of contone buffers, and saving out. Samples
    are stored msb first, akin to pbms.

    The internals of this struct are considered implementation
    details and subject to change. Where possible, accessor
    functions should be used in preference.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bitmap_details(self, w, h, n, stride):
        r"""
        Class-aware wrapper for `::fz_bitmap_details()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_bitmap_details()` => `(int w, int h, int n, int stride)`

        	Retrieve details of a given bitmap.

        	bitmap: The bitmap to query.

        	w: Pointer to storage to retrieve width (or NULL).

        	h: Pointer to storage to retrieve height (or NULL).

        	n: Pointer to storage to retrieve number of color components (or
        	NULL).

        	stride: Pointer to storage to retrieve bitmap stride (or NULL).
        """
        return _mupdf.FzBitmap_fz_bitmap_details(self, w, h, n, stride)

    def fz_clear_bitmap(self):
        r"""
        Class-aware wrapper for `::fz_clear_bitmap()`.
        	Set the entire bitmap to 0.

        	Never throws exceptions.
        """
        return _mupdf.FzBitmap_fz_clear_bitmap(self)

    def fz_invert_bitmap(self):
        r"""
        Class-aware wrapper for `::fz_invert_bitmap()`.
        	Invert bitmap.

        	Never throws exceptions.
        """
        return _mupdf.FzBitmap_fz_invert_bitmap(self)

    def fz_save_bitmap_as_pbm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_bitmap_as_pbm()`.
        	Save a bitmap as a pbm.
        """
        return _mupdf.FzBitmap_fz_save_bitmap_as_pbm(self, filename)

    def fz_save_bitmap_as_pcl(self, filename, append, pcl):
        r"""
        Class-aware wrapper for `::fz_save_bitmap_as_pcl()`.
        	Save a bitmap as mono PCL.
        """
        return _mupdf.FzBitmap_fz_save_bitmap_as_pcl(self, filename, append, pcl)

    def fz_save_bitmap_as_pkm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_bitmap_as_pkm()`.
        	Save a CMYK bitmap as a pkm.
        """
        return _mupdf.FzBitmap_fz_save_bitmap_as_pkm(self, filename)

    def fz_save_bitmap_as_pwg(self, filename, append, pwg):
        r"""
        Class-aware wrapper for `::fz_save_bitmap_as_pwg()`.
        	Save a bitmap as a PWG.
        """
        return _mupdf.FzBitmap_fz_save_bitmap_as_pwg(self, filename, append, pwg)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_bitmap()`.
        		Create a new bitmap.

        		w, h: Width and Height for the bitmap

        		n: Number of color components (assumed to be a divisor of 8)

        		xres, yres: X and Y resolutions (in pixels per inch).

        		Returns pointer to created bitmap structure. The bitmap
        		data is uninitialised.


        |

        *Overload 2:*
         Constructor using `fz_new_bitmap_from_pixmap()`.
        		Make a bitmap from a pixmap and a halftone.

        		pix: The pixmap to generate from. Currently must be a single
        		color component with no alpha.

        		ht: The halftone to use. NULL implies the default halftone.

        		Returns the resultant bitmap. Throws exceptions in the case of
        		failure to allocate.


        |

        *Overload 3:*
         Constructor using `fz_new_bitmap_from_pixmap_band()`.
        		Make a bitmap from a pixmap and a
        		halftone, allowing for the position of the pixmap within an
        		overall banded rendering.

        		pix: The pixmap to generate from. Currently must be a single
        		color component with no alpha.

        		ht: The halftone to use. NULL implies the default halftone.

        		band_start: Vertical offset within the overall banded rendering
        		(in pixels)

        		Returns the resultant bitmap. Throws exceptions in the case of
        		failure to allocate.


        |

        *Overload 4:*
         Copy constructor using `fz_keep_bitmap()`.

        |

        *Overload 5:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 6:*
         Constructor using raw copy of pre-existing `::fz_bitmap`.
        """
        _mupdf.FzBitmap_swiginit(self, _mupdf.new_FzBitmap(*args))

    def refs(self):
        return _mupdf.FzBitmap_refs(self)

    def w(self):
        return _mupdf.FzBitmap_w(self)

    def h(self):
        return _mupdf.FzBitmap_h(self)

    def stride(self):
        return _mupdf.FzBitmap_stride(self)

    def n(self):
        return _mupdf.FzBitmap_n(self)

    def xres(self):
        return _mupdf.FzBitmap_xres(self)

    def yres(self):
        return _mupdf.FzBitmap_yres(self)

    def samples(self):
        return _mupdf.FzBitmap_samples(self)
    __swig_destroy__ = _mupdf.delete_FzBitmap

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzBitmap_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzBitmap___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzBitmap_m_internal_get, _mupdf.FzBitmap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzBitmap_s_num_instances_get, _mupdf.FzBitmap_s_num_instances_set)

# Register FzBitmap in _mupdf:
_mupdf.FzBitmap_swigregister(FzBitmap)
class FzBuffer(object):
    r"""
    Wrapper class for struct `fz_buffer`.
    fz_buffer is a wrapper around a dynamically allocated array of
    bytes.

    Buffers have a capacity (the number of bytes storage immediately
    available) and a current size.

    The contents of the structure are considered implementation
    details and are subject to change. Users should use the accessor
    functions in preference.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_new_buffer_from_copied_data(data, size):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_copied_data()`.
        	Create a new buffer containing a copy of the passed data.
        """
        return _mupdf.FzBuffer_fz_new_buffer_from_copied_data(data, size)

    @staticmethod
    def fz_new_buffer_from_image_as_pnm(image, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_image_as_pnm(image, color_params)

    @staticmethod
    def fz_new_buffer_from_image_as_pam(image, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_image_as_pam(image, color_params)

    @staticmethod
    def fz_new_buffer_from_image_as_psd(image, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_image_as_psd(image, color_params)

    @staticmethod
    def fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params)

    @staticmethod
    def fz_new_buffer_from_pixmap_as_pam(pixmap, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_pam(pixmap, color_params)

    @staticmethod
    def fz_new_buffer_from_pixmap_as_psd(pix, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_psd(pix, color_params)

    def fz_append_base64(self, data, size, newline):
        r"""
        Class-aware wrapper for `::fz_append_base64()`.
        	Write a base64 encoded data block, optionally with periodic newlines.
        """
        return _mupdf.FzBuffer_fz_append_base64(self, data, size, newline)

    def fz_append_base64_buffer(self, data, newline):
        r"""
        Class-aware wrapper for `::fz_append_base64_buffer()`.
        	Append a base64 encoded fz_buffer, optionally with periodic newlines.
        """
        return _mupdf.FzBuffer_fz_append_base64_buffer(self, data, newline)

    def fz_append_bits(self, value, count):
        r"""Class-aware wrapper for `::fz_append_bits()`."""
        return _mupdf.FzBuffer_fz_append_bits(self, value, count)

    def fz_append_bits_pad(self):
        r"""Class-aware wrapper for `::fz_append_bits_pad()`."""
        return _mupdf.FzBuffer_fz_append_bits_pad(self)

    def fz_append_buffer(self, source):
        r"""
        Class-aware wrapper for `::fz_append_buffer()`.
        	Append the contents of the source buffer onto the end of the
        	destination buffer, extending automatically as required.

        	Ownership of buffers does not change.
        """
        return _mupdf.FzBuffer_fz_append_buffer(self, source)

    def fz_append_byte(self, c):
        r"""Class-aware wrapper for `::fz_append_byte()`."""
        return _mupdf.FzBuffer_fz_append_byte(self, c)

    def fz_append_data(self, data, len):
        r"""
        Class-aware wrapper for `::fz_append_data()`.
        	fz_append_*: Append data to a buffer.

        	The buffer will automatically grow as required.
        """
        return _mupdf.FzBuffer_fz_append_data(self, data, len)

    def fz_append_image_as_data_uri(self, image):
        r"""Class-aware wrapper for `::fz_append_image_as_data_uri()`."""
        return _mupdf.FzBuffer_fz_append_image_as_data_uri(self, image)

    def fz_append_int16_be(self, x):
        r"""Class-aware wrapper for `::fz_append_int16_be()`."""
        return _mupdf.FzBuffer_fz_append_int16_be(self, x)

    def fz_append_int16_le(self, x):
        r"""Class-aware wrapper for `::fz_append_int16_le()`."""
        return _mupdf.FzBuffer_fz_append_int16_le(self, x)

    def fz_append_int32_be(self, x):
        r"""Class-aware wrapper for `::fz_append_int32_be()`."""
        return _mupdf.FzBuffer_fz_append_int32_be(self, x)

    def fz_append_int32_le(self, x):
        r"""Class-aware wrapper for `::fz_append_int32_le()`."""
        return _mupdf.FzBuffer_fz_append_int32_le(self, x)

    def fz_append_pdf_string(self, text):
        r"""
        Class-aware wrapper for `::fz_append_pdf_string()`.
        	fz_append_pdf_string: Append a string with PDF syntax quotes and
        	escapes.

        	The buffer will automatically grow as required.
        """
        return _mupdf.FzBuffer_fz_append_pdf_string(self, text)

    def fz_append_pixmap_as_data_uri(self, pixmap):
        r"""Class-aware wrapper for `::fz_append_pixmap_as_data_uri()`."""
        return _mupdf.FzBuffer_fz_append_pixmap_as_data_uri(self, pixmap)

    def fz_append_rune(self, c):
        r"""Class-aware wrapper for `::fz_append_rune()`."""
        return _mupdf.FzBuffer_fz_append_rune(self, c)

    def fz_append_string(self, data):
        r"""Class-aware wrapper for `::fz_append_string()`."""
        return _mupdf.FzBuffer_fz_append_string(self, data)

    def fz_buffer_extract(self, data):
        r"""
        Class-aware wrapper for `::fz_buffer_extract()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_buffer_extract()` => `(size_t, unsigned char *data)`

        	Take ownership of buffer contents.

        	Performs the same task as fz_buffer_storage, but ownership of
        	the data buffer returns with this call. The buffer is left
        	empty.

        	Note: Bad things may happen if this is called on a buffer with
        	multiple references that is being used from multiple threads.

        	data: Pointer to place to retrieve data pointer.

        	Returns length of stream.
        """
        return _mupdf.FzBuffer_fz_buffer_extract(self, data)

    def fz_buffer_storage(self, datap):
        r"""
        Class-aware wrapper for `::fz_buffer_storage()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_buffer_storage()` => `(size_t, unsigned char *datap)`

        	Retrieve internal memory of buffer.

        	datap: Output parameter that will be pointed to the data.

        	Returns the current size of the data in bytes.
        """
        return _mupdf.FzBuffer_fz_buffer_storage(self, datap)

    def fz_clear_buffer(self):
        r"""
        Class-aware wrapper for `::fz_clear_buffer()`.
        	Empties the buffer. Storage is not freed, but is held ready
        	to be reused as the buffer is refilled.

        	Never throws exceptions.
        """
        return _mupdf.FzBuffer_fz_clear_buffer(self)

    def fz_clone_buffer(self):
        r"""
        Class-aware wrapper for `::fz_clone_buffer()`.
        	Make a new buffer, containing a copy of the data used in
        	the original.
        """
        return _mupdf.FzBuffer_fz_clone_buffer(self)

    def fz_grow_buffer(self):
        r"""
        Class-aware wrapper for `::fz_grow_buffer()`.
        	Make some space within a buffer (i.e. ensure that
        	capacity > size).
        """
        return _mupdf.FzBuffer_fz_grow_buffer(self)

    def fz_load_jbig2_globals(self):
        r"""
        Class-aware wrapper for `::fz_load_jbig2_globals()`.
        	Create a jbig2 globals record from a buffer.

        	Immutable once created.
        """
        return _mupdf.FzBuffer_fz_load_jbig2_globals(self)

    def fz_md5_buffer(self, digest):
        r"""
        Class-aware wrapper for `::fz_md5_buffer()`.
        	Create an MD5 digest from buffer contents.

        	Never throws exceptions.
        """
        return _mupdf.FzBuffer_fz_md5_buffer(self, digest)

    def fz_new_display_list_from_svg(self, base_uri, dir, w, h):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_svg()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_new_display_list_from_svg(const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

        	Parse an SVG document into a display-list.
        """
        return _mupdf.FzBuffer_fz_new_display_list_from_svg(self, base_uri, dir, w, h)

    def fz_new_image_from_buffer(self):
        r"""
        Class-aware wrapper for `::fz_new_image_from_buffer()`.
        	Create a new image from a
        	buffer of data, inferring its type from the format
        	of the data.
        """
        return _mupdf.FzBuffer_fz_new_image_from_buffer(self)

    def fz_new_image_from_svg(self, base_uri, dir):
        r"""
        Class-aware wrapper for `::fz_new_image_from_svg()`.
        	Create a scalable image from an SVG document.
        """
        return _mupdf.FzBuffer_fz_new_image_from_svg(self, base_uri, dir)

    def fz_open_buffer(self):
        r"""
        Class-aware wrapper for `::fz_open_buffer()`.
        	Open a buffer as a stream.

        	buf: The buffer to open. Ownership of the buffer is NOT passed
        	in (this function takes its own reference).

        	Returns pointer to newly created stream. May throw exceptions on
        	failure to allocate.
        """
        return _mupdf.FzBuffer_fz_open_buffer(self)

    def fz_parse_xml(self, preserve_white):
        r"""
        Class-aware wrapper for `::fz_parse_xml()`.
        	Parse the contents of buffer into a tree of xml nodes.

        	preserve_white: whether to keep or delete all-whitespace nodes.
        """
        return _mupdf.FzBuffer_fz_parse_xml(self, preserve_white)

    def fz_parse_xml_from_html5(self):
        r"""
        Class-aware wrapper for `::fz_parse_xml_from_html5()`.
        	Parse the contents of a buffer into a tree of XML nodes,
        	using the HTML5 parsing algorithm.
        """
        return _mupdf.FzBuffer_fz_parse_xml_from_html5(self)

    def fz_resize_buffer(self, capacity):
        r"""
        Class-aware wrapper for `::fz_resize_buffer()`.
        	Ensure that a buffer has a given capacity,
        	truncating data if required.

        	capacity: The desired capacity for the buffer. If the current
        	size of the buffer contents is smaller than capacity, it is
        	truncated.
        """
        return _mupdf.FzBuffer_fz_resize_buffer(self, capacity)

    def fz_save_buffer(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_buffer()`.
        	Save the contents of a buffer to a file.
        """
        return _mupdf.FzBuffer_fz_save_buffer(self, filename)

    def fz_slice_buffer(self, start, end):
        r"""
        Class-aware wrapper for `::fz_slice_buffer()`.
        	Create a new buffer with a (subset of) the data from the buffer.

        	start: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

        	end: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

        """
        return _mupdf.FzBuffer_fz_slice_buffer(self, start, end)

    def fz_string_from_buffer(self):
        r"""
        Class-aware wrapper for `::fz_string_from_buffer()`.
        	Ensure that a buffer's data ends in a
        	0 byte, and return a pointer to it.
        """
        return _mupdf.FzBuffer_fz_string_from_buffer(self)

    def fz_subset_cff_for_gids(self, gids, num_gids, symbolic, cidfont):
        r"""
        Class-aware wrapper for `::fz_subset_cff_for_gids()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_subset_cff_for_gids(int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
        """
        return _mupdf.FzBuffer_fz_subset_cff_for_gids(self, gids, num_gids, symbolic, cidfont)

    def fz_subset_ttf_for_gids(self, gids, num_gids, symbolic, cidfont):
        r"""
        Class-aware wrapper for `::fz_subset_ttf_for_gids()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_subset_ttf_for_gids(int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
        """
        return _mupdf.FzBuffer_fz_subset_ttf_for_gids(self, gids, num_gids, symbolic, cidfont)

    def fz_terminate_buffer(self):
        r"""
        Class-aware wrapper for `::fz_terminate_buffer()`.
        	Zero-terminate buffer in order to use as a C string.

        	This byte is invisible and does not affect the length of the
        	buffer as returned by fz_buffer_storage. The zero byte is
        	written *after* the data, and subsequent writes will overwrite
        	the terminating byte.

        	Subsequent changes to the size of the buffer (such as by
        	fz_buffer_trim, fz_buffer_grow, fz_resize_buffer, etc) may
        	invalidate this.
        """
        return _mupdf.FzBuffer_fz_terminate_buffer(self)

    def fz_trim_buffer(self):
        r"""
        Class-aware wrapper for `::fz_trim_buffer()`.
        	Trim wasted capacity from a buffer by resizing internal memory.
        """
        return _mupdf.FzBuffer_fz_trim_buffer(self)

    def pdf_append_token(self, tok, lex):
        r"""Class-aware wrapper for `::pdf_append_token()`."""
        return _mupdf.FzBuffer_pdf_append_token(self, tok, lex)

    def pdf_new_buffer_processor(self, ahxencode, newlines):
        r"""Class-aware wrapper for `::pdf_new_buffer_processor()`."""
        return _mupdf.FzBuffer_pdf_new_buffer_processor(self, ahxencode, newlines)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_buffer()`.

        |

        *Overload 2:*
         Constructor using `fz_new_buffer_from_base64()`.
        		Create a new buffer with data decoded from a base64 input string.


        |

        *Overload 3:*
         Constructor using `fz_new_buffer_from_data()`.
        		Create a new buffer with existing data.

        		data: Pointer to existing data.
        		size: Size of existing data.

        		Takes ownership of data. Does not make a copy. Calls fz_free on
        		the data when the buffer is deallocated. Do not use 'data' after
        		passing to this function.

        		Returns pointer to new buffer. Throws exception on allocation
        		failure.


        |

        *Overload 4:*
         Constructor using `fz_new_buffer_from_display_list()`.

        |

        *Overload 5:*
         Constructor using `fz_new_buffer_from_image_as_jpeg()`.

        |

        *Overload 6:*
         Constructor using `fz_new_buffer_from_image_as_jpx()`.

        |

        *Overload 7:*
         Constructor using `fz_new_buffer_from_image_as_png()`.
        		Reencode a given image as a PNG into a buffer.

        		Ownership of the buffer is returned.


        |

        *Overload 8:*
         Constructor using `fz_new_buffer_from_page()`.

        |

        *Overload 9:*
         Constructor using `fz_new_buffer_from_page_number()`.

        |

        *Overload 10:*
         Constructor using `fz_new_buffer_from_page_with_format()`.
        		Returns an fz_buffer containing a page after conversion to specified format.

        		page: The page to convert.
        		format, options: Passed to fz_new_document_writer_with_output() internally.
        		transform, cookie: Passed to fz_run_page() internally.


        |

        *Overload 11:*
         Constructor using `fz_new_buffer_from_pixmap_as_jpeg()`.

        |

        *Overload 12:*
         Constructor using `fz_new_buffer_from_pixmap_as_jpx()`.

        |

        *Overload 13:*
         Constructor using `fz_new_buffer_from_pixmap_as_png()`.
        		Reencode a given pixmap as a PNG into a buffer.

        		Ownership of the buffer is returned.


        |

        *Overload 14:*
         Constructor using `fz_new_buffer_from_shared_data()`.
        		Like fz_new_buffer, but does not take ownership.


        |

        *Overload 15:*
         Constructor using `fz_new_buffer_from_stext_page()`.
        		Convert structured text into plain text.


        |

        *Overload 16:*
         Constructor using `fz_read_file()`.
        		Read all the contents of a file into a buffer.


        |

        *Overload 17:*
         Copy constructor using `fz_keep_buffer()`.

        |

        *Overload 18:*
         Constructor using raw copy of pre-existing `::fz_buffer`.

        |

        *Overload 19:*
         Constructor using raw copy of pre-existing `::fz_buffer`.
        """
        _mupdf.FzBuffer_swiginit(self, _mupdf.new_FzBuffer(*args))
    __swig_destroy__ = _mupdf.delete_FzBuffer

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzBuffer_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzBuffer___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzBuffer_m_internal_get, _mupdf.FzBuffer_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzBuffer_s_num_instances_get, _mupdf.FzBuffer_s_num_instances_set)

# Register FzBuffer in _mupdf:
_mupdf.FzBuffer_swigregister(FzBuffer)
class FzColorParams(object):
    r"""Wrapper class for struct `fz_color_params`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Equivalent to fz_default_color_params.

        |

        *Overload 2:*
        We use default copy constructor and operator=.  Constructor using raw copy of pre-existing `::fz_color_params`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_color_params`.
        """
        _mupdf.FzColorParams_swiginit(self, _mupdf.new_FzColorParams(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzColorParams_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzColorParams
    ri = property(_mupdf.FzColorParams_ri_get, _mupdf.FzColorParams_ri_set)
    bp = property(_mupdf.FzColorParams_bp_get, _mupdf.FzColorParams_bp_set)
    op = property(_mupdf.FzColorParams_op_get, _mupdf.FzColorParams_op_set)
    opm = property(_mupdf.FzColorParams_opm_get, _mupdf.FzColorParams_opm_set)
    s_num_instances = property(_mupdf.FzColorParams_s_num_instances_get, _mupdf.FzColorParams_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzColorParams_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzColorParams___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzColorParams___ne__(self, rhs)

# Register FzColorParams in _mupdf:
_mupdf.FzColorParams_swigregister(FzColorParams)
class FzColorspace(object):
    r"""
    Wrapper class for struct `fz_colorspace`.
    Describes a given colorspace.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Fixed_GRAY = _mupdf.FzColorspace_Fixed_GRAY
    Fixed_RGB = _mupdf.FzColorspace_Fixed_RGB
    Fixed_BGR = _mupdf.FzColorspace_Fixed_BGR
    Fixed_CMYK = _mupdf.FzColorspace_Fixed_CMYK
    Fixed_LAB = _mupdf.FzColorspace_Fixed_LAB

    def fz_base_colorspace(self):
        r"""
        Class-aware wrapper for `::fz_base_colorspace()`.
        	Get the 'base' colorspace for a colorspace.

        	For indexed colorspaces, this is the colorspace the index
        	decodes into. For all other colorspaces, it is the colorspace
        	itself.

        	The returned colorspace is 'borrowed' (i.e. no additional
        	references are taken or dropped).
        """
        return _mupdf.FzColorspace_fz_base_colorspace(self)

    def fz_clamp_color(self, _in, out):
        r"""
        Class-aware wrapper for `::fz_clamp_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_clamp_color(const float *in)` => float out

        	Clamp the samples in a color to the correct ranges for a
        	given colorspace.
        """
        return _mupdf.FzColorspace_fz_clamp_color(self, _in, out)

    def fz_colorspace_colorant(self, n):
        r"""
        Class-aware wrapper for `::fz_colorspace_colorant()`.
        	Retrieve a the name for a colorant.

        	Returns a pointer with the same lifespan as the colorspace.
        """
        return _mupdf.FzColorspace_fz_colorspace_colorant(self, n)

    def fz_colorspace_device_n_has_cmyk(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_device_n_has_cmyk()`.
        	True if DeviceN color space has cyan magenta yellow or black as
        	one of its colorants.
        """
        return _mupdf.FzColorspace_fz_colorspace_device_n_has_cmyk(self)

    def fz_colorspace_device_n_has_only_cmyk(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.
        	True if DeviceN color space has only colorants from the CMYK set.
        """
        return _mupdf.FzColorspace_fz_colorspace_device_n_has_only_cmyk(self)

    def fz_colorspace_is_cmyk(self):
        r"""Class-aware wrapper for `::fz_colorspace_is_cmyk()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_cmyk(self)

    def fz_colorspace_is_device(self):
        r"""Class-aware wrapper for `::fz_colorspace_is_device()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_device(self)

    def fz_colorspace_is_device_cmyk(self):
        r"""Class-aware wrapper for `::fz_colorspace_is_device_cmyk()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_device_cmyk(self)

    def fz_colorspace_is_device_gray(self):
        r"""Class-aware wrapper for `::fz_colorspace_is_device_gray()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_device_gray(self)

    def fz_colorspace_is_device_n(self):
        r"""Class-aware wrapper for `::fz_colorspace_is_device_n()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_device_n(self)

    def fz_colorspace_is_gray(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_is_gray()`.
        	Tests for particular types of colorspaces
        """
        return _mupdf.FzColorspace_fz_colorspace_is_gray(self)

    def fz_colorspace_is_indexed(self):
        r"""Class-aware wrapper for `::fz_colorspace_is_indexed()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_indexed(self)

    def fz_colorspace_is_lab(self):
        r"""Class-aware wrapper for `::fz_colorspace_is_lab()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_lab(self)

    def fz_colorspace_is_lab_icc(self):
        r"""Class-aware wrapper for `::fz_colorspace_is_lab_icc()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_lab_icc(self)

    def fz_colorspace_is_rgb(self):
        r"""Class-aware wrapper for `::fz_colorspace_is_rgb()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_rgb(self)

    def fz_colorspace_is_subtractive(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_is_subtractive()`.
        	True for CMYK, Separation and DeviceN colorspaces.
        """
        return _mupdf.FzColorspace_fz_colorspace_is_subtractive(self)

    def fz_colorspace_n(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_n()`.
        	Query the number of colorants in a colorspace.
        """
        return _mupdf.FzColorspace_fz_colorspace_n(self)

    def fz_colorspace_name(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_name()`.
        	Query the name of a colorspace.

        	The returned string has the same lifespan as the colorspace
        	does. Caller should not free it.
        """
        return _mupdf.FzColorspace_fz_colorspace_name(self)

    def fz_colorspace_name_colorant(self, n, name):
        r"""
        Class-aware wrapper for `::fz_colorspace_name_colorant()`.
        	Assign a name for a given colorant in a colorspace.

        	Used while initially setting up a colorspace. The string is
        	copied into local storage, so need not be retained by the
        	caller.
        """
        return _mupdf.FzColorspace_fz_colorspace_name_colorant(self, n, name)

    def fz_colorspace_type(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_type()`.
        	Query the type of colorspace.
        """
        return _mupdf.FzColorspace_fz_colorspace_type(self)

    def fz_convert_color(self, sv, ds, dv, _is, params):
        r"""
        Class-aware wrapper for `::fz_convert_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_convert_color(const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv

        	Convert color values sv from colorspace ss into colorvalues dv
        	for colorspace ds, via an optional intervening space is,
        	respecting the given color_params.
        """
        return _mupdf.FzColorspace_fz_convert_color(self, sv, ds, dv, _is, params)

    def fz_convert_separation_colors(self, src_color, dst_seps, dst_cs, dst_color, color_params):
        r"""
        Class-aware wrapper for `::fz_convert_separation_colors()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_convert_separation_colors(const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color

        	Convert a color given in terms of one colorspace,
        	to a color in terms of another colorspace/separations.
        """
        return _mupdf.FzColorspace_fz_convert_separation_colors(self, src_color, dst_seps, dst_cs, dst_color, color_params)

    def fz_is_valid_blend_colorspace(self):
        r"""
        Class-aware wrapper for `::fz_is_valid_blend_colorspace()`.
        	Check to see that a colorspace is appropriate to be used as
        	a blending space (i.e. only grey, rgb or cmyk).
        """
        return _mupdf.FzColorspace_fz_is_valid_blend_colorspace(self)

    def fz_new_indexed_colorspace(self, high, lookup):
        r"""
        Class-aware wrapper for `::fz_new_indexed_colorspace()`.
        	Create an indexed colorspace.

        	The supplied lookup table is high palette entries long. Each
        	entry is n bytes long, where n is given by the number of
        	colorants in the base colorspace, one byte per colorant.

        	Ownership of lookup is passed it; it will be freed on
        	destruction, so must be heap allocated.

        	The colorspace will keep an additional reference to the base
        	colorspace that will be dropped on destruction.

        	The returned reference should be dropped when it is finished
        	with.

        	Colorspaces are immutable once created.
        """
        return _mupdf.FzColorspace_fz_new_indexed_colorspace(self, high, lookup)

    def fz_new_pixmap(self, w, h, seps, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap()`.
        	Create a new pixmap, with its origin at (0,0)

        	cs: The colorspace to use for the pixmap, or NULL for an alpha
        	plane/mask.

        	w: The width of the pixmap (in pixels)

        	h: The height of the pixmap (in pixels)

        	seps: Details of separations.

        	alpha: 0 for no alpha, 1 for alpha.

        	Returns a pointer to the new pixmap. Throws exception on failure
        	to allocate.
        """
        return _mupdf.FzColorspace_fz_new_pixmap(self, w, h, seps, alpha)

    def fz_new_pixmap_with_bbox(self, bbox, seps, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_with_bbox()`.
        	Create a pixmap of a given size, location and pixel format.

        	The bounding box specifies the size of the created pixmap and
        	where it will be located. The colorspace determines the number
        	of components per pixel. Alpha is always present. Pixmaps are
        	reference counted, so drop references using fz_drop_pixmap.

        	colorspace: Colorspace format used for the created pixmap. The
        	pixmap will keep a reference to the colorspace.

        	bbox: Bounding box specifying location/size of created pixmap.

        	seps: Details of separations.

        	alpha: 0 for no alpha, 1 for alpha.

        	Returns a pointer to the new pixmap. Throws exception on failure
        	to allocate.
        """
        return _mupdf.FzColorspace_fz_new_pixmap_with_bbox(self, bbox, seps, alpha)

    def fz_new_pixmap_with_bbox_and_data(self, rect, seps, alpha, samples):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_with_bbox_and_data()`.
        	Create a pixmap of a given size, location and pixel format,
        	using the supplied data block.

        	The bounding box specifies the size of the created pixmap and
        	where it will be located. The colorspace determines the number
        	of components per pixel. Alpha is always present. Pixmaps are
        	reference counted, so drop references using fz_drop_pixmap.

        	colorspace: Colorspace format used for the created pixmap. The
        	pixmap will keep a reference to the colorspace.

        	rect: Bounding box specifying location/size of created pixmap.

        	seps: Details of separations.

        	alpha: Number of alpha planes (0 or 1).

        	samples: The data block to keep the samples in.

        	Returns a pointer to the new pixmap. Throws exception on failure
        	to allocate.
        """
        return _mupdf.FzColorspace_fz_new_pixmap_with_bbox_and_data(self, rect, seps, alpha, samples)

    def fz_new_pixmap_with_data(self, w, h, seps, alpha, stride, samples):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_with_data()`.
        	Create a new pixmap, with its origin at
        	(0,0) using the supplied data block.

        	cs: The colorspace to use for the pixmap, or NULL for an alpha
        	plane/mask.

        	w: The width of the pixmap (in pixels)

        	h: The height of the pixmap (in pixels)

        	seps: Details of separations.

        	alpha: 0 for no alpha, 1 for alpha.

        	stride: The byte offset from the pixel data in a row to the
        	pixel data in the next row.

        	samples: The data block to keep the samples in.

        	Returns a pointer to the new pixmap. Throws exception on failure to
        	allocate.
        """
        return _mupdf.FzColorspace_fz_new_pixmap_with_data(self, w, h, seps, alpha, stride, samples)

    def pdf_is_tint_colorspace(self):
        r"""Class-aware wrapper for `::pdf_is_tint_colorspace()`."""
        return _mupdf.FzColorspace_pdf_is_tint_colorspace(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_cal_gray_colorspace()`.
        		Create a calibrated gray colorspace.

        		The returned reference should be dropped when it is finished
        		with.

        		Colorspaces are immutable once created.


        |

        *Overload 2:*
         Constructor using `fz_new_cal_rgb_colorspace()`.
        		Create a calibrated rgb colorspace.

        		The returned reference should be dropped when it is finished
        		with.

        		Colorspaces are immutable once created.


        |

        *Overload 3:*
         Constructor using `fz_new_colorspace()`.
        		Creates a new colorspace instance and returns a reference.

        		No internal checking is done that the colorspace type (e.g.
        		CMYK) matches with the flags (e.g. FZ_COLORSPACE_HAS_CMYK) or
        		colorant count (n) or name.

        		The reference should be dropped when it is finished with.

        		Colorspaces are immutable once created (with the exception of
        		setting up colorant names for separation spaces).


        |

        *Overload 4:*
         Constructor using `fz_new_icc_colorspace()`.
        		Create a colorspace from an ICC profile supplied in buf.

        		Limited checking is done to ensure that the colorspace type is
        		appropriate for the supplied ICC profile.

        		An additional reference is taken to buf, which will be dropped
        		on destruction. Ownership is NOT passed in.

        		The returned reference should be dropped when it is finished
        		with.

        		Colorspaces are immutable once created.


        |

        *Overload 5:*
         Constructor using `fz_new_indexed_colorspace()`.
        		Create an indexed colorspace.

        		The supplied lookup table is high palette entries long. Each
        		entry is n bytes long, where n is given by the number of
        		colorants in the base colorspace, one byte per colorant.

        		Ownership of lookup is passed it; it will be freed on
        		destruction, so must be heap allocated.

        		The colorspace will keep an additional reference to the base
        		colorspace that will be dropped on destruction.

        		The returned reference should be dropped when it is finished
        		with.

        		Colorspaces are immutable once created.


        |

        *Overload 6:*
         Construct using one of: fz_device_gray(), fz_device_rgb(), fz_device_bgr(), fz_device_cmyk(), fz_device_lab().

        |

        *Overload 7:*
         Copy constructor using `fz_keep_colorspace()`.

        |

        *Overload 8:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 9:*
         Constructor using raw copy of pre-existing `::fz_colorspace`.
        """
        _mupdf.FzColorspace_swiginit(self, _mupdf.new_FzColorspace(*args))
    __swig_destroy__ = _mupdf.delete_FzColorspace

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzColorspace_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzColorspace___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzColorspace_m_internal_get, _mupdf.FzColorspace_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzColorspace_s_num_instances_get, _mupdf.FzColorspace_s_num_instances_set)

# Register FzColorspace in _mupdf:
_mupdf.FzColorspace_swigregister(FzColorspace)
class FzColorspaceContext(object):
    r"""Wrapper class for struct `fz_colorspace_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_colorspace_context`.
        """
        _mupdf.FzColorspaceContext_swiginit(self, _mupdf.new_FzColorspaceContext(*args))
    __swig_destroy__ = _mupdf.delete_FzColorspaceContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzColorspaceContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzColorspaceContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzColorspaceContext_m_internal_get, _mupdf.FzColorspaceContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzColorspaceContext_s_num_instances_get, _mupdf.FzColorspaceContext_s_num_instances_set)

# Register FzColorspaceContext in _mupdf:
_mupdf.FzColorspaceContext_swigregister(FzColorspaceContext)
class FzCompressedBuffer(object):
    r"""
    Wrapper class for struct `fz_compressed_buffer`.
    Buffers of compressed data; typically for the source data
    for images.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_compressed_buffer_size(self):
        r"""
        Class-aware wrapper for `::fz_compressed_buffer_size()`.
        	Return the storage size used for a buffer and its data.
        	Used in implementing store handling.

        	Never throws exceptions.
        """
        return _mupdf.FzCompressedBuffer_fz_compressed_buffer_size(self)

    def fz_open_compressed_buffer(self):
        r"""
        Class-aware wrapper for `::fz_open_compressed_buffer()`.
        	Open a stream to read the decompressed version of a buffer.
        """
        return _mupdf.FzCompressedBuffer_fz_open_compressed_buffer(self)

    def fz_open_image_decomp_stream_from_buffer(self, l2factor):
        r"""
        Class-aware wrapper for `::fz_open_image_decomp_stream_from_buffer()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_open_image_decomp_stream_from_buffer()` => `(fz_stream *, int l2factor)`

        	Open a stream to read the decompressed version of a buffer,
        	with optional log2 subsampling.

        	l2factor = NULL for no subsampling, or a pointer to an integer
        	containing the maximum log2 subsample factor acceptable (0 =
        	none, 1 = halve dimensions, 2 = quarter dimensions etc). If
        	non-NULL, then *l2factor will be updated on exit with the actual
        	log2 subsample factor achieved.
        """
        return _mupdf.FzCompressedBuffer_fz_open_image_decomp_stream_from_buffer(self, l2factor)

    def get_buffer(self):
        r"""Returns wrapper class for fz_buffer *m_internal.buffer."""
        return _mupdf.FzCompressedBuffer_get_buffer(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_compressed_buffer()`.
        		Create a new, UNKNOWN format, compressed_buffer.


        |

        *Overload 2:*
         Copy constructor using `fz_keep_compressed_buffer()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_compressed_buffer`.
        """
        _mupdf.FzCompressedBuffer_swiginit(self, _mupdf.new_FzCompressedBuffer(*args))
    __swig_destroy__ = _mupdf.delete_FzCompressedBuffer

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzCompressedBuffer_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzCompressedBuffer___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzCompressedBuffer_m_internal_get, _mupdf.FzCompressedBuffer_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzCompressedBuffer_s_num_instances_get, _mupdf.FzCompressedBuffer_s_num_instances_set)

# Register FzCompressedBuffer in _mupdf:
_mupdf.FzCompressedBuffer_swigregister(FzCompressedBuffer)
class FzCompressedImage(object):
    r"""Wrapper class for struct `fz_compressed_image`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_set_compressed_image_buffer(self, buf):
        r"""Class-aware wrapper for `::fz_set_compressed_image_buffer()`."""
        return _mupdf.FzCompressedImage_fz_set_compressed_image_buffer(self, buf)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_compressed_image`.
        """
        _mupdf.FzCompressedImage_swiginit(self, _mupdf.new_FzCompressedImage(*args))
    __swig_destroy__ = _mupdf.delete_FzCompressedImage

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzCompressedImage_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzCompressedImage___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzCompressedImage_m_internal_get, _mupdf.FzCompressedImage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzCompressedImage_s_num_instances_get, _mupdf.FzCompressedImage_s_num_instances_set)

# Register FzCompressedImage in _mupdf:
_mupdf.FzCompressedImage_swigregister(FzCompressedImage)
class FzCompressionParams(object):
    r"""
    Wrapper class for struct `fz_compression_params`. Not copyable or assignable.
    Compression parameters used for buffers of compressed data;
    typically for the source data for images.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_compression_params`.
        """
        _mupdf.FzCompressionParams_swiginit(self, _mupdf.new_FzCompressionParams(*args))
    __swig_destroy__ = _mupdf.delete_FzCompressionParams

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzCompressionParams_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzCompressionParams___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzCompressionParams_m_internal_get, _mupdf.FzCompressionParams_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzCompressionParams_s_num_instances_get, _mupdf.FzCompressionParams_s_num_instances_set)

# Register FzCompressionParams in _mupdf:
_mupdf.FzCompressionParams_swigregister(FzCompressionParams)
class FzContext(object):
    r"""Wrapper class for struct `fz_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_new_context_imp()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_context`.
        """
        _mupdf.FzContext_swiginit(self, _mupdf.new_FzContext(*args))
    __swig_destroy__ = _mupdf.delete_FzContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzContext_m_internal_get, _mupdf.FzContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzContext_s_num_instances_get, _mupdf.FzContext_s_num_instances_set)

# Register FzContext in _mupdf:
_mupdf.FzContext_swigregister(FzContext)
class FzCookie(object):
    r"""
    Wrapper class for struct `fz_cookie`. Not copyable or assignable.
    Provide two-way communication between application and library.
    Intended for multi-threaded applications where one thread is
    rendering pages and another thread wants to read progress
    feedback or abort a job that takes a long time to finish. The
    communication is unsynchronized without locking.

    abort: The application should set this field to 0 before
    calling fz_run_page to render a page. At any point when the
    page is being rendered the application my set this field to 1
    which will cause the rendering to finish soon. This field is
    checked periodically when the page is rendered, but exactly
    when is not known, therefore there is no upper bound on
    exactly when the rendering will abort. If the application
    did not provide a set of locks to fz_new_context, it must also
    await the completion of fz_run_page before issuing another
    call to fz_run_page. Note that once the application has set
    this field to 1 after it called fz_run_page it may not change
    the value again.

    progress: Communicates rendering progress back to the
    application and is read only. Increments as a page is being
    rendered. The value starts out at 0 and is limited to less
    than or equal to progress_max, unless progress_max is -1.

    progress_max: Communicates the known upper bound of rendering
    back to the application and is read only. The maximum value
    that the progress field may take. If there is no known upper
    bound on how long the rendering may take this value is -1 and
    progress is not limited. Note that the value of progress_max
    may change from -1 to a positive value once an upper bound is
    known, so take this into consideration when comparing the
    value of progress to that of progress_max.

    errors: count of errors during current rendering.

    incomplete: Initially should be set to 0. Will be set to
    non-zero if a TRYLATER error is thrown during rendering.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""Default constructor sets all fields to default values."""
        _mupdf.FzCookie_swiginit(self, _mupdf.new_FzCookie())

    def set_abort(self):
        r"""Sets m_internal.abort to 1."""
        return _mupdf.FzCookie_set_abort(self)

    def increment_errors(self, delta):
        r"""Increments m_internal.errors by <delta>."""
        return _mupdf.FzCookie_increment_errors(self, delta)

    def abort(self):
        return _mupdf.FzCookie_abort(self)

    def progress(self):
        return _mupdf.FzCookie_progress(self)

    def progress_max(self):
        return _mupdf.FzCookie_progress_max(self)

    def errors(self):
        return _mupdf.FzCookie_errors(self)

    def incomplete(self):
        return _mupdf.FzCookie_incomplete(self)
    __swig_destroy__ = _mupdf.delete_FzCookie
    m_internal = property(_mupdf.FzCookie_m_internal_get, _mupdf.FzCookie_m_internal_set)
    s_num_instances = property(_mupdf.FzCookie_s_num_instances_get, _mupdf.FzCookie_s_num_instances_set, doc=r"""Wrapped data is held by value.""")

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzCookie_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzCookie___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzCookie___ne__(self, rhs)

# Register FzCookie in _mupdf:
_mupdf.FzCookie_swigregister(FzCookie)
class FzDefaultColorspaces(object):
    r"""
    Wrapper class for struct `fz_default_colorspaces`.
    Structure to hold default colorspaces.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_clone_default_colorspaces(self):
        r"""
        Class-aware wrapper for `::fz_clone_default_colorspaces()`.
        	Returns a reference to a newly cloned default colorspaces
        	structure.

        	The new clone may safely be altered without fear of race
        	conditions as the caller is the only reference holder.
        """
        return _mupdf.FzDefaultColorspaces_fz_clone_default_colorspaces(self)

    def fz_default_cmyk(self):
        r"""Class-aware wrapper for `::fz_default_cmyk()`."""
        return _mupdf.FzDefaultColorspaces_fz_default_cmyk(self)

    def fz_default_gray(self):
        r"""
        Class-aware wrapper for `::fz_default_gray()`.
        	Retrieve default colorspaces (typically page local).

        	If default_cs is non NULL, the default is retrieved from there,
        	otherwise the global default is retrieved.

        	These return borrowed references that should not be dropped,
        	unless they are kept first.
        """
        return _mupdf.FzDefaultColorspaces_fz_default_gray(self)

    def fz_default_output_intent(self):
        r"""Class-aware wrapper for `::fz_default_output_intent()`."""
        return _mupdf.FzDefaultColorspaces_fz_default_output_intent(self)

    def fz_default_rgb(self):
        r"""Class-aware wrapper for `::fz_default_rgb()`."""
        return _mupdf.FzDefaultColorspaces_fz_default_rgb(self)

    def fz_set_default_cmyk(self, cs):
        r"""Class-aware wrapper for `::fz_set_default_cmyk()`."""
        return _mupdf.FzDefaultColorspaces_fz_set_default_cmyk(self, cs)

    def fz_set_default_gray(self, cs):
        r"""
        Class-aware wrapper for `::fz_set_default_gray()`.
        	Set new defaults within the default colorspace structure.

        	New references are taken to the new default, and references to
        	the old defaults dropped.

        	Never throws exceptions.
        """
        return _mupdf.FzDefaultColorspaces_fz_set_default_gray(self, cs)

    def fz_set_default_output_intent(self, cs):
        r"""Class-aware wrapper for `::fz_set_default_output_intent()`."""
        return _mupdf.FzDefaultColorspaces_fz_set_default_output_intent(self, cs)

    def fz_set_default_rgb(self, cs):
        r"""Class-aware wrapper for `::fz_set_default_rgb()`."""
        return _mupdf.FzDefaultColorspaces_fz_set_default_rgb(self, cs)

    def pdf_update_default_colorspaces(self, res):
        r"""Class-aware wrapper for `::pdf_update_default_colorspaces()`."""
        return _mupdf.FzDefaultColorspaces_pdf_update_default_colorspaces(self, res)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_default_colorspaces()`.
        		Create a new default colorspace structure with values inherited
        		from the context, and return a reference to it.

        		These can be overridden using fz_set_default_xxxx.

        		These should not be overridden while more than one caller has
        		the reference for fear of race conditions.

        		The caller should drop this reference once finished with it.


        |

        *Overload 2:*
         Copy constructor using `fz_keep_default_colorspaces()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_default_colorspaces`.
        """
        _mupdf.FzDefaultColorspaces_swiginit(self, _mupdf.new_FzDefaultColorspaces(*args))
    __swig_destroy__ = _mupdf.delete_FzDefaultColorspaces

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDefaultColorspaces_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzDefaultColorspaces___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzDefaultColorspaces_m_internal_get, _mupdf.FzDefaultColorspaces_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDefaultColorspaces_s_num_instances_get, _mupdf.FzDefaultColorspaces_s_num_instances_set)

# Register FzDefaultColorspaces in _mupdf:
_mupdf.FzDefaultColorspaces_swigregister(FzDefaultColorspaces)
class FzDevice(object):
    r"""
    Wrapper class for struct `fz_device`.
    The different format handlers (pdf, xps etc) interpret pages to
    a device. These devices can then process the stream of calls
    they receive in various ways:
    	The trace device outputs debugging information for the calls.
    	The draw device will render them.
    	The list device stores them in a list to play back later.
    	The text device performs text extraction and searching.
    	The bbox device calculates the bounding box for the page.
    Other devices can (and will) be written in the future.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_new_xmltext_device(out):
        r"""
        Class-aware wrapper for `::fz_new_xmltext_device()`.
        	Create a device to output raw information.
        """
        return _mupdf.FzDevice_fz_new_xmltext_device(out)

    @staticmethod
    def fz_new_draw_device_type3(transform, dest):
        r"""Class-aware wrapper for `::fz_new_draw_device_type3()`."""
        return _mupdf.FzDevice_fz_new_draw_device_type3(transform, dest)

    def fz_begin_group(self, area, cs, isolated, knockout, blendmode, alpha):
        r"""Class-aware wrapper for `::fz_begin_group()`."""
        return _mupdf.FzDevice_fz_begin_group(self, area, cs, isolated, knockout, blendmode, alpha)

    def fz_begin_layer(self, layer_name):
        r"""Class-aware wrapper for `::fz_begin_layer()`."""
        return _mupdf.FzDevice_fz_begin_layer(self, layer_name)

    def fz_begin_mask(self, area, luminosity, colorspace, bc, color_params):
        r"""Class-aware wrapper for `::fz_begin_mask()`."""
        return _mupdf.FzDevice_fz_begin_mask(self, area, luminosity, colorspace, bc, color_params)

    def fz_begin_metatext(self, meta, text):
        r"""Class-aware wrapper for `::fz_begin_metatext()`."""
        return _mupdf.FzDevice_fz_begin_metatext(self, meta, text)

    def fz_begin_structure(self, standard, raw, idx):
        r"""Class-aware wrapper for `::fz_begin_structure()`."""
        return _mupdf.FzDevice_fz_begin_structure(self, standard, raw, idx)

    def fz_begin_tile(self, area, view, xstep, ystep, ctm):
        r"""Class-aware wrapper for `::fz_begin_tile()`."""
        return _mupdf.FzDevice_fz_begin_tile(self, area, view, xstep, ystep, ctm)

    def fz_begin_tile_id(self, area, view, xstep, ystep, ctm, id):
        r"""Class-aware wrapper for `::fz_begin_tile_id()`."""
        return _mupdf.FzDevice_fz_begin_tile_id(self, area, view, xstep, ystep, ctm, id)

    def fz_clip_image_mask(self, image, ctm, scissor):
        r"""Class-aware wrapper for `::fz_clip_image_mask()`."""
        return _mupdf.FzDevice_fz_clip_image_mask(self, image, ctm, scissor)

    def fz_clip_path(self, path, even_odd, ctm, scissor):
        r"""Class-aware wrapper for `::fz_clip_path()`."""
        return _mupdf.FzDevice_fz_clip_path(self, path, even_odd, ctm, scissor)

    def fz_clip_stroke_path(self, path, stroke, ctm, scissor):
        r"""Class-aware wrapper for `::fz_clip_stroke_path()`."""
        return _mupdf.FzDevice_fz_clip_stroke_path(self, path, stroke, ctm, scissor)

    def fz_clip_stroke_text(self, text, stroke, ctm, scissor):
        r"""Class-aware wrapper for `::fz_clip_stroke_text()`."""
        return _mupdf.FzDevice_fz_clip_stroke_text(self, text, stroke, ctm, scissor)

    def fz_clip_text(self, text, ctm, scissor):
        r"""Class-aware wrapper for `::fz_clip_text()`."""
        return _mupdf.FzDevice_fz_clip_text(self, text, ctm, scissor)

    def fz_close_device(self):
        r"""
        Class-aware wrapper for `::fz_close_device()`.
        	Signal the end of input, and flush any buffered output.
        	This is NOT called implicitly on fz_drop_device. This
        	may throw exceptions.
        """
        return _mupdf.FzDevice_fz_close_device(self)

    def fz_device_current_scissor(self):
        r"""
        Class-aware wrapper for `::fz_device_current_scissor()`.
        	Find current scissor region as tracked by the device.
        """
        return _mupdf.FzDevice_fz_device_current_scissor(self)

    def fz_disable_device_hints(self, hints):
        r"""
        Class-aware wrapper for `::fz_disable_device_hints()`.
        	Disable (clear) hint bits within the hint bitfield for a device.
        """
        return _mupdf.FzDevice_fz_disable_device_hints(self, hints)

    def fz_enable_device_hints(self, hints):
        r"""
        Class-aware wrapper for `::fz_enable_device_hints()`.
        	Enable (set) hint bits within the hint bitfield for a device.
        """
        return _mupdf.FzDevice_fz_enable_device_hints(self, hints)

    def fz_end_group(self):
        r"""Class-aware wrapper for `::fz_end_group()`."""
        return _mupdf.FzDevice_fz_end_group(self)

    def fz_end_layer(self):
        r"""Class-aware wrapper for `::fz_end_layer()`."""
        return _mupdf.FzDevice_fz_end_layer(self)

    def fz_end_mask(self):
        r"""Class-aware wrapper for `::fz_end_mask()`."""
        return _mupdf.FzDevice_fz_end_mask(self)

    def fz_end_mask_tr(self, fn):
        r"""Class-aware wrapper for `::fz_end_mask_tr()`."""
        return _mupdf.FzDevice_fz_end_mask_tr(self, fn)

    def fz_end_metatext(self):
        r"""Class-aware wrapper for `::fz_end_metatext()`."""
        return _mupdf.FzDevice_fz_end_metatext(self)

    def fz_end_structure(self):
        r"""Class-aware wrapper for `::fz_end_structure()`."""
        return _mupdf.FzDevice_fz_end_structure(self)

    def fz_end_tile(self):
        r"""Class-aware wrapper for `::fz_end_tile()`."""
        return _mupdf.FzDevice_fz_end_tile(self)

    def fz_fill_image(self, image, ctm, alpha, color_params):
        r"""Class-aware wrapper for `::fz_fill_image()`."""
        return _mupdf.FzDevice_fz_fill_image(self, image, ctm, alpha, color_params)

    def fz_fill_image_mask(self, image, ctm, colorspace, color, alpha, color_params):
        r"""Class-aware wrapper for `::fz_fill_image_mask()`."""
        return _mupdf.FzDevice_fz_fill_image_mask(self, image, ctm, colorspace, color, alpha, color_params)

    def fz_fill_path(self, path, even_odd, ctm, colorspace, color, alpha, color_params):
        r"""
        Class-aware wrapper for `::fz_fill_path()`.
        	Device calls; graphics primitives and containers.
        """
        return _mupdf.FzDevice_fz_fill_path(self, path, even_odd, ctm, colorspace, color, alpha, color_params)

    def fz_fill_shade(self, shade, ctm, alpha, color_params):
        r"""Class-aware wrapper for `::fz_fill_shade()`."""
        return _mupdf.FzDevice_fz_fill_shade(self, shade, ctm, alpha, color_params)

    def fz_fill_text(self, text, ctm, colorspace, color, alpha, color_params):
        r"""Class-aware wrapper for `::fz_fill_text()`."""
        return _mupdf.FzDevice_fz_fill_text(self, text, ctm, colorspace, color, alpha, color_params)

    def fz_ignore_text(self, text, ctm):
        r"""Class-aware wrapper for `::fz_ignore_text()`."""
        return _mupdf.FzDevice_fz_ignore_text(self, text, ctm)

    def fz_new_ocr_device(self, ctm, mediabox, with_list, language, datadir, progress, progress_arg):
        r"""
        Class-aware wrapper for `::fz_new_ocr_device()`.
        	Create a device to OCR the text on the page.

        	Renders the page internally to a bitmap that is then OCRd. Text
        	is then forwarded onto the target device.

        	target: The target device to receive the OCRd text.

        	ctm: The transform to apply to the mediabox to get the size for
        	the rendered page image. Also used to calculate the resolution
        	for the page image. In general, this will be the same as the CTM
        	that you pass to fz_run_page (or fz_run_display_list) to feed
        	this device.

        	mediabox: The mediabox (in points). Combined with the CTM to get
        	the bounds of the pixmap used internally for the rendered page
        	image.

        	with_list: If with_list is false, then all non-text operations
        	are forwarded instantly to the target device. This results in
        	the target device seeing all NON-text operations, followed by
        	all the text operations (derived from OCR).

        	If with_list is true, then all the marking operations are
        	collated into a display list which is then replayed to the
        	target device at the end.

        	language: NULL (for "eng"), or a pointer to a string to describe
        	the languages/scripts that should be used for OCR (e.g.
        	"eng,ara").

        	datadir: NULL (for ""), or a pointer to a path string otherwise
        	provided to Tesseract in the TESSDATA_PREFIX environment variable.

        	progress: NULL, or function to be called periodically to indicate
        	progress. Return 0 to continue, or 1 to cancel. progress_arg is
        	returned as the void *. The int is a value between 0 and 100 to
        	indicate progress.

        	progress_arg: A void * value to be parrotted back to the progress
        	function.
        """
        return _mupdf.FzDevice_fz_new_ocr_device(self, ctm, mediabox, with_list, language, datadir, progress, progress_arg)

    def fz_pop_clip(self):
        r"""Class-aware wrapper for `::fz_pop_clip()`."""
        return _mupdf.FzDevice_fz_pop_clip(self)

    def fz_render_flags(self, set, clear):
        r"""Class-aware wrapper for `::fz_render_flags()`."""
        return _mupdf.FzDevice_fz_render_flags(self, set, clear)

    def fz_render_t3_glyph_direct(self, font, gid, trm, gstate, def_cs):
        r"""
        Class-aware wrapper for `::fz_render_t3_glyph_direct()`.
        	Nasty PDF interpreter specific hernia, required to allow the
        	interpreter to replay glyphs from a type3 font directly into
        	the target device.

        	This is only used in exceptional circumstances (such as type3
        	glyphs that inherit current graphics state, or nested type3
        	glyphs).
        """
        return _mupdf.FzDevice_fz_render_t3_glyph_direct(self, font, gid, trm, gstate, def_cs)

    def fz_set_default_colorspaces(self, default_cs):
        r"""Class-aware wrapper for `::fz_set_default_colorspaces()`."""
        return _mupdf.FzDevice_fz_set_default_colorspaces(self, default_cs)

    def fz_stroke_path(self, path, stroke, ctm, colorspace, color, alpha, color_params):
        r"""Class-aware wrapper for `::fz_stroke_path()`."""
        return _mupdf.FzDevice_fz_stroke_path(self, path, stroke, ctm, colorspace, color, alpha, color_params)

    def fz_stroke_text(self, text, stroke, ctm, colorspace, color, alpha, color_params):
        r"""Class-aware wrapper for `::fz_stroke_text()`."""
        return _mupdf.FzDevice_fz_stroke_text(self, text, stroke, ctm, colorspace, color, alpha, color_params)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_bbox_device()`.
        		Create a device to compute the bounding
        		box of all marks on a page.

        		The returned bounding box will be the union of all bounding
        		boxes of all objects on a page.


        |

        *Overload 2:*
         Constructor using `fz_new_device_of_size()`.
        		Devices are created by calls to device implementations, for
        		instance: foo_new_device(). These will be implemented by calling
        		fz_new_derived_device(ctx, foo_device) where foo_device is a
        		structure "derived from" fz_device, for instance
        		typedef struct { fz_device base;  ...extras...} foo_device;


        |

        *Overload 3:*
         Constructor using `fz_new_draw_device()`.
        		Create a device to draw on a pixmap.

        		dest: Target pixmap for the draw device. See fz_new_pixmap*
        		for how to obtain a pixmap. The pixmap is not cleared by the
        		draw device, see fz_clear_pixmap* for how to clear it prior to
        		calling fz_new_draw_device. Free the device by calling
        		fz_drop_device.

        		transform: Transform from user space in points to device space
        		in pixels.


        |

        *Overload 4:*
         Constructor using `fz_new_draw_device_with_bbox()`.
        		Create a device to draw on a pixmap.

        		dest: Target pixmap for the draw device. See fz_new_pixmap*
        		for how to obtain a pixmap. The pixmap is not cleared by the
        		draw device, see fz_clear_pixmap* for how to clear it prior to
        		calling fz_new_draw_device. Free the device by calling
        		fz_drop_device.

        		transform: Transform from user space in points to device space
        		in pixels.

        		clip: Bounding box to restrict any marking operations of the
        		draw device.


        |

        *Overload 5:*
         Constructor using `fz_new_draw_device_with_bbox_proof()`.
        		Create a device to draw on a pixmap.

        		dest: Target pixmap for the draw device. See fz_new_pixmap*
        		for how to obtain a pixmap. The pixmap is not cleared by the
        		draw device, see fz_clear_pixmap* for how to clear it prior to
        		calling fz_new_draw_device. Free the device by calling
        		fz_drop_device.

        		transform: Transform from user space in points to device space
        		in pixels.

        		clip: Bounding box to restrict any marking operations of the
        		draw device.

        		proof_cs: Color space to render to prior to mapping to color
        		space defined by pixmap.


        |

        *Overload 6:*
         Constructor using `fz_new_draw_device_with_options()`.
        		Create a new pixmap and draw device, using the specified options.

        		options: Options to configure the draw device, and choose the
        		resolution and colorspace.

        		mediabox: The bounds of the page in points.

        		pixmap: An out parameter containing the newly created pixmap.


        |

        *Overload 7:*
         Constructor using `fz_new_draw_device_with_proof()`.
        		Create a device to draw on a pixmap.

        		dest: Target pixmap for the draw device. See fz_new_pixmap*
        		for how to obtain a pixmap. The pixmap is not cleared by the
        		draw device, see fz_clear_pixmap* for how to clear it prior to
        		calling fz_new_draw_device. Free the device by calling
        		fz_drop_device.

        		transform: Transform from user space in points to device space
        		in pixels.

        		proof_cs: Intermediate color space to map though when mapping to
        		color space defined by pixmap.


        |

        *Overload 8:*
         Constructor using `fz_new_list_device()`.
        		Create a rendering device for a display list.

        		When the device is rendering a page it will populate the
        		display list with drawing commands (text, images, etc.). The
        		display list can later be reused to render a page many times
        		without having to re-interpret the page from the document file
        		for each rendering. Once the device is no longer needed, free
        		it with fz_drop_device.

        		list: A display list that the list device takes a reference to.


        |

        *Overload 9:*
         Constructor using `fz_new_ocr_device()`.
        		Create a device to OCR the text on the page.

        		Renders the page internally to a bitmap that is then OCRd. Text
        		is then forwarded onto the target device.

        		target: The target device to receive the OCRd text.

        		ctm: The transform to apply to the mediabox to get the size for
        		the rendered page image. Also used to calculate the resolution
        		for the page image. In general, this will be the same as the CTM
        		that you pass to fz_run_page (or fz_run_display_list) to feed
        		this device.

        		mediabox: The mediabox (in points). Combined with the CTM to get
        		the bounds of the pixmap used internally for the rendered page
        		image.

        		with_list: If with_list is false, then all non-text operations
        		are forwarded instantly to the target device. This results in
        		the target device seeing all NON-text operations, followed by
        		all the text operations (derived from OCR).

        		If with_list is true, then all the marking operations are
        		collated into a display list which is then replayed to the
        		target device at the end.

        		language: NULL (for "eng"), or a pointer to a string to describe
        		the languages/scripts that should be used for OCR (e.g.
        		"eng,ara").

        		datadir: NULL (for ""), or a pointer to a path string otherwise
        		provided to Tesseract in the TESSDATA_PREFIX environment variable.

        		progress: NULL, or function to be called periodically to indicate
        		progress. Return 0 to continue, or 1 to cancel. progress_arg is
        		returned as the void *. The int is a value between 0 and 100 to
        		indicate progress.

        		progress_arg: A void * value to be parrotted back to the progress
        		function.


        |

        *Overload 10:*
         Constructor using `fz_new_stext_device()`.
        		Create a device to extract the text on a page.

        		Gather the text on a page into blocks and lines.

        		The reading order is taken from the order the text is drawn in
        		the source file, so may not be accurate.

        		page: The text page to which content should be added. This will
        		usually be a newly created (empty) text page, but it can be one
        		containing data already (for example when merging multiple
        		pages, or watermarking).

        		options: Options to configure the stext device.


        |

        *Overload 11:*
         Constructor using `fz_new_svg_device()`.
        		Create a device that outputs (single page) SVG files to
        		the given output stream.

        		Equivalent to fz_new_svg_device_with_id passing id = NULL.


        |

        *Overload 12:*
         Constructor using `fz_new_svg_device_with_id()`.
        		Create a device that outputs (single page) SVG files to
        		the given output stream.

        		output: The output stream to send the constructed SVG page to.

        		page_width, page_height: The page dimensions to use (in points).

        		text_format: How to emit text. One of the following values:
        			FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
        			layout errors and mismatching fonts.
        			FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
        			visual appearance.

        		reuse_images: Share image resources using <symbol> definitions.

        		id: ID parameter to keep generated IDs unique across SVG files.


        |

        *Overload 13:*
         Constructor using `fz_new_test_device()`.
        		Create a device to test for features.

        		Currently only tests for the presence of non-grayscale colors.

        		is_color: Possible values returned:
        			0: Definitely greyscale
        			1: Probably color (all colors were grey, but there
        			were images or shadings in a non grey colorspace).
        			2: Definitely color

        		threshold: The difference from grayscale that will be tolerated.
        		Typical values to use are either 0 (be exact) and 0.02 (allow an
        		imperceptible amount of slop).

        		options: A set of bitfield options, from the FZ_TEST_OPT set.

        		passthrough: A device to pass all calls through to, or NULL.
        		If set, then the test device can both test and pass through to
        		an underlying device (like, say, the display list device). This
        		means that a display list can be created and at the end we'll
        		know if it's colored or not.

        		In the absence of a passthrough device, the device will throw
        		an exception to stop page interpretation when color is found.


        |

        *Overload 14:*
         Constructor using `fz_new_trace_device()`.
        		Create a device to print a debug trace of all device calls.


        |

        *Overload 15:*
         Constructor using `pdf_new_pdf_device()`.

        |

        *Overload 16:*
         Copy constructor using `fz_keep_device()`.

        |

        *Overload 17:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 18:*
         Constructor using raw copy of pre-existing `::fz_device`.
        """
        _mupdf.FzDevice_swiginit(self, _mupdf.new_FzDevice(*args))
    __swig_destroy__ = _mupdf.delete_FzDevice

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDevice_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzDevice___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzDevice_m_internal_get, _mupdf.FzDevice_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDevice_s_num_instances_get, _mupdf.FzDevice_s_num_instances_set)

# Register FzDevice in _mupdf:
_mupdf.FzDevice_swigregister(FzDevice)
class FzDevice2(FzDevice):
    r"""Wrapper class for struct fz_device with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""== Constructor."""
        if self.__class__ == FzDevice2:
            _self = None
        else:
            _self = self
        _mupdf.FzDevice2_swiginit(self, _mupdf.new_FzDevice2(_self, ))
    __swig_destroy__ = _mupdf.delete_FzDevice2

    def use_virtual_close_device(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.FzDevice2_use_virtual_close_device(self, use)

    def use_virtual_drop_device(self, use=True):
        return _mupdf.FzDevice2_use_virtual_drop_device(self, use)

    def use_virtual_fill_path(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_path(self, use)

    def use_virtual_stroke_path(self, use=True):
        return _mupdf.FzDevice2_use_virtual_stroke_path(self, use)

    def use_virtual_clip_path(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_path(self, use)

    def use_virtual_clip_stroke_path(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_stroke_path(self, use)

    def use_virtual_fill_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_text(self, use)

    def use_virtual_stroke_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_stroke_text(self, use)

    def use_virtual_clip_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_text(self, use)

    def use_virtual_clip_stroke_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_stroke_text(self, use)

    def use_virtual_ignore_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_ignore_text(self, use)

    def use_virtual_fill_shade(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_shade(self, use)

    def use_virtual_fill_image(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_image(self, use)

    def use_virtual_fill_image_mask(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_image_mask(self, use)

    def use_virtual_clip_image_mask(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_image_mask(self, use)

    def use_virtual_pop_clip(self, use=True):
        return _mupdf.FzDevice2_use_virtual_pop_clip(self, use)

    def use_virtual_begin_mask(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_mask(self, use)

    def use_virtual_end_mask(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_mask(self, use)

    def use_virtual_begin_group(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_group(self, use)

    def use_virtual_end_group(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_group(self, use)

    def use_virtual_begin_tile(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_tile(self, use)

    def use_virtual_end_tile(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_tile(self, use)

    def use_virtual_render_flags(self, use=True):
        return _mupdf.FzDevice2_use_virtual_render_flags(self, use)

    def use_virtual_set_default_colorspaces(self, use=True):
        return _mupdf.FzDevice2_use_virtual_set_default_colorspaces(self, use)

    def use_virtual_begin_layer(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_layer(self, use)

    def use_virtual_end_layer(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_layer(self, use)

    def use_virtual_begin_structure(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_structure(self, use)

    def use_virtual_end_structure(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_structure(self, use)

    def use_virtual_begin_metatext(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_metatext(self, use)

    def use_virtual_end_metatext(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_metatext(self, use)

    def close_device(self, arg_0):
        r"""Default virtual method implementations; these all throw an exception."""
        return _mupdf.FzDevice2_close_device(self, arg_0)

    def drop_device(self, arg_0):
        return _mupdf.FzDevice2_drop_device(self, arg_0)

    def fill_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
        return _mupdf.FzDevice2_fill_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)

    def stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
        return _mupdf.FzDevice2_stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)

    def clip_path(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_clip_path(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def clip_stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_clip_stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def fill_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzDevice2_fill_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
        return _mupdf.FzDevice2_stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)

    def clip_text(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.FzDevice2_clip_text(self, arg_0, arg_2, arg_3, arg_4)

    def clip_stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_clip_stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def ignore_text(self, arg_0, arg_2, arg_3):
        return _mupdf.FzDevice2_ignore_text(self, arg_0, arg_2, arg_3)

    def fill_shade(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_fill_shade(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def fill_image(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_fill_image(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def fill_image_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzDevice2_fill_image_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def clip_image_mask(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.FzDevice2_clip_image_mask(self, arg_0, arg_2, arg_3, arg_4)

    def pop_clip(self, arg_0):
        return _mupdf.FzDevice2_pop_clip(self, arg_0)

    def begin_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6):
        return _mupdf.FzDevice2_begin_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6)

    def end_mask(self, arg_0, arg_2):
        return _mupdf.FzDevice2_end_mask(self, arg_0, arg_2)

    def begin_group(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzDevice2_begin_group(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def end_group(self, arg_0):
        return _mupdf.FzDevice2_end_group(self, arg_0)

    def begin_tile(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzDevice2_begin_tile(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def end_tile(self, arg_0):
        return _mupdf.FzDevice2_end_tile(self, arg_0)

    def render_flags(self, arg_0, arg_2, arg_3):
        return _mupdf.FzDevice2_render_flags(self, arg_0, arg_2, arg_3)

    def set_default_colorspaces(self, arg_0, arg_2):
        return _mupdf.FzDevice2_set_default_colorspaces(self, arg_0, arg_2)

    def begin_layer(self, arg_0, arg_2):
        return _mupdf.FzDevice2_begin_layer(self, arg_0, arg_2)

    def end_layer(self, arg_0):
        return _mupdf.FzDevice2_end_layer(self, arg_0)

    def begin_structure(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.FzDevice2_begin_structure(self, arg_0, arg_2, arg_3, arg_4)

    def end_structure(self, arg_0):
        return _mupdf.FzDevice2_end_structure(self, arg_0)

    def begin_metatext(self, arg_0, arg_2, arg_3):
        return _mupdf.FzDevice2_begin_metatext(self, arg_0, arg_2, arg_3)

    def end_metatext(self, arg_0):
        return _mupdf.FzDevice2_end_metatext(self, arg_0)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_FzDevice2(self)
        return weakref.proxy(self)

# Register FzDevice2 in _mupdf:
_mupdf.FzDevice2_swigregister(FzDevice2)
class FzDeviceContainerStack(object):
    r"""
    Wrapper class for struct `fz_device_container_stack`. Not copyable or assignable.
    Devices can keep track of containers (clips/masks/groups/tiles)
    as they go to save callers having to do it.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_device_container_stack`.
        """
        _mupdf.FzDeviceContainerStack_swiginit(self, _mupdf.new_FzDeviceContainerStack(*args))
    __swig_destroy__ = _mupdf.delete_FzDeviceContainerStack

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDeviceContainerStack_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzDeviceContainerStack___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzDeviceContainerStack_m_internal_get, _mupdf.FzDeviceContainerStack_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDeviceContainerStack_s_num_instances_get, _mupdf.FzDeviceContainerStack_s_num_instances_set)

# Register FzDeviceContainerStack in _mupdf:
_mupdf.FzDeviceContainerStack_swigregister(FzDeviceContainerStack)
class FzDisplayList(object):
    r"""
    Wrapper class for struct `fz_display_list`.
    fz_display_list is a list containing drawing commands (text,
    images, etc.). The intent is two-fold: as a caching-mechanism
    to reduce parsing of a page, and to be used as a data
    structure in multi-threading where one thread parses the page
    and another renders pages.

    Create a display list with fz_new_display_list, hand it over to
    fz_new_list_device to have it populated, and later replay the
    list (once or many times) by calling fz_run_display_list. When
    the list is no longer needed drop it with fz_drop_display_list.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_new_display_list_from_page_contents(page):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.
        	Create a display list from page contents (no annotations).

        	Ownership of the display list is returned to the caller.
        """
        return _mupdf.FzDisplayList_fz_new_display_list_from_page_contents(page)

    def fz_bound_display_list(self):
        r"""
        Class-aware wrapper for `::fz_bound_display_list()`.
        	Return the bounding box of the page recorded in a display list.
        """
        return _mupdf.FzDisplayList_fz_bound_display_list(self)

    def fz_display_list_is_empty(self):
        r"""
        Class-aware wrapper for `::fz_display_list_is_empty()`.
        	Check for a display list being empty

        	list: The list to check.

        	Returns true if empty, false otherwise.
        """
        return _mupdf.FzDisplayList_fz_display_list_is_empty(self)

    def fz_fill_pixmap_from_display_list(self, ctm, pix):
        r"""Class-aware wrapper for `::fz_fill_pixmap_from_display_list()`."""
        return _mupdf.FzDisplayList_fz_fill_pixmap_from_display_list(self, ctm, pix)

    def fz_new_buffer_from_display_list(self, options):
        r"""Class-aware wrapper for `::fz_new_buffer_from_display_list()`."""
        return _mupdf.FzDisplayList_fz_new_buffer_from_display_list(self, options)

    def fz_new_list_device(self):
        r"""
        Class-aware wrapper for `::fz_new_list_device()`.
        	Create a rendering device for a display list.

        	When the device is rendering a page it will populate the
        	display list with drawing commands (text, images, etc.). The
        	display list can later be reused to render a page many times
        	without having to re-interpret the page from the document file
        	for each rendering. Once the device is no longer needed, free
        	it with fz_drop_device.

        	list: A display list that the list device takes a reference to.
        """
        return _mupdf.FzDisplayList_fz_new_list_device(self)

    def fz_new_pixmap_from_display_list(self, ctm, cs, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_display_list()`.
        	Render the page to a pixmap using the transform and colorspace.

        	Ownership of the pixmap is returned to the caller.
        """
        return _mupdf.FzDisplayList_fz_new_pixmap_from_display_list(self, ctm, cs, alpha)

    def fz_new_pixmap_from_display_list_with_separations(self, ctm, cs, seps, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.
        	Render the page contents with control over spot colors.

        	Ownership of the pixmap is returned to the caller.
        """
        return _mupdf.FzDisplayList_fz_new_pixmap_from_display_list_with_separations(self, ctm, cs, seps, alpha)

    def fz_run_display_list(self, dev, ctm, scissor, cookie):
        r"""
        Class-aware wrapper for `::fz_run_display_list()`.
        	(Re)-run a display list through a device.

        	list: A display list, created by fz_new_display_list and
        	populated with objects from a page by running fz_run_page on a
        	device obtained from fz_new_list_device.

        	ctm: Transform to apply to display list contents. May include
        	for example scaling and rotation, see fz_scale, fz_rotate and
        	fz_concat. Set to fz_identity if no transformation is desired.

        	scissor: Only the part of the contents of the display list
        	visible within this area will be considered when the list is
        	run through the device. This does not imply for tile objects
        	contained in the display list.

        	cookie: Communication mechanism between caller and library
        	running the page. Intended for multi-threaded applications,
        	while single-threaded applications set cookie to NULL. The
        	caller may abort an ongoing page run. Cookie also communicates
        	progress information back to the caller. The fields inside
        	cookie are continually updated while the page is being run.
        """
        return _mupdf.FzDisplayList_fz_run_display_list(self, dev, ctm, scissor, cookie)

    def fz_search_display_list(self, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_display_list()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_display_list(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
        """
        return _mupdf.FzDisplayList_fz_search_display_list(self, needle, hit_mark, hit_bbox, hit_max)

    def fz_search_display_list_cb(self, needle, cb, opaque):
        r"""Class-aware wrapper for `::fz_search_display_list_cb()`."""
        return _mupdf.FzDisplayList_fz_search_display_list_cb(self, needle, cb, opaque)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_display_list()`.
        		Create an empty display list.

        		A display list contains drawing commands (text, images, etc.).
        		Use fz_new_list_device for populating the list.

        		mediabox: Bounds of the page (in points) represented by the
        		display list.


        |

        *Overload 2:*
         Constructor using `fz_new_display_list_from_page()`.
        		Create a display list.

        		Ownership of the display list is returned to the caller.


        |

        *Overload 3:*
         Constructor using `fz_new_display_list_from_page_number()`.

        |

        *Overload 4:*
         Constructor using `fz_new_display_list_from_svg()`.
        		Parse an SVG document into a display-list.


        |

        *Overload 5:*
         Constructor using `fz_new_display_list_from_svg_xml()`.
        		Parse an SVG document into a display-list.


        |

        *Overload 6:*
         Constructor using `pdf_new_display_list_from_annot()`.

        |

        *Overload 7:*
         Copy constructor using `fz_keep_display_list()`.

        |

        *Overload 8:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 9:*
         Constructor using raw copy of pre-existing `::fz_display_list`.
        """
        _mupdf.FzDisplayList_swiginit(self, _mupdf.new_FzDisplayList(*args))
    __swig_destroy__ = _mupdf.delete_FzDisplayList

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDisplayList_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzDisplayList___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzDisplayList_m_internal_get, _mupdf.FzDisplayList_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDisplayList_s_num_instances_get, _mupdf.FzDisplayList_s_num_instances_set)

# Register FzDisplayList in _mupdf:
_mupdf.FzDisplayList_swigregister(FzDisplayList)
class FzDocument(object):
    r"""Wrapper class for struct `fz_document`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_authenticate_password(self, password):
        r"""
        Class-aware wrapper for `::fz_authenticate_password()`.
        	Test if the given password can decrypt the document.

        	password: The password string to be checked. Some document
        	specifications do not specify any particular text encoding, so
        	neither do we.

        	Returns 0 for failure to authenticate, non-zero for success.

        	For PDF documents, further information can be given by examining
        	the bits in the return code.

        		Bit 0 => No password required
        		Bit 1 => User password authenticated
        		Bit 2 => Owner password authenticated
        """
        return _mupdf.FzDocument_fz_authenticate_password(self, password)

    def fz_clamp_location(self, loc):
        r"""
        Class-aware wrapper for `::fz_clamp_location()`.
        	Clamps a location into valid chapter/page range. (First clamps
        	the chapter into range, then the page into range).
        """
        return _mupdf.FzDocument_fz_clamp_location(self, loc)

    def fz_count_chapter_pages(self, chapter):
        r"""
        Class-aware wrapper for `::fz_count_chapter_pages()`.
        	Return the number of pages in a chapter.
        	May return 0.
        """
        return _mupdf.FzDocument_fz_count_chapter_pages(self, chapter)

    def fz_count_chapters(self):
        r"""
        Class-aware wrapper for `::fz_count_chapters()`.
        	Return the number of chapters in the document.
        	At least 1.
        """
        return _mupdf.FzDocument_fz_count_chapters(self)

    def fz_count_pages(self):
        r"""
        Class-aware wrapper for `::fz_count_pages()`.
        	Return the number of pages in document

        	May return 0 for documents with no pages.
        """
        return _mupdf.FzDocument_fz_count_pages(self)

    def fz_document_output_intent(self):
        r"""
        Class-aware wrapper for `::fz_document_output_intent()`.
        	Find the output intent colorspace if the document has defined
        	one.

        	Returns a borrowed reference that should not be dropped, unless
        	it is kept first.
        """
        return _mupdf.FzDocument_fz_document_output_intent(self)

    def fz_document_supports_accelerator(self):
        r"""
        Class-aware wrapper for `::fz_document_supports_accelerator()`.
        	Query if the document supports the saving of accelerator data.
        """
        return _mupdf.FzDocument_fz_document_supports_accelerator(self)

    def fz_format_link_uri(self, dest):
        r"""
        Class-aware wrapper for `::fz_format_link_uri()`.
        	Format an internal link to a page number, location, and possible viewing parameters,
        	suitable for use with fz_create_link.

        	Returns a newly allocated string that the caller must free.
        """
        return _mupdf.FzDocument_fz_format_link_uri(self, dest)

    def fz_has_permission(self, p):
        r"""
        Class-aware wrapper for `::fz_has_permission()`.
        	Check permission flags on document.
        """
        return _mupdf.FzDocument_fz_has_permission(self, p)

    def fz_is_document_reflowable(self):
        r"""
        Class-aware wrapper for `::fz_is_document_reflowable()`.
        	Is the document reflowable.

        	Returns 1 to indicate reflowable documents, otherwise 0.
        """
        return _mupdf.FzDocument_fz_is_document_reflowable(self)

    def fz_last_page(self):
        r"""
        Class-aware wrapper for `::fz_last_page()`.
        	Function to get the location for the last page in the document.
        	Using this can be far more efficient in some cases than calling
        	fz_count_pages and using the page number.
        """
        return _mupdf.FzDocument_fz_last_page(self)

    def fz_layout_document(self, w, h, em):
        r"""
        Class-aware wrapper for `::fz_layout_document()`.
        	Layout reflowable document types.

        	w, h: Page size in points.
        	em: Default font size in points.
        """
        return _mupdf.FzDocument_fz_layout_document(self, w, h, em)

    def fz_load_chapter_page(self, chapter, page):
        r"""
        Class-aware wrapper for `::fz_load_chapter_page()`.
        	Load a page.

        	After fz_load_page is it possible to retrieve the size of the
        	page using fz_bound_page, or to render the page using
        	fz_run_page_*. Free the page by calling fz_drop_page.

        	chapter: chapter number, 0 is the first chapter of the document.
        	number: page number, 0 is the first page of the chapter.
        """
        return _mupdf.FzDocument_fz_load_chapter_page(self, chapter, page)

    def fz_load_outline(self):
        r"""
        Class-aware wrapper for `::fz_load_outline()`.
        	Load the hierarchical document outline.

        	Should be freed by fz_drop_outline.
        """
        return _mupdf.FzDocument_fz_load_outline(self)

    def fz_load_page(self, number):
        r"""
        Class-aware wrapper for `::fz_load_page()`.
        	Load a given page number from a document. This may be much less
        	efficient than loading by location (chapter+page) for some
        	document types.
        """
        return _mupdf.FzDocument_fz_load_page(self, number)

    def fz_location_from_page_number(self, number):
        r"""
        Class-aware wrapper for `::fz_location_from_page_number()`.
        	Converts from page number to chapter+page. This may cause many
        	chapters to be laid out in order to calculate the number of
        	pages within those chapters.
        """
        return _mupdf.FzDocument_fz_location_from_page_number(self, number)

    def fz_lookup_bookmark(self, mark):
        r"""
        Class-aware wrapper for `::fz_lookup_bookmark()`.
        	Find a bookmark and return its page number.
        """
        return _mupdf.FzDocument_fz_lookup_bookmark(self, mark)

    def fz_lookup_metadata(self, key, buf, size):
        r"""
        Class-aware wrapper for `::fz_lookup_metadata()`.
        	Retrieve document meta data strings.

        	doc: The document to query.

        	key: Which meta data key to retrieve...

        	Basic information:
        		'format'	-- Document format and version.
        		'encryption'	-- Description of the encryption used.

        	From the document information dictionary:
        		'info:Title'
        		'info:Author'
        		'info:Subject'
        		'info:Keywords'
        		'info:Creator'
        		'info:Producer'
        		'info:CreationDate'
        		'info:ModDate'

        	buf: The buffer to hold the results (a nul-terminated UTF-8
        	string).

        	size: Size of 'buf'.

        	Returns the number of bytes need to store the string plus terminator
        	(will be larger than 'size' if the output was truncated), or -1 if the
        	key is not recognized or found.
        """
        return _mupdf.FzDocument_fz_lookup_metadata(self, key, buf, size)

    def fz_lookup_metadata2(self, key):
        r"""
        Class-aware wrapper for `::fz_lookup_metadata2()`.
        C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
        or calls `fz_throw()` if not found.
        """
        return _mupdf.FzDocument_fz_lookup_metadata2(self, key)

    def fz_needs_password(self):
        r"""
        Class-aware wrapper for `::fz_needs_password()`.
        	Check if a document is encrypted with a
        	non-blank password.
        """
        return _mupdf.FzDocument_fz_needs_password(self)

    def fz_new_buffer_from_page_number(self, number, options):
        r"""Class-aware wrapper for `::fz_new_buffer_from_page_number()`."""
        return _mupdf.FzDocument_fz_new_buffer_from_page_number(self, number, options)

    def fz_new_display_list_from_page_number(self, number):
        r"""Class-aware wrapper for `::fz_new_display_list_from_page_number()`."""
        return _mupdf.FzDocument_fz_new_display_list_from_page_number(self, number)

    def fz_new_pdf_document_from_fz_document(self):
        r"""Class-aware wrapper for `::fz_new_pdf_document_from_fz_document()`."""
        return _mupdf.FzDocument_fz_new_pdf_document_from_fz_document(self)

    def fz_new_pixmap_from_page_number(self, number, ctm, cs, alpha):
        r"""Class-aware wrapper for `::fz_new_pixmap_from_page_number()`."""
        return _mupdf.FzDocument_fz_new_pixmap_from_page_number(self, number, ctm, cs, alpha)

    def fz_new_pixmap_from_page_number_with_separations(self, number, ctm, cs, seps, alpha):
        r"""Class-aware wrapper for `::fz_new_pixmap_from_page_number_with_separations()`."""
        return _mupdf.FzDocument_fz_new_pixmap_from_page_number_with_separations(self, number, ctm, cs, seps, alpha)

    def fz_new_xhtml_document_from_document(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.
        		Use text extraction to convert the input document into XHTML,
        		then open the result as a new document that can be reflowed.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.
        		Use text extraction to convert the input document into XHTML,
        		then open the result as a new document that can be reflowed.
        """
        return _mupdf.FzDocument_fz_new_xhtml_document_from_document(self, *args)

    def fz_next_page(self, loc):
        r"""
        Class-aware wrapper for `::fz_next_page()`.
        	Function to get the location of the next page (allowing for the
        	end of chapters etc). If at the end of the document, returns the
        	current location.
        """
        return _mupdf.FzDocument_fz_next_page(self, loc)

    def fz_open_reflowed_document(self, opts):
        r"""Class-aware wrapper for `::fz_open_reflowed_document()`."""
        return _mupdf.FzDocument_fz_open_reflowed_document(self, opts)

    def fz_output_accelerator(self, accel):
        r"""
        Class-aware wrapper for `::fz_output_accelerator()`.
        	Output accelerator data for the document to a given output
        	stream.
        """
        return _mupdf.FzDocument_fz_output_accelerator(self, accel)

    def fz_page_number_from_location(self, loc):
        r"""
        Class-aware wrapper for `::fz_page_number_from_location()`.
        	Converts from chapter+page to page number. This may cause many
        	chapters to be laid out in order to calculate the number of
        	pages within those chapters.
        """
        return _mupdf.FzDocument_fz_page_number_from_location(self, loc)

    def fz_previous_page(self, loc):
        r"""
        Class-aware wrapper for `::fz_previous_page()`.
        	Function to get the location of the previous page (allowing for
        	the end of chapters etc). If already at the start of the
        	document, returns the current page.
        """
        return _mupdf.FzDocument_fz_previous_page(self, loc)

    def fz_process_opened_pages(self, process_openend_page, state):
        r"""
        Class-aware wrapper for `::fz_process_opened_pages()`.
        	Iterates over all opened pages of the document, calling the
        	provided callback for each page for processing. If the callback
        	returns non-NULL then the iteration stops and that value is returned
        	to the called of fz_process_opened_pages().

        	The state pointer provided to fz_process_opened_pages() is
        	passed on to the callback but is owned by the caller.

        	Returns the first non-NULL value returned by the callback,
        	or NULL if the callback returned NULL for all opened pages.
        """
        return _mupdf.FzDocument_fz_process_opened_pages(self, process_openend_page, state)

    def fz_resolve_link(self, uri, xp, yp):
        r"""
        Class-aware wrapper for `::fz_resolve_link()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_resolve_link(const char *uri)` => `(fz_location, float xp, float yp)`

        	Resolve an internal link to a page number.

        	xp, yp: Pointer to store coordinate of destination on the page.

        	Returns (-1,-1) if the URI cannot be resolved.
        """
        return _mupdf.FzDocument_fz_resolve_link(self, uri, xp, yp)

    def fz_run_document_structure(self, dev, cookie):
        r"""
        Class-aware wrapper for `::fz_run_document_structure()`.
        	Run the document structure through a device.

        	doc: Document in question.

        	dev: Device obtained from fz_new_*_device.

        	cookie: Communication mechanism between caller and library.
        	Intended for multi-threaded applications, while
        	single-threaded applications set cookie to NULL. The
        	caller may abort an ongoing rendering of a page. Cookie also
        	communicates progress information back to the caller. The
        	fields inside cookie are continually updated while the page is
        	rendering.
        """
        return _mupdf.FzDocument_fz_run_document_structure(self, dev, cookie)

    def fz_save_accelerator(self, accel):
        r"""
        Class-aware wrapper for `::fz_save_accelerator()`.
        	Save accelerator data for the document to a given file.
        """
        return _mupdf.FzDocument_fz_save_accelerator(self, accel)

    def fz_search_chapter_page_number(self, chapter, page, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_chapter_page_number()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_chapter_page_number(int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
        """
        return _mupdf.FzDocument_fz_search_chapter_page_number(self, chapter, page, needle, hit_mark, hit_bbox, hit_max)

    def fz_search_chapter_page_number_cb(self, chapter, page, needle, cb, opaque):
        r"""Class-aware wrapper for `::fz_search_chapter_page_number_cb()`."""
        return _mupdf.FzDocument_fz_search_chapter_page_number_cb(self, chapter, page, needle, cb, opaque)

    def fz_search_page2(self, number, needle, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_page2()`.
        C++ alternative to fz_search_page() that returns information in a std::vector.
        """
        return _mupdf.FzDocument_fz_search_page2(self, number, needle, hit_max)

    def fz_search_page_number(self, number, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_page_number()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_page_number(int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
        """
        return _mupdf.FzDocument_fz_search_page_number(self, number, needle, hit_mark, hit_bbox, hit_max)

    def fz_search_page_number_cb(self, number, needle, cb, opaque):
        r"""Class-aware wrapper for `::fz_search_page_number_cb()`."""
        return _mupdf.FzDocument_fz_search_page_number_cb(self, number, needle, cb, opaque)

    def fz_set_metadata(self, key, value):
        r"""Class-aware wrapper for `::fz_set_metadata()`."""
        return _mupdf.FzDocument_fz_set_metadata(self, key, value)

    def pdf_count_pages_imp(self, chapter):
        r"""Class-aware wrapper for `::pdf_count_pages_imp()`."""
        return _mupdf.FzDocument_pdf_count_pages_imp(self, chapter)

    def pdf_document_from_fz_document(self):
        r"""Class-aware wrapper for `::pdf_document_from_fz_document()`."""
        return _mupdf.FzDocument_pdf_document_from_fz_document(self)

    def pdf_load_page_imp(self, chapter, number):
        r"""Class-aware wrapper for `::pdf_load_page_imp()`."""
        return _mupdf.FzDocument_pdf_load_page_imp(self, chapter, number)

    def pdf_page_label_imp(self, chapter, page, buf, size):
        r"""Class-aware wrapper for `::pdf_page_label_imp()`."""
        return _mupdf.FzDocument_pdf_page_label_imp(self, chapter, page, buf, size)

    def pdf_specifics(self):
        r"""Class-aware wrapper for `::pdf_specifics()`."""
        return _mupdf.FzDocument_pdf_specifics(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_open_accelerated_document()`.
        		Open a document file and read its basic structure so pages and
        		objects can be located. MuPDF will try to repair broken
        		documents (without actually changing the file contents).

        		The returned fz_document is used when calling most other
        		document related functions.

        		filename: a path to a file as it would be given to open(2).


        |

        *Overload 2:*
         Constructor using `fz_open_accelerated_document_with_stream()`.
        		Open a document using the specified stream object rather than
        		opening a file on disk.

        		magic: a string used to detect document type; either a file name
        		or mime-type.

        		stream: a stream of the document contents.

        		accel: NULL, or a stream of the 'accelerator' contents for this document.

        		NOTE: The caller retains ownership of 'stream' and 'accel' - the document will
        		take its own references if required.


        |

        *Overload 3:*
         Constructor using `fz_open_accelerated_document_with_stream_and_dir()`.
        		Open a document using the specified stream object rather than
        		opening a file on disk.

        		magic: a string used to detect document type; either a file name
        		or mime-type.

        		stream: a stream of the document contents.

        		accel: NULL, or a stream of the 'accelerator' contents for this document.

        		dir: NULL, or the 'directory context' for the stream contents.

        		NOTE: The caller retains ownership of 'stream', 'accel' and 'dir' - the document will
        		take its own references if required.


        |

        *Overload 4:*
         Constructor using `fz_open_document()`.
        		Open a document file and read its basic structure so pages and
        		objects can be located. MuPDF will try to repair broken
        		documents (without actually changing the file contents).

        		The returned fz_document is used when calling most other
        		document related functions.

        		filename: a path to a file as it would be given to open(2).


        |

        *Overload 5:*
         Constructor using `fz_open_document_with_buffer()`.
        		Open a document using a buffer rather than opening a file on disk.


        |

        *Overload 6:*
         Constructor using `fz_open_document_with_stream()`.
        		Open a document using the specified stream object rather than
        		opening a file on disk.

        		magic: a string used to detect document type; either a file name
        		or mime-type.

        		stream: a stream representing the contents of the document file.

        		NOTE: The caller retains ownership of 'stream' - the document will take its
        		own reference if required.


        |

        *Overload 7:*
         Constructor using `fz_open_document_with_stream_and_dir()`.
        		Open a document using the specified stream object rather than
        		opening a file on disk.

        		magic: a string used to detect document type; either a file name
        		or mime-type.

        		stream: a stream representing the contents of the document file.

        		dir: a 'directory context' for those filetypes that need it.

        		NOTE: The caller retains ownership of 'stream' and 'dir' - the document will
        		take its own references if required.


        |

        *Overload 8:*
         Returns a FzDocument for pdfdocument.m_internal.super.

        |

        *Overload 9:*
         Copy constructor using `fz_keep_document()`.

        |

        *Overload 10:*
         Constructor using raw copy of pre-existing `::fz_document`.

        |

        *Overload 11:*
         Constructor using raw copy of pre-existing `::fz_document`.
        """
        _mupdf.FzDocument_swiginit(self, _mupdf.new_FzDocument(*args))
    __swig_destroy__ = _mupdf.delete_FzDocument

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDocument_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzDocument___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzDocument_m_internal_get, _mupdf.FzDocument_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDocument_s_num_instances_get, _mupdf.FzDocument_s_num_instances_set)

# Register FzDocument in _mupdf:
_mupdf.FzDocument_swigregister(FzDocument)
class FzDocumentHandler(object):
    r"""Wrapper class for struct `fz_document_handler`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_document_handler_open(self, stream, accel, dir, recognize_state):
        r"""
        Class-aware wrapper for `::fz_document_handler_open()`.   Helper for calling `fz_document_handler::open` function pointer via
        Swig from Python/C#.
        """
        return _mupdf.FzDocumentHandler_fz_document_handler_open(self, stream, accel, dir, recognize_state)

    def fz_document_handler_recognize(self, magic):
        r"""
        Class-aware wrapper for `::fz_document_handler_recognize()`.   Helper for calling a `fz_document_handler::recognize` function
        pointer via Swig from Python/C#.
        """
        return _mupdf.FzDocumentHandler_fz_document_handler_recognize(self, magic)

    def fz_register_document_handler(self):
        r"""
        Class-aware wrapper for `::fz_register_document_handler()`.
        	Register a handler for a document type.

        	handler: The handler to register. This must live on for the duration of the
        	use of this handler. It will be passed back to the handler for calls so
        	the caller can use it to retrieve state.
        """
        return _mupdf.FzDocumentHandler_fz_register_document_handler(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_document_handler`.
        """
        _mupdf.FzDocumentHandler_swiginit(self, _mupdf.new_FzDocumentHandler(*args))
    __swig_destroy__ = _mupdf.delete_FzDocumentHandler

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDocumentHandler_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzDocumentHandler___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzDocumentHandler_m_internal_get, _mupdf.FzDocumentHandler_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDocumentHandler_s_num_instances_get, _mupdf.FzDocumentHandler_s_num_instances_set)

# Register FzDocumentHandler in _mupdf:
_mupdf.FzDocumentHandler_swigregister(FzDocumentHandler)
class FzDocumentHandlerContext(object):
    r"""Wrapper class for struct `fz_document_handler_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_document_handler_context`.
        """
        _mupdf.FzDocumentHandlerContext_swiginit(self, _mupdf.new_FzDocumentHandlerContext(*args))
    __swig_destroy__ = _mupdf.delete_FzDocumentHandlerContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDocumentHandlerContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzDocumentHandlerContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzDocumentHandlerContext_m_internal_get, _mupdf.FzDocumentHandlerContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDocumentHandlerContext_s_num_instances_get, _mupdf.FzDocumentHandlerContext_s_num_instances_set)

# Register FzDocumentHandlerContext in _mupdf:
_mupdf.FzDocumentHandlerContext_swigregister(FzDocumentHandlerContext)
class FzDocumentWriter(object):
    r"""Wrapper class for struct `fz_document_writer`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PathType_CBZ = _mupdf.FzDocumentWriter_PathType_CBZ
    PathType_DOCX = _mupdf.FzDocumentWriter_PathType_DOCX
    PathType_ODT = _mupdf.FzDocumentWriter_PathType_ODT
    PathType_PAM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PAM_PIXMAP
    PathType_PBM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PBM_PIXMAP
    PathType_PCL = _mupdf.FzDocumentWriter_PathType_PCL
    PathType_PCLM = _mupdf.FzDocumentWriter_PathType_PCLM
    PathType_PDF = _mupdf.FzDocumentWriter_PathType_PDF
    PathType_PDFOCR = _mupdf.FzDocumentWriter_PathType_PDFOCR
    PathType_PGM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PGM_PIXMAP
    PathType_PKM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PKM_PIXMAP
    PathType_PNG_PIXMAP = _mupdf.FzDocumentWriter_PathType_PNG_PIXMAP
    PathType_PNM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PNM_PIXMAP
    PathType_PPM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PPM_PIXMAP
    PathType_PS = _mupdf.FzDocumentWriter_PathType_PS
    PathType_PWG = _mupdf.FzDocumentWriter_PathType_PWG
    PathType_SVG = _mupdf.FzDocumentWriter_PathType_SVG
    OutputType_CBZ = _mupdf.FzDocumentWriter_OutputType_CBZ
    OutputType_DOCX = _mupdf.FzDocumentWriter_OutputType_DOCX
    OutputType_ODT = _mupdf.FzDocumentWriter_OutputType_ODT
    OutputType_PCL = _mupdf.FzDocumentWriter_OutputType_PCL
    OutputType_PCLM = _mupdf.FzDocumentWriter_OutputType_PCLM
    OutputType_PDF = _mupdf.FzDocumentWriter_OutputType_PDF
    OutputType_PDFOCR = _mupdf.FzDocumentWriter_OutputType_PDFOCR
    OutputType_PS = _mupdf.FzDocumentWriter_OutputType_PS
    OutputType_PWG = _mupdf.FzDocumentWriter_OutputType_PWG
    FormatPathType_DOCUMENT = _mupdf.FzDocumentWriter_FormatPathType_DOCUMENT
    FormatPathType_TEXT = _mupdf.FzDocumentWriter_FormatPathType_TEXT

    def fz_begin_page(self, mediabox):
        r"""
        Class-aware wrapper for `::fz_begin_page()`.
        	Called to start the process of writing a page to
        	a document.

        	mediabox: page size rectangle in points.

        	Returns a borrowed fz_device to write page contents to. This
        	should be kept if required, and only dropped if it was kept.
        """
        return _mupdf.FzDocumentWriter_fz_begin_page(self, mediabox)

    def fz_close_document_writer(self):
        r"""
        Class-aware wrapper for `::fz_close_document_writer()`.
        	Called to end the process of writing
        	pages to a document.

        	This writes any file level trailers required. After this
        	completes successfully the file is up to date and complete.
        """
        return _mupdf.FzDocumentWriter_fz_close_document_writer(self)

    def fz_end_page(self):
        r"""
        Class-aware wrapper for `::fz_end_page()`.
        	Called to end the process of writing a page to a
        	document.
        """
        return _mupdf.FzDocumentWriter_fz_end_page(self)

    def fz_pdfocr_writer_set_progress(self, progress, arg_2):
        r"""Class-aware wrapper for `::fz_pdfocr_writer_set_progress()`."""
        return _mupdf.FzDocumentWriter_fz_pdfocr_writer_set_progress(self, progress, arg_2)

    def fz_write_document(self, doc):
        r"""
        Class-aware wrapper for `::fz_write_document()`.
        	Convenience function to feed all the pages of a document to
        	fz_begin_page/fz_run_page/fz_end_page.
        """
        return _mupdf.FzDocumentWriter_fz_write_document(self, doc)

    def fz_write_stabilized_story(self, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir):
        r"""Class-aware wrapper for `::fz_write_stabilized_story()`."""
        return _mupdf.FzDocumentWriter_fz_write_stabilized_story(self, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir)

    def fz_write_story(self, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref):
        r"""Class-aware wrapper for `::fz_write_story()`."""
        return _mupdf.FzDocumentWriter_fz_write_story(self, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_document_writer_of_size()`.
        		Internal function to allocate a
        		block for a derived document_writer structure, with the base
        		structure's function pointers populated correctly, and the extra
        		space zero initialised.


        |

        *Overload 2:*
         Constructor using `fz_new_document_writer_with_buffer()`.

        |

        *Overload 3:*
         Constructor using `fz_new_jpeg_pixmap_writer()`.

        |

        *Overload 4:*
         Constructor using `fz_new_pixmap_writer()`.

        |

        *Overload 5:*
         Constructor using `fz_new_svg_writer_with_output()`.

        |

        *Overload 6:*
         Constructor using one of:
        		fz_new_cbz_writer()
        		fz_new_docx_writer()
        		fz_new_odt_writer()
        		fz_new_pam_pixmap_writer()
        		fz_new_pbm_pixmap_writer()
        		fz_new_pcl_writer()
        		fz_new_pclm_writer()
        		fz_new_pdf_writer()
        		fz_new_pdfocr_writer()
        		fz_new_pgm_pixmap_writer()
        		fz_new_pkm_pixmap_writer()
        		fz_new_png_pixmap_writer()
        		fz_new_pnm_pixmap_writer()
        		fz_new_ppm_pixmap_writer()
        		fz_new_ps_writer()
        		fz_new_pwg_writer()
        		fz_new_svg_writer()


        |

        *Overload 7:*
         Constructor using one of:
        		fz_new_cbz_writer_with_output()
        		fz_new_docx_writer_with_output()
        		fz_new_odt_writer_with_output()
        		fz_new_pcl_writer_with_output()
        		fz_new_pclm_writer_with_output()
        		fz_new_pdf_writer_with_output()
        		fz_new_pdfocr_writer_with_output()
        		fz_new_ps_writer_with_output()
        		fz_new_pwg_writer_with_output()

        	This constructor takes ownership of <out> -
        	out.m_internal is set to NULL after this constructor
        	returns so <out> must not be used again.


        |

        *Overload 8:*
         Constructor using one of:
        		fz_new_document_writer()
        		fz_new_text_writer()


        |

        *Overload 9:*
         Constructor using fz_new_document_writer_with_output().

        	This constructor takes ownership of <out> -
        	out.m_internal is set to NULL after this constructor
        	returns so <out> must not be used again.


        |

        *Overload 10:*
         Constructor using fz_new_text_writer_with_output().

        	This constructor takes ownership of <out> -
        	out.m_internal is set to NULL after this constructor
        	returns so <out> must not be used again.


        |

        *Overload 11:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 12:*
         Constructor using raw copy of pre-existing `::fz_document_writer`.
        """
        _mupdf.FzDocumentWriter_swiginit(self, _mupdf.new_FzDocumentWriter(*args))
    __swig_destroy__ = _mupdf.delete_FzDocumentWriter

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDocumentWriter_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzDocumentWriter___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzDocumentWriter_m_internal_get, _mupdf.FzDocumentWriter_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDocumentWriter_s_num_instances_get, _mupdf.FzDocumentWriter_s_num_instances_set)

# Register FzDocumentWriter in _mupdf:
_mupdf.FzDocumentWriter_swigregister(FzDocumentWriter)
class FzDrawOptions(object):
    r"""
    Wrapper class for struct `fz_draw_options`. Not copyable or assignable.
    struct fz_draw_options: Options for creating a pixmap and draw
    device.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_parse_draw_options()`.
        		Parse draw device options from a comma separated key-value string.


        |

        *Overload 2:*
         Default constructor, sets each member to default value.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_draw_options`.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_draw_options`.
        """
        _mupdf.FzDrawOptions_swiginit(self, _mupdf.new_FzDrawOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzDrawOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzDrawOptions
    rotate = property(_mupdf.FzDrawOptions_rotate_get, _mupdf.FzDrawOptions_rotate_set)
    x_resolution = property(_mupdf.FzDrawOptions_x_resolution_get, _mupdf.FzDrawOptions_x_resolution_set)
    y_resolution = property(_mupdf.FzDrawOptions_y_resolution_get, _mupdf.FzDrawOptions_y_resolution_set)
    width = property(_mupdf.FzDrawOptions_width_get, _mupdf.FzDrawOptions_width_set)
    height = property(_mupdf.FzDrawOptions_height_get, _mupdf.FzDrawOptions_height_set)
    colorspace = property(_mupdf.FzDrawOptions_colorspace_get, _mupdf.FzDrawOptions_colorspace_set)
    alpha = property(_mupdf.FzDrawOptions_alpha_get, _mupdf.FzDrawOptions_alpha_set)
    graphics = property(_mupdf.FzDrawOptions_graphics_get, _mupdf.FzDrawOptions_graphics_set)
    text = property(_mupdf.FzDrawOptions_text_get, _mupdf.FzDrawOptions_text_set)
    s_num_instances = property(_mupdf.FzDrawOptions_s_num_instances_get, _mupdf.FzDrawOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzDrawOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzDrawOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzDrawOptions___ne__(self, rhs)

# Register FzDrawOptions in _mupdf:
_mupdf.FzDrawOptions_swigregister(FzDrawOptions)
class FzErrorContext(object):
    r"""Wrapper class for struct `fz_error_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_error_context`.
        """
        _mupdf.FzErrorContext_swiginit(self, _mupdf.new_FzErrorContext(*args))
    __swig_destroy__ = _mupdf.delete_FzErrorContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzErrorContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzErrorContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzErrorContext_m_internal_get, _mupdf.FzErrorContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzErrorContext_s_num_instances_get, _mupdf.FzErrorContext_s_num_instances_set)

# Register FzErrorContext in _mupdf:
_mupdf.FzErrorContext_swigregister(FzErrorContext)
class FzErrorStackSlot(object):
    r"""Wrapper class for struct `fz_error_stack_slot`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_error_stack_slot`.
        """
        _mupdf.FzErrorStackSlot_swiginit(self, _mupdf.new_FzErrorStackSlot(*args))
    __swig_destroy__ = _mupdf.delete_FzErrorStackSlot

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzErrorStackSlot_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzErrorStackSlot___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzErrorStackSlot_m_internal_get, _mupdf.FzErrorStackSlot_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzErrorStackSlot_s_num_instances_get, _mupdf.FzErrorStackSlot_s_num_instances_set)

# Register FzErrorStackSlot in _mupdf:
_mupdf.FzErrorStackSlot_swigregister(FzErrorStackSlot)
class FzFont(object):
    r"""
    Wrapper class for struct `fz_font`.
    An abstract font handle.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_advance_glyph(self, glyph, wmode):
        r"""
        Class-aware wrapper for `::fz_advance_glyph()`.
        	Return the advance for a given glyph.

        	font: The font to look for the glyph in.

        	glyph: The glyph to find the advance for.

        	wmode: 1 for vertical mode, 0 for horizontal.

        	Returns the advance for the glyph.
        """
        return _mupdf.FzFont_fz_advance_glyph(self, glyph, wmode)

    def fz_bound_glyph(self, gid, trm):
        r"""
        Class-aware wrapper for `::fz_bound_glyph()`.
        	Return a bbox for a given glyph in a font.

        	font: The font to look for the glyph in.

        	gid: The glyph to bound.

        	trm: The matrix to apply to the glyph before bounding.

        	Returns rectangle by value containing the bounds of the given
        	glyph.
        """
        return _mupdf.FzFont_fz_bound_glyph(self, gid, trm)

    def fz_decouple_type3_font(self, t3doc):
        r"""Class-aware wrapper for `::fz_decouple_type3_font()`."""
        return _mupdf.FzFont_fz_decouple_type3_font(self, t3doc)

    def fz_encode_character(self, unicode):
        r"""
        Class-aware wrapper for `::fz_encode_character()`.
        	Find the glyph id for a given unicode
        	character within a font.

        	font: The font to look for the unicode character in.

        	unicode: The unicode character to encode.

        	Returns the glyph id for the given unicode value, or 0 if
        	unknown.
        """
        return _mupdf.FzFont_fz_encode_character(self, unicode)

    def fz_encode_character_by_glyph_name(self, glyphname):
        r"""
        Class-aware wrapper for `::fz_encode_character_by_glyph_name()`.
        	Encode character.

        	Either by direct lookup of glyphname within a font, or, failing
        	that, by mapping glyphname to unicode and thence to the glyph
        	index within the given font.

        	Returns zero for type3 fonts.
        """
        return _mupdf.FzFont_fz_encode_character_by_glyph_name(self, glyphname)

    def fz_encode_character_sc(self, unicode):
        r"""
        Class-aware wrapper for `::fz_encode_character_sc()`.
        	Encode character, preferring small-caps variant if available.

        	font: The font to look for the unicode character in.

        	unicode: The unicode character to encode.

        	Returns the glyph id for the given unicode value, or 0 if
        	unknown.
        """
        return _mupdf.FzFont_fz_encode_character_sc(self, unicode)

    def fz_encode_character_with_fallback(self, unicode, script, language, out_font):
        r"""
        Class-aware wrapper for `::fz_encode_character_with_fallback()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_encode_character_with_fallback(int unicode, int script, int language, ::fz_font **out_font)` => `(int)`

        	Find the glyph id for
        	a given unicode character within a font, falling back to
        	an alternative if not found.

        	font: The font to look for the unicode character in.

        	unicode: The unicode character to encode.

        	script: The script in use.

        	language: The language in use.

        	out_font: The font handle in which the given glyph represents
        	the requested unicode character. The caller does not own the
        	reference it is passed, so should call fz_keep_font if it is
        	not simply to be used immediately.

        	Returns the glyph id for the given unicode value in the supplied
        	font (and sets *out_font to font) if it is present. Otherwise
        	an alternative fallback font (based on script/language) is
        	searched for. If the glyph is found therein, *out_font is set
        	to this reference, and the glyph reference is returned. If it
        	cannot be found anywhere, the function returns 0.
        """
        return _mupdf.FzFont_fz_encode_character_with_fallback(self, unicode, script, language, out_font)

    def fz_enumerate_font_cmap(self, cb, opaque):
        r"""
        Class-aware wrapper for `::fz_enumerate_font_cmap()`.
        	Enumerate a cmap using a callback.
        """
        return _mupdf.FzFont_fz_enumerate_font_cmap(self, cb, opaque)

    def fz_enumerate_font_cmap2(self):
        r"""Class-aware wrapper for `::fz_enumerate_font_cmap2()`.   SWIG-friendly wrapper for fz_enumerate_font_cmap()."""
        return _mupdf.FzFont_fz_enumerate_font_cmap2(self)

    def fz_extract_ttf_from_ttc(self):
        r"""Class-aware wrapper for `::fz_extract_ttf_from_ttc()`."""
        return _mupdf.FzFont_fz_extract_ttf_from_ttc(self)

    def fz_font_ascender(self):
        r"""
        Class-aware wrapper for `::fz_font_ascender()`.
        	Retrieve font ascender in ems.
        """
        return _mupdf.FzFont_fz_font_ascender(self)

    def fz_font_bbox(self):
        r"""
        Class-aware wrapper for `::fz_font_bbox()`.
        	Retrieve the font bbox.

        	font: The font to query.

        	Returns the font bbox by value; it is valid only if
        	fz_font_flags(font)->invalid_bbox is zero.
        """
        return _mupdf.FzFont_fz_font_bbox(self)

    def fz_font_descender(self):
        r"""
        Class-aware wrapper for `::fz_font_descender()`.
        	Retrieve font descender in ems.
        """
        return _mupdf.FzFont_fz_font_descender(self)

    def fz_font_digest(self, digest):
        r"""
        Class-aware wrapper for `::fz_font_digest()`.
        	Retrieve the MD5 digest for the font's data.
        """
        return _mupdf.FzFont_fz_font_digest(self, digest)

    def fz_font_ft_face(self):
        r"""
        Class-aware wrapper for `::fz_font_ft_face()`.
        	Retrieve the FT_Face handle
        	for the font.

        	font: The font to query

        	Returns the FT_Face handle for the font, or NULL
        	if not a freetype handled font. (Cast to void *
        	to avoid nasty header exposure).
        """
        return _mupdf.FzFont_fz_font_ft_face(self)

    def fz_font_is_bold(self):
        r"""
        Class-aware wrapper for `::fz_font_is_bold()`.
        	Query whether the font flags say that this font is bold.
        """
        return _mupdf.FzFont_fz_font_is_bold(self)

    def fz_font_is_italic(self):
        r"""
        Class-aware wrapper for `::fz_font_is_italic()`.
        	Query whether the font flags say that this font is italic.
        """
        return _mupdf.FzFont_fz_font_is_italic(self)

    def fz_font_is_monospaced(self):
        r"""
        Class-aware wrapper for `::fz_font_is_monospaced()`.
        	Query whether the font flags say that this font is monospaced.
        """
        return _mupdf.FzFont_fz_font_is_monospaced(self)

    def fz_font_is_serif(self):
        r"""
        Class-aware wrapper for `::fz_font_is_serif()`.
        	Query whether the font flags say that this font is serif.
        """
        return _mupdf.FzFont_fz_font_is_serif(self)

    def fz_font_name(self):
        r"""
        Class-aware wrapper for `::fz_font_name()`.
        	Retrieve a pointer to the name of the font.

        	font: The font to query.

        	Returns a pointer to an internal copy of the font name.
        	Will never be NULL, but may be the empty string.
        """
        return _mupdf.FzFont_fz_font_name(self)

    def fz_font_t3_procs(self):
        r"""
        Class-aware wrapper for `::fz_font_t3_procs()`.
        	Retrieve the Type3 procs
        	for a font.

        	font: The font to query

        	Returns the t3_procs pointer. Will be NULL for a
        	non type-3 font.
        """
        return _mupdf.FzFont_fz_font_t3_procs(self)

    def fz_get_glyph_name(self, glyph, buf, size):
        r"""
        Class-aware wrapper for `::fz_get_glyph_name()`.
        	Find the name of a glyph

        	font: The font to look for the glyph in.

        	glyph: The glyph id to look for.

        	buf: Pointer to a buffer for the name to be inserted into.

        	size: The size of the buffer.

        	If a font contains a name table, then the name of the glyph
        	will be returned in the supplied buffer. Otherwise a name
        	is synthesised. The name will be truncated to fit in
        	the buffer.
        """
        return _mupdf.FzFont_fz_get_glyph_name(self, glyph, buf, size)

    def fz_get_glyph_name2(self, glyph):
        r"""
        Class-aware wrapper for `::fz_get_glyph_name2()`.
        C++ alternative to fz_get_glyph_name() that returns information in a std::string.
        """
        return _mupdf.FzFont_fz_get_glyph_name2(self, glyph)

    def fz_glyph_cacheable(self, gid):
        r"""
        Class-aware wrapper for `::fz_glyph_cacheable()`.
        	Determine if a given glyph in a font
        	is cacheable. Certain glyphs in a type 3 font cannot safely
        	be cached, as their appearance depends on the enclosing
        	graphic state.

        	font: The font to look for the glyph in.

        	gif: The glyph to query.

        	Returns non-zero if cacheable, 0 if not.
        """
        return _mupdf.FzFont_fz_glyph_cacheable(self, gid)

    def fz_measure_string(self, trm, s, wmode, bidi_level, markup_dir, language):
        r"""
        Class-aware wrapper for `::fz_measure_string()`.
        	Measure the advance width of a UTF8 string should it be added to a text object.

        	This uses the same layout algorithms as fz_show_string, and can be used
        	to calculate text alignment adjustments.
        """
        return _mupdf.FzFont_fz_measure_string(self, trm, s, wmode, bidi_level, markup_dir, language)

    def fz_outline_glyph(self, gid, ctm):
        r"""
        Class-aware wrapper for `::fz_outline_glyph()`.
        	Look a glyph up from a font, and return the outline of the
        	glyph using the given transform.

        	The caller owns the returned path, and so is responsible for
        	ensuring that it eventually gets dropped.
        """
        return _mupdf.FzFont_fz_outline_glyph(self, gid, ctm)

    def fz_prepare_t3_glyph(self, gid):
        r"""
        Class-aware wrapper for `::fz_prepare_t3_glyph()`.
        	Force a type3 font to cache the displaylist for a given glyph
        	id.

        	This caching can involve reading the underlying file, so must
        	happen ahead of time, so we aren't suddenly forced to read the
        	file while playing a displaylist back.
        """
        return _mupdf.FzFont_fz_prepare_t3_glyph(self, gid)

    def fz_render_glyph_pixmap(self, gid, ctm, scissor, aa):
        r"""
        Class-aware wrapper for `::fz_render_glyph_pixmap()`.
        	Create a pixmap containing a rendered glyph.

        	Lookup gid from font, clip it with scissor, and rendering it
        	with aa bits of antialiasing into a new pixmap.

        	The caller takes ownership of the pixmap and so must free it.

        	Note: This function is no longer used for normal rendering
        	operations, and is kept around just because we use it in the
        	app. It should be considered "at risk" of removal from the API.
        """
        return _mupdf.FzFont_fz_render_glyph_pixmap(self, gid, ctm, scissor, aa)

    def fz_run_t3_glyph(self, gid, trm, dev):
        r"""
        Class-aware wrapper for `::fz_run_t3_glyph()`.
        	Run a glyph from a Type3 font to
        	a given device.

        	font: The font to find the glyph in.

        	gid: The glyph to run.

        	trm: The transform to apply.

        	dev: The device to render onto.
        """
        return _mupdf.FzFont_fz_run_t3_glyph(self, gid, trm, dev)

    def fz_set_font_bbox(self, xmin, ymin, xmax, ymax):
        r"""
        Class-aware wrapper for `::fz_set_font_bbox()`.
        	Set the font bbox.

        	font: The font to set the bbox for.

        	xmin, ymin, xmax, ymax: The bounding box.
        """
        return _mupdf.FzFont_fz_set_font_bbox(self, xmin, ymin, xmax, ymax)

    def fz_set_font_embedding(self, embed):
        r"""
        Class-aware wrapper for `::fz_set_font_embedding()`.
        	Control whether a given font should be embedded or not when writing.
        """
        return _mupdf.FzFont_fz_set_font_embedding(self, embed)

    def pdf_font_writing_supported(self):
        r"""Class-aware wrapper for `::pdf_font_writing_supported()`."""
        return _mupdf.FzFont_pdf_font_writing_supported(self)

    def pdf_layout_fit_text(self, lang, str, bounds):
        r"""Class-aware wrapper for `::pdf_layout_fit_text()`."""
        return _mupdf.FzFont_pdf_layout_fit_text(self, lang, str, bounds)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_base14_font()`.
        		Create a new font from one of the built-in fonts.


        |

        *Overload 2:*
         Constructor using `fz_new_builtin_font()`.

        |

        *Overload 3:*
         Constructor using `fz_new_cjk_font()`.

        |

        *Overload 4:*
         Constructor using `fz_new_font_from_buffer()`.
        		Create a new font from a font file in a fz_buffer.

        		Fonts created in this way, will be eligible for embedding by default.

        		name: Name of font (leave NULL to use name from font).

        		buffer: Buffer to load from.

        		index: Which font from the file to load (0 for default).

        		use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

        		Returns new font handle, or throws exception on error.


        |

        *Overload 5:*
         Constructor using `fz_new_font_from_file()`.
        		Create a new font from a font file.

        		Fonts created in this way, will be eligible for embedding by default.

        		name: Name of font (leave NULL to use name from font).

        		path: File path to load from.

        		index: Which font from the file to load (0 for default).

        		use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

        		Returns new font handle, or throws exception on error.


        |

        *Overload 6:*
         Constructor using `fz_new_font_from_memory()`.
        		Create a new font from a font file in memory.

        		Fonts created in this way, will be eligible for embedding by default.

        		name: Name of font (leave NULL to use name from font).

        		data: Pointer to the font file data.

        		len: Length of the font file data.

        		index: Which font from the file to load (0 for default).

        		use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

        		Returns new font handle, or throws exception on error.


        |

        *Overload 7:*
         Constructor using `fz_new_type3_font()`.
        		Create a new (empty) type3 font.

        		name: Name of font (or NULL).

        		matrix: Font matrix.

        		Returns a new font handle, or throws exception on
        		allocation failure.


        |

        *Overload 8:*
         Copy constructor using `fz_keep_font()`.

        |

        *Overload 9:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 10:*
         Constructor using raw copy of pre-existing `::fz_font`.
        """
        _mupdf.FzFont_swiginit(self, _mupdf.new_FzFont(*args))
    __swig_destroy__ = _mupdf.delete_FzFont

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzFont_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzFont___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzFont_m_internal_get, _mupdf.FzFont_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzFont_s_num_instances_get, _mupdf.FzFont_s_num_instances_set)

# Register FzFont in _mupdf:
_mupdf.FzFont_swigregister(FzFont)
class FzFontContext(object):
    r"""Wrapper class for struct `fz_font_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_font_context`.
        """
        _mupdf.FzFontContext_swiginit(self, _mupdf.new_FzFontContext(*args))
    __swig_destroy__ = _mupdf.delete_FzFontContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzFontContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzFontContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzFontContext_m_internal_get, _mupdf.FzFontContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzFontContext_s_num_instances_get, _mupdf.FzFontContext_s_num_instances_set)

# Register FzFontContext in _mupdf:
_mupdf.FzFontContext_swigregister(FzFontContext)
class FzFontFlagsT(object):
    r"""
    Wrapper class for struct `fz_font_flags_t`. Not copyable or assignable.
    Every fz_font carries a set of flags
    within it, in a fz_font_flags_t structure.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_font_flags_t`.
        """
        _mupdf.FzFontFlagsT_swiginit(self, _mupdf.new_FzFontFlagsT(*args))
    __swig_destroy__ = _mupdf.delete_FzFontFlagsT

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzFontFlagsT_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzFontFlagsT___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzFontFlagsT_m_internal_get, _mupdf.FzFontFlagsT_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzFontFlagsT_s_num_instances_get, _mupdf.FzFontFlagsT_s_num_instances_set)

# Register FzFontFlagsT in _mupdf:
_mupdf.FzFontFlagsT_swigregister(FzFontFlagsT)
class FzFunction(object):
    r"""Wrapper class for struct `fz_function`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_eval_function(self, _in, inlen, out, outlen):
        r"""
        Class-aware wrapper for `::fz_eval_function()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_eval_function(const float *in, int inlen, int outlen)` => float out
        """
        return _mupdf.FzFunction_fz_eval_function(self, _in, inlen, out, outlen)

    def fz_function_size(self):
        r"""Class-aware wrapper for `::fz_function_size()`."""
        return _mupdf.FzFunction_fz_function_size(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_new_function_of_size()`.

        |

        *Overload 2:*
        Copy constructor using `fz_keep_function()`.

        |

        *Overload 3:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_function`.
        """
        _mupdf.FzFunction_swiginit(self, _mupdf.new_FzFunction(*args))
    __swig_destroy__ = _mupdf.delete_FzFunction

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzFunction_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzFunction___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzFunction_m_internal_get, _mupdf.FzFunction_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzFunction_s_num_instances_get, _mupdf.FzFunction_s_num_instances_set)

# Register FzFunction in _mupdf:
_mupdf.FzFunction_swigregister(FzFunction)
class FzGetoptLongOptions(object):
    r"""Wrapper class for struct `fz_getopt_long_options`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_getopt_long_options`.
        """
        _mupdf.FzGetoptLongOptions_swiginit(self, _mupdf.new_FzGetoptLongOptions(*args))
    __swig_destroy__ = _mupdf.delete_FzGetoptLongOptions

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzGetoptLongOptions_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzGetoptLongOptions___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzGetoptLongOptions_m_internal_get, _mupdf.FzGetoptLongOptions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzGetoptLongOptions_s_num_instances_get, _mupdf.FzGetoptLongOptions_s_num_instances_set)

# Register FzGetoptLongOptions in _mupdf:
_mupdf.FzGetoptLongOptions_swigregister(FzGetoptLongOptions)
class FzGlyph(object):
    r"""
    Wrapper class for struct `fz_glyph`.
    Glyphs represent a run length encoded set of pixels for a 2
    dimensional region of a plane.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_glyph_bbox(self):
        r"""
        Class-aware wrapper for `::fz_glyph_bbox()`.
        	Return the bounding box of the glyph in pixels.
        """
        return _mupdf.FzGlyph_fz_glyph_bbox(self)

    def fz_glyph_bbox_no_ctx(self):
        r"""Class-aware wrapper for `::fz_glyph_bbox_no_ctx()`."""
        return _mupdf.FzGlyph_fz_glyph_bbox_no_ctx(self)

    def fz_glyph_height(self):
        r"""
        Class-aware wrapper for `::fz_glyph_height()`.
        	Return the height of the glyph in pixels.
        """
        return _mupdf.FzGlyph_fz_glyph_height(self)

    def fz_glyph_width(self):
        r"""
        Class-aware wrapper for `::fz_glyph_width()`.
        	Return the width of the glyph in pixels.
        """
        return _mupdf.FzGlyph_fz_glyph_width(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_glyph()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_glyph`.
        """
        _mupdf.FzGlyph_swiginit(self, _mupdf.new_FzGlyph(*args))
    __swig_destroy__ = _mupdf.delete_FzGlyph

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzGlyph_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzGlyph___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzGlyph_m_internal_get, _mupdf.FzGlyph_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzGlyph_s_num_instances_get, _mupdf.FzGlyph_s_num_instances_set)

# Register FzGlyph in _mupdf:
_mupdf.FzGlyph_swigregister(FzGlyph)
class FzGlyphCache(object):
    r"""Wrapper class for struct `fz_glyph_cache`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_glyph_cache`.
        """
        _mupdf.FzGlyphCache_swiginit(self, _mupdf.new_FzGlyphCache(*args))
    __swig_destroy__ = _mupdf.delete_FzGlyphCache

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzGlyphCache_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzGlyphCache___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzGlyphCache_m_internal_get, _mupdf.FzGlyphCache_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzGlyphCache_s_num_instances_get, _mupdf.FzGlyphCache_s_num_instances_set)

# Register FzGlyphCache in _mupdf:
_mupdf.FzGlyphCache_swigregister(FzGlyphCache)
class FzHalftone(object):
    r"""
    Wrapper class for struct `fz_halftone`.
    A halftone is a set of threshold tiles, one per component. Each
    threshold tile is a pixmap, possibly of varying sizes and
    phases. Currently, we only provide one 'default' halftone tile
    for operating on 1 component plus alpha pixmaps (where the alpha
    is ignored). This is signified by a fz_halftone pointer to NULL.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_halftone()`.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_halftone`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_halftone`.
        """
        _mupdf.FzHalftone_swiginit(self, _mupdf.new_FzHalftone(*args))
    __swig_destroy__ = _mupdf.delete_FzHalftone

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzHalftone_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzHalftone___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzHalftone_m_internal_get, _mupdf.FzHalftone_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzHalftone_s_num_instances_get, _mupdf.FzHalftone_s_num_instances_set)

# Register FzHalftone in _mupdf:
_mupdf.FzHalftone_swigregister(FzHalftone)
class FzHashTable(object):
    r"""
    Wrapper class for struct `fz_hash_table`. Not copyable or assignable.
    Generic hash-table with fixed-length keys.

    The keys and values are NOT reference counted by the hash table.
    Callers are responsible for taking care the reference counts are
    correct. Inserting a duplicate entry will NOT overwrite the old
    value, and will return the old value.

    The drop_val callback function is only used to release values
    when the hash table is destroyed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_hash_filter(self, state, callback):
        r"""
        Class-aware wrapper for `::fz_hash_filter()`.
        	Iterate over the entries in a hash table, removing all the ones where callback returns true.
        	Does NOT free the value of the entry, so the caller is expected to take care of this.
        """
        return _mupdf.FzHashTable_fz_hash_filter(self, state, callback)

    def fz_hash_find(self, key):
        r"""
        Class-aware wrapper for `::fz_hash_find()`.
        	Search for a matching hash within the table, and return the
        	associated value.
        """
        return _mupdf.FzHashTable_fz_hash_find(self, key)

    def fz_hash_for_each(self, state, callback):
        r"""
        Class-aware wrapper for `::fz_hash_for_each()`.
        	Iterate over the entries in a hash table.
        """
        return _mupdf.FzHashTable_fz_hash_for_each(self, state, callback)

    def fz_hash_insert(self, key, val):
        r"""
        Class-aware wrapper for `::fz_hash_insert()`.
        	Insert a new key/value pair into the hash table.

        	If an existing entry with the same key is found, no change is
        	made to the hash table, and a pointer to the existing value is
        	returned.

        	If no existing entry with the same key is found, ownership of
        	val passes in, key is copied, and NULL is returned.
        """
        return _mupdf.FzHashTable_fz_hash_insert(self, key, val)

    def fz_hash_remove(self, key):
        r"""
        Class-aware wrapper for `::fz_hash_remove()`.
        	Remove the entry for a given key.

        	The value is NOT freed, so the caller is expected to take care
        	of this.
        """
        return _mupdf.FzHashTable_fz_hash_remove(self, key)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_hash_table()`.
        		Create a new hash table.

        		initialsize: The initial size of the hashtable. The hashtable
        		may grow (double in size) if it starts to get crowded (80%
        		full).

        		keylen: byte length for each key.

        		lock: -1 for no lock, otherwise the FZ_LOCK to use to protect
        		this table.

        		drop_val: Function to use to destroy values on table drop.


        |

        *Overload 2:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_hash_table`.
        """
        _mupdf.FzHashTable_swiginit(self, _mupdf.new_FzHashTable(*args))
    __swig_destroy__ = _mupdf.delete_FzHashTable

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzHashTable_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzHashTable___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzHashTable_m_internal_get, _mupdf.FzHashTable_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzHashTable_s_num_instances_get, _mupdf.FzHashTable_s_num_instances_set)

# Register FzHashTable in _mupdf:
_mupdf.FzHashTable_swigregister(FzHashTable)
class FzIccProfile(object):
    r"""
    Wrapper class for struct `fz_icc_profile`. Not copyable or assignable.
    Opaque type for an ICC Profile.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_icc_profile`.
        """
        _mupdf.FzIccProfile_swiginit(self, _mupdf.new_FzIccProfile(*args))
    __swig_destroy__ = _mupdf.delete_FzIccProfile

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzIccProfile_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzIccProfile___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzIccProfile_m_internal_get, _mupdf.FzIccProfile_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzIccProfile_s_num_instances_get, _mupdf.FzIccProfile_s_num_instances_set)

# Register FzIccProfile in _mupdf:
_mupdf.FzIccProfile_swigregister(FzIccProfile)
class FzImage(object):
    r"""
    Wrapper class for struct `fz_image`.
    Images are storable objects from which we can obtain fz_pixmaps.
    These may be implemented as simple wrappers around a pixmap, or
    as more complex things that decode at different subsample
    settings on demand.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_compressed_image_buffer(self):
        r"""
        Class-aware wrapper for `::fz_compressed_image_buffer()`.
        	Retrieve the underlying compressed data for an image.

        	Returns a pointer to the underlying data buffer for an image,
        	or NULL if this image is not based upon a compressed data
        	buffer.

        	This is not a reference counted structure, so no reference is
        	returned. Lifespan is limited to that of the image itself.
        """
        return _mupdf.FzImage_fz_compressed_image_buffer(self)

    def fz_compressed_image_type(self):
        r"""
        Class-aware wrapper for `::fz_compressed_image_type()`.
        	Return the type of a compressed image.

        	Any non-compressed image will have the type returned as UNKNOWN.
        """
        return _mupdf.FzImage_fz_compressed_image_type(self)

    def fz_get_pixmap_from_image(self, subarea, ctm, w, h):
        r"""
        Class-aware wrapper for `::fz_get_pixmap_from_image()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_get_pixmap_from_image(const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`

        	Called to get a handle to a pixmap from an image.

        	image: The image to retrieve a pixmap from.

        	subarea: The subarea of the image that we actually care about
        	(or NULL to indicate the whole image).

        	ctm: Optional, unless subarea is given. If given, then on
        	entry this is the transform that will be applied to the complete
        	image. It should be updated on exit to the transform to apply to
        	the given subarea of the image. This is used to calculate the
        	desired width/height for subsampling.

        	w: If non-NULL, a pointer to an int to be updated on exit to the
        	width (in pixels) that the scaled output will cover.

        	h: If non-NULL, a pointer to an int to be updated on exit to the
        	height (in pixels) that the scaled output will cover.

        	Returns a non NULL kept pixmap pointer. May throw exceptions.
        """
        return _mupdf.FzImage_fz_get_pixmap_from_image(self, subarea, ctm, w, h)

    def fz_get_unscaled_pixmap_from_image(self):
        r"""
        Class-aware wrapper for `::fz_get_unscaled_pixmap_from_image()`.
        	Calls fz_get_pixmap_from_image() with ctm, subarea, w and h all set to NULL.
        """
        return _mupdf.FzImage_fz_get_unscaled_pixmap_from_image(self)

    def fz_image_orientation(self):
        r"""
        Class-aware wrapper for `::fz_image_orientation()`.
        	Request the natural orientation of an image.

        	This is for images (such as JPEG) that can contain internal
        	specifications of rotation/flips. This is ignored by all the
        	internal decode/rendering routines, but can be used by callers
        	(such as the image document handler) to respect such
        	specifications.

        	The values used by MuPDF are as follows, with the equivalent
        	Exif specifications given for information:

        	0: Undefined
        	1: 0 degree ccw rotation. (Exif = 1)
        	2: 90 degree ccw rotation. (Exif = 8)
        	3: 180 degree ccw rotation. (Exif = 3)
        	4: 270 degree ccw rotation. (Exif = 6)
        	5: flip on X. (Exif = 2)
        	6: flip on X, then rotate ccw by 90 degrees. (Exif = 5)
        	7: flip on X, then rotate ccw by 180 degrees. (Exif = 4)
        	8: flip on X, then rotate ccw by 270 degrees. (Exif = 7)
        """
        return _mupdf.FzImage_fz_image_orientation(self)

    def fz_image_orientation_matrix(self):
        r"""Class-aware wrapper for `::fz_image_orientation_matrix()`."""
        return _mupdf.FzImage_fz_image_orientation_matrix(self)

    def fz_image_resolution(self, xres, yres):
        r"""
        Class-aware wrapper for `::fz_image_resolution()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_image_resolution()` => `(int xres, int yres)`

        	Request the natural resolution
        	of an image.

        	xres, yres: Pointers to ints to be updated with the
        	natural resolution of an image (or a sensible default
        	if not encoded).
        """
        return _mupdf.FzImage_fz_image_resolution(self, xres, yres)

    def fz_image_size(self):
        r"""
        Class-aware wrapper for `::fz_image_size()`.
        	Return the size of the storage used by an image.
        """
        return _mupdf.FzImage_fz_image_size(self)

    def fz_new_buffer_from_image_as_jpeg(self, color_params, quality, invert_cmyk):
        r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_jpeg()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_jpeg(self, color_params, quality, invert_cmyk)

    def fz_new_buffer_from_image_as_jpx(self, color_params, quality):
        r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_jpx()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_jpx(self, color_params, quality)

    def fz_new_buffer_from_image_as_pam(self, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_pam(self, color_params)

    def fz_new_buffer_from_image_as_png(self, color_params):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_image_as_png()`.
        	Reencode a given image as a PNG into a buffer.

        	Ownership of the buffer is returned.
        """
        return _mupdf.FzImage_fz_new_buffer_from_image_as_png(self, color_params)

    def fz_new_buffer_from_image_as_pnm(self, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_pnm(self, color_params)

    def fz_new_buffer_from_image_as_psd(self, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_psd(self, color_params)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_image_from_buffer()`.
        		Create a new image from a
        		buffer of data, inferring its type from the format
        		of the data.


        |

        *Overload 2:*
         Constructor using `fz_new_image_from_compressed_buffer()`.
        		Create an image based on
        		the data in the supplied compressed buffer.

        		w,h: Width and height of the created image.

        		bpc: Bits per component.

        		colorspace: The colorspace (determines the number of components,
        		and any color conversions required while decoding).

        		xres, yres: The X and Y resolutions respectively.

        		interpolate: 1 if interpolation should be used when decoding
        		this image, 0 otherwise.

        		imagemask: 1 if this is an imagemask (i.e. transparency bitmap
        		mask), 0 otherwise.

        		decode: NULL, or a pointer to to a decode array. The default
        		decode array is [0 1] (repeated n times, for n color components).

        		colorkey: NULL, or a pointer to a colorkey array. The default
        		colorkey array is [0 255] (repeated n times, for n color
        		components).

        		buffer: Buffer of compressed data and compression parameters.
        		Ownership of this reference is passed in.

        		mask: NULL, or another image to use as a mask for this one.
        		A new reference is taken to this image. Supplying a masked
        		image as a mask to another image is illegal!


        |

        *Overload 3:*
         Constructor using `fz_new_image_from_compressed_buffer2()`.  Swig-friendly wrapper for fz_new_image_from_compressed_buffer(),
        	uses specified `decode` and `colorkey` if they are not null (in which
        	case we assert that they have size `2*fz_colorspace_n(colorspace)`).

        |

        *Overload 4:*
         Constructor using `fz_new_image_from_display_list()`.
        		Create a new image from a display list.

        		w, h: The conceptual width/height of the image.

        		transform: The matrix that needs to be applied to the given
        		list to make it render to the unit square.

        		list: The display list.


        |

        *Overload 5:*
         Constructor using `fz_new_image_from_file()`.
        		Create a new image from the contents
        		of a file, inferring its type from the format of the
        		data.


        |

        *Overload 6:*
         Constructor using `fz_new_image_from_pixmap()`.
        		Create an image from the given
        		pixmap.

        		pixmap: The pixmap to base the image upon. A new reference
        		to this is taken.

        		mask: NULL, or another image to use as a mask for this one.
        		A new reference is taken to this image. Supplying a masked
        		image as a mask to another image is illegal!


        |

        *Overload 7:*
         Constructor using `fz_new_image_from_svg()`.
        		Create a scalable image from an SVG document.


        |

        *Overload 8:*
         Constructor using `fz_new_image_from_svg_xml()`.
        		Create a scalable image from an SVG document.


        |

        *Overload 9:*
         Constructor using `fz_new_image_of_size()`.
        		Internal function to make a new fz_image structure
        		for a derived class.

        		w,h: Width and height of the created image.

        		bpc: Bits per component.

        		colorspace: The colorspace (determines the number of components,
        		and any color conversions required while decoding).

        		xres, yres: The X and Y resolutions respectively.

        		interpolate: 1 if interpolation should be used when decoding
        		this image, 0 otherwise.

        		imagemask: 1 if this is an imagemask (i.e. transparent), 0
        		otherwise.

        		decode: NULL, or a pointer to to a decode array. The default
        		decode array is [0 1] (repeated n times, for n color components).

        		colorkey: NULL, or a pointer to a colorkey array. The default
        		colorkey array is [0 255] (repeated n times, for n color
        		components).

        		mask: NULL, or another image to use as a mask for this one.
        		A new reference is taken to this image. Supplying a masked
        		image as a mask to another image is illegal!

        		size: The size of the required allocated structure (the size of
        		the derived structure).

        		get: The function to be called to obtain a decoded pixmap.

        		get_size: The function to be called to return the storage size
        		used by this image.

        		drop: The function to be called to dispose of this image once
        		the last reference is dropped.

        		Returns a pointer to an allocated structure of the required size,
        		with the first sizeof(fz_image) bytes initialised as appropriate
        		given the supplied parameters, and the other bytes set to zero.


        |

        *Overload 10:*
         Copy constructor using `fz_keep_image()`.

        |

        *Overload 11:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 12:*
         Constructor using raw copy of pre-existing `::fz_image`.
        """
        _mupdf.FzImage_swiginit(self, _mupdf.new_FzImage(*args))

    def key_storable(self):
        return _mupdf.FzImage_key_storable(self)

    def w(self):
        return _mupdf.FzImage_w(self)

    def h(self):
        return _mupdf.FzImage_h(self)

    def n(self):
        return _mupdf.FzImage_n(self)

    def bpc(self):
        return _mupdf.FzImage_bpc(self)

    def imagemask(self):
        return _mupdf.FzImage_imagemask(self)

    def interpolate(self):
        return _mupdf.FzImage_interpolate(self)

    def use_colorkey(self):
        return _mupdf.FzImage_use_colorkey(self)

    def use_decode(self):
        return _mupdf.FzImage_use_decode(self)

    def decoded(self):
        return _mupdf.FzImage_decoded(self)

    def scalable(self):
        return _mupdf.FzImage_scalable(self)

    def orientation(self):
        return _mupdf.FzImage_orientation(self)

    def mask(self):
        return _mupdf.FzImage_mask(self)

    def xres(self):
        return _mupdf.FzImage_xres(self)

    def yres(self):
        return _mupdf.FzImage_yres(self)

    def colorspace(self):
        return _mupdf.FzImage_colorspace(self)

    def colorkey(self):
        return _mupdf.FzImage_colorkey(self)

    def decode(self):
        return _mupdf.FzImage_decode(self)
    __swig_destroy__ = _mupdf.delete_FzImage

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzImage_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzImage___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzImage_m_internal_get, _mupdf.FzImage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzImage_s_num_instances_get, _mupdf.FzImage_s_num_instances_set)

# Register FzImage in _mupdf:
_mupdf.FzImage_swigregister(FzImage)
class FzInstallLoadSystemFontFuncsArgs(object):
    r"""
     Wrapper class for struct `fz_install_load_system_font_funcs_args`.
    Extra struct containing fz_install_load_system_font_funcs()'s args,
    which we wrap with virtual_fnptrs set to allow use from Python/C# via
    Swig Directors.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_install_load_system_font_funcs2(self):
        r"""
        Class-aware wrapper for `::fz_install_load_system_font_funcs2()`.
        Alternative to fz_install_load_system_font_funcs() that takes args in a
        struct, to allow use from Python/C# via Swig Directors.
        """
        return _mupdf.FzInstallLoadSystemFontFuncsArgs_fz_install_load_system_font_funcs2(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_install_load_system_font_funcs_args`.
        """
        _mupdf.FzInstallLoadSystemFontFuncsArgs_swiginit(self, _mupdf.new_FzInstallLoadSystemFontFuncsArgs(*args))
    __swig_destroy__ = _mupdf.delete_FzInstallLoadSystemFontFuncsArgs
    m_internal = property(_mupdf.FzInstallLoadSystemFontFuncsArgs_m_internal_get, _mupdf.FzInstallLoadSystemFontFuncsArgs_m_internal_set)
    s_num_instances = property(_mupdf.FzInstallLoadSystemFontFuncsArgs_s_num_instances_get, _mupdf.FzInstallLoadSystemFontFuncsArgs_s_num_instances_set, doc=r"""Wrapped data is held by value.""")

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzInstallLoadSystemFontFuncsArgs_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzInstallLoadSystemFontFuncsArgs___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzInstallLoadSystemFontFuncsArgs___ne__(self, rhs)

# Register FzInstallLoadSystemFontFuncsArgs in _mupdf:
_mupdf.FzInstallLoadSystemFontFuncsArgs_swigregister(FzInstallLoadSystemFontFuncsArgs)
class FzInstallLoadSystemFontFuncsArgs2(FzInstallLoadSystemFontFuncsArgs):
    r"""Wrapper class for struct fz_install_load_system_font_funcs_args with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""== Constructor."""
        if self.__class__ == FzInstallLoadSystemFontFuncsArgs2:
            _self = None
        else:
            _self = self
        _mupdf.FzInstallLoadSystemFontFuncsArgs2_swiginit(self, _mupdf.new_FzInstallLoadSystemFontFuncsArgs2(_self, ))
    __swig_destroy__ = _mupdf.delete_FzInstallLoadSystemFontFuncsArgs2

    def use_virtual_f(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_use_virtual_f(self, use)

    def use_virtual_f_cjk(self, use=True):
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_use_virtual_f_cjk(self, use)

    def use_virtual_f_fallback(self, use=True):
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_use_virtual_f_fallback(self, use)

    def f(self, arg_0, arg_1, arg_2, arg_3, arg_4):
        r"""Default virtual method implementations; these all throw an exception."""
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_f(self, arg_0, arg_1, arg_2, arg_3, arg_4)

    def f_cjk(self, arg_0, arg_1, arg_2, arg_3):
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_f_cjk(self, arg_0, arg_1, arg_2, arg_3)

    def f_fallback(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_f_fallback(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_FzInstallLoadSystemFontFuncsArgs2(self)
        return weakref.proxy(self)

# Register FzInstallLoadSystemFontFuncsArgs2 in _mupdf:
_mupdf.FzInstallLoadSystemFontFuncsArgs2_swigregister(FzInstallLoadSystemFontFuncsArgs2)
class FzInt2(object):
    r"""Wrapper class for struct `fz_int2`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_int2`.
        """
        _mupdf.FzInt2_swiginit(self, _mupdf.new_FzInt2(*args))
    __swig_destroy__ = _mupdf.delete_FzInt2

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzInt2_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzInt2___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzInt2_m_internal_get, _mupdf.FzInt2_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzInt2_s_num_instances_get, _mupdf.FzInt2_s_num_instances_set)

# Register FzInt2 in _mupdf:
_mupdf.FzInt2_swigregister(FzInt2)
class FzInt2Heap(object):
    r"""Wrapper class for struct `fz_int2_heap`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_int2_heap_insert(self, v):
        r"""Class-aware wrapper for `::fz_int2_heap_insert()`."""
        return _mupdf.FzInt2Heap_fz_int2_heap_insert(self, v)

    def fz_int2_heap_sort(self):
        r"""Class-aware wrapper for `::fz_int2_heap_sort()`."""
        return _mupdf.FzInt2Heap_fz_int2_heap_sort(self)

    def fz_int2_heap_uniq(self):
        r"""Class-aware wrapper for `::fz_int2_heap_uniq()`."""
        return _mupdf.FzInt2Heap_fz_int2_heap_uniq(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_int2_heap`.
        """
        _mupdf.FzInt2Heap_swiginit(self, _mupdf.new_FzInt2Heap(*args))
    __swig_destroy__ = _mupdf.delete_FzInt2Heap

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzInt2Heap_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzInt2Heap___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzInt2Heap_m_internal_get, _mupdf.FzInt2Heap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzInt2Heap_s_num_instances_get, _mupdf.FzInt2Heap_s_num_instances_set)

# Register FzInt2Heap in _mupdf:
_mupdf.FzInt2Heap_swigregister(FzInt2Heap)
class FzIntHeap(object):
    r"""Wrapper class for struct `fz_int_heap`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_int_heap_insert(self, v):
        r"""Class-aware wrapper for `::fz_int_heap_insert()`."""
        return _mupdf.FzIntHeap_fz_int_heap_insert(self, v)

    def fz_int_heap_sort(self):
        r"""Class-aware wrapper for `::fz_int_heap_sort()`."""
        return _mupdf.FzIntHeap_fz_int_heap_sort(self)

    def fz_int_heap_uniq(self):
        r"""Class-aware wrapper for `::fz_int_heap_uniq()`."""
        return _mupdf.FzIntHeap_fz_int_heap_uniq(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_int_heap`.
        """
        _mupdf.FzIntHeap_swiginit(self, _mupdf.new_FzIntHeap(*args))
    __swig_destroy__ = _mupdf.delete_FzIntHeap

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzIntHeap_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzIntHeap___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzIntHeap_m_internal_get, _mupdf.FzIntHeap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzIntHeap_s_num_instances_get, _mupdf.FzIntHeap_s_num_instances_set)

# Register FzIntHeap in _mupdf:
_mupdf.FzIntHeap_swigregister(FzIntHeap)
class FzIntptr(object):
    r"""Wrapper class for struct `fz_intptr`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_intptr`.
        """
        _mupdf.FzIntptr_swiginit(self, _mupdf.new_FzIntptr(*args))
    __swig_destroy__ = _mupdf.delete_FzIntptr

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzIntptr_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzIntptr___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzIntptr_m_internal_get, _mupdf.FzIntptr_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzIntptr_s_num_instances_get, _mupdf.FzIntptr_s_num_instances_set)

# Register FzIntptr in _mupdf:
_mupdf.FzIntptr_swigregister(FzIntptr)
class FzIntptrHeap(object):
    r"""Wrapper class for struct `fz_intptr_heap`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_intptr_heap_insert(self, v):
        r"""Class-aware wrapper for `::fz_intptr_heap_insert()`."""
        return _mupdf.FzIntptrHeap_fz_intptr_heap_insert(self, v)

    def fz_intptr_heap_sort(self):
        r"""Class-aware wrapper for `::fz_intptr_heap_sort()`."""
        return _mupdf.FzIntptrHeap_fz_intptr_heap_sort(self)

    def fz_intptr_heap_uniq(self):
        r"""Class-aware wrapper for `::fz_intptr_heap_uniq()`."""
        return _mupdf.FzIntptrHeap_fz_intptr_heap_uniq(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_intptr_heap`.
        """
        _mupdf.FzIntptrHeap_swiginit(self, _mupdf.new_FzIntptrHeap(*args))
    __swig_destroy__ = _mupdf.delete_FzIntptrHeap

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzIntptrHeap_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzIntptrHeap___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzIntptrHeap_m_internal_get, _mupdf.FzIntptrHeap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzIntptrHeap_s_num_instances_get, _mupdf.FzIntptrHeap_s_num_instances_set)

# Register FzIntptrHeap in _mupdf:
_mupdf.FzIntptrHeap_swigregister(FzIntptrHeap)
class FzIrect(object):
    r"""
    Wrapper class for struct `fz_irect`.
    fz_irect is a rectangle using integers instead of floats.

    It's used in the draw device and for pixmap dimensions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_expand_irect(self, expand):
        r"""Class-aware wrapper for `::fz_expand_irect()`."""
        return _mupdf.FzIrect_fz_expand_irect(self, expand)

    def fz_intersect_irect(self, b):
        r"""
        Class-aware wrapper for `::fz_intersect_irect()`.
        	Compute intersection of two bounding boxes.

        	Similar to fz_intersect_rect but operates on two bounding
        	boxes instead of two rectangles.
        """
        return _mupdf.FzIrect_fz_intersect_irect(self, b)

    def fz_irect_height(self):
        r"""
        Class-aware wrapper for `::fz_irect_height()`.
        	Return the height of an irect. Invalid irects return 0.
        """
        return _mupdf.FzIrect_fz_irect_height(self)

    def fz_irect_width(self):
        r"""
        Class-aware wrapper for `::fz_irect_width()`.
        	Return the width of an irect. Invalid irects return 0.
        """
        return _mupdf.FzIrect_fz_irect_width(self)

    def fz_is_empty_irect(self):
        r"""Class-aware wrapper for `::fz_is_empty_irect()`."""
        return _mupdf.FzIrect_fz_is_empty_irect(self)

    def fz_is_infinite_irect(self):
        r"""
        Class-aware wrapper for `::fz_is_infinite_irect()`.
        	Check if an integer rectangle
        	is infinite.
        """
        return _mupdf.FzIrect_fz_is_infinite_irect(self)

    def fz_is_valid_irect(self):
        r"""
        Class-aware wrapper for `::fz_is_valid_irect()`.
        	Check if an integer rectangle is valid.
        """
        return _mupdf.FzIrect_fz_is_valid_irect(self)

    def fz_rect_from_irect(self):
        r"""
        Class-aware wrapper for `::fz_rect_from_irect()`.
        	Convert a bbox into a rect.

        	For our purposes, a rect can represent all the values we meet in
        	a bbox, so nothing can go wrong.

        	rect: A place to store the generated rectangle.

        	bbox: The bbox to convert.

        	Returns rect (updated).
        """
        return _mupdf.FzIrect_fz_rect_from_irect(self)

    def fz_translate_irect(self, xoff, yoff):
        r"""Class-aware wrapper for `::fz_translate_irect()`."""
        return _mupdf.FzIrect_fz_translate_irect(self, xoff, yoff)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_irect_from_rect()`.
        		Convert a rect into the minimal bounding box
        		that covers the rectangle.

        		Coordinates in a bounding box are integers, so rounding of the
        		rects coordinates takes place. The top left corner is rounded
        		upwards and left while the bottom right corner is rounded
        		downwards and to the right.


        |

        *Overload 2:*
         Constructor using `fz_make_irect()`.

        |

        *Overload 3:*
         We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_irect`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_irect`.
        """
        _mupdf.FzIrect_swiginit(self, _mupdf.new_FzIrect(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzIrect_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzIrect
    x0 = property(_mupdf.FzIrect_x0_get, _mupdf.FzIrect_x0_set)
    y0 = property(_mupdf.FzIrect_y0_get, _mupdf.FzIrect_y0_set)
    x1 = property(_mupdf.FzIrect_x1_get, _mupdf.FzIrect_x1_set)
    y1 = property(_mupdf.FzIrect_y1_get, _mupdf.FzIrect_y1_set)
    s_num_instances = property(_mupdf.FzIrect_s_num_instances_get, _mupdf.FzIrect_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzIrect_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzIrect___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzIrect___ne__(self, rhs)

# Register FzIrect in _mupdf:
_mupdf.FzIrect_swigregister(FzIrect)
class FzJbig2Globals(object):
    r"""Wrapper class for struct `fz_jbig2_globals`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_jbig2_globals_data(self):
        r"""
        Class-aware wrapper for `::fz_jbig2_globals_data()`.
        	Return buffer containing jbig2 globals data stream.
        """
        return _mupdf.FzJbig2Globals_fz_jbig2_globals_data(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_jbig2_globals()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_jbig2_globals`.
        """
        _mupdf.FzJbig2Globals_swiginit(self, _mupdf.new_FzJbig2Globals(*args))
    __swig_destroy__ = _mupdf.delete_FzJbig2Globals

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzJbig2Globals_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzJbig2Globals___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzJbig2Globals_m_internal_get, _mupdf.FzJbig2Globals_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzJbig2Globals_s_num_instances_get, _mupdf.FzJbig2Globals_s_num_instances_set)

# Register FzJbig2Globals in _mupdf:
_mupdf.FzJbig2Globals_swigregister(FzJbig2Globals)
class FzKeyStorable(object):
    r"""
    Wrapper class for struct `fz_key_storable`.
    Any storable object that can appear in the key of another
    storable object should include an fz_key_storable structure
    at the start (by convention at least) of their structure.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_key_storable()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_key_storable`.
        """
        _mupdf.FzKeyStorable_swiginit(self, _mupdf.new_FzKeyStorable(*args))
    __swig_destroy__ = _mupdf.delete_FzKeyStorable

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzKeyStorable_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzKeyStorable___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzKeyStorable_m_internal_get, _mupdf.FzKeyStorable_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzKeyStorable_s_num_instances_get, _mupdf.FzKeyStorable_s_num_instances_set)

# Register FzKeyStorable in _mupdf:
_mupdf.FzKeyStorable_swigregister(FzKeyStorable)
class FzLayoutBlock(object):
    r"""Wrapper class for struct `fz_layout_block`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_add_layout_char(self, x, w, p):
        r"""
        Class-aware wrapper for `::fz_add_layout_char()`.
        	Add a new char to the line at the end of the layout block.
        """
        return _mupdf.FzLayoutBlock_fz_add_layout_char(self, x, w, p)

    def fz_add_layout_line(self, x, y, h, p):
        r"""
        Class-aware wrapper for `::fz_add_layout_line()`.
        	Add a new line to the end of the layout block.
        """
        return _mupdf.FzLayoutBlock_fz_add_layout_line(self, x, y, h, p)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_layout()`.
        		Create a new layout block, with new allocation pool, zero
        		matrices, and initialise linked pointers.


        |

        *Overload 2:*
         Constructor using raw copy of pre-existing `::fz_layout_block`.
        """
        _mupdf.FzLayoutBlock_swiginit(self, _mupdf.new_FzLayoutBlock(*args))
    __swig_destroy__ = _mupdf.delete_FzLayoutBlock

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLayoutBlock_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzLayoutBlock___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzLayoutBlock_m_internal_get, _mupdf.FzLayoutBlock_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLayoutBlock_s_num_instances_get, _mupdf.FzLayoutBlock_s_num_instances_set)

# Register FzLayoutBlock in _mupdf:
_mupdf.FzLayoutBlock_swigregister(FzLayoutBlock)
class FzLayoutChar(object):
    r"""
    Wrapper class for struct `fz_layout_char`. Not copyable or assignable.
    Simple text layout (for use with annotation editing primarily).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_layout_char`.
        """
        _mupdf.FzLayoutChar_swiginit(self, _mupdf.new_FzLayoutChar(*args))
    __swig_destroy__ = _mupdf.delete_FzLayoutChar

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLayoutChar_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzLayoutChar___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzLayoutChar_m_internal_get, _mupdf.FzLayoutChar_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLayoutChar_s_num_instances_get, _mupdf.FzLayoutChar_s_num_instances_set)

# Register FzLayoutChar in _mupdf:
_mupdf.FzLayoutChar_swigregister(FzLayoutChar)
class FzLayoutLine(object):
    r"""Wrapper class for struct `fz_layout_line`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_layout_line`.
        """
        _mupdf.FzLayoutLine_swiginit(self, _mupdf.new_FzLayoutLine(*args))
    __swig_destroy__ = _mupdf.delete_FzLayoutLine

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLayoutLine_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzLayoutLine___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzLayoutLine_m_internal_get, _mupdf.FzLayoutLine_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLayoutLine_s_num_instances_get, _mupdf.FzLayoutLine_s_num_instances_set)

# Register FzLayoutLine in _mupdf:
_mupdf.FzLayoutLine_swigregister(FzLayoutLine)
class FzLink(object):
    r"""
    Wrapper class for struct `fz_link`.
    fz_link is a list of interactive links on a page.

    There is no relation between the order of the links in the
    list and the order they appear on the page. The list of links
    for a given page can be obtained from fz_load_links.

    A link is reference counted. Dropping a reference to a link is
    done by calling fz_drop_link.

    rect: The hot zone. The area that can be clicked in
    untransformed coordinates.

    uri: Link destinations come in two forms: internal and external.
    Internal links refer to other pages in the same document.
    External links are URLs to other documents.

    next: A pointer to the next link on the same page.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_set_link_rect(self, rect):
        r"""Class-aware wrapper for `::fz_set_link_rect()`."""
        return _mupdf.FzLink_fz_set_link_rect(self, rect)

    def fz_set_link_uri(self, uri):
        r"""Class-aware wrapper for `::fz_set_link_uri()`."""
        return _mupdf.FzLink_fz_set_link_uri(self, uri)

    def begin(self):
        r"""Used for iteration over linked list of FzLink items starting at fz_link::."""
        return _mupdf.FzLink_begin(self)

    def end(self):
        r"""Used for iteration over linked list of FzLink items starting at fz_link::."""
        return _mupdf.FzLink_end(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_link_of_size()`.
        		Create a new link record.

        		next is set to NULL with the expectation that the caller will
        		handle the linked list setup. Internal function.

        		Different document types will be implemented by deriving from
        		fz_link. This macro allocates such derived structures, and
        		initialises the base sections.


        |

        *Overload 2:*
         Constructor using `pdf_new_link()`.

        |

        *Overload 3:*
         Construct by calling fz_new_link_of_size() with size=sizeof(fz_link).

        |

        *Overload 4:*
         Copy constructor using `fz_keep_link()`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_link`.

        |

        *Overload 6:*
         Constructor using raw copy of pre-existing `::fz_link`.
        """
        _mupdf.FzLink_swiginit(self, _mupdf.new_FzLink(*args))

    def refs(self):
        return _mupdf.FzLink_refs(self)

    def next(self):
        return _mupdf.FzLink_next(self)

    def rect(self):
        return _mupdf.FzLink_rect(self)

    def uri(self):
        return _mupdf.FzLink_uri(self)
    __swig_destroy__ = _mupdf.delete_FzLink

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLink_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzLink___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzLink_m_internal_get, _mupdf.FzLink_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLink_s_num_instances_get, _mupdf.FzLink_s_num_instances_set)

# Register FzLink in _mupdf:
_mupdf.FzLink_swigregister(FzLink)
class FzLinkDest(object):
    r"""Wrapper class for struct `fz_link_dest`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_new_uri_from_explicit_dest(self):
        r"""Class-aware wrapper for `::pdf_new_uri_from_explicit_dest()`."""
        return _mupdf.FzLinkDest_pdf_new_uri_from_explicit_dest(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_link_dest`.
        """
        _mupdf.FzLinkDest_swiginit(self, _mupdf.new_FzLinkDest(*args))
    __swig_destroy__ = _mupdf.delete_FzLinkDest

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLinkDest_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzLinkDest___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzLinkDest_m_internal_get, _mupdf.FzLinkDest_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLinkDest_s_num_instances_get, _mupdf.FzLinkDest_s_num_instances_set)

# Register FzLinkDest in _mupdf:
_mupdf.FzLinkDest_swigregister(FzLinkDest)
class FzLocation(object):
    r"""
    Wrapper class for struct `fz_location`.
    Locations within the document are referred to in terms of
    chapter and page, rather than just a page number. For some
    documents (such as epub documents with large numbers of pages
    broken into many chapters) this can make navigation much faster
    as only the required chapter needs to be decoded at a time.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_make_location()`.
        		Simple constructor for fz_locations.


        |

        *Overload 2:*
         We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_location`.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_location`.
        """
        _mupdf.FzLocation_swiginit(self, _mupdf.new_FzLocation(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzLocation_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzLocation
    chapter = property(_mupdf.FzLocation_chapter_get, _mupdf.FzLocation_chapter_set)
    page = property(_mupdf.FzLocation_page_get, _mupdf.FzLocation_page_set)
    s_num_instances = property(_mupdf.FzLocation_s_num_instances_get, _mupdf.FzLocation_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzLocation_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzLocation___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzLocation___ne__(self, rhs)

# Register FzLocation in _mupdf:
_mupdf.FzLocation_swigregister(FzLocation)
class FzLocksContext(object):
    r"""
    Wrapper class for struct `fz_locks_context`. Not copyable or assignable.
    Locking functions

    MuPDF is kept deliberately free of any knowledge of particular
    threading systems. As such, in order for safe multi-threaded
    operation, we rely on callbacks to client provided functions.

    A client is expected to provide FZ_LOCK_MAX number of mutexes,
    and a function to lock/unlock each of them. These may be
    recursive mutexes, but do not have to be.

    If a client does not intend to use multiple threads, then it
    may pass NULL instead of a lock structure.

    In order to avoid deadlocks, we have one simple rule
    internally as to how we use locks: We can never take lock n
    when we already hold any lock i, where 0 <= i <= n. In order
    to verify this, we have some debugging code, that can be
    enabled by defining FITZ_DEBUG_LOCKING.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_locks_context`.
        """
        _mupdf.FzLocksContext_swiginit(self, _mupdf.new_FzLocksContext(*args))
    __swig_destroy__ = _mupdf.delete_FzLocksContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLocksContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzLocksContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzLocksContext_m_internal_get, _mupdf.FzLocksContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLocksContext_s_num_instances_get, _mupdf.FzLocksContext_s_num_instances_set)

# Register FzLocksContext in _mupdf:
_mupdf.FzLocksContext_swigregister(FzLocksContext)
class FzMatrix(object):
    r"""
     Wrapper class for struct `fz_matrix`.
    	fz_matrix is a row-major 3x3 matrix used for representing
    	transformations of coordinates throughout MuPDF.

    	Since all points reside in a two-dimensional space, one vector
    	is always a constant unit vector; hence only some elements may
    	vary in a matrix. Below is how the elements map between
    	different representations.

    a b 0
    	| c d 0 | normally represented as [ a b c d e f ].
    	\ e f 1 /
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_scale(sx, sy):
        r"""
        Class-aware wrapper for `::fz_scale()`.
        	Create a scaling matrix.

        	The returned matrix is of the form [ sx 0 0 sy 0 0 ].

        	m: Pointer to the matrix to populate

        	sx, sy: Scaling factors along the X- and Y-axes. A scaling
        	factor of 1.0 will not cause any scaling along the relevant
        	axis.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_scale(sx, sy)

    @staticmethod
    def fz_shear(sx, sy):
        r"""
        Class-aware wrapper for `::fz_shear()`.
        	Create a shearing matrix.

        	The returned matrix is of the form [ 1 sy sx 1 0 0 ].

        	m: pointer to place to store returned matrix

        	sx, sy: Shearing factors. A shearing factor of 0.0 will not
        	cause any shearing along the relevant axis.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_shear(sx, sy)

    @staticmethod
    def fz_rotate(degrees):
        r"""
        Class-aware wrapper for `::fz_rotate()`.
        	Create a rotation matrix.

        	The returned matrix is of the form
        	[ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

        	m: Pointer to place to store matrix

        	degrees: Degrees of counter clockwise rotation. Values less
        	than zero and greater than 360 are handled as expected.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_rotate(degrees)

    @staticmethod
    def fz_translate(tx, ty):
        r"""
        Class-aware wrapper for `::fz_translate()`.
        	Create a translation matrix.

        	The returned matrix is of the form [ 1 0 0 1 tx ty ].

        	m: A place to store the created matrix.

        	tx, ty: Translation distances along the X- and Y-axes. A
        	translation of 0 will not cause any translation along the
        	relevant axis.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_translate(tx, ty)

    @staticmethod
    def fz_transform_page(mediabox, resolution, rotate):
        r"""
        Class-aware wrapper for `::fz_transform_page()`.
        	Create transform matrix to draw page
        	at a given resolution and rotation. Adjusts the scaling
        	factors so that the page covers whole number of
        	pixels and adjust the page origin to be at 0,0.
        """
        return _mupdf.FzMatrix_fz_transform_page(mediabox, resolution, rotate)

    def fz_concat(self, *args):
        r"""
        *Overload 1:*
         We use default copy constructor and operator=.  Class-aware wrapper for `::fz_concat()`.
        		Multiply two matrices.

        		The order of the two matrices are important since matrix
        		multiplication is not commutative.

        		Returns result.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_concat()`.
        		Multiply two matrices.

        		The order of the two matrices are important since matrix
        		multiplication is not commutative.

        		Returns result.
        """
        return _mupdf.FzMatrix_fz_concat(self, *args)

    def fz_invert_matrix(self):
        r"""
        Class-aware wrapper for `::fz_invert_matrix()`.
        	Create an inverse matrix.

        	matrix: Matrix to invert. A degenerate matrix, where the
        	determinant is equal to zero, can not be inverted and the
        	original matrix is returned instead.

        	Returns inverse.
        """
        return _mupdf.FzMatrix_fz_invert_matrix(self)

    def fz_is_identity(self):
        r"""Class-aware wrapper for `::fz_is_identity()`."""
        return _mupdf.FzMatrix_fz_is_identity(self)

    def fz_is_rectilinear(self):
        r"""
        Class-aware wrapper for `::fz_is_rectilinear()`.
        	Check if a transformation is rectilinear.

        	Rectilinear means that no shearing is present and that any
        	rotations present are a multiple of 90 degrees. Usually this
        	is used to make sure that axis-aligned rectangles before the
        	transformation are still axis-aligned rectangles afterwards.
        """
        return _mupdf.FzMatrix_fz_is_rectilinear(self)

    def fz_matrix_expansion(self):
        r"""
        Class-aware wrapper for `::fz_matrix_expansion()`.
        	Calculate average scaling factor of matrix.
        """
        return _mupdf.FzMatrix_fz_matrix_expansion(self)

    def fz_matrix_max_expansion(self):
        r"""
        Class-aware wrapper for `::fz_matrix_max_expansion()`.
        	Find the largest expansion performed by this matrix.
        	(i.e. max(abs(m.a),abs(m.b),abs(m.c),abs(m.d))
        """
        return _mupdf.FzMatrix_fz_matrix_max_expansion(self)

    def fz_post_scale(self, sx, sy):
        r"""
        Class-aware wrapper for `::fz_post_scale()`.
        	Scale a matrix by postmultiplication.

        	m: Pointer to the matrix to scale

        	sx, sy: Scaling factors along the X- and Y-axes. A scaling
        	factor of 1.0 will not cause any scaling along the relevant
        	axis.

        	Returns m (updated).
        """
        return _mupdf.FzMatrix_fz_post_scale(self, sx, sy)

    def fz_pre_rotate(self, degrees):
        r"""
        Class-aware wrapper for `::fz_pre_rotate()`.
        	Rotate a transformation by premultiplying.

        	The premultiplied matrix is of the form
        	[ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

        	m: Pointer to matrix to premultiply.

        	degrees: Degrees of counter clockwise rotation. Values less
        	than zero and greater than 360 are handled as expected.

        	Returns m (updated).
        """
        return _mupdf.FzMatrix_fz_pre_rotate(self, degrees)

    def fz_pre_scale(self, sx, sy):
        r"""
        Class-aware wrapper for `::fz_pre_scale()`.
        	Scale a matrix by premultiplication.

        	m: Pointer to the matrix to scale

        	sx, sy: Scaling factors along the X- and Y-axes. A scaling
        	factor of 1.0 will not cause any scaling along the relevant
        	axis.

        	Returns m (updated).
        """
        return _mupdf.FzMatrix_fz_pre_scale(self, sx, sy)

    def fz_pre_shear(self, sx, sy):
        r"""
        Class-aware wrapper for `::fz_pre_shear()`.
        	Premultiply a matrix with a shearing matrix.

        	The shearing matrix is of the form [ 1 sy sx 1 0 0 ].

        	m: pointer to matrix to premultiply

        	sx, sy: Shearing factors. A shearing factor of 0.0 will not
        	cause any shearing along the relevant axis.

        	Returns m (updated).
        """
        return _mupdf.FzMatrix_fz_pre_shear(self, sx, sy)

    def fz_pre_translate(self, tx, ty):
        r"""
        Class-aware wrapper for `::fz_pre_translate()`.
        	Translate a matrix by premultiplication.

        	m: The matrix to translate

        	tx, ty: Translation distances along the X- and Y-axes. A
        	translation of 0 will not cause any translation along the
        	relevant axis.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_pre_translate(self, tx, ty)

    def fz_subpixel_adjust(self, subpix_ctm, qe, qf):
        r"""
        Class-aware wrapper for `::fz_subpixel_adjust()`.
        	Perform subpixel quantisation and adjustment on a glyph matrix.

        	ctm: On entry, the desired 'ideal' transformation for a glyph.
        	On exit, adjusted to a (very similar) transformation quantised
        	for subpixel caching.

        	subpix_ctm: Initialised by the routine to the transform that
        	should be used to render the glyph.

        	qe, qf: which subpixel position we quantised to.

        	Returns: the size of the glyph.

        	Note: This is currently only exposed for use in our app. It
        	should be considered "at risk" of removal from the API.
        """
        return _mupdf.FzMatrix_fz_subpixel_adjust(self, subpix_ctm, qe, qf)

    def fz_try_invert_matrix(self, src):
        r"""
        Class-aware wrapper for `::fz_try_invert_matrix()`.
        	Attempt to create an inverse matrix.

        	inv: Place to store inverse matrix.

        	src: Matrix to invert. A degenerate matrix, where the
        	determinant is equal to zero, can not be inverted.

        	Returns 1 if matrix is degenerate (singular), or 0 otherwise.
        """
        return _mupdf.FzMatrix_fz_try_invert_matrix(self, src)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_make_matrix()`.

        |

        *Overload 2:*
        Constructs identity matrix (like fz_identity).

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_matrix`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_matrix`.
        """
        _mupdf.FzMatrix_swiginit(self, _mupdf.new_FzMatrix(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzMatrix_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzMatrix
    a = property(_mupdf.FzMatrix_a_get, _mupdf.FzMatrix_a_set)
    b = property(_mupdf.FzMatrix_b_get, _mupdf.FzMatrix_b_set)
    c = property(_mupdf.FzMatrix_c_get, _mupdf.FzMatrix_c_set)
    d = property(_mupdf.FzMatrix_d_get, _mupdf.FzMatrix_d_set)
    e = property(_mupdf.FzMatrix_e_get, _mupdf.FzMatrix_e_set)
    f = property(_mupdf.FzMatrix_f_get, _mupdf.FzMatrix_f_set)
    s_num_instances = property(_mupdf.FzMatrix_s_num_instances_get, _mupdf.FzMatrix_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzMatrix_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzMatrix___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzMatrix___ne__(self, rhs)

# Register FzMatrix in _mupdf:
_mupdf.FzMatrix_swigregister(FzMatrix)
class FzMd5(object):
    r"""
    Wrapper class for struct `fz_md5`.
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_md5_final(self, digest):
        r"""
        We use default copy constructor and operator=.  Class-aware wrapper for `::fz_md5_final()`.
        	MD5 finalization. Ends an MD5 message-digest operation, writing
        	the message digest and zeroizing the context.

        	Never throws an exception.
        """
        return _mupdf.FzMd5_fz_md5_final(self, digest)

    def fz_md5_final2(self):
        r"""
        Class-aware wrapper for `::fz_md5_final2()`.
        C++ alternative to fz_md5_final() that returns the digest by value.
        """
        return _mupdf.FzMd5_fz_md5_final2(self)

    def fz_md5_init(self):
        r"""
        Class-aware wrapper for `::fz_md5_init()`.
        	MD5 initialization. Begins an MD5 operation, writing a new
        	context.

        	Never throws an exception.
        """
        return _mupdf.FzMd5_fz_md5_init(self)

    def fz_md5_update(self, input, inlen):
        r"""
        Class-aware wrapper for `::fz_md5_update()`.
        	MD5 block update operation. Continues an MD5 message-digest
        	operation, processing another message block, and updating the
        	context.

        	Never throws an exception.
        """
        return _mupdf.FzMd5_fz_md5_update(self, input, inlen)

    def fz_md5_update_int64(self, i):
        r"""
        Class-aware wrapper for `::fz_md5_update_int64()`.
        	MD5 block update operation. Continues an MD5 message-digest
        	operation, processing an int64, and updating the context.

        	Never throws an exception.
        """
        return _mupdf.FzMd5_fz_md5_update_int64(self, i)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor calls md5_init().

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_md5`.
        """
        _mupdf.FzMd5_swiginit(self, _mupdf.new_FzMd5(*args))

    def lo(self):
        return _mupdf.FzMd5_lo(self)

    def hi(self):
        return _mupdf.FzMd5_hi(self)

    def a(self):
        return _mupdf.FzMd5_a(self)

    def b(self):
        return _mupdf.FzMd5_b(self)

    def c(self):
        return _mupdf.FzMd5_c(self)

    def d(self):
        return _mupdf.FzMd5_d(self)

    def buffer(self):
        return _mupdf.FzMd5_buffer(self)
    __swig_destroy__ = _mupdf.delete_FzMd5
    m_internal = property(_mupdf.FzMd5_m_internal_get, _mupdf.FzMd5_m_internal_set)
    s_num_instances = property(_mupdf.FzMd5_s_num_instances_get, _mupdf.FzMd5_s_num_instances_set, doc=r"""Wrapped data is held by value.""")

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzMd5_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzMd5___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzMd5___ne__(self, rhs)

# Register FzMd5 in _mupdf:
_mupdf.FzMd5_swigregister(FzMd5)
class FzOutline(object):
    r"""
    Wrapper class for struct `fz_outline`.
    fz_outline is a tree of the outline of a document (also known
    as table of contents).

    title: Title of outline item using UTF-8 encoding. May be NULL
    if the outline item has no text string.

    uri: Destination in the document to be displayed when this
    outline item is activated. May be an internal or external
    link, or NULL if the outline item does not have a destination.

    page: The page number of an internal link, or -1 for external
    links or links with no destination.

    next: The next outline item at the same level as this outline
    item. May be NULL if no more outline items exist at this level.

    down: The outline items immediate children in the hierarchy.
    May be NULL if no children exist.

    is_open: If zero, the outline element is closed in the UI. If
    1, it should be open, showing any child elements. All other
    values reserved.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_load_outline()`.
        		Load the hierarchical document outline.

        		Should be freed by fz_drop_outline.


        |

        *Overload 2:*
         Constructor using `fz_load_outline_from_iterator()`.
        		Routine to implement the old Structure based API from an iterator.


        |

        *Overload 3:*
         Constructor using `fz_new_outline()`.
        		Create a new outline entry with zeroed fields for the caller
        		to fill in.


        |

        *Overload 4:*
         Copy constructor using `fz_keep_outline()`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_outline`.
        """
        _mupdf.FzOutline_swiginit(self, _mupdf.new_FzOutline(*args))

    def refs(self):
        return _mupdf.FzOutline_refs(self)

    def title(self):
        return _mupdf.FzOutline_title(self)

    def uri(self):
        return _mupdf.FzOutline_uri(self)

    def page(self):
        return _mupdf.FzOutline_page(self)

    def x(self):
        return _mupdf.FzOutline_x(self)

    def y(self):
        return _mupdf.FzOutline_y(self)

    def next(self):
        return _mupdf.FzOutline_next(self)

    def down(self):
        return _mupdf.FzOutline_down(self)

    def is_open(self):
        return _mupdf.FzOutline_is_open(self)
    __swig_destroy__ = _mupdf.delete_FzOutline

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzOutline_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzOutline___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzOutline_m_internal_get, _mupdf.FzOutline_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzOutline_s_num_instances_get, _mupdf.FzOutline_s_num_instances_set)

# Register FzOutline in _mupdf:
_mupdf.FzOutline_swigregister(FzOutline)
class FzOutlineItem(object):
    r"""Wrapper class for struct `fz_outline_item`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def valid(self):
        return _mupdf.FzOutlineItem_valid(self)

    def title(self):
        return _mupdf.FzOutlineItem_title(self)

    def uri(self):
        return _mupdf.FzOutlineItem_uri(self)

    def is_open(self):
        return _mupdf.FzOutlineItem_is_open(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_outline_item`.
        """
        _mupdf.FzOutlineItem_swiginit(self, _mupdf.new_FzOutlineItem(*args))
    __swig_destroy__ = _mupdf.delete_FzOutlineItem
    s_num_instances = property(_mupdf.FzOutlineItem_s_num_instances_get, _mupdf.FzOutlineItem_s_num_instances_set)

# Register FzOutlineItem in _mupdf:
_mupdf.FzOutlineItem_swigregister(FzOutlineItem)
class FzOutlineIterator(object):
    r"""Wrapper class for struct `fz_outline_iterator`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_load_outline_from_iterator(self):
        r"""
        Class-aware wrapper for `::fz_load_outline_from_iterator()`.
        	Routine to implement the old Structure based API from an iterator.
        """
        return _mupdf.FzOutlineIterator_fz_load_outline_from_iterator(self)

    def fz_outline_iterator_delete(self):
        r"""
        Class-aware wrapper for `::fz_outline_iterator_delete()`.
        	Delete the current item.

        	This implicitly moves us to the 'next' item, and the return code is as for fz_outline_iterator_next.
        """
        return _mupdf.FzOutlineIterator_fz_outline_iterator_delete(self)

    def fz_outline_iterator_down(self):
        r"""Class-aware wrapper for `::fz_outline_iterator_down()`."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_down(self)

    def fz_outline_iterator_item(self):
        r"""
        Class-aware wrapper for `::fz_outline_iterator_item()`.
        	Call to get the current outline item.

        	Can return NULL. The item is only valid until the next call.
        """
        return _mupdf.FzOutlineIterator_fz_outline_iterator_item(self)

    def fz_outline_iterator_next(self):
        r"""
        Class-aware wrapper for `::fz_outline_iterator_next()`.
        	Calls to move the iterator position.

        	A negative return value means we could not move as requested. Otherwise:
        	0 = the final position has a valid item.
        	1 = not a valid item, but we can insert an item here.
        """
        return _mupdf.FzOutlineIterator_fz_outline_iterator_next(self)

    def fz_outline_iterator_prev(self):
        r"""Class-aware wrapper for `::fz_outline_iterator_prev()`."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_prev(self)

    def fz_outline_iterator_up(self):
        r"""Class-aware wrapper for `::fz_outline_iterator_up()`."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_up(self)

    def fz_outline_iterator_insert(self, item):
        r"""Custom wrapper for fz_outline_iterator_insert()."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_insert(self, item)

    def fz_outline_iterator_update(self, item):
        r"""Custom wrapper for fz_outline_iterator_update()."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_update(self, item)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_outline_iterator()`.
        		Get an iterator for the document outline.

        		Should be freed by fz_drop_outline_iterator.


        |

        *Overload 2:*
         Constructor using `fz_new_outline_iterator_of_size()`.

        |

        *Overload 3:*
         Constructor using `pdf_new_outline_iterator()`.

        |

        *Overload 4:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_outline_iterator`.
        """
        _mupdf.FzOutlineIterator_swiginit(self, _mupdf.new_FzOutlineIterator(*args))
    __swig_destroy__ = _mupdf.delete_FzOutlineIterator

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzOutlineIterator_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzOutlineIterator___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzOutlineIterator_m_internal_get, _mupdf.FzOutlineIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzOutlineIterator_s_num_instances_get, _mupdf.FzOutlineIterator_s_num_instances_set)

# Register FzOutlineIterator in _mupdf:
_mupdf.FzOutlineIterator_swigregister(FzOutlineIterator)
class FzOutput(object):
    r"""Wrapper class for struct `fz_output`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Fixed_STDOUT = _mupdf.FzOutput_Fixed_STDOUT
    Fixed_STDERR = _mupdf.FzOutput_Fixed_STDERR
    Filter_HEX = _mupdf.FzOutput_Filter_HEX
    Filter_85 = _mupdf.FzOutput_Filter_85
    Filter_RLE = _mupdf.FzOutput_Filter_RLE

    def fz_close_output(self):
        r"""
        Class-aware wrapper for `::fz_close_output()`.
        	Flush pending output and close an output stream.
        """
        return _mupdf.FzOutput_fz_close_output(self)

    def fz_debug_store(self):
        r"""
        Class-aware wrapper for `::fz_debug_store()`.
        	Output debugging information for the current state of the store
        	to the given output channel.
        """
        return _mupdf.FzOutput_fz_debug_store(self)

    def fz_dump_glyph_cache_stats(self):
        r"""
        Class-aware wrapper for `::fz_dump_glyph_cache_stats()`.
        	Dump debug statistics for the glyph cache.
        """
        return _mupdf.FzOutput_fz_dump_glyph_cache_stats(self)

    def fz_flush_output(self):
        r"""
        Class-aware wrapper for `::fz_flush_output()`.
        	Flush unwritten data.
        """
        return _mupdf.FzOutput_fz_flush_output(self)

    def fz_new_svg_device(self, page_width, page_height, text_format, reuse_images):
        r"""
        Class-aware wrapper for `::fz_new_svg_device()`.
        	Create a device that outputs (single page) SVG files to
        	the given output stream.

        	Equivalent to fz_new_svg_device_with_id passing id = NULL.
        """
        return _mupdf.FzOutput_fz_new_svg_device(self, page_width, page_height, text_format, reuse_images)

    def fz_new_svg_device_with_id(self, page_width, page_height, text_format, reuse_images, id):
        r"""
        Class-aware wrapper for `::fz_new_svg_device_with_id()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_new_svg_device_with_id(float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`

        	Create a device that outputs (single page) SVG files to
        	the given output stream.

        	output: The output stream to send the constructed SVG page to.

        	page_width, page_height: The page dimensions to use (in points).

        	text_format: How to emit text. One of the following values:
        		FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
        		layout errors and mismatching fonts.
        		FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
        		visual appearance.

        	reuse_images: Share image resources using <symbol> definitions.

        	id: ID parameter to keep generated IDs unique across SVG files.
        """
        return _mupdf.FzOutput_fz_new_svg_device_with_id(self, page_width, page_height, text_format, reuse_images, id)

    def fz_new_trace_device(self):
        r"""
        Class-aware wrapper for `::fz_new_trace_device()`.
        	Create a device to print a debug trace of all device calls.
        """
        return _mupdf.FzOutput_fz_new_trace_device(self)

    def fz_new_xmltext_device(self):
        r"""
        Class-aware wrapper for `::fz_new_xmltext_device()`.
        	Create a device to output raw information.
        """
        return _mupdf.FzOutput_fz_new_xmltext_device(self)

    def fz_output_supports_stream(self):
        r"""
        Class-aware wrapper for `::fz_output_supports_stream()`.
        	Query whether a given fz_output supports fz_stream_from_output.
        """
        return _mupdf.FzOutput_fz_output_supports_stream(self)

    def fz_output_xml(self, item, level):
        r"""
        Class-aware wrapper for `::fz_output_xml()`.
        	Pretty-print an XML tree to given output.
        """
        return _mupdf.FzOutput_fz_output_xml(self, item, level)

    def fz_print_stext_header_as_html(self):
        r"""Class-aware wrapper for `::fz_print_stext_header_as_html()`."""
        return _mupdf.FzOutput_fz_print_stext_header_as_html(self)

    def fz_print_stext_header_as_xhtml(self):
        r"""Class-aware wrapper for `::fz_print_stext_header_as_xhtml()`."""
        return _mupdf.FzOutput_fz_print_stext_header_as_xhtml(self)

    def fz_print_stext_page_as_html(self, page, id):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_html()`.
        	Output structured text to a file in HTML (visual) format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_html(self, page, id)

    def fz_print_stext_page_as_json(self, page, scale):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_json()`.
        	Output structured text to a file in JSON format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_json(self, page, scale)

    def fz_print_stext_page_as_text(self, page):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_text()`.
        	Output structured text to a file in plain-text UTF-8 format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_text(self, page)

    def fz_print_stext_page_as_xhtml(self, page, id):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_xhtml()`.
        	Output structured text to a file in XHTML (semantic) format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_xhtml(self, page, id)

    def fz_print_stext_page_as_xml(self, page, id):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_xml()`.
        	Output structured text to a file in XML format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_xml(self, page, id)

    def fz_print_stext_trailer_as_html(self):
        r"""Class-aware wrapper for `::fz_print_stext_trailer_as_html()`."""
        return _mupdf.FzOutput_fz_print_stext_trailer_as_html(self)

    def fz_print_stext_trailer_as_xhtml(self):
        r"""Class-aware wrapper for `::fz_print_stext_trailer_as_xhtml()`."""
        return _mupdf.FzOutput_fz_print_stext_trailer_as_xhtml(self)

    def fz_reset_output(self):
        r"""
        Class-aware wrapper for `::fz_reset_output()`.
        	Reset a closed output stream. Returns state to
        	(broadly) that which it was in when opened. Not
        	all outputs can be reset, so this may throw an
        	exception.
        """
        return _mupdf.FzOutput_fz_reset_output(self)

    def fz_seek_output(self, off, whence):
        r"""
        Class-aware wrapper for `::fz_seek_output()`.
        	Seek to the specified file position.
        	See fseek for arguments.

        	Throw an error on unseekable outputs.
        """
        return _mupdf.FzOutput_fz_seek_output(self, off, whence)

    def fz_set_stddbg(self):
        r"""
        Class-aware wrapper for `::fz_set_stddbg()`.
        	Set the output stream to be used for fz_stddbg. Set to NULL to
        	reset to default (stderr).
        """
        return _mupdf.FzOutput_fz_set_stddbg(self)

    def fz_stream_from_output(self):
        r"""
        Class-aware wrapper for `::fz_stream_from_output()`.
        	Obtain the fz_output in the form of a fz_stream.

        	This allows data to be read back from some forms of fz_output
        	object. When finished reading, the fz_stream should be released
        	by calling fz_drop_stream. Until the fz_stream is dropped, no
        	further operations should be performed on the fz_output object.
        """
        return _mupdf.FzOutput_fz_stream_from_output(self)

    def fz_tell_output(self):
        r"""
        Class-aware wrapper for `::fz_tell_output()`.
        	Return the current file position.

        	Throw an error on untellable outputs.
        """
        return _mupdf.FzOutput_fz_tell_output(self)

    def fz_truncate_output(self):
        r"""
        Class-aware wrapper for `::fz_truncate_output()`.
        	Truncate the output at the current position.

        	This allows output streams which have seeked back from the end
        	of their storage to be truncated at the current point.
        """
        return _mupdf.FzOutput_fz_truncate_output(self)

    def fz_write_base64(self, data, size, newline):
        r"""
        Class-aware wrapper for `::fz_write_base64()`.
        	Write a base64 encoded data block, optionally with periodic
        	newlines.
        """
        return _mupdf.FzOutput_fz_write_base64(self, data, size, newline)

    def fz_write_base64_buffer(self, data, newline):
        r"""
        Class-aware wrapper for `::fz_write_base64_buffer()`.
        	Write a base64 encoded fz_buffer, optionally with periodic
        	newlines.
        """
        return _mupdf.FzOutput_fz_write_base64_buffer(self, data, newline)

    def fz_write_bitmap_as_pbm(self, bitmap):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pbm()`.
        	Write a bitmap as a pbm.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pbm(self, bitmap)

    def fz_write_bitmap_as_pcl(self, bitmap, pcl):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pcl()`.
        	Write a bitmap as mono PCL.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pcl(self, bitmap, pcl)

    def fz_write_bitmap_as_pkm(self, bitmap):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pkm()`.
        	Write a CMYK bitmap as a pkm.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pkm(self, bitmap)

    def fz_write_bitmap_as_pwg(self, bitmap, pwg):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pwg()`.
        	Write a bitmap as a PWG.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pwg(self, bitmap, pwg)

    def fz_write_bitmap_as_pwg_page(self, bitmap, pwg):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pwg_page()`.
        	Write a bitmap as a PWG page.

        	Caller should provide a file header by calling
        	fz_write_pwg_file_header, but can then write several pages to
        	the same file.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pwg_page(self, bitmap, pwg)

    def fz_write_bits(self, data, num_bits):
        r"""
        Class-aware wrapper for `::fz_write_bits()`.
        	Write num_bits of data to the end of the output stream, assumed to be packed
        	most significant bits first.
        """
        return _mupdf.FzOutput_fz_write_bits(self, data, num_bits)

    def fz_write_bits_sync(self):
        r"""
        Class-aware wrapper for `::fz_write_bits_sync()`.
        	Sync to byte boundary after writing bits.
        """
        return _mupdf.FzOutput_fz_write_bits_sync(self)

    def fz_write_buffer(self, data):
        r"""Class-aware wrapper for `::fz_write_buffer()`."""
        return _mupdf.FzOutput_fz_write_buffer(self, data)

    def fz_write_byte(self, x):
        r"""Class-aware wrapper for `::fz_write_byte()`."""
        return _mupdf.FzOutput_fz_write_byte(self, x)

    def fz_write_char(self, x):
        r"""Class-aware wrapper for `::fz_write_char()`."""
        return _mupdf.FzOutput_fz_write_char(self, x)

    def fz_write_data(self, data, size):
        r"""
        Class-aware wrapper for `::fz_write_data()`.
        	Write data to output.

        	data: Pointer to data to write.
        	size: Size of data to write in bytes.
        """
        return _mupdf.FzOutput_fz_write_data(self, data, size)

    def fz_write_float_be(self, f):
        r"""Class-aware wrapper for `::fz_write_float_be()`."""
        return _mupdf.FzOutput_fz_write_float_be(self, f)

    def fz_write_float_le(self, f):
        r"""Class-aware wrapper for `::fz_write_float_le()`."""
        return _mupdf.FzOutput_fz_write_float_le(self, f)

    def fz_write_image_as_data_uri(self, image):
        r"""
        Class-aware wrapper for `::fz_write_image_as_data_uri()`.
        	Write image as a data URI (for HTML and SVG output).
        """
        return _mupdf.FzOutput_fz_write_image_as_data_uri(self, image)

    def fz_write_int16_be(self, x):
        r"""Class-aware wrapper for `::fz_write_int16_be()`."""
        return _mupdf.FzOutput_fz_write_int16_be(self, x)

    def fz_write_int16_le(self, x):
        r"""Class-aware wrapper for `::fz_write_int16_le()`."""
        return _mupdf.FzOutput_fz_write_int16_le(self, x)

    def fz_write_int32_be(self, x):
        r"""
        Class-aware wrapper for `::fz_write_int32_be()`.
        	Write different sized data to an output stream.
        """
        return _mupdf.FzOutput_fz_write_int32_be(self, x)

    def fz_write_int32_le(self, x):
        r"""Class-aware wrapper for `::fz_write_int32_le()`."""
        return _mupdf.FzOutput_fz_write_int32_le(self, x)

    def fz_write_pixmap_as_data_uri(self, pixmap):
        r"""Class-aware wrapper for `::fz_write_pixmap_as_data_uri()`."""
        return _mupdf.FzOutput_fz_write_pixmap_as_data_uri(self, pixmap)

    def fz_write_pixmap_as_jpeg(self, pix, quality, invert_cmyk):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_jpeg()`.
        	Write a pixmap as a JPEG.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_jpeg(self, pix, quality, invert_cmyk)

    def fz_write_pixmap_as_jpx(self, pix, quality):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_jpx()`.
        	Pixmap data as JP2K with no subsampling.

        	quality = 100 = lossless
        	otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_jpx(self, pix, quality)

    def fz_write_pixmap_as_pam(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pam()`.
        	Write a pixmap as a pnm (greyscale, rgb or cmyk, with or without
        	alpha).
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pam(self, pixmap)

    def fz_write_pixmap_as_pcl(self, pixmap, pcl):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pcl()`.
        	Write an (RGB) pixmap as color PCL.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pcl(self, pixmap, pcl)

    def fz_write_pixmap_as_pclm(self, pixmap, options):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pclm()`.
        	Write a (Greyscale or RGB) pixmap as pclm.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pclm(self, pixmap, options)

    def fz_write_pixmap_as_pdfocr(self, pixmap, options):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pdfocr()`.
        	Write a (Greyscale or RGB) pixmap as pdfocr.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pdfocr(self, pixmap, options)

    def fz_write_pixmap_as_png(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_png()`.
        	Write a (Greyscale or RGB) pixmap as a png.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_png(self, pixmap)

    def fz_write_pixmap_as_pnm(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pnm()`.
        	Write a pixmap as a pnm (greyscale or rgb, no alpha).
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pnm(self, pixmap)

    def fz_write_pixmap_as_ps(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_ps()`.
        	Write a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_ps(self, pixmap)

    def fz_write_pixmap_as_psd(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_psd()`.
        	Write a pixmap as a PSD file.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_psd(self, pixmap)

    def fz_write_pixmap_as_pwg(self, pixmap, pwg):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pwg()`.
        	Write a pixmap as a PWG.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pwg(self, pixmap, pwg)

    def fz_write_pixmap_as_pwg_page(self, pixmap, pwg):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pwg_page()`.
        	Write a pixmap as a PWG page.

        	Caller should provide a file header by calling
        	fz_write_pwg_file_header, but can then write several pages to
        	the same file.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pwg_page(self, pixmap, pwg)

    def fz_write_ps_file_header(self):
        r"""
        Class-aware wrapper for `::fz_write_ps_file_header()`.
        	Write the file level header for ps band writer output.
        """
        return _mupdf.FzOutput_fz_write_ps_file_header(self)

    def fz_write_ps_file_trailer(self, pages):
        r"""
        Class-aware wrapper for `::fz_write_ps_file_trailer()`.
        	Write the file level trailer for ps band writer output.
        """
        return _mupdf.FzOutput_fz_write_ps_file_trailer(self, pages)

    def fz_write_pwg_file_header(self):
        r"""
        Class-aware wrapper for `::fz_write_pwg_file_header()`.
        	Output the file header to a pwg stream, ready for pages to follow it.
        """
        return _mupdf.FzOutput_fz_write_pwg_file_header(self)

    def fz_write_rune(self, rune):
        r"""
        Class-aware wrapper for `::fz_write_rune()`.
        	Write a UTF-8 encoded unicode character.
        """
        return _mupdf.FzOutput_fz_write_rune(self, rune)

    def fz_write_stream(self, _in):
        r"""
        Class-aware wrapper for `::fz_write_stream()`.
        	Copy the stream contents to the output.
        """
        return _mupdf.FzOutput_fz_write_stream(self, _in)

    def fz_write_string(self, s):
        r"""
        Class-aware wrapper for `::fz_write_string()`.
        	Write a string. Does not write zero terminator.
        """
        return _mupdf.FzOutput_fz_write_string(self, s)

    def fz_write_uint16_be(self, x):
        r"""Class-aware wrapper for `::fz_write_uint16_be()`."""
        return _mupdf.FzOutput_fz_write_uint16_be(self, x)

    def fz_write_uint16_le(self, x):
        r"""Class-aware wrapper for `::fz_write_uint16_le()`."""
        return _mupdf.FzOutput_fz_write_uint16_le(self, x)

    def fz_write_uint32_be(self, x):
        r"""Class-aware wrapper for `::fz_write_uint32_be()`."""
        return _mupdf.FzOutput_fz_write_uint32_be(self, x)

    def fz_write_uint32_le(self, x):
        r"""Class-aware wrapper for `::fz_write_uint32_le()`."""
        return _mupdf.FzOutput_fz_write_uint32_le(self, x)

    def pdf_new_output_processor(self, ahxencode, newlines):
        r"""Class-aware wrapper for `::pdf_new_output_processor()`."""
        return _mupdf.FzOutput_pdf_new_output_processor(self, ahxencode, newlines)

    def pdf_print_crypt(self, crypt):
        r"""Class-aware wrapper for `::pdf_print_crypt()`."""
        return _mupdf.FzOutput_pdf_print_crypt(self, crypt)

    def pdf_print_encrypted_obj(self, obj, tight, ascii, crypt, num, gen, sep):
        r"""
        Class-aware wrapper for `::pdf_print_encrypted_obj()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_print_encrypted_obj(::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
        """
        return _mupdf.FzOutput_pdf_print_encrypted_obj(self, obj, tight, ascii, crypt, num, gen, sep)

    def pdf_print_font(self, fontdesc):
        r"""Class-aware wrapper for `::pdf_print_font()`."""
        return _mupdf.FzOutput_pdf_print_font(self, fontdesc)

    def pdf_print_obj(self, obj, tight, ascii):
        r"""Class-aware wrapper for `::pdf_print_obj()`."""
        return _mupdf.FzOutput_pdf_print_obj(self, obj, tight, ascii)

    def pdf_write_digest(self, byte_range, field, digest_offset, digest_length, signer):
        r"""Class-aware wrapper for `::pdf_write_digest()`."""
        return _mupdf.FzOutput_pdf_write_digest(self, byte_range, field, digest_offset, digest_length, signer)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_arc4_output()`.

        |

        *Overload 2:*
         Constructor using `fz_new_deflate_output()`.

        |

        *Overload 3:*
         Constructor using `fz_new_log_for_module()`.
        		Internal function to actually do the opening of the logfile.

        		Caller should close/drop the output when finished with it.


        |

        *Overload 4:*
         Constructor using `fz_new_output()`.
        		Create a new output object with the given
        		internal state and function pointers.

        		state: Internal state (opaque to everything but implementation).

        		write: Function to output a given buffer.

        		close: Cleanup function to destroy state when output closed.
        		May permissibly be null.


        |

        *Overload 5:*
         Constructor using `fz_new_output_with_buffer()`.
        		Open an output stream that appends
        		to a buffer.

        		buf: The buffer to append to.


        |

        *Overload 6:*
         Constructor using `fz_new_output_with_file_ptr()`.
        		Open an output stream that writes to a
        		given FILE *.

        		file: The file pointers to write to. NULL is interpreted as effectively
        		meaning /dev/null or similar.


        |

        *Overload 7:*
         Constructor using `fz_new_output_with_path()`.
        		Open an output stream that writes to a
        		given path.

        		filename: The filename to write to (specified in UTF-8).

        		append: non-zero if we should append to the file, rather than
        		overwriting it.


        |

        *Overload 8:*
         Uses fz_stdout() or fz_stderr().

        |

        *Overload 9:*
         Calls one of: fz_new_asciihex_output(), fz_new_ascii85_output(), fz_new_rle_output().

        |

        *Overload 10:*
         Constructor using raw copy of pre-existing `::fz_output`.

        |

        *Overload 11:*
         Constructor using raw copy of pre-existing `::fz_output`.
        """
        _mupdf.FzOutput_swiginit(self, _mupdf.new_FzOutput(*args))
    __swig_destroy__ = _mupdf.delete_FzOutput

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzOutput_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzOutput___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzOutput_m_internal_get, _mupdf.FzOutput_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzOutput_s_num_instances_get, _mupdf.FzOutput_s_num_instances_set)

# Register FzOutput in _mupdf:
_mupdf.FzOutput_swigregister(FzOutput)
class FzOutput2(FzOutput):
    r"""Wrapper class for struct fz_output with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""== Constructor."""
        if self.__class__ == FzOutput2:
            _self = None
        else:
            _self = self
        _mupdf.FzOutput2_swiginit(self, _mupdf.new_FzOutput2(_self, ))
    __swig_destroy__ = _mupdf.delete_FzOutput2

    def use_virtual_write(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.FzOutput2_use_virtual_write(self, use)

    def use_virtual_seek(self, use=True):
        return _mupdf.FzOutput2_use_virtual_seek(self, use)

    def use_virtual_tell(self, use=True):
        return _mupdf.FzOutput2_use_virtual_tell(self, use)

    def use_virtual_close(self, use=True):
        return _mupdf.FzOutput2_use_virtual_close(self, use)

    def use_virtual_drop(self, use=True):
        return _mupdf.FzOutput2_use_virtual_drop(self, use)

    def use_virtual_reset(self, use=True):
        return _mupdf.FzOutput2_use_virtual_reset(self, use)

    def use_virtual_as_stream(self, use=True):
        return _mupdf.FzOutput2_use_virtual_as_stream(self, use)

    def use_virtual_truncate(self, use=True):
        return _mupdf.FzOutput2_use_virtual_truncate(self, use)

    def write(self, arg_0, arg_2, arg_3):
        r"""Default virtual method implementations; these all throw an exception."""
        return _mupdf.FzOutput2_write(self, arg_0, arg_2, arg_3)

    def seek(self, arg_0, arg_2, arg_3):
        return _mupdf.FzOutput2_seek(self, arg_0, arg_2, arg_3)

    def tell(self, arg_0):
        return _mupdf.FzOutput2_tell(self, arg_0)

    def close(self, arg_0):
        return _mupdf.FzOutput2_close(self, arg_0)

    def drop(self, arg_0):
        return _mupdf.FzOutput2_drop(self, arg_0)

    def reset(self, arg_0):
        return _mupdf.FzOutput2_reset(self, arg_0)

    def as_stream(self, arg_0):
        return _mupdf.FzOutput2_as_stream(self, arg_0)

    def truncate(self, arg_0):
        return _mupdf.FzOutput2_truncate(self, arg_0)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_FzOutput2(self)
        return weakref.proxy(self)

# Register FzOutput2 in _mupdf:
_mupdf.FzOutput2_swigregister(FzOutput2)
class FzOverprint(object):
    r"""
    Wrapper class for struct `fz_overprint`. Not copyable or assignable.
    Pixmaps represent a set of pixels for a 2 dimensional region of
    a plane. Each pixel has n components per pixel. The components
    are in the order process-components, spot-colors, alpha, where
    there can be 0 of any of those types. The data is in
    premultiplied alpha when rendering, but non-premultiplied for
    colorspace conversions and rescaling.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_overprint`.
        """
        _mupdf.FzOverprint_swiginit(self, _mupdf.new_FzOverprint(*args))
    __swig_destroy__ = _mupdf.delete_FzOverprint

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzOverprint_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzOverprint___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzOverprint_m_internal_get, _mupdf.FzOverprint_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzOverprint_s_num_instances_get, _mupdf.FzOverprint_s_num_instances_set)

# Register FzOverprint in _mupdf:
_mupdf.FzOverprint_swigregister(FzOverprint)
class FzPage(object):
    r"""Wrapper class for struct `fz_page`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bound_page(self):
        r"""
        Class-aware wrapper for `::fz_bound_page()`.
        	Determine the size of a page at 72 dpi.
        """
        return _mupdf.FzPage_fz_bound_page(self)

    def fz_bound_page_box(self, box):
        r"""Class-aware wrapper for `::fz_bound_page_box()`."""
        return _mupdf.FzPage_fz_bound_page_box(self, box)

    def fz_create_link(self, bbox, uri):
        r"""
        Class-aware wrapper for `::fz_create_link()`.
        	Create a new link on a page.
        """
        return _mupdf.FzPage_fz_create_link(self, bbox, uri)

    def fz_delete_link(self, link):
        r"""
        Class-aware wrapper for `::fz_delete_link()`.
        	Delete an existing link on a page.
        """
        return _mupdf.FzPage_fz_delete_link(self, link)

    def fz_load_links(self):
        r"""
        Class-aware wrapper for `::fz_load_links()`.
        	Load the list of links for a page.

        	Returns a linked list of all the links on the page, each with
        	its clickable region and link destination. Each link is
        	reference counted so drop and free the list of links by
        	calling fz_drop_link on the pointer return from fz_load_links.

        	page: Page obtained from fz_load_page.
        """
        return _mupdf.FzPage_fz_load_links(self)

    def fz_new_buffer_from_page(self, options):
        r"""Class-aware wrapper for `::fz_new_buffer_from_page()`."""
        return _mupdf.FzPage_fz_new_buffer_from_page(self, options)

    def fz_new_buffer_from_page_with_format(self, format, options, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_page_with_format()`.
        	Returns an fz_buffer containing a page after conversion to specified format.

        	page: The page to convert.
        	format, options: Passed to fz_new_document_writer_with_output() internally.
        	transform, cookie: Passed to fz_run_page() internally.
        """
        return _mupdf.FzPage_fz_new_buffer_from_page_with_format(self, format, options, transform, cookie)

    def fz_new_display_list_from_page(self):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_page()`.
        	Create a display list.

        	Ownership of the display list is returned to the caller.
        """
        return _mupdf.FzPage_fz_new_display_list_from_page(self)

    def fz_new_display_list_from_page_contents(self):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.
        	Create a display list from page contents (no annotations).

        	Ownership of the display list is returned to the caller.
        """
        return _mupdf.FzPage_fz_new_display_list_from_page_contents(self)

    def fz_new_pixmap_from_page(self, ctm, cs, alpha):
        r"""Class-aware wrapper for `::fz_new_pixmap_from_page()`."""
        return _mupdf.FzPage_fz_new_pixmap_from_page(self, ctm, cs, alpha)

    def fz_new_pixmap_from_page_contents(self, ctm, cs, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.
        	Render the page contents without annotations.

        	Ownership of the pixmap is returned to the caller.
        """
        return _mupdf.FzPage_fz_new_pixmap_from_page_contents(self, ctm, cs, alpha)

    def fz_new_pixmap_from_page_contents_with_separations(self, ctm, cs, seps, alpha):
        r"""Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
        return _mupdf.FzPage_fz_new_pixmap_from_page_contents_with_separations(self, ctm, cs, seps, alpha)

    def fz_new_pixmap_from_page_with_separations(self, ctm, cs, seps, alpha):
        r"""Class-aware wrapper for `::fz_new_pixmap_from_page_with_separations()`."""
        return _mupdf.FzPage_fz_new_pixmap_from_page_with_separations(self, ctm, cs, seps, alpha)

    def fz_page_label(self, buf, size):
        r"""
        Class-aware wrapper for `::fz_page_label()`.
        	Get page label for a given page.
        """
        return _mupdf.FzPage_fz_page_label(self, buf, size)

    def fz_page_presentation(self, transition, duration):
        r"""
        Class-aware wrapper for `::fz_page_presentation()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_page_presentation(::fz_transition *transition)` => `(fz_transition *, float duration)`

        	Get the presentation details for a given page.

        	transition: A pointer to a transition struct to fill out.

        	duration: A pointer to a place to set the page duration in
        	seconds. Will be set to 0 if no transition is specified for the
        	page.

        	Returns: a pointer to the transition structure, or NULL if there
        	is no transition specified for the page.
        """
        return _mupdf.FzPage_fz_page_presentation(self, transition, duration)

    def fz_page_separations(self):
        r"""
        Class-aware wrapper for `::fz_page_separations()`.
        	Get the separations details for a page.
        	This will be NULL, unless the format specifically supports
        	separations (such as PDF files). May be NULL even
        	so, if there are no separations on a page.

        	Returns a reference that must be dropped.
        """
        return _mupdf.FzPage_fz_page_separations(self)

    def fz_page_uses_overprint(self):
        r"""
        Class-aware wrapper for `::fz_page_uses_overprint()`.
        	Query if a given page requires overprint.
        """
        return _mupdf.FzPage_fz_page_uses_overprint(self)

    def fz_run_page(self, dev, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_run_page()`.
        	Run a page through a device.

        	page: Page obtained from fz_load_page.

        	dev: Device obtained from fz_new_*_device.

        	transform: Transform to apply to page. May include for example
        	scaling and rotation, see fz_scale, fz_rotate and fz_concat.
        	Set to fz_identity if no transformation is desired.

        	cookie: Communication mechanism between caller and library
        	rendering the page. Intended for multi-threaded applications,
        	while single-threaded applications set cookie to NULL. The
        	caller may abort an ongoing rendering of a page. Cookie also
        	communicates progress information back to the caller. The
        	fields inside cookie are continually updated while the page is
        	rendering.
        """
        return _mupdf.FzPage_fz_run_page(self, dev, transform, cookie)

    def fz_run_page_annots(self, dev, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_run_page_annots()`.
        	Run the annotations on a page through a device.
        """
        return _mupdf.FzPage_fz_run_page_annots(self, dev, transform, cookie)

    def fz_run_page_contents(self, dev, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_run_page_contents()`.
        	Run a page through a device. Just the main
        	page content, without the annotations, if any.

        	page: Page obtained from fz_load_page.

        	dev: Device obtained from fz_new_*_device.

        	transform: Transform to apply to page. May include for example
        	scaling and rotation, see fz_scale, fz_rotate and fz_concat.
        	Set to fz_identity if no transformation is desired.

        	cookie: Communication mechanism between caller and library
        	rendering the page. Intended for multi-threaded applications,
        	while single-threaded applications set cookie to NULL. The
        	caller may abort an ongoing rendering of a page. Cookie also
        	communicates progress information back to the caller. The
        	fields inside cookie are continually updated while the page is
        	rendering.
        """
        return _mupdf.FzPage_fz_run_page_contents(self, dev, transform, cookie)

    def fz_run_page_widgets(self, dev, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_run_page_widgets()`.
        	Run the widgets on a page through a device.
        """
        return _mupdf.FzPage_fz_run_page_widgets(self, dev, transform, cookie)

    def fz_search_page(self, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_page()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_page(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

        	Search for the 'needle' text on the page.
        	Record the hits in the hit_bbox array and return the number of
        	hits. Will stop looking once it has filled hit_max rectangles.
        """
        return _mupdf.FzPage_fz_search_page(self, needle, hit_mark, hit_bbox, hit_max)

    def fz_search_page_cb(self, needle, cb, opaque):
        r"""
        Class-aware wrapper for `::fz_search_page_cb()`.
        	Search for the 'needle' text on the page.
        """
        return _mupdf.FzPage_fz_search_page_cb(self, needle, cb, opaque)

    def pdf_page_from_fz_page(self):
        r"""Class-aware wrapper for `::pdf_page_from_fz_page()`."""
        return _mupdf.FzPage_pdf_page_from_fz_page(self)

    def doc(self):
        r"""Returns wrapper for .doc member."""
        return _mupdf.FzPage_doc(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_load_chapter_page()`.
        		Load a page.

        		After fz_load_page is it possible to retrieve the size of the
        		page using fz_bound_page, or to render the page using
        		fz_run_page_*. Free the page by calling fz_drop_page.

        		chapter: chapter number, 0 is the first chapter of the document.
        		number: page number, 0 is the first page of the chapter.


        |

        *Overload 2:*
         Constructor using `fz_load_page()`.
        		Load a given page number from a document. This may be much less
        		efficient than loading by location (chapter+page) for some
        		document types.


        |

        *Overload 3:*
         Constructor using `fz_new_page_of_size()`.
        		Different document types will be implemented by deriving from
        		fz_page. This macro allocates such derived structures, and
        		initialises the base sections.


        |

        *Overload 4:*
         Return FzPage for pdfpage.m_internal.super.

        |

        *Overload 5:*
         Copy constructor using `fz_keep_page()`.

        |

        *Overload 6:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 7:*
         Constructor using raw copy of pre-existing `::fz_page`.
        """
        _mupdf.FzPage_swiginit(self, _mupdf.new_FzPage(*args))
    __swig_destroy__ = _mupdf.delete_FzPage

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPage_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzPage___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzPage_m_internal_get, _mupdf.FzPage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPage_s_num_instances_get, _mupdf.FzPage_s_num_instances_set)

# Register FzPage in _mupdf:
_mupdf.FzPage_swigregister(FzPage)
class FzPath(object):
    r"""
     Wrapper class for struct `fz_path`.
    Vector path buffer.
    It can be stroked and dashed, or be filled.
    It has a fill rule (nonzero or even_odd).

    When rendering, they are flattened, stroked and dashed straight
    into the Global Edge List.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bound_path(self, stroke, ctm):
        r"""
        Class-aware wrapper for `::fz_bound_path()`.
        	Return a bounding rectangle for a path.

        	path: The path to bound.

        	stroke: If NULL, the bounding rectangle given is for
        	the filled path. If non-NULL the bounding rectangle
        	given is for the path stroked with the given attributes.

        	ctm: The matrix to apply to the path during stroking.

        	r: Pointer to a fz_rect which will be used to hold
        	the result.

        	Returns r, updated to contain the bounding rectangle.
        """
        return _mupdf.FzPath_fz_bound_path(self, stroke, ctm)

    def fz_clone_path(self):
        r"""
        Class-aware wrapper for `::fz_clone_path()`.
        	Clone the data for a path.

        	This is used in preference to fz_keep_path when a whole
        	new copy of a path is required, rather than just a shared
        	pointer. This probably indicates that the path is about to
        	be modified.

        	path: path to clone.

        	Throws exceptions on failure to allocate.
        """
        return _mupdf.FzPath_fz_clone_path(self)

    def fz_closepath(self):
        r"""
        Class-aware wrapper for `::fz_closepath()`.
        	Close the current subpath.

        	path: The path to modify.

        	Throws exceptions on failure to allocate, attempting to modify
        	a packed path, and illegal path closes (i.e. closing a non open
        	path).
        """
        return _mupdf.FzPath_fz_closepath(self)

    def fz_currentpoint(self):
        r"""
        Class-aware wrapper for `::fz_currentpoint()`.
        	Return the current point that a path has
        	reached or (0,0) if empty.

        	path: path to return the current point of.
        """
        return _mupdf.FzPath_fz_currentpoint(self)

    def fz_curveto(self, x0, y0, x1, y1, x2, y2):
        r"""
        Class-aware wrapper for `::fz_curveto()`.
        	Append a 'curveto' command to an open path. (For a
        	cubic bezier).

        	path: The path to modify.

        	x0, y0: The coordinates of the first control point for the
        	curve.

        	x1, y1: The coordinates of the second control point for the
        	curve.

        	x2, y2: The end coordinates for the curve.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_curveto(self, x0, y0, x1, y1, x2, y2)

    def fz_curvetov(self, x1, y1, x2, y2):
        r"""
        Class-aware wrapper for `::fz_curvetov()`.
        	Append a 'curvetov' command to an open path. (For a
        	cubic bezier with the first control coordinate equal to
        	the start point).

        	path: The path to modify.

        	x1, y1: The coordinates of the second control point for the
        	curve.

        	x2, y2: The end coordinates for the curve.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_curvetov(self, x1, y1, x2, y2)

    def fz_curvetoy(self, x0, y0, x2, y2):
        r"""
        Class-aware wrapper for `::fz_curvetoy()`.
        	Append a 'curvetoy' command to an open path. (For a
        	cubic bezier with the second control coordinate equal to
        	the end point).

        	path: The path to modify.

        	x0, y0: The coordinates of the first control point for the
        	curve.

        	x2, y2: The end coordinates for the curve (and the second
        	control coordinate).

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_curvetoy(self, x0, y0, x2, y2)

    def fz_lineto(self, x, y):
        r"""
        Class-aware wrapper for `::fz_lineto()`.
        	Append a 'lineto' command to an open path.

        	path: The path to modify.

        	x, y: The coordinate to line to.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_lineto(self, x, y)

    def fz_moveto(self, x, y):
        r"""
        Class-aware wrapper for `::fz_moveto()`.
        	Append a 'moveto' command to a path.
        	This 'opens' a path.

        	path: The path to modify.

        	x, y: The coordinate to move to.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_moveto(self, x, y)

    def fz_packed_path_size(self):
        r"""
        Class-aware wrapper for `::fz_packed_path_size()`.
        	Return the number of bytes required to pack a path.
        """
        return _mupdf.FzPath_fz_packed_path_size(self)

    def fz_quadto(self, x0, y0, x1, y1):
        r"""
        Class-aware wrapper for `::fz_quadto()`.
        	Append a 'quadto' command to an open path. (For a
        	quadratic bezier).

        	path: The path to modify.

        	x0, y0: The control coordinates for the quadratic curve.

        	x1, y1: The end coordinates for the quadratic curve.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_quadto(self, x0, y0, x1, y1)

    def fz_rectto(self, x0, y0, x1, y1):
        r"""
        Class-aware wrapper for `::fz_rectto()`.
        	Append a 'rectto' command to an open path.

        	The rectangle is equivalent to:
        		moveto x0 y0
        		lineto x1 y0
        		lineto x1 y1
        		lineto x0 y1
        		closepath

        	path: The path to modify.

        	x0, y0: First corner of the rectangle.

        	x1, y1: Second corner of the rectangle.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_rectto(self, x0, y0, x1, y1)

    def fz_transform_path(self, transform):
        r"""
        Class-aware wrapper for `::fz_transform_path()`.
        	Transform a path by a given
        	matrix.

        	path: The path to modify (must not be a packed path).

        	transform: The transform to apply.

        	Throws exceptions if the path is packed, or on failure
        	to allocate.
        """
        return _mupdf.FzPath_fz_transform_path(self, transform)

    def fz_trim_path(self):
        r"""
        Class-aware wrapper for `::fz_trim_path()`.
        	Minimise the internal storage used by a path.

        	As paths are constructed, the internal buffers
        	grow. To avoid repeated reallocations they
        	grow with some spare space. Once a path has
        	been fully constructed, this call allows the
        	excess space to be trimmed.
        """
        return _mupdf.FzPath_fz_trim_path(self)

    def fz_walk_path(self, walker, arg):
        r"""
        Class-aware wrapper for `::fz_walk_path()`.
        	Walk the segments of a path, calling the
        	appropriate callback function from a given set for each
        	segment of the path.

        	path: The path to walk.

        	walker: The set of callback functions to use. The first
        	4 callback pointers in the set must be non-NULL. The
        	subsequent ones can either be supplied, or can be left
        	as NULL, in which case the top 4 functions will be
        	called as appropriate to simulate them.

        	arg: An opaque argument passed in to each callback.

        	Exceptions will only be thrown if the underlying callback
        	functions throw them.
        """
        return _mupdf.FzPath_fz_walk_path(self, walker, arg)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_path()`.
        		Create a new (empty) path structure.


        |

        *Overload 2:*
         Copy constructor using `fz_keep_path()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_path`.
        """
        _mupdf.FzPath_swiginit(self, _mupdf.new_FzPath(*args))
    __swig_destroy__ = _mupdf.delete_FzPath

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPath_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzPath___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzPath_m_internal_get, _mupdf.FzPath_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPath_s_num_instances_get, _mupdf.FzPath_s_num_instances_set)

# Register FzPath in _mupdf:
_mupdf.FzPath_swigregister(FzPath)
class FzPathWalker(object):
    r"""Wrapper class for struct `fz_path_walker`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, internal=None):
        r"""Constructor using raw copy of pre-existing `::fz_path_walker`."""
        _mupdf.FzPathWalker_swiginit(self, _mupdf.new_FzPathWalker(internal))
    __swig_destroy__ = _mupdf.delete_FzPathWalker

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPathWalker_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzPathWalker___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzPathWalker_m_internal_get, _mupdf.FzPathWalker_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPathWalker_s_num_instances_get, _mupdf.FzPathWalker_s_num_instances_set)

# Register FzPathWalker in _mupdf:
_mupdf.FzPathWalker_swigregister(FzPathWalker)
class FzPathWalker2(FzPathWalker):
    r"""Wrapper class for struct fz_path_walker with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""== Constructor."""
        if self.__class__ == FzPathWalker2:
            _self = None
        else:
            _self = self
        _mupdf.FzPathWalker2_swiginit(self, _mupdf.new_FzPathWalker2(_self, ))
    __swig_destroy__ = _mupdf.delete_FzPathWalker2

    def use_virtual_moveto(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.FzPathWalker2_use_virtual_moveto(self, use)

    def use_virtual_lineto(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_lineto(self, use)

    def use_virtual_curveto(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_curveto(self, use)

    def use_virtual_closepath(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_closepath(self, use)

    def use_virtual_quadto(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_quadto(self, use)

    def use_virtual_curvetov(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_curvetov(self, use)

    def use_virtual_curvetoy(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_curvetoy(self, use)

    def use_virtual_rectto(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_rectto(self, use)

    def moveto(self, arg_0, arg_2, arg_3):
        r"""Default virtual method implementations; these all throw an exception."""
        return _mupdf.FzPathWalker2_moveto(self, arg_0, arg_2, arg_3)

    def lineto(self, arg_0, arg_2, arg_3):
        return _mupdf.FzPathWalker2_lineto(self, arg_0, arg_2, arg_3)

    def curveto(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzPathWalker2_curveto(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def closepath(self, arg_0):
        return _mupdf.FzPathWalker2_closepath(self, arg_0)

    def quadto(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzPathWalker2_quadto(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def curvetov(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzPathWalker2_curvetov(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def curvetoy(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzPathWalker2_curvetoy(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def rectto(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzPathWalker2_rectto(self, arg_0, arg_2, arg_3, arg_4, arg_5)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_FzPathWalker2(self)
        return weakref.proxy(self)

# Register FzPathWalker2 in _mupdf:
_mupdf.FzPathWalker2_swigregister(FzPathWalker2)
class FzPclOptions(object):
    r"""
    Wrapper class for struct `fz_pcl_options`. Not copyable or assignable.
    PCL output
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_pcl_preset(self, preset):
        r"""
        Class-aware wrapper for `::fz_pcl_preset()`.
        	Initialize PCL option struct for a given preset.

        	Currently defined presets include:

        		generic	Generic PCL printer
        		ljet4	HP DeskJet
        		dj500	HP DeskJet 500
        		fs600	Kyocera FS-600
        		lj	HP LaserJet, HP LaserJet Plus
        		lj2	HP LaserJet IIp, HP LaserJet IId
        		lj3	HP LaserJet III
        		lj3d	HP LaserJet IIId
        		lj4	HP LaserJet 4
        		lj4pl	HP LaserJet 4 PL
        		lj4d	HP LaserJet 4d
        		lp2563b	HP 2563B line printer
        		oce9050	Oce 9050 Line printer
        """
        return _mupdf.FzPclOptions_fz_pcl_preset(self, preset)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_parse_pcl_options()`.
        		Parse PCL options.

        		Currently defined options and values are as follows:

        			preset=X	Either "generic" or one of the presets as for fz_pcl_preset.
        			spacing=0	No vertical spacing capability
        			spacing=1	PCL 3 spacing (<ESC>*p+<n>Y)
        			spacing=2	PCL 4 spacing (<ESC>*b<n>Y)
        			spacing=3	PCL 5 spacing (<ESC>*b<n>Y and clear seed row)
        			mode2		Disable/Enable mode 2 graphics compression
        			mode3		Disable/Enable mode 3 graphics compression
        			eog_reset	End of graphics (<ESC>*rB) resets all parameters
        			has_duplex	Duplex supported (<ESC>&l<duplex>S)
        			has_papersize	Papersize setting supported (<ESC>&l<sizecode>A)
        			has_copies	Number of copies supported (<ESC>&l<copies>X)
        			is_ljet4pjl	Disable/Enable HP 4PJL model-specific output
        			is_oce9050	Disable/Enable Oce 9050 model-specific output


        |

        *Overload 2:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_pcl_options`.
        """
        _mupdf.FzPclOptions_swiginit(self, _mupdf.new_FzPclOptions(*args))
    __swig_destroy__ = _mupdf.delete_FzPclOptions

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPclOptions_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzPclOptions___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzPclOptions_m_internal_get, _mupdf.FzPclOptions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPclOptions_s_num_instances_get, _mupdf.FzPclOptions_s_num_instances_set)

# Register FzPclOptions in _mupdf:
_mupdf.FzPclOptions_swigregister(FzPclOptions)
class FzPclmOptions(object):
    r"""
    Wrapper class for struct `fz_pclm_options`. Not copyable or assignable.
    PCLm output
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_parse_pclm_options()`.
        		Parse PCLm options.

        		Currently defined options and values are as follows:

        			compression=none: No compression
        			compression=flate: Flate compression
        			strip-height=n: Strip height (default 16)


        |

        *Overload 2:*
         Construct using fz_parse_pclm_options().

        |

        *Overload 3:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_pclm_options`.
        """
        _mupdf.FzPclmOptions_swiginit(self, _mupdf.new_FzPclmOptions(*args))
    __swig_destroy__ = _mupdf.delete_FzPclmOptions

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPclmOptions_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzPclmOptions___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzPclmOptions_m_internal_get, _mupdf.FzPclmOptions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPclmOptions_s_num_instances_get, _mupdf.FzPclmOptions_s_num_instances_set)

# Register FzPclmOptions in _mupdf:
_mupdf.FzPclmOptions_swigregister(FzPclmOptions)
class FzPdfocrOptions(object):
    r"""
    Wrapper class for struct `fz_pdfocr_options`.
    PDFOCR output
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_parse_pdfocr_options(self, args):
        r"""
        Class-aware wrapper for `::fz_parse_pdfocr_options()`.
        	Parse PDFOCR options.

        	Currently defined options and values are as follows:

        		compression=none: No compression
        		compression=flate: Flate compression
        		strip-height=n: Strip height (default 16)
        		ocr-language=<lang>: OCR Language (default eng)
        		ocr-datadir=<datadir>: OCR data path (default rely on TESSDATA_PREFIX)
        """
        return _mupdf.FzPdfocrOptions_fz_parse_pdfocr_options(self, args)

    def language_set2(self, language):
        r"""Copies <language> into this->language, truncating if necessary."""
        return _mupdf.FzPdfocrOptions_language_set2(self, language)

    def datadir_set2(self, datadir):
        r"""Copies <datadir> into this->datadir, truncating if necessary."""
        return _mupdf.FzPdfocrOptions_datadir_set2(self, datadir)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_pdfocr_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_pdfocr_options`.
        """
        _mupdf.FzPdfocrOptions_swiginit(self, _mupdf.new_FzPdfocrOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzPdfocrOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzPdfocrOptions
    compress = property(_mupdf.FzPdfocrOptions_compress_get, _mupdf.FzPdfocrOptions_compress_set)
    strip_height = property(_mupdf.FzPdfocrOptions_strip_height_get, _mupdf.FzPdfocrOptions_strip_height_set)
    language = property(_mupdf.FzPdfocrOptions_language_get, _mupdf.FzPdfocrOptions_language_set)
    datadir = property(_mupdf.FzPdfocrOptions_datadir_get, _mupdf.FzPdfocrOptions_datadir_set)
    skew_correct = property(_mupdf.FzPdfocrOptions_skew_correct_get, _mupdf.FzPdfocrOptions_skew_correct_set)
    skew_angle = property(_mupdf.FzPdfocrOptions_skew_angle_get, _mupdf.FzPdfocrOptions_skew_angle_set)
    skew_border = property(_mupdf.FzPdfocrOptions_skew_border_get, _mupdf.FzPdfocrOptions_skew_border_set)
    page_count = property(_mupdf.FzPdfocrOptions_page_count_get, _mupdf.FzPdfocrOptions_page_count_set)
    s_num_instances = property(_mupdf.FzPdfocrOptions_s_num_instances_get, _mupdf.FzPdfocrOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzPdfocrOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzPdfocrOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzPdfocrOptions___ne__(self, rhs)

# Register FzPdfocrOptions in _mupdf:
_mupdf.FzPdfocrOptions_swigregister(FzPdfocrOptions)
class FzPixmap(object):
    r"""
    Wrapper class for struct `fz_pixmap`.
    Pixmaps represent a set of pixels for a 2 dimensional region of
    a plane. Each pixel has n components per pixel. The components
    are in the order process-components, spot-colors, alpha, where
    there can be 0 of any of those types. The data is in
    premultiplied alpha when rendering, but non-premultiplied for
    colorspace conversions and rescaling.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box):
        r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
        return _mupdf.FzPixmap_pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box)

    @staticmethod
    def pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
        r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
        return _mupdf.FzPixmap_pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

    @staticmethod
    def fz_new_pixmap_from_page_contents(page, ctm, cs, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.
        	Render the page contents without annotations.

        	Ownership of the pixmap is returned to the caller.
        """
        return _mupdf.FzPixmap_fz_new_pixmap_from_page_contents(page, ctm, cs, alpha)

    @staticmethod
    def fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha):
        r"""Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
        return _mupdf.FzPixmap_fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha)

    def fz_alpha_from_gray(self):
        r"""Class-aware wrapper for `::fz_alpha_from_gray()`."""
        return _mupdf.FzPixmap_fz_alpha_from_gray(self)

    def fz_clear_pixmap(self):
        r"""
        Class-aware wrapper for `::fz_clear_pixmap()`.
        	Sets all components (including alpha) of
        	all pixels in a pixmap to 0.

        	pix: The pixmap to clear.
        """
        return _mupdf.FzPixmap_fz_clear_pixmap(self)

    def fz_clear_pixmap_rect_with_value(self, value, r):
        r"""
        Class-aware wrapper for `::fz_clear_pixmap_rect_with_value()`.
        	Clears a subrect of a pixmap with the given value.

        	pix: The pixmap to clear.

        	value: Values in the range 0 to 255 are valid. Each component
        	sample for each pixel in the pixmap will be set to this value,
        	while alpha will always be set to 255 (non-transparent).

        	r: the rectangle.
        """
        return _mupdf.FzPixmap_fz_clear_pixmap_rect_with_value(self, value, r)

    def fz_clear_pixmap_with_value(self, value):
        r"""
        Class-aware wrapper for `::fz_clear_pixmap_with_value()`.
        	Clears a pixmap with the given value.

        	pix: The pixmap to clear.

        	value: Values in the range 0 to 255 are valid. Each component
        	sample for each pixel in the pixmap will be set to this value,
        	while alpha will always be set to 255 (non-transparent).

        	This function is horrible, and should be removed from the
        	API and replaced with a less magic one.
        """
        return _mupdf.FzPixmap_fz_clear_pixmap_with_value(self, value)

    def fz_clone_pixmap(self):
        r"""
        Class-aware wrapper for `::fz_clone_pixmap()`.
        	Clone a pixmap, copying the pixels and associated data to new
        	storage.

        	The reference count of 'old' is unchanged.
        """
        return _mupdf.FzPixmap_fz_clone_pixmap(self)

    def fz_clone_pixmap_area_with_different_seps(self, bbox, dcs, seps, color_params, default_cs):
        r"""Class-aware wrapper for `::fz_clone_pixmap_area_with_different_seps()`."""
        return _mupdf.FzPixmap_fz_clone_pixmap_area_with_different_seps(self, bbox, dcs, seps, color_params, default_cs)

    def fz_convert_indexed_pixmap_to_base(self):
        r"""
        Class-aware wrapper for `::fz_convert_indexed_pixmap_to_base()`.
        	Convert pixmap from indexed to base colorspace.

        	This creates a new bitmap containing the converted pixmap data.
        """
        return _mupdf.FzPixmap_fz_convert_indexed_pixmap_to_base(self)

    def fz_convert_pixmap(self, cs_des, prf, default_cs, color_params, keep_alpha):
        r"""
        Class-aware wrapper for `::fz_convert_pixmap()`.
        	Convert an existing pixmap to a desired
        	colorspace. Other properties of the pixmap, such as resolution
        	and position are copied to the converted pixmap.

        	pix: The pixmap to convert.

        	default_cs: If NULL pix->colorspace is used. It is possible that
        	the data may need to be interpreted as one of the color spaces
        	in default_cs.

        	cs_des: Desired colorspace, may be NULL to denote alpha-only.

        	prf: Proofing color space through which we need to convert.

        	color_params: Parameters that may be used in conversion (e.g.
        	ri).

        	keep_alpha: If 0 any alpha component is removed, otherwise
        	alpha is kept if present in the pixmap.
        """
        return _mupdf.FzPixmap_fz_convert_pixmap(self, cs_des, prf, default_cs, color_params, keep_alpha)

    def fz_convert_separation_pixmap_to_base(self):
        r"""
        Class-aware wrapper for `::fz_convert_separation_pixmap_to_base()`.
        	Convert pixmap from DeviceN/Separation to base colorspace.

        	This creates a new bitmap containing the converted pixmap data.
        """
        return _mupdf.FzPixmap_fz_convert_separation_pixmap_to_base(self)

    def fz_copy_pixmap_rect(self, src, r, default_cs):
        r"""Class-aware wrapper for `::fz_copy_pixmap_rect()`."""
        return _mupdf.FzPixmap_fz_copy_pixmap_rect(self, src, r, default_cs)

    def fz_decode_tile(self, decode):
        r"""Class-aware wrapper for `::fz_decode_tile()`."""
        return _mupdf.FzPixmap_fz_decode_tile(self, decode)

    def fz_deskew_pixmap(self, degrees, border):
        r"""Class-aware wrapper for `::fz_deskew_pixmap()`."""
        return _mupdf.FzPixmap_fz_deskew_pixmap(self, degrees, border)

    def fz_fill_pixmap_with_color(self, colorspace, color, color_params):
        r"""
        Class-aware wrapper for `::fz_fill_pixmap_with_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_fill_pixmap_with_color(::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color

        	Fill pixmap with solid color.
        """
        return _mupdf.FzPixmap_fz_fill_pixmap_with_color(self, colorspace, color, color_params)

    def fz_gamma_pixmap(self, gamma):
        r"""
        Class-aware wrapper for `::fz_gamma_pixmap()`.
        	Apply gamma correction to a pixmap. All components
        	of all pixels are modified (except alpha, which is unchanged).

        	gamma: The gamma value to apply; 1.0 for no change.
        """
        return _mupdf.FzPixmap_fz_gamma_pixmap(self, gamma)

    def fz_generate_transition(self, opix, npix, time, trans):
        r"""
        Class-aware wrapper for `::fz_generate_transition()`.
        	Generate a frame of a transition.

        	tpix: Target pixmap
        	opix: Old pixmap
        	npix: New pixmap
        	time: Position within the transition (0 to 256)
        	trans: Transition details

        	Returns 1 if successfully generated a frame.

        	Note: Pixmaps must include alpha.
        """
        return _mupdf.FzPixmap_fz_generate_transition(self, opix, npix, time, trans)

    def fz_invert_pixmap(self):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap()`.
        	Invert all the pixels in a pixmap. All components (process and
        	spots) of all pixels are inverted (except alpha, which is
        	unchanged).
        """
        return _mupdf.FzPixmap_fz_invert_pixmap(self)

    def fz_invert_pixmap_alpha(self):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap_alpha()`.
        	Invert the alpha fo all the pixels in a pixmap.
        """
        return _mupdf.FzPixmap_fz_invert_pixmap_alpha(self)

    def fz_invert_pixmap_luminance(self):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap_luminance()`.
        	Transform the pixels in a pixmap so that luminance of each
        	pixel is inverted, and the chrominance remains unchanged (as
        	much as accuracy allows).

        	All components of all pixels are inverted (except alpha, which
        	is unchanged). Only supports Grey and RGB bitmaps.
        """
        return _mupdf.FzPixmap_fz_invert_pixmap_luminance(self)

    def fz_invert_pixmap_raw(self):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap_raw()`.
        	Invert all the pixels in a non-premultiplied pixmap in a
        	very naive manner.
        """
        return _mupdf.FzPixmap_fz_invert_pixmap_raw(self)

    def fz_invert_pixmap_rect(self, rect):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap_rect()`.
        	Invert all the pixels in a given rectangle of a (premultiplied)
        	pixmap. All components of all pixels in the rectangle are
        	inverted (except alpha, which is unchanged).
        """
        return _mupdf.FzPixmap_fz_invert_pixmap_rect(self, rect)

    def fz_is_pixmap_monochrome(self):
        r"""
        Class-aware wrapper for `::fz_is_pixmap_monochrome()`.
        	Check if the pixmap is a 1-channel image containing samples with
        	only values 0 and 255
        """
        return _mupdf.FzPixmap_fz_is_pixmap_monochrome(self)

    def fz_md5_pixmap(self, digest):
        r"""Class-aware wrapper for `::fz_md5_pixmap()`."""
        return _mupdf.FzPixmap_fz_md5_pixmap(self, digest)

    def fz_md5_pixmap2(self):
        r"""
        Class-aware wrapper for `::fz_md5_pixmap2()`.
        C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
        """
        return _mupdf.FzPixmap_fz_md5_pixmap2(self)

    def fz_new_bitmap_from_pixmap(self, ht):
        r"""
        Class-aware wrapper for `::fz_new_bitmap_from_pixmap()`.
        	Make a bitmap from a pixmap and a halftone.

        	pix: The pixmap to generate from. Currently must be a single
        	color component with no alpha.

        	ht: The halftone to use. NULL implies the default halftone.

        	Returns the resultant bitmap. Throws exceptions in the case of
        	failure to allocate.
        """
        return _mupdf.FzPixmap_fz_new_bitmap_from_pixmap(self, ht)

    def fz_new_bitmap_from_pixmap_band(self, ht, band_start):
        r"""
        Class-aware wrapper for `::fz_new_bitmap_from_pixmap_band()`.
        	Make a bitmap from a pixmap and a
        	halftone, allowing for the position of the pixmap within an
        	overall banded rendering.

        	pix: The pixmap to generate from. Currently must be a single
        	color component with no alpha.

        	ht: The halftone to use. NULL implies the default halftone.

        	band_start: Vertical offset within the overall banded rendering
        	(in pixels)

        	Returns the resultant bitmap. Throws exceptions in the case of
        	failure to allocate.
        """
        return _mupdf.FzPixmap_fz_new_bitmap_from_pixmap_band(self, ht, band_start)

    def fz_new_buffer_from_pixmap_as_jpeg(self, color_params, quality, invert_cmyk):
        r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_jpeg(self, color_params, quality, invert_cmyk)

    def fz_new_buffer_from_pixmap_as_jpx(self, color_params, quality):
        r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_jpx(self, color_params, quality)

    def fz_new_buffer_from_pixmap_as_pam(self, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_pam(self, color_params)

    def fz_new_buffer_from_pixmap_as_png(self, color_params):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_png()`.
        	Reencode a given pixmap as a PNG into a buffer.

        	Ownership of the buffer is returned.
        """
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_png(self, color_params)

    def fz_new_buffer_from_pixmap_as_pnm(self, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_pnm(self, color_params)

    def fz_new_buffer_from_pixmap_as_psd(self, color_params):
        r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_psd(self, color_params)

    def fz_new_image_from_pixmap(self, mask):
        r"""
        Class-aware wrapper for `::fz_new_image_from_pixmap()`.
        	Create an image from the given
        	pixmap.

        	pixmap: The pixmap to base the image upon. A new reference
        	to this is taken.

        	mask: NULL, or another image to use as a mask for this one.
        	A new reference is taken to this image. Supplying a masked
        	image as a mask to another image is illegal!
        """
        return _mupdf.FzPixmap_fz_new_image_from_pixmap(self, mask)

    def fz_new_pixmap_from_alpha_channel(self):
        r"""Class-aware wrapper for `::fz_new_pixmap_from_alpha_channel()`."""
        return _mupdf.FzPixmap_fz_new_pixmap_from_alpha_channel(self)

    def fz_new_pixmap_from_color_and_mask(self, mask):
        r"""Class-aware wrapper for `::fz_new_pixmap_from_color_and_mask()`."""
        return _mupdf.FzPixmap_fz_new_pixmap_from_color_and_mask(self, mask)

    def fz_new_pixmap_from_pixmap(self, rect):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_pixmap()`.
        	Create a new pixmap that represents a subarea of the specified
        	pixmap. A reference is taken to this pixmap that will be dropped
        	on destruction.

        	The supplied rectangle must be wholly contained within the
        	original pixmap.

        	Returns a pointer to the new pixmap. Throws exception on failure
        	to allocate.
        """
        return _mupdf.FzPixmap_fz_new_pixmap_from_pixmap(self, rect)

    def fz_pixmap_alpha(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_alpha()`.
        	Return the number of alpha planes in a pixmap.

        	Returns the number of alphas. Does not throw exceptions.
        """
        return _mupdf.FzPixmap_fz_pixmap_alpha(self)

    def fz_pixmap_bbox(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_bbox()`.
        	Return the bounding box for a pixmap.
        """
        return _mupdf.FzPixmap_fz_pixmap_bbox(self)

    def fz_pixmap_colorants(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_colorants()`.
        	Return the number of colorants in a pixmap.

        	Returns the number of colorants (components, less any spots and
        	alpha).
        """
        return _mupdf.FzPixmap_fz_pixmap_colorants(self)

    def fz_pixmap_colorspace(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_colorspace()`.
        	Return the colorspace of a pixmap

        	Returns colorspace.
        """
        return _mupdf.FzPixmap_fz_pixmap_colorspace(self)

    def fz_pixmap_components(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_components()`.
        	Return the number of components in a pixmap.

        	Returns the number of components (including spots and alpha).
        """
        return _mupdf.FzPixmap_fz_pixmap_components(self)

    def fz_pixmap_height(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_height()`.
        	Return the height of the pixmap in pixels.
        """
        return _mupdf.FzPixmap_fz_pixmap_height(self)

    def fz_pixmap_samples(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_samples()`.
        	Returns a pointer to the pixel data of a pixmap.

        	Returns the pointer.
        """
        return _mupdf.FzPixmap_fz_pixmap_samples(self)

    def fz_pixmap_samples_int(self):
        r"""Class-aware wrapper for `::fz_pixmap_samples_int()`."""
        return _mupdf.FzPixmap_fz_pixmap_samples_int(self)

    def fz_pixmap_size(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_size()`.
        	Return sizeof fz_pixmap plus size of data, in bytes.
        """
        return _mupdf.FzPixmap_fz_pixmap_size(self)

    def fz_pixmap_spots(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_spots()`.
        	Return the number of spots in a pixmap.

        	Returns the number of spots (components, less colorants and
        	alpha). Does not throw exceptions.
        """
        return _mupdf.FzPixmap_fz_pixmap_spots(self)

    def fz_pixmap_stride(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_stride()`.
        	Return the number of bytes in a row in the pixmap.
        """
        return _mupdf.FzPixmap_fz_pixmap_stride(self)

    def fz_pixmap_width(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_width()`.
        	Return the width of the pixmap in pixels.
        """
        return _mupdf.FzPixmap_fz_pixmap_width(self)

    def fz_pixmap_x(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_x()`.
        	Return the x value of the pixmap in pixels.
        """
        return _mupdf.FzPixmap_fz_pixmap_x(self)

    def fz_pixmap_y(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_y()`.
        	Return the y value of the pixmap in pixels.
        """
        return _mupdf.FzPixmap_fz_pixmap_y(self)

    def fz_samples_get(self, offset):
        r"""
        Class-aware wrapper for `::fz_samples_get()`.
        Provides simple (but slow) access to pixmap data from Python and C#.
        """
        return _mupdf.FzPixmap_fz_samples_get(self, offset)

    def fz_samples_set(self, offset, value):
        r"""
        Class-aware wrapper for `::fz_samples_set()`.
        Provides simple (but slow) write access to pixmap data from Python and
        C#.
        """
        return _mupdf.FzPixmap_fz_samples_set(self, offset, value)

    def fz_save_pixmap_as_jpeg(self, filename, quality):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_jpeg()`.
        	Save a pixmap as a JPEG.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_jpeg(self, filename, quality)

    def fz_save_pixmap_as_jpx(self, filename, q):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_jpx()`.
        	Save pixmap data as JP2K with no subsampling.

        	quality = 100 = lossless
        	otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_jpx(self, filename, q)

    def fz_save_pixmap_as_pam(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pam()`.
        	Save a pixmap as a pnm (greyscale, rgb or cmyk, with or without
        	alpha).
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pam(self, filename)

    def fz_save_pixmap_as_pbm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pbm()`.
        	Save a pixmap as a pbm. (Performing halftoning).
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pbm(self, filename)

    def fz_save_pixmap_as_pcl(self, filename, append, pcl):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pcl()`.
        	Save an (RGB) pixmap as color PCL.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pcl(self, filename, append, pcl)

    def fz_save_pixmap_as_pclm(self, filename, append, options):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pclm()`.
        	Save a (Greyscale or RGB) pixmap as pclm.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pclm(self, filename, append, options)

    def fz_save_pixmap_as_pdfocr(self, filename, append, options):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pdfocr()`.
        	Save a (Greyscale or RGB) pixmap as pdfocr.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pdfocr(self, filename, append, options)

    def fz_save_pixmap_as_pkm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pkm()`.
        	Save a CMYK pixmap as a pkm. (Performing halftoning).
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pkm(self, filename)

    def fz_save_pixmap_as_png(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_png()`.
        	Save a (Greyscale or RGB) pixmap as a png.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_png(self, filename)

    def fz_save_pixmap_as_pnm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pnm()`.
        	Save a pixmap as a pnm (greyscale or rgb, no alpha).
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pnm(self, filename)

    def fz_save_pixmap_as_ps(self, filename, append):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_ps()`.
        	Save a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_ps(self, filename, append)

    def fz_save_pixmap_as_psd(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_psd()`.
        	Save a pixmap as a PSD file.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_psd(self, filename)

    def fz_save_pixmap_as_pwg(self, filename, append, pwg):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pwg()`.
        	Save a pixmap as a PWG.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pwg(self, filename, append, pwg)

    def fz_scale_pixmap(self, x, y, w, h, clip):
        r"""Class-aware wrapper for `::fz_scale_pixmap()`."""
        return _mupdf.FzPixmap_fz_scale_pixmap(self, x, y, w, h, clip)

    def fz_set_pixmap_resolution(self, xres, yres):
        r"""
        Class-aware wrapper for `::fz_set_pixmap_resolution()`.
        	Set the pixels per inch resolution of the pixmap.
        """
        return _mupdf.FzPixmap_fz_set_pixmap_resolution(self, xres, yres)

    def fz_skew_detect(self):
        r"""Class-aware wrapper for `::fz_skew_detect()`."""
        return _mupdf.FzPixmap_fz_skew_detect(self)

    def fz_subsample_pixmap(self, factor):
        r"""Class-aware wrapper for `::fz_subsample_pixmap()`."""
        return _mupdf.FzPixmap_fz_subsample_pixmap(self, factor)

    def fz_tint_pixmap(self, black, white):
        r"""
        Class-aware wrapper for `::fz_tint_pixmap()`.
        	Tint all the pixels in an RGB, BGR, or Gray pixmap.

        	black: Map black to this hexadecimal RGB color.

        	white: Map white to this hexadecimal RGB color.
        """
        return _mupdf.FzPixmap_fz_tint_pixmap(self, black, white)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_pixmap()`.
        		Create a new pixmap, with its origin at (0,0)

        		cs: The colorspace to use for the pixmap, or NULL for an alpha
        		plane/mask.

        		w: The width of the pixmap (in pixels)

        		h: The height of the pixmap (in pixels)

        		seps: Details of separations.

        		alpha: 0 for no alpha, 1 for alpha.

        		Returns a pointer to the new pixmap. Throws exception on failure
        		to allocate.


        |

        *Overload 2:*
         Constructor using `fz_new_pixmap_from_color_and_mask()`.

        |

        *Overload 3:*
         Constructor using `fz_new_pixmap_from_display_list()`.
        		Render the page to a pixmap using the transform and colorspace.

        		Ownership of the pixmap is returned to the caller.


        |

        *Overload 4:*
         Constructor using `fz_new_pixmap_from_display_list_with_separations()`.
        		Render the page contents with control over spot colors.

        		Ownership of the pixmap is returned to the caller.


        |

        *Overload 5:*
         Constructor using `fz_new_pixmap_from_page()`.

        |

        *Overload 6:*
         Constructor using `fz_new_pixmap_from_page_number()`.

        |

        *Overload 7:*
         Constructor using `fz_new_pixmap_from_page_number_with_separations()`.

        |

        *Overload 8:*
         Constructor using `fz_new_pixmap_from_page_with_separations()`.

        |

        *Overload 9:*
         Constructor using `fz_new_pixmap_from_pixmap()`.
        		Create a new pixmap that represents a subarea of the specified
        		pixmap. A reference is taken to this pixmap that will be dropped
        		on destruction.

        		The supplied rectangle must be wholly contained within the
        		original pixmap.

        		Returns a pointer to the new pixmap. Throws exception on failure
        		to allocate.


        |

        *Overload 10:*
         Constructor using `fz_new_pixmap_with_bbox()`.
        		Create a pixmap of a given size, location and pixel format.

        		The bounding box specifies the size of the created pixmap and
        		where it will be located. The colorspace determines the number
        		of components per pixel. Alpha is always present. Pixmaps are
        		reference counted, so drop references using fz_drop_pixmap.

        		colorspace: Colorspace format used for the created pixmap. The
        		pixmap will keep a reference to the colorspace.

        		bbox: Bounding box specifying location/size of created pixmap.

        		seps: Details of separations.

        		alpha: 0 for no alpha, 1 for alpha.

        		Returns a pointer to the new pixmap. Throws exception on failure
        		to allocate.


        |

        *Overload 11:*
         Constructor using `fz_new_pixmap_with_bbox_and_data()`.
        		Create a pixmap of a given size, location and pixel format,
        		using the supplied data block.

        		The bounding box specifies the size of the created pixmap and
        		where it will be located. The colorspace determines the number
        		of components per pixel. Alpha is always present. Pixmaps are
        		reference counted, so drop references using fz_drop_pixmap.

        		colorspace: Colorspace format used for the created pixmap. The
        		pixmap will keep a reference to the colorspace.

        		rect: Bounding box specifying location/size of created pixmap.

        		seps: Details of separations.

        		alpha: Number of alpha planes (0 or 1).

        		samples: The data block to keep the samples in.

        		Returns a pointer to the new pixmap. Throws exception on failure
        		to allocate.


        |

        *Overload 12:*
         Constructor using `fz_new_pixmap_with_data()`.
        		Create a new pixmap, with its origin at
        		(0,0) using the supplied data block.

        		cs: The colorspace to use for the pixmap, or NULL for an alpha
        		plane/mask.

        		w: The width of the pixmap (in pixels)

        		h: The height of the pixmap (in pixels)

        		seps: Details of separations.

        		alpha: 0 for no alpha, 1 for alpha.

        		stride: The byte offset from the pixel data in a row to the
        		pixel data in the next row.

        		samples: The data block to keep the samples in.

        		Returns a pointer to the new pixmap. Throws exception on failure to
        		allocate.


        |

        *Overload 13:*
         Constructor using `pdf_new_pixmap_from_annot()`.

        |

        *Overload 14:*
         Constructor using `pdf_new_pixmap_from_page_contents_with_separations_and_usage()`.

        |

        *Overload 15:*
         Constructor using `pdf_new_pixmap_from_page_contents_with_usage()`.

        |

        *Overload 16:*
         Copy constructor using `fz_keep_pixmap()`.

        |

        *Overload 17:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 18:*
         Constructor using raw copy of pre-existing `::fz_pixmap`.
        """
        _mupdf.FzPixmap_swiginit(self, _mupdf.new_FzPixmap(*args))

    def storable(self):
        return _mupdf.FzPixmap_storable(self)

    def x(self):
        return _mupdf.FzPixmap_x(self)

    def y(self):
        return _mupdf.FzPixmap_y(self)

    def w(self):
        return _mupdf.FzPixmap_w(self)

    def h(self):
        return _mupdf.FzPixmap_h(self)

    def n(self):
        return _mupdf.FzPixmap_n(self)

    def s(self):
        return _mupdf.FzPixmap_s(self)

    def alpha(self):
        return _mupdf.FzPixmap_alpha(self)

    def flags(self):
        return _mupdf.FzPixmap_flags(self)

    def stride(self):
        return _mupdf.FzPixmap_stride(self)

    def seps(self):
        return _mupdf.FzPixmap_seps(self)

    def xres(self):
        return _mupdf.FzPixmap_xres(self)

    def yres(self):
        return _mupdf.FzPixmap_yres(self)

    def colorspace(self):
        return _mupdf.FzPixmap_colorspace(self)

    def samples(self):
        return _mupdf.FzPixmap_samples(self)

    def underlying(self):
        return _mupdf.FzPixmap_underlying(self)
    __swig_destroy__ = _mupdf.delete_FzPixmap

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPixmap_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzPixmap___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzPixmap_m_internal_get, _mupdf.FzPixmap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPixmap_s_num_instances_get, _mupdf.FzPixmap_s_num_instances_set)

# Register FzPixmap in _mupdf:
_mupdf.FzPixmap_swigregister(FzPixmap)
class FzPixmapImage(object):
    r"""Wrapper class for struct `fz_pixmap_image`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_pixmap_image_tile(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_image_tile()`.
        	Retrieve the underlying fz_pixmap for an image.

        	Returns a pointer to the underlying fz_pixmap for an image,
        	or NULL if this image is not based upon an fz_pixmap.

        	No reference is returned. Lifespan is limited to that of
        	the image itself. If required, use fz_keep_pixmap to take
        	a reference to keep it longer.
        """
        return _mupdf.FzPixmapImage_fz_pixmap_image_tile(self)

    def fz_set_pixmap_image_tile(self, pix):
        r"""Class-aware wrapper for `::fz_set_pixmap_image_tile()`."""
        return _mupdf.FzPixmapImage_fz_set_pixmap_image_tile(self, pix)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_pixmap_image`.
        """
        _mupdf.FzPixmapImage_swiginit(self, _mupdf.new_FzPixmapImage(*args))
    __swig_destroy__ = _mupdf.delete_FzPixmapImage

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPixmapImage_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzPixmapImage___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzPixmapImage_m_internal_get, _mupdf.FzPixmapImage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPixmapImage_s_num_instances_get, _mupdf.FzPixmapImage_s_num_instances_set)

# Register FzPixmapImage in _mupdf:
_mupdf.FzPixmapImage_swigregister(FzPixmapImage)
class FzPoint(object):
    r"""
    Wrapper class for struct `fz_point`.
    fz_point is a point in a two-dimensional space.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_transform_point_xy(x, y, m):
        r"""Class-aware wrapper for `::fz_transform_point_xy()`."""
        return _mupdf.FzPoint_fz_transform_point_xy(x, y, m)

    def fz_detect_document(self, src):
        r"""Class-aware wrapper for `::fz_detect_document()`."""
        return _mupdf.FzPoint_fz_detect_document(self, src)

    def fz_is_point_inside_quad(self, q):
        r"""
        Class-aware wrapper for `::fz_is_point_inside_quad()`.
        	Inclusion test for quads.
        """
        return _mupdf.FzPoint_fz_is_point_inside_quad(self, q)

    def fz_is_point_inside_rect(self, r):
        r"""
        Class-aware wrapper for `::fz_is_point_inside_rect()`.
        	Inclusion test for rects. (Rect is assumed to be open, i.e.
        	top right corner is not included).
        """
        return _mupdf.FzPoint_fz_is_point_inside_rect(self, r)

    def fz_normalize_vector(self):
        r"""
        Class-aware wrapper for `::fz_normalize_vector()`.
        	Normalize a vector to length one.
        """
        return _mupdf.FzPoint_fz_normalize_vector(self)

    def fz_transform_point(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_transform_point()`.
        		Apply a transformation to a point.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale, fz_rotate and fz_translate for how to create a
        		matrix.

        		point: Pointer to point to update.

        		Returns transform (unchanged).


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_transform_point()`.
        		Apply a transformation to a point.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale, fz_rotate and fz_translate for how to create a
        		matrix.

        		point: Pointer to point to update.

        		Returns transform (unchanged).
        """
        return _mupdf.FzPoint_fz_transform_point(self, *args)

    def fz_transform_vector(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_transform_vector()`.
        		Apply a transformation to a vector.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale and fz_rotate for how to create a matrix. Any
        		translation will be ignored.

        		vector: Pointer to vector to update.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_transform_vector()`.
        		Apply a transformation to a vector.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale and fz_rotate for how to create a matrix. Any
        		translation will be ignored.

        		vector: Pointer to vector to update.
        """
        return _mupdf.FzPoint_fz_transform_vector(self, *args)

    def transform(self, m):
        r"""Post-multiply *this by <m> and return *this."""
        return _mupdf.FzPoint_transform(self, m)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Construct using specified values.

        |

        *Overload 2:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_point`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_point`.
        """
        _mupdf.FzPoint_swiginit(self, _mupdf.new_FzPoint(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzPoint_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzPoint
    x = property(_mupdf.FzPoint_x_get, _mupdf.FzPoint_x_set)
    y = property(_mupdf.FzPoint_y_get, _mupdf.FzPoint_y_set)
    s_num_instances = property(_mupdf.FzPoint_s_num_instances_get, _mupdf.FzPoint_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzPoint_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzPoint___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzPoint___ne__(self, rhs)

# Register FzPoint in _mupdf:
_mupdf.FzPoint_swigregister(FzPoint)
class FzPool(object):
    r"""
    Wrapper class for struct `fz_pool`. Not copyable or assignable.
    Simple pool allocators.

    Allocate from the pool, which can then be freed at once.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_pool_alloc(self, size):
        r"""
        Class-aware wrapper for `::fz_pool_alloc()`.
        	Allocate a block of size bytes from the pool.
        """
        return _mupdf.FzPool_fz_pool_alloc(self, size)

    def fz_pool_size(self):
        r"""
        Class-aware wrapper for `::fz_pool_size()`.
        	The current size of the pool.

        	The number of bytes of storage currently allocated to the pool.
        	This is the total of the storage used for the blocks making
        	up the pool, rather then total of the allocated blocks so far,
        	so it will increase in 'lumps'.
        	from the pool, then the pool size may still be X
        """
        return _mupdf.FzPool_fz_pool_size(self)

    def fz_pool_strdup(self, s):
        r"""
        Class-aware wrapper for `::fz_pool_strdup()`.
        	strdup equivalent allocating from the pool.
        """
        return _mupdf.FzPool_fz_pool_strdup(self, s)

    def fz_xml_add_att(self, node, key, val):
        r"""
        Class-aware wrapper for `::fz_xml_add_att()`.
        	Add an attribute to an XML node.
        """
        return _mupdf.FzPool_fz_xml_add_att(self, node, key, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_pool()`.
        		Create a new pool to allocate from.


        |

        *Overload 2:*
         Constructor using raw copy of pre-existing `::fz_pool`.
        """
        _mupdf.FzPool_swiginit(self, _mupdf.new_FzPool(*args))
    __swig_destroy__ = _mupdf.delete_FzPool

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPool_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzPool___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzPool_m_internal_get, _mupdf.FzPool_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPool_s_num_instances_get, _mupdf.FzPool_s_num_instances_set)

# Register FzPool in _mupdf:
_mupdf.FzPool_swigregister(FzPool)
class FzPtrHeap(object):
    r"""Wrapper class for struct `fz_ptr_heap`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_ptr_heap_insert(self, v, HEAP_CMP):
        r"""Class-aware wrapper for `::fz_ptr_heap_insert()`."""
        return _mupdf.FzPtrHeap_fz_ptr_heap_insert(self, v, HEAP_CMP)

    def fz_ptr_heap_sort(self, HEAP_CMP):
        r"""Class-aware wrapper for `::fz_ptr_heap_sort()`."""
        return _mupdf.FzPtrHeap_fz_ptr_heap_sort(self, HEAP_CMP)

    def fz_ptr_heap_uniq(self, HEAP_CMP):
        r"""Class-aware wrapper for `::fz_ptr_heap_uniq()`."""
        return _mupdf.FzPtrHeap_fz_ptr_heap_uniq(self, HEAP_CMP)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_ptr_heap`.
        """
        _mupdf.FzPtrHeap_swiginit(self, _mupdf.new_FzPtrHeap(*args))
    __swig_destroy__ = _mupdf.delete_FzPtrHeap

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPtrHeap_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzPtrHeap___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzPtrHeap_m_internal_get, _mupdf.FzPtrHeap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPtrHeap_s_num_instances_get, _mupdf.FzPtrHeap_s_num_instances_set)

# Register FzPtrHeap in _mupdf:
_mupdf.FzPtrHeap_swigregister(FzPtrHeap)
class FzPwgOptions(object):
    r"""Wrapper class for struct `fz_pwg_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_pwg_options`.
        """
        _mupdf.FzPwgOptions_swiginit(self, _mupdf.new_FzPwgOptions(*args))

    def media_class(self):
        return _mupdf.FzPwgOptions_media_class(self)

    def media_color(self):
        return _mupdf.FzPwgOptions_media_color(self)

    def media_type(self):
        return _mupdf.FzPwgOptions_media_type(self)

    def output_type(self):
        return _mupdf.FzPwgOptions_output_type(self)

    def advance_distance(self):
        return _mupdf.FzPwgOptions_advance_distance(self)

    def advance_media(self):
        return _mupdf.FzPwgOptions_advance_media(self)

    def collate(self):
        return _mupdf.FzPwgOptions_collate(self)

    def cut_media(self):
        return _mupdf.FzPwgOptions_cut_media(self)

    def duplex(self):
        return _mupdf.FzPwgOptions_duplex(self)

    def insert_sheet(self):
        return _mupdf.FzPwgOptions_insert_sheet(self)

    def jog(self):
        return _mupdf.FzPwgOptions_jog(self)

    def leading_edge(self):
        return _mupdf.FzPwgOptions_leading_edge(self)

    def manual_feed(self):
        return _mupdf.FzPwgOptions_manual_feed(self)

    def media_position(self):
        return _mupdf.FzPwgOptions_media_position(self)

    def media_weight(self):
        return _mupdf.FzPwgOptions_media_weight(self)

    def mirror_print(self):
        return _mupdf.FzPwgOptions_mirror_print(self)

    def negative_print(self):
        return _mupdf.FzPwgOptions_negative_print(self)

    def num_copies(self):
        return _mupdf.FzPwgOptions_num_copies(self)

    def orientation(self):
        return _mupdf.FzPwgOptions_orientation(self)

    def output_face_up(self):
        return _mupdf.FzPwgOptions_output_face_up(self)

    def PageSize(self):
        return _mupdf.FzPwgOptions_PageSize(self)

    def separations(self):
        return _mupdf.FzPwgOptions_separations(self)

    def tray_switch(self):
        return _mupdf.FzPwgOptions_tray_switch(self)

    def tumble(self):
        return _mupdf.FzPwgOptions_tumble(self)

    def media_type_num(self):
        return _mupdf.FzPwgOptions_media_type_num(self)

    def compression(self):
        return _mupdf.FzPwgOptions_compression(self)

    def row_count(self):
        return _mupdf.FzPwgOptions_row_count(self)

    def row_feed(self):
        return _mupdf.FzPwgOptions_row_feed(self)

    def row_step(self):
        return _mupdf.FzPwgOptions_row_step(self)

    def rendering_intent(self):
        return _mupdf.FzPwgOptions_rendering_intent(self)

    def page_size_name(self):
        return _mupdf.FzPwgOptions_page_size_name(self)
    __swig_destroy__ = _mupdf.delete_FzPwgOptions
    m_internal = property(_mupdf.FzPwgOptions_m_internal_get, _mupdf.FzPwgOptions_m_internal_set)
    s_num_instances = property(_mupdf.FzPwgOptions_s_num_instances_get, _mupdf.FzPwgOptions_s_num_instances_set, doc=r"""Wrapped data is held by value.""")

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzPwgOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzPwgOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzPwgOptions___ne__(self, rhs)

# Register FzPwgOptions in _mupdf:
_mupdf.FzPwgOptions_swigregister(FzPwgOptions)
class FzQuad(object):
    r"""
    Wrapper class for struct `fz_quad`.
    A representation for a region defined by 4 points.

    The significant difference between quads and rects is that
    the edges of quads are not axis aligned.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_is_empty_quad(self):
        r"""
        Class-aware wrapper for `::fz_is_empty_quad()`.
        	Is a quad empty?
        """
        return _mupdf.FzQuad_fz_is_empty_quad(self)

    def fz_is_infinite_quad(self):
        r"""
        Class-aware wrapper for `::fz_is_infinite_quad()`.
        	Is a quad infinite?
        """
        return _mupdf.FzQuad_fz_is_infinite_quad(self)

    def fz_is_quad_inside_quad(self, haystack):
        r"""
        Class-aware wrapper for `::fz_is_quad_inside_quad()`.
        	Inclusion test for quad in quad.

        	This may break down if quads are not 'well formed'.
        """
        return _mupdf.FzQuad_fz_is_quad_inside_quad(self, haystack)

    def fz_is_quad_intersecting_quad(self, b):
        r"""
        Class-aware wrapper for `::fz_is_quad_intersecting_quad()`.
        	Intersection test for quads.

        	This may break down if quads are not 'well formed'.
        """
        return _mupdf.FzQuad_fz_is_quad_intersecting_quad(self, b)

    def fz_is_valid_quad(self):
        r"""
        Class-aware wrapper for `::fz_is_valid_quad()`.
        	Is a quad valid?
        """
        return _mupdf.FzQuad_fz_is_valid_quad(self)

    def fz_rect_from_quad(self):
        r"""
        Class-aware wrapper for `::fz_rect_from_quad()`.
        	Convert a quad to the smallest rect that covers it.
        """
        return _mupdf.FzQuad_fz_rect_from_quad(self)

    def fz_transform_quad(self, m):
        r"""
        Class-aware wrapper for `::fz_transform_quad()`.
        	Transform a quad by a matrix.
        """
        return _mupdf.FzQuad_fz_transform_quad(self, m)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_quad_from_rect()`.
        		Convert a rect to a quad (losslessly).


        |

        *Overload 2:*
         Constructor using `fz_transform_quad()`.
        		Transform a quad by a matrix.


        |

        *Overload 3:*
         We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_quad`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_quad`.
        """
        _mupdf.FzQuad_swiginit(self, _mupdf.new_FzQuad(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzQuad_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzQuad
    ul = property(_mupdf.FzQuad_ul_get, _mupdf.FzQuad_ul_set)
    ur = property(_mupdf.FzQuad_ur_get, _mupdf.FzQuad_ur_set)
    ll = property(_mupdf.FzQuad_ll_get, _mupdf.FzQuad_ll_set)
    lr = property(_mupdf.FzQuad_lr_get, _mupdf.FzQuad_lr_set)
    s_num_instances = property(_mupdf.FzQuad_s_num_instances_get, _mupdf.FzQuad_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzQuad_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzQuad___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzQuad___ne__(self, rhs)

# Register FzQuad in _mupdf:
_mupdf.FzQuad_swigregister(FzQuad)
class FzRange(object):
    r"""Wrapper class for struct `fz_range`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_range`.
        """
        _mupdf.FzRange_swiginit(self, _mupdf.new_FzRange(*args))
    __swig_destroy__ = _mupdf.delete_FzRange

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzRange_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzRange___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzRange_m_internal_get, _mupdf.FzRange_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzRange_s_num_instances_get, _mupdf.FzRange_s_num_instances_set)

# Register FzRange in _mupdf:
_mupdf.FzRange_swigregister(FzRange)
class FzRect(object):
    r"""Wrapper class for struct `fz_rect`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Fixed_UNIT = _mupdf.FzRect_Fixed_UNIT
    Fixed_EMPTY = _mupdf.FzRect_Fixed_EMPTY
    Fixed_INFINITE = _mupdf.FzRect_Fixed_INFINITE

    def fz_adjust_rect_for_stroke(self, stroke, ctm):
        r"""
        Class-aware wrapper for `::fz_adjust_rect_for_stroke()`.
        	Given a rectangle (assumed to be the bounding box for a path),
        	expand it to allow for the expansion of the bbox that would be
        	seen by stroking the path with the given stroke state and
        	transform.
        """
        return _mupdf.FzRect_fz_adjust_rect_for_stroke(self, stroke, ctm)

    def fz_contains_rect(self, b):
        r"""
        Class-aware wrapper for `::fz_contains_rect()`.
        	Test rectangle inclusion.

        	Return true if a entirely contains b.
        """
        return _mupdf.FzRect_fz_contains_rect(self, b)

    def fz_expand_rect(self, expand):
        r"""
        Class-aware wrapper for `::fz_expand_rect()`.
        	Expand a bbox by a given amount in all directions.
        """
        return _mupdf.FzRect_fz_expand_rect(self, expand)

    def fz_include_point_in_rect(self, p):
        r"""
        Class-aware wrapper for `::fz_include_point_in_rect()`.
        	Expand a bbox to include a given point.
        	To create a rectangle that encompasses a sequence of points, the
        	rectangle must first be set to be the empty rectangle at one of
        	the points before including the others.
        """
        return _mupdf.FzRect_fz_include_point_in_rect(self, p)

    def fz_intersect_rect(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_intersect_rect()`.
        		Compute intersection of two rectangles.

        		Given two rectangles, update the first to be the smallest
        		axis-aligned rectangle that covers the area covered by both
        		given rectangles. If either rectangle is empty then the
        		intersection is also empty. If either rectangle is infinite
        		then the intersection is simply the non-infinite rectangle.
        		Should both rectangles be infinite, then the intersection is
        		also infinite.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_intersect_rect()`.
        		Compute intersection of two rectangles.

        		Given two rectangles, update the first to be the smallest
        		axis-aligned rectangle that covers the area covered by both
        		given rectangles. If either rectangle is empty then the
        		intersection is also empty. If either rectangle is infinite
        		then the intersection is simply the non-infinite rectangle.
        		Should both rectangles be infinite, then the intersection is
        		also infinite.
        """
        return _mupdf.FzRect_fz_intersect_rect(self, *args)

    def fz_irect_from_rect(self):
        r"""
        Class-aware wrapper for `::fz_irect_from_rect()`.
        	Convert a rect into the minimal bounding box
        	that covers the rectangle.

        	Coordinates in a bounding box are integers, so rounding of the
        	rects coordinates takes place. The top left corner is rounded
        	upwards and left while the bottom right corner is rounded
        	downwards and to the right.
        """
        return _mupdf.FzRect_fz_irect_from_rect(self)

    def fz_is_empty_rect(self):
        r"""
        Class-aware wrapper for `::fz_is_empty_rect()`.
        	Check if rectangle is empty.

        	An empty rectangle is defined as one whose area is zero.
        	All invalid rectangles are empty.
        """
        return _mupdf.FzRect_fz_is_empty_rect(self)

    def fz_is_infinite_rect(self):
        r"""
        Class-aware wrapper for `::fz_is_infinite_rect()`.
        	Check if rectangle is infinite.
        """
        return _mupdf.FzRect_fz_is_infinite_rect(self)

    def fz_is_valid_rect(self):
        r"""
        Class-aware wrapper for `::fz_is_valid_rect()`.
        	Check if rectangle is valid.
        """
        return _mupdf.FzRect_fz_is_valid_rect(self)

    def fz_new_bbox_device(self):
        r"""
        Class-aware wrapper for `::fz_new_bbox_device()`.
        	Create a device to compute the bounding
        	box of all marks on a page.

        	The returned bounding box will be the union of all bounding
        	boxes of all objects on a page.
        """
        return _mupdf.FzRect_fz_new_bbox_device(self)

    def fz_new_display_list(self):
        r"""
        Class-aware wrapper for `::fz_new_display_list()`.
        	Create an empty display list.

        	A display list contains drawing commands (text, images, etc.).
        	Use fz_new_list_device for populating the list.

        	mediabox: Bounds of the page (in points) represented by the
        	display list.
        """
        return _mupdf.FzRect_fz_new_display_list(self)

    def fz_quad_from_rect(self):
        r"""
        Class-aware wrapper for `::fz_quad_from_rect()`.
        	Convert a rect to a quad (losslessly).
        """
        return _mupdf.FzRect_fz_quad_from_rect(self)

    def fz_round_rect(self):
        r"""
        Class-aware wrapper for `::fz_round_rect()`.
        	Round rectangle coordinates.

        	Coordinates in a bounding box are integers, so rounding of the
        	rects coordinates takes place. The top left corner is rounded
        	upwards and left while the bottom right corner is rounded
        	downwards and to the right.

        	This differs from fz_irect_from_rect, in that fz_irect_from_rect
        	slavishly follows the numbers (i.e any slight over/under
        	calculations can cause whole extra pixels to be added).
        	fz_round_rect allows for a small amount of rounding error when
        	calculating the bbox.
        """
        return _mupdf.FzRect_fz_round_rect(self)

    def fz_transform_page(self, resolution, rotate):
        r"""
        Class-aware wrapper for `::fz_transform_page()`.
        	Create transform matrix to draw page
        	at a given resolution and rotation. Adjusts the scaling
        	factors so that the page covers whole number of
        	pixels and adjust the page origin to be at 0,0.
        """
        return _mupdf.FzRect_fz_transform_page(self, resolution, rotate)

    def fz_transform_rect(self, m):
        r"""
        Class-aware wrapper for `::fz_transform_rect()`.
        	Apply a transform to a rectangle.

        	After the four corner points of the axis-aligned rectangle
        	have been transformed it may not longer be axis-aligned. So a
        	new axis-aligned rectangle is created covering at least the
        	area of the transformed rectangle.

        	transform: Transformation matrix to apply. See fz_concat,
        	fz_scale and fz_rotate for how to create a matrix.

        	rect: Rectangle to be transformed. The two special cases
        	fz_empty_rect and fz_infinite_rect, may be used but are
        	returned unchanged as expected.
        """
        return _mupdf.FzRect_fz_transform_rect(self, m)

    def fz_translate_rect(self, xoff, yoff):
        r"""
        Class-aware wrapper for `::fz_translate_rect()`.
        	Translate bounding box.

        	Translate a bbox by a given x and y offset. Allows for overflow.
        """
        return _mupdf.FzRect_fz_translate_rect(self, xoff, yoff)

    def fz_union_rect(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_union_rect()`.
        		Compute union of two rectangles.

        		Given two rectangles, update the first to be the smallest
        		axis-aligned rectangle that encompasses both given rectangles.
        		If either rectangle is infinite then the union is also infinite.
        		If either rectangle is empty then the union is simply the
        		non-empty rectangle. Should both rectangles be empty, then the
        		union is also empty.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_union_rect()`.
        		Compute union of two rectangles.

        		Given two rectangles, update the first to be the smallest
        		axis-aligned rectangle that encompasses both given rectangles.
        		If either rectangle is infinite then the union is also infinite.
        		If either rectangle is empty then the union is simply the
        		non-empty rectangle. Should both rectangles be empty, then the
        		union is also empty.
        """
        return _mupdf.FzRect_fz_union_rect(self, *args)

    def pdf_signature_appearance_signed(self, lang, img, left_text, right_text, include_logo):
        r"""Class-aware wrapper for `::pdf_signature_appearance_signed()`."""
        return _mupdf.FzRect_pdf_signature_appearance_signed(self, lang, img, left_text, right_text, include_logo)

    def pdf_signature_appearance_unsigned(self, lang):
        r"""Class-aware wrapper for `::pdf_signature_appearance_unsigned()`."""
        return _mupdf.FzRect_pdf_signature_appearance_unsigned(self, lang)

    def transform(self, m):
        r"""Transforms *this using fz_transform_rect() with <m>."""
        return _mupdf.FzRect_transform(self, m)

    def contains(self, *args):
        r"""
        *Overload 1:*
        Convenience method using fz_contains_rect().

        |

        *Overload 2:*
        Uses fz_contains_rect(*this, rhs).
        """
        return _mupdf.FzRect_contains(self, *args)

    def is_empty(self):
        r"""Uses fz_is_empty_rect()."""
        return _mupdf.FzRect_is_empty(self)

    def union_(self, rhs):
        r"""Updates *this using fz_union_rect()."""
        return _mupdf.FzRect_union_(self, rhs)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_bound_display_list()`.
        		Return the bounding box of the page recorded in a display list.


        |

        *Overload 2:*
         Constructor using `fz_rect_from_irect()`.
        		Convert a bbox into a rect.

        		For our purposes, a rect can represent all the values we meet in
        		a bbox, so nothing can go wrong.

        		rect: A place to store the generated rectangle.

        		bbox: The bbox to convert.

        		Returns rect (updated).


        |

        *Overload 3:*
         Constructor using `fz_rect_from_quad()`.
        		Convert a quad to the smallest rect that covers it.


        |

        *Overload 4:*
         Constructor using `fz_transform_rect()`.
        		Apply a transform to a rectangle.

        		After the four corner points of the axis-aligned rectangle
        		have been transformed it may not longer be axis-aligned. So a
        		new axis-aligned rectangle is created covering at least the
        		area of the transformed rectangle.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale and fz_rotate for how to create a matrix.

        		rect: Rectangle to be transformed. The two special cases
        		fz_empty_rect and fz_infinite_rect, may be used but are
        		returned unchanged as expected.


        |

        *Overload 5:*
         Construct from specified values.

        |

        *Overload 6:*
         Copy constructor using plain copy.

        |

        *Overload 7:*
         Construct from fz_unit_rect, fz_empty_rect or fz_infinite_rect.

        |

        *Overload 8:*
         We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 9:*
         Constructor using raw copy of pre-existing `::fz_rect`.

        |

        *Overload 10:*
         Constructor using raw copy of pre-existing `::fz_rect`.
        """
        _mupdf.FzRect_swiginit(self, _mupdf.new_FzRect(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzRect_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzRect
    x0 = property(_mupdf.FzRect_x0_get, _mupdf.FzRect_x0_set)
    y0 = property(_mupdf.FzRect_y0_get, _mupdf.FzRect_y0_set)
    x1 = property(_mupdf.FzRect_x1_get, _mupdf.FzRect_x1_set)
    y1 = property(_mupdf.FzRect_y1_get, _mupdf.FzRect_y1_set)
    s_num_instances = property(_mupdf.FzRect_s_num_instances_get, _mupdf.FzRect_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzRect_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzRect___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzRect___ne__(self, rhs)

# Register FzRect in _mupdf:
_mupdf.FzRect_swigregister(FzRect)
class FzSeparations(object):
    r"""Wrapper class for struct `fz_separations`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_add_separation(self, name, cs, cs_channel):
        r"""
        Class-aware wrapper for `::fz_add_separation()`.
        	Add a separation (null terminated name, colorspace)
        """
        return _mupdf.FzSeparations_fz_add_separation(self, name, cs, cs_channel)

    def fz_add_separation_equivalents(self, rgba, cmyk, name):
        r"""
        Class-aware wrapper for `::fz_add_separation_equivalents()`.
        	Add a separation with equivalents (null terminated name,
        	colorspace)

        	(old, deprecated)
        """
        return _mupdf.FzSeparations_fz_add_separation_equivalents(self, rgba, cmyk, name)

    def fz_clone_separations_for_overprint(self):
        r"""
        Class-aware wrapper for `::fz_clone_separations_for_overprint()`.
        	Return a separations object with all the spots in the input
        	separations object that are set to composite, reset to be
        	enabled. If there ARE no spots in the object, this returns
        	NULL. If the object already has all its spots enabled, then
        	just returns another handle on the same object.
        """
        return _mupdf.FzSeparations_fz_clone_separations_for_overprint(self)

    def fz_compare_separations(self, sep2):
        r"""
        Class-aware wrapper for `::fz_compare_separations()`.
        	Compare 2 separations structures (or NULLs).

        	Return 0 if identical, non-zero if not identical.
        """
        return _mupdf.FzSeparations_fz_compare_separations(self, sep2)

    def fz_count_active_separations(self):
        r"""
        Class-aware wrapper for `::fz_count_active_separations()`.
        	Return the number of active separations.
        """
        return _mupdf.FzSeparations_fz_count_active_separations(self)

    def fz_count_separations(self):
        r"""Class-aware wrapper for `::fz_count_separations()`."""
        return _mupdf.FzSeparations_fz_count_separations(self)

    def fz_separation_equivalent(self, idx, dst_cs, dst_color, prf, color_params):
        r"""
        Class-aware wrapper for `::fz_separation_equivalent()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_separation_equivalent(int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color

        	Get the equivalent separation color in a given colorspace.
        """
        return _mupdf.FzSeparations_fz_separation_equivalent(self, idx, dst_cs, dst_color, prf, color_params)

    def fz_separation_name(self, separation):
        r"""Class-aware wrapper for `::fz_separation_name()`."""
        return _mupdf.FzSeparations_fz_separation_name(self, separation)

    def fz_set_separation_behavior(self, separation, behavior):
        r"""
        Class-aware wrapper for `::fz_set_separation_behavior()`.
        	Control the rendering of a given separation.
        """
        return _mupdf.FzSeparations_fz_set_separation_behavior(self, separation, behavior)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_separations()`.
        		Create a new separations structure (initially empty)


        |

        *Overload 2:*
         Copy constructor using `fz_keep_separations()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_separations`.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_separations`.
        """
        _mupdf.FzSeparations_swiginit(self, _mupdf.new_FzSeparations(*args))
    __swig_destroy__ = _mupdf.delete_FzSeparations

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzSeparations_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzSeparations___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzSeparations_m_internal_get, _mupdf.FzSeparations_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzSeparations_s_num_instances_get, _mupdf.FzSeparations_s_num_instances_set)

# Register FzSeparations in _mupdf:
_mupdf.FzSeparations_swigregister(FzSeparations)
class FzSha256(object):
    r"""
    Wrapper class for struct `fz_sha256`. Not copyable or assignable.
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_sha256_final(self, digest):
        r"""
        Class-aware wrapper for `::fz_sha256_final()`.
        	MD5 finalization. Ends an MD5 message-digest operation, writing
        	the message digest and zeroizing the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha256_fz_sha256_final(self, digest)

    def fz_sha256_init(self):
        r"""
        Class-aware wrapper for `::fz_sha256_init()`.
        	SHA256 initialization. Begins an SHA256 operation, initialising
        	the supplied context.

        	Never throws an exception.
        """
        return _mupdf.FzSha256_fz_sha256_init(self)

    def fz_sha256_update(self, input, inlen):
        r"""
        Class-aware wrapper for `::fz_sha256_update()`.
        	SHA256 block update operation. Continues an SHA256 message-
        	digest operation, processing another message block, and updating
        	the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha256_fz_sha256_update(self, input, inlen)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_sha256`.
        """
        _mupdf.FzSha256_swiginit(self, _mupdf.new_FzSha256(*args))
    __swig_destroy__ = _mupdf.delete_FzSha256

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzSha256_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzSha256___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzSha256_m_internal_get, _mupdf.FzSha256_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzSha256_s_num_instances_get, _mupdf.FzSha256_s_num_instances_set)

# Register FzSha256 in _mupdf:
_mupdf.FzSha256_swigregister(FzSha256)
class FzSha384(object):
    r"""Wrapper class for struct `fz_sha384`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_sha384`.
        """
        _mupdf.FzSha384_swiginit(self, _mupdf.new_FzSha384(*args))
    __swig_destroy__ = _mupdf.delete_FzSha384

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzSha384_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzSha384___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzSha384_m_internal_get, _mupdf.FzSha384_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzSha384_s_num_instances_get, _mupdf.FzSha384_s_num_instances_set)

# Register FzSha384 in _mupdf:
_mupdf.FzSha384_swigregister(FzSha384)
class FzSha512(object):
    r"""
    Wrapper class for struct `fz_sha512`. Not copyable or assignable.
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_sha384_final(self, digest):
        r"""
        Class-aware wrapper for `::fz_sha384_final()`.
        	SHA384 finalization. Ends an SHA384 message-digest operation,
        	writing the message digest and zeroizing the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha384_final(self, digest)

    def fz_sha384_init(self):
        r"""
        Class-aware wrapper for `::fz_sha384_init()`.
        	SHA384 initialization. Begins an SHA384 operation, initialising
        	the supplied context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha384_init(self)

    def fz_sha384_update(self, input, inlen):
        r"""
        Class-aware wrapper for `::fz_sha384_update()`.
        	SHA384 block update operation. Continues an SHA384 message-
        	digest operation, processing another message block, and updating
        	the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha384_update(self, input, inlen)

    def fz_sha512_final(self, digest):
        r"""
        Class-aware wrapper for `::fz_sha512_final()`.
        	SHA512 finalization. Ends an SHA512 message-digest operation,
        	writing the message digest and zeroizing the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha512_final(self, digest)

    def fz_sha512_init(self):
        r"""
        Class-aware wrapper for `::fz_sha512_init()`.
        	SHA512 initialization. Begins an SHA512 operation, initialising
        	the supplied context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha512_init(self)

    def fz_sha512_update(self, input, inlen):
        r"""
        Class-aware wrapper for `::fz_sha512_update()`.
        	SHA512 block update operation. Continues an SHA512 message-
        	digest operation, processing another message block, and updating
        	the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha512_update(self, input, inlen)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_sha512`.
        """
        _mupdf.FzSha512_swiginit(self, _mupdf.new_FzSha512(*args))
    __swig_destroy__ = _mupdf.delete_FzSha512

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzSha512_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzSha512___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzSha512_m_internal_get, _mupdf.FzSha512_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzSha512_s_num_instances_get, _mupdf.FzSha512_s_num_instances_set)

# Register FzSha512 in _mupdf:
_mupdf.FzSha512_swigregister(FzSha512)
class FzShade(object):
    r"""
    Wrapper class for struct `fz_shade`.
    Structure is public to allow derived classes. Do not
    access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bound_shade(self, ctm):
        r"""
        Class-aware wrapper for `::fz_bound_shade()`.
        	Bound a given shading.

        	shade: The shade to bound.

        	ctm: The transform to apply to the shade before bounding.

        	r: Pointer to storage to put the bounds in.

        	Returns r, updated to contain the bounds for the shading.
        """
        return _mupdf.FzShade_fz_bound_shade(self, ctm)

    def fz_paint_shade(self, override_cs, ctm, dest, color_params, bbox, eop, cache):
        r"""
        Class-aware wrapper for `::fz_paint_shade()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_paint_shade(::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` =>

        	Render a shade to a given pixmap.

        	shade: The shade to paint.

        	override_cs: NULL, or colorspace to override the shades
        	inbuilt colorspace.

        	ctm: The transform to apply.

        	dest: The pixmap to render into.

        	color_params: The color rendering settings

        	bbox: Pointer to a bounding box to limit the rendering
        	of the shade.

        	eop: NULL, or pointer to overprint bitmap.

        	cache: *cache is used to cache color information. If *cache is NULL it
        	is set to point to a new fz_shade_color_cache. If cache is NULL it is
        	ignored.
        """
        return _mupdf.FzShade_fz_paint_shade(self, override_cs, ctm, dest, color_params, bbox, eop, cache)

    def fz_process_shade(self, ctm, scissor, prepare, process, process_arg):
        r"""
        Class-aware wrapper for `::fz_process_shade()`.
        	Process a shade, using supplied callback functions. This
        	decomposes the shading to a mesh (even ones that are not
        	natively meshes, such as linear or radial shadings), and
        	processes triangles from those meshes.

        	shade: The shade to process.

        	ctm: The transform to use

        	prepare: Callback function to 'prepare' each vertex.
        	This function is passed an array of floats, and populates
        	a fz_vertex structure.

        	process: This function is passed 3 pointers to vertex
        	structures, and actually performs the processing (typically
        	filling the area between the vertexes).

        	process_arg: An opaque argument passed through from caller
        	to callback functions.
        """
        return _mupdf.FzShade_fz_process_shade(self, ctm, scissor, prepare, process, process_arg)

    def fz_paint_shade_no_cache(self, override_cs, ctm, dest, color_params, bbox, eop):
        r"""Extra wrapper for fz_paint_shade(), passing cache=NULL."""
        return _mupdf.FzShade_fz_paint_shade_no_cache(self, override_cs, ctm, dest, color_params, bbox, eop)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_shade()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_shade`.
        """
        _mupdf.FzShade_swiginit(self, _mupdf.new_FzShade(*args))
    __swig_destroy__ = _mupdf.delete_FzShade

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzShade_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzShade___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzShade_m_internal_get, _mupdf.FzShade_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzShade_s_num_instances_get, _mupdf.FzShade_s_num_instances_set)

# Register FzShade in _mupdf:
_mupdf.FzShade_swigregister(FzShade)
class FzShadeColorCache(object):
    r"""Wrapper class for struct `fz_shade_color_cache`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_shade_color_cache`.
        """
        _mupdf.FzShadeColorCache_swiginit(self, _mupdf.new_FzShadeColorCache(*args))
    __swig_destroy__ = _mupdf.delete_FzShadeColorCache

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzShadeColorCache_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzShadeColorCache___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzShadeColorCache_m_internal_get, _mupdf.FzShadeColorCache_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzShadeColorCache_s_num_instances_get, _mupdf.FzShadeColorCache_s_num_instances_set)

# Register FzShadeColorCache in _mupdf:
_mupdf.FzShadeColorCache_swigregister(FzShadeColorCache)
class FzShaperDataT(object):
    r"""
    Wrapper class for struct `fz_shaper_data_t`. Not copyable or assignable.
    In order to shape a given font, we need to
    declare it to a shaper library (harfbuzz, by default, but others
    are possible). To avoid redeclaring it every time we need to
    shape, we hold a shaper handle and the destructor for it within
    the font itself. The handle is initialised by the caller when
    first required and the destructor is called when the fz_font is
    destroyed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_shaper_data_t`.
        """
        _mupdf.FzShaperDataT_swiginit(self, _mupdf.new_FzShaperDataT(*args))
    __swig_destroy__ = _mupdf.delete_FzShaperDataT

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzShaperDataT_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzShaperDataT___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzShaperDataT_m_internal_get, _mupdf.FzShaperDataT_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzShaperDataT_s_num_instances_get, _mupdf.FzShaperDataT_s_num_instances_set)

# Register FzShaperDataT in _mupdf:
_mupdf.FzShaperDataT_swigregister(FzShaperDataT)
class FzStextBlock(object):
    r"""Wrapper class for struct `fz_stext_block`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def i_transform(self):
        r"""Returns m_internal.u.i.transform if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
        return _mupdf.FzStextBlock_i_transform(self)

    def i_image(self):
        r"""Returns m_internal.u.i.image if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
        return _mupdf.FzStextBlock_i_image(self)

    def begin(self):
        r"""Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
        return _mupdf.FzStextBlock_begin(self)

    def end(self):
        r"""Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
        return _mupdf.FzStextBlock_end(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_stext_block`.
        """
        _mupdf.FzStextBlock_swiginit(self, _mupdf.new_FzStextBlock(*args))
    __swig_destroy__ = _mupdf.delete_FzStextBlock

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextBlock_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStextBlock___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStextBlock_m_internal_get, _mupdf.FzStextBlock_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextBlock_s_num_instances_get, _mupdf.FzStextBlock_s_num_instances_set)

# Register FzStextBlock in _mupdf:
_mupdf.FzStextBlock_swigregister(FzStextBlock)
class FzStextChar(object):
    r"""
    Wrapper class for struct `fz_stext_char`.
    Text extraction device: Used for searching, format conversion etc.

    (In development - Subject to change in future versions)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_stext_char`.
        """
        _mupdf.FzStextChar_swiginit(self, _mupdf.new_FzStextChar(*args))
    __swig_destroy__ = _mupdf.delete_FzStextChar

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextChar_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStextChar___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStextChar_m_internal_get, _mupdf.FzStextChar_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextChar_s_num_instances_get, _mupdf.FzStextChar_s_num_instances_set)

# Register FzStextChar in _mupdf:
_mupdf.FzStextChar_swigregister(FzStextChar)
class FzStextGridPositions(object):
    r"""Wrapper class for struct `fz_stext_grid_positions`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_stext_grid_positions`.
        """
        _mupdf.FzStextGridPositions_swiginit(self, _mupdf.new_FzStextGridPositions(*args))
    __swig_destroy__ = _mupdf.delete_FzStextGridPositions

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextGridPositions_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStextGridPositions___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStextGridPositions_m_internal_get, _mupdf.FzStextGridPositions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextGridPositions_s_num_instances_get, _mupdf.FzStextGridPositions_s_num_instances_set)

# Register FzStextGridPositions in _mupdf:
_mupdf.FzStextGridPositions_swigregister(FzStextGridPositions)
class FzStextLine(object):
    r"""Wrapper class for struct `fz_stext_line`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def begin(self):
        r"""Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
        return _mupdf.FzStextLine_begin(self)

    def end(self):
        r"""Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
        return _mupdf.FzStextLine_end(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_stext_line`.
        """
        _mupdf.FzStextLine_swiginit(self, _mupdf.new_FzStextLine(*args))
    __swig_destroy__ = _mupdf.delete_FzStextLine

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextLine_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStextLine___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStextLine_m_internal_get, _mupdf.FzStextLine_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextLine_s_num_instances_get, _mupdf.FzStextLine_s_num_instances_set)

# Register FzStextLine in _mupdf:
_mupdf.FzStextLine_swigregister(FzStextLine)
class FzStextOptions(object):
    r"""
    Wrapper class for struct `fz_stext_options`.
    Options for creating structured text.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_parse_stext_options(self, string):
        r"""
        Class-aware wrapper for `::fz_parse_stext_options()`.
        	Parse stext device options from a comma separated key-value
        	string.
        """
        return _mupdf.FzStextOptions_fz_parse_stext_options(self, string)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Construct with .flags set to <flags>.

        |

        *Overload 2:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_stext_options`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_stext_options`.
        """
        _mupdf.FzStextOptions_swiginit(self, _mupdf.new_FzStextOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzStextOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzStextOptions
    flags = property(_mupdf.FzStextOptions_flags_get, _mupdf.FzStextOptions_flags_set)
    scale = property(_mupdf.FzStextOptions_scale_get, _mupdf.FzStextOptions_scale_set)
    s_num_instances = property(_mupdf.FzStextOptions_s_num_instances_get, _mupdf.FzStextOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzStextOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzStextOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzStextOptions___ne__(self, rhs)

# Register FzStextOptions in _mupdf:
_mupdf.FzStextOptions_swigregister(FzStextOptions)
class FzStextPage(object):
    r"""
    Wrapper class for struct `fz_stext_page`. Not copyable or assignable.
    A text page is a list of blocks, together with an overall
    bounding box.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_highlight_selection(self, a, b, quads, max_quads):
        r"""
        Class-aware wrapper for `::fz_highlight_selection()`.
        	Return a list of quads to highlight lines inside the selection
        	points.
        """
        return _mupdf.FzStextPage_fz_highlight_selection(self, a, b, quads, max_quads)

    def fz_highlight_selection2(self, a, b, max_quads):
        r"""
        Class-aware wrapper for `::fz_highlight_selection2()`.
        C++ alternative to fz_highlight_selection() that returns quads in a
        std::vector.
        """
        return _mupdf.FzStextPage_fz_highlight_selection2(self, a, b, max_quads)

    def fz_new_buffer_from_stext_page(self):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_stext_page()`.
        	Convert structured text into plain text.
        """
        return _mupdf.FzStextPage_fz_new_buffer_from_stext_page(self)

    def fz_new_stext_device(self, options):
        r"""
        Class-aware wrapper for `::fz_new_stext_device()`.
        	Create a device to extract the text on a page.

        	Gather the text on a page into blocks and lines.

        	The reading order is taken from the order the text is drawn in
        	the source file, so may not be accurate.

        	page: The text page to which content should be added. This will
        	usually be a newly created (empty) text page, but it can be one
        	containing data already (for example when merging multiple
        	pages, or watermarking).

        	options: Options to configure the stext device.
        """
        return _mupdf.FzStextPage_fz_new_stext_device(self, options)

    def fz_search_stext_page(self, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_stext_page()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_stext_page(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

        	Search for occurrence of 'needle' in text page.

        	Return the number of quads and store hit quads in the passed in
        	array.

        	NOTE: This is an experimental interface and subject to change
        	without notice.
        """
        return _mupdf.FzStextPage_fz_search_stext_page(self, needle, hit_mark, hit_bbox, hit_max)

    def fz_search_stext_page_cb(self, needle, cb, opaque):
        r"""
        Class-aware wrapper for `::fz_search_stext_page_cb()`.
        	Search for occurrence of 'needle' in text page.

        	Call callback once for each hit. This callback will receive
        	(potentially) multiple quads for each hit.

        	Returns the number of hits - note that this is potentially
        	different from (i.e. is not greater than) the number of quads
        	as returned by the non callback API.

        	NOTE: This is an experimental interface and subject to change
        	without notice.
        """
        return _mupdf.FzStextPage_fz_search_stext_page_cb(self, needle, cb, opaque)

    def fz_segment_stext_page(self):
        r"""
        Class-aware wrapper for `::fz_segment_stext_page()`.
        	Perform segmentation analysis on an (unstructured) page to look for
        	recursive subdivisions.

        	Essentially this code attempts to split the page horizontally and/or
        	vertically repeatedly into smaller and smaller "segments" (divisions).

        	Returns 0 if no changes were made to the document.

        	This is experimental code, and may change (or be removed) in future
        	versions!
        """
        return _mupdf.FzStextPage_fz_segment_stext_page(self)

    def fz_snap_selection(self, ap, bp, mode):
        r"""Class-aware wrapper for `::fz_snap_selection()`."""
        return _mupdf.FzStextPage_fz_snap_selection(self, ap, bp, mode)

    def fz_copy_selection(self, a, b, crlf):
        r"""Wrapper for fz_copy_selection() that returns std::string."""
        return _mupdf.FzStextPage_fz_copy_selection(self, a, b, crlf)

    def fz_copy_rectangle(self, area, crlf):
        r"""Wrapper for fz_copy_rectangle() that returns a std::string."""
        return _mupdf.FzStextPage_fz_copy_rectangle(self, area, crlf)

    def search_stext_page(self, needle, hit_mark, max_quads):
        r"""Wrapper for fz_search_stext_page() that returns std::vector of Quads."""
        return _mupdf.FzStextPage_search_stext_page(self, needle, hit_mark, max_quads)

    def begin(self):
        r"""Used for iteration over linked list of FzStextBlock items starting at fz_stext_block::first_block."""
        return _mupdf.FzStextPage_begin(self)

    def end(self):
        r"""Used for iteration over linked list of FzStextBlock items starting at fz_stext_block::first_block."""
        return _mupdf.FzStextPage_end(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_stext_page()`.
        		Create an empty text page.

        		The text page is filled out by the text device to contain the
        		blocks and lines of text on the page.

        		mediabox: optional mediabox information.


        |

        *Overload 2:*
         Constructor using `fz_new_stext_page_from_chapter_page_number()`.

        |

        *Overload 3:*
         Constructor using `fz_new_stext_page_from_display_list()`.

        |

        *Overload 4:*
         Constructor using `fz_new_stext_page_from_page()`.
        		Extract text from page.

        		Ownership of the fz_stext_page is returned to the caller.


        |

        *Overload 5:*
         Constructor using `fz_new_stext_page_from_page_number()`.

        |

        *Overload 6:*
         Constructor using `pdf_new_stext_page_from_annot()`.

        |

        *Overload 7:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 8:*
         Constructor using raw copy of pre-existing `::fz_stext_page`.
        """
        _mupdf.FzStextPage_swiginit(self, _mupdf.new_FzStextPage(*args))
    __swig_destroy__ = _mupdf.delete_FzStextPage

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextPage_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStextPage___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStextPage_m_internal_get, _mupdf.FzStextPage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextPage_s_num_instances_get, _mupdf.FzStextPage_s_num_instances_set)

# Register FzStextPage in _mupdf:
_mupdf.FzStextPage_swigregister(FzStextPage)
class FzStextStruct(object):
    r"""Wrapper class for struct `fz_stext_struct`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_stext_struct`.
        """
        _mupdf.FzStextStruct_swiginit(self, _mupdf.new_FzStextStruct(*args))
    __swig_destroy__ = _mupdf.delete_FzStextStruct

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextStruct_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStextStruct___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStextStruct_m_internal_get, _mupdf.FzStextStruct_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextStruct_s_num_instances_get, _mupdf.FzStextStruct_s_num_instances_set)

# Register FzStextStruct in _mupdf:
_mupdf.FzStextStruct_swigregister(FzStextStruct)
class FzStorable(object):
    r"""
    Wrapper class for struct `fz_storable`.
    Resource store

    MuPDF stores decoded "objects" into a store for potential reuse.
    If the size of the store gets too big, objects stored within it
    can be evicted and freed to recover space. When MuPDF comes to
    decode such an object, it will check to see if a version of this
    object is already in the store - if it is, it will simply reuse
    it. If not, it will decode it and place it into the store.

    All objects that can be placed into the store are derived from
    the fz_storable type (i.e. this should be the first component of
    the objects structure). This allows for consistent (thread safe)
    reference counting, and includes a function that will be called
    to free the object as soon as the reference count reaches zero.

    Most objects offer fz_keep_XXXX/fz_drop_XXXX functions derived
    from fz_keep_storable/fz_drop_storable. Creation of such objects
    includes a call to FZ_INIT_STORABLE to set up the fz_storable
    header.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_storable()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_storable`.
        """
        _mupdf.FzStorable_swiginit(self, _mupdf.new_FzStorable(*args))
    __swig_destroy__ = _mupdf.delete_FzStorable

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStorable_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStorable___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStorable_m_internal_get, _mupdf.FzStorable_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStorable_s_num_instances_get, _mupdf.FzStorable_s_num_instances_set)

# Register FzStorable in _mupdf:
_mupdf.FzStorable_swigregister(FzStorable)
class FzStore(object):
    r"""Wrapper class for struct `fz_store`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_store`.
        """
        _mupdf.FzStore_swiginit(self, _mupdf.new_FzStore(*args))
    __swig_destroy__ = _mupdf.delete_FzStore

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStore_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStore___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStore_m_internal_get, _mupdf.FzStore_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStore_s_num_instances_get, _mupdf.FzStore_s_num_instances_set)

# Register FzStore in _mupdf:
_mupdf.FzStore_swigregister(FzStore)
class FzStoreHash(object):
    r"""
    Wrapper class for struct `fz_store_hash`. Not copyable or assignable.
    The store can be seen as a dictionary that maps keys to
    fz_storable values. In order to allow keys of different types to
    be stored, we have a structure full of functions for each key
    'type'; this fz_store_type pointer is stored with each key, and
    tells the store how to perform certain operations (like taking/
    dropping a reference, comparing two keys, outputting details for
    debugging etc).

    The store uses a hash table internally for speed where possible.
    In order for this to work, we need a mechanism for turning a
    generic 'key' into 'a hashable string'. For this purpose the
    type structure contains a make_hash_key function pointer that
    maps from a void * to a fz_store_hash structure. If
    make_hash_key function returns 0, then the key is determined not
    to be hashable, and the value is not stored in the hash table.

    Some objects can be used both as values within the store, and as
    a component of keys within the store. We refer to these objects
    as "key storable" objects. In this case, we need to take
    additional care to ensure that we do not end up keeping an item
    within the store, purely because its value is referred to by
    another key in the store.

    An example of this are fz_images in PDF files. Each fz_image is
    placed into the	store to enable it to be easily reused. When the
    image is rendered, a pixmap is generated from the image, and the
    pixmap is placed into the store so it can be reused on
    subsequent renders. The image forms part of the key for the
    pixmap.

    When we close the pdf document (and any associated pages/display
    lists etc), we drop the images from the store. This may leave us
    in the position of the images having non-zero reference counts
    purely because they are used as part of the keys for the
    pixmaps.

    We therefore use special reference counting functions to keep
    track of these "key storable" items, and hence store the number
    of references to these items that are used in keys.

    When the number of references to an object == the number of
    references to an object from keys in the store, we know that we
    can remove all the items which have that object as part of the
    key. This is done by running a pass over the store, 'reaping'
    those items.

    Reap passes are slower than we would like as they touch every
    item in the store. We therefore provide a way to 'batch' such
    reap passes together, using fz_defer_reap_start/
    fz_defer_reap_end to bracket a region in which many may be
    triggered.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_store_hash`.
        """
        _mupdf.FzStoreHash_swiginit(self, _mupdf.new_FzStoreHash(*args))
    __swig_destroy__ = _mupdf.delete_FzStoreHash

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStoreHash_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStoreHash___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStoreHash_m_internal_get, _mupdf.FzStoreHash_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStoreHash_s_num_instances_get, _mupdf.FzStoreHash_s_num_instances_set)

# Register FzStoreHash in _mupdf:
_mupdf.FzStoreHash_swigregister(FzStoreHash)
class FzStoreType(object):
    r"""
    Wrapper class for struct `fz_store_type`. Not copyable or assignable.
    Every type of object to be placed into the store defines an
    fz_store_type. This contains the pointers to functions to
    make hashes, manipulate keys, and check for needing reaping.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_store_type`.
        """
        _mupdf.FzStoreType_swiginit(self, _mupdf.new_FzStoreType(*args))
    __swig_destroy__ = _mupdf.delete_FzStoreType

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStoreType_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStoreType___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStoreType_m_internal_get, _mupdf.FzStoreType_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStoreType_s_num_instances_get, _mupdf.FzStoreType_s_num_instances_set)

# Register FzStoreType in _mupdf:
_mupdf.FzStoreType_swigregister(FzStoreType)
class FzStory(object):
    r"""Wrapper class for struct `fz_story`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_draw_story(self, dev, ctm):
        r"""Class-aware wrapper for `::fz_draw_story()`."""
        return _mupdf.FzStory_fz_draw_story(self, dev, ctm)

    def fz_place_story(self, where, filled):
        r"""Class-aware wrapper for `::fz_place_story()`."""
        return _mupdf.FzStory_fz_place_story(self, where, filled)

    def fz_place_story_flags(self, where, filled, flags):
        r"""Class-aware wrapper for `::fz_place_story_flags()`."""
        return _mupdf.FzStory_fz_place_story_flags(self, where, filled, flags)

    def fz_reset_story(self):
        r"""Class-aware wrapper for `::fz_reset_story()`."""
        return _mupdf.FzStory_fz_reset_story(self)

    def fz_story_document(self):
        r"""Class-aware wrapper for `::fz_story_document()`."""
        return _mupdf.FzStory_fz_story_document(self)

    def fz_story_positions(self, cb, arg):
        r"""Class-aware wrapper for `::fz_story_positions()`."""
        return _mupdf.FzStory_fz_story_positions(self, cb, arg)

    def fz_story_warnings(self):
        r"""Class-aware wrapper for `::fz_story_warnings()`."""
        return _mupdf.FzStory_fz_story_warnings(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_new_story()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_story`.
        """
        _mupdf.FzStory_swiginit(self, _mupdf.new_FzStory(*args))
    __swig_destroy__ = _mupdf.delete_FzStory

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStory_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStory___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStory_m_internal_get, _mupdf.FzStory_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStory_s_num_instances_get, _mupdf.FzStory_s_num_instances_set)

# Register FzStory in _mupdf:
_mupdf.FzStory_swigregister(FzStory)
class FzStoryElementPosition(object):
    r"""Wrapper class for struct `fz_story_element_position`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_story_element_position`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_story_element_position`.
        """
        _mupdf.FzStoryElementPosition_swiginit(self, _mupdf.new_FzStoryElementPosition(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzStoryElementPosition_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzStoryElementPosition
    depth = property(_mupdf.FzStoryElementPosition_depth_get, _mupdf.FzStoryElementPosition_depth_set)
    heading = property(_mupdf.FzStoryElementPosition_heading_get, _mupdf.FzStoryElementPosition_heading_set)
    id = property(_mupdf.FzStoryElementPosition_id_get, _mupdf.FzStoryElementPosition_id_set)
    href = property(_mupdf.FzStoryElementPosition_href_get, _mupdf.FzStoryElementPosition_href_set)
    rect = property(_mupdf.FzStoryElementPosition_rect_get, _mupdf.FzStoryElementPosition_rect_set)
    text = property(_mupdf.FzStoryElementPosition_text_get, _mupdf.FzStoryElementPosition_text_set)
    open_close = property(_mupdf.FzStoryElementPosition_open_close_get, _mupdf.FzStoryElementPosition_open_close_set)
    rectangle_num = property(_mupdf.FzStoryElementPosition_rectangle_num_get, _mupdf.FzStoryElementPosition_rectangle_num_set)
    s_num_instances = property(_mupdf.FzStoryElementPosition_s_num_instances_get, _mupdf.FzStoryElementPosition_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzStoryElementPosition_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzStoryElementPosition___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzStoryElementPosition___ne__(self, rhs)

# Register FzStoryElementPosition in _mupdf:
_mupdf.FzStoryElementPosition_swigregister(FzStoryElementPosition)
class FzStream(object):
    r"""
    Wrapper class for struct `fz_stream`.
    fz_stream is a buffered reader capable of seeking in both
    directions.

    Streams are reference counted, so references must be dropped
    by a call to fz_drop_stream.

    Only the data between rp and wp is valid.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_open_file_autodelete(filename):
        r"""
        Class-aware wrapper for `::fz_open_file_autodelete()`.
        	Do the same as fz_open_file, but delete the file upon close.
        """
        return _mupdf.FzStream_fz_open_file_autodelete(filename)

    def fz_available(self, max):
        r"""
        Class-aware wrapper for `::fz_available()`.
        	Ask how many bytes are available immediately from
        	a given stream.

        	stm: The stream to read from.

        	max: A hint for the underlying stream; the maximum number of
        	bytes that we are sure we will want to read. If you do not know
        	this number, give 1.

        	Returns the number of bytes immediately available between the
        	read and write pointers. This number is guaranteed only to be 0
        	if we have hit EOF. The number of bytes returned here need have
        	no relation to max (could be larger, could be smaller).
        """
        return _mupdf.FzStream_fz_available(self, max)

    def fz_decomp_image_from_stream(self, image, subarea, indexed, l2factor, l2extra):
        r"""
        Class-aware wrapper for `::fz_decomp_image_from_stream()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_decomp_image_from_stream(::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`

        	Decode a subarea of a compressed image. l2factor is the amount
        	of subsampling inbuilt to the stream (i.e. performed by the
        	decoder). If non NULL, l2extra is the extra amount of
        	subsampling that should be performed by this routine. This will
        	be updated on exit to the amount of subsampling that is still
        	required to be done.

        	Returns a kept reference.
        """
        return _mupdf.FzStream_fz_decomp_image_from_stream(self, image, subarea, indexed, l2factor, l2extra)

    def fz_is_cfb_archive(self):
        r"""
        Class-aware wrapper for `::fz_is_cfb_archive()`.
        	Detect if stream object is a cfb archive.

        	Assumes that the stream object is seekable.
        """
        return _mupdf.FzStream_fz_is_cfb_archive(self)

    def fz_is_eof(self):
        r"""
        Class-aware wrapper for `::fz_is_eof()`.
        	Query if the stream has reached EOF (during normal bytewise
        	reading).

        	See fz_is_eof_bits for the equivalent function for bitwise
        	reading.
        """
        return _mupdf.FzStream_fz_is_eof(self)

    def fz_is_eof_bits(self):
        r"""
        Class-aware wrapper for `::fz_is_eof_bits()`.
        	Query if the stream has reached EOF (during bitwise
        	reading).

        	See fz_is_eof for the equivalent function for bytewise
        	reading.
        """
        return _mupdf.FzStream_fz_is_eof_bits(self)

    def fz_is_libarchive_archive(self):
        r"""
        Class-aware wrapper for `::fz_is_libarchive_archive()`.
        	Detect if stream object is an archive supported by libarchive.

        	Assumes that the stream object is seekable.
        """
        return _mupdf.FzStream_fz_is_libarchive_archive(self)

    def fz_is_tar_archive(self):
        r"""
        Class-aware wrapper for `::fz_is_tar_archive()`.
        	Detect if stream object is a tar archive.

        	Assumes that the stream object is seekable.
        """
        return _mupdf.FzStream_fz_is_tar_archive(self)

    def fz_is_zip_archive(self):
        r"""
        Class-aware wrapper for `::fz_is_zip_archive()`.
        	Detect if stream object is a zip archive.

        	Assumes that the stream object is seekable.
        """
        return _mupdf.FzStream_fz_is_zip_archive(self)

    def fz_new_archive_of_size(self, size):
        r"""Class-aware wrapper for `::fz_new_archive_of_size()`."""
        return _mupdf.FzStream_fz_new_archive_of_size(self, size)

    def fz_open_a85d(self):
        r"""
        Class-aware wrapper for `::fz_open_a85d()`.
        	a85d filter performs ASCII 85 Decoding of data read
        	from the chained filter.
        """
        return _mupdf.FzStream_fz_open_a85d(self)

    def fz_open_aesd(self, key, keylen):
        r"""
        Class-aware wrapper for `::fz_open_aesd()`.
        	aesd filter performs AES decoding of data read from the chained
        	filter using the supplied key.
        """
        return _mupdf.FzStream_fz_open_aesd(self, key, keylen)

    def fz_open_ahxd(self):
        r"""
        Class-aware wrapper for `::fz_open_ahxd()`.
        	ahxd filter performs ASCII Hex decoding of data read
        	from the chained filter.
        """
        return _mupdf.FzStream_fz_open_ahxd(self)

    def fz_open_arc4(self, key, keylen):
        r"""
        Class-aware wrapper for `::fz_open_arc4()`.
        	arc4 filter performs RC4 decoding of data read from the chained
        	filter using the supplied key.
        """
        return _mupdf.FzStream_fz_open_arc4(self, key, keylen)

    def fz_open_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_archive_with_stream()`.
        	Open zip or tar archive stream.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.
        """
        return _mupdf.FzStream_fz_open_archive_with_stream(self)

    def fz_open_cfb_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_cfb_archive_with_stream()`.
        	Open a cfb file as an archive.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.

        	An exception is thrown if the file is not recognised as a chm.
        """
        return _mupdf.FzStream_fz_open_cfb_archive_with_stream(self)

    def fz_open_dctd(self, color_transform, invert_cmyk, l2factor, jpegtables):
        r"""
        Class-aware wrapper for `::fz_open_dctd()`.
        	dctd filter performs DCT (JPEG) decoding of data read
        	from the chained filter.

        	color_transform implements the PDF color_transform option
        		use -1 for default behavior
        		use 0 to disable YUV-RGB / YCCK-CMYK transforms
        		use 1 to enable YUV-RGB / YCCK-CMYK transforms

        	invert_cmyk implements the necessary inversion for Photoshop CMYK images
        		use 0 if embedded in PDF
        		use 1 if not embedded in PDF

        	For subsampling on decode, set l2factor to the log2 of the
        	reduction required (therefore 0 = full size decode).

        	jpegtables is an optional stream from which the JPEG tables
        	can be read. Use NULL if not required.
        """
        return _mupdf.FzStream_fz_open_dctd(self, color_transform, invert_cmyk, l2factor, jpegtables)

    def fz_open_endstream_filter(self, len, offset):
        r"""
        Class-aware wrapper for `::fz_open_endstream_filter()`.
        	The endstream filter reads a PDF substream, and starts to look
        	for an 'endstream' token after the specified length.
        """
        return _mupdf.FzStream_fz_open_endstream_filter(self, len, offset)

    def fz_open_faxd(self, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1):
        r"""
        Class-aware wrapper for `::fz_open_faxd()`.
        	faxd filter performs FAX decoding of data read from
        	the chained filter.

        	k: see fax specification (fax default is 0).

        	end_of_line: whether we expect end of line markers (fax default
        	is 0).

        	encoded_byte_align: whether we align to bytes after each line
        	(fax default is 0).

        	columns: how many columns in the image (fax default is 1728).

        	rows: 0 for unspecified or the number of rows of data to expect.

        	end_of_block: whether we expect end of block markers (fax
        	default is 1).

        	black_is_1: determines the polarity of the image (fax default is
        	0).
        """
        return _mupdf.FzStream_fz_open_faxd(self, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1)

    def fz_open_flated(self, window_bits):
        r"""
        Class-aware wrapper for `::fz_open_flated()`.
        	flated filter performs LZ77 decoding (inflating) of data read
        	from the chained filter.

        	window_bits: How large a decompression window to use. Typically
        	15. A negative number, -n, means to use n bits, but to expect
        	raw data with no header.
        """
        return _mupdf.FzStream_fz_open_flated(self, window_bits)

    def fz_open_image_decomp_stream(self, arg_1, l2factor):
        r"""
        Class-aware wrapper for `::fz_open_image_decomp_stream()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_open_image_decomp_stream(::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`

        	Open a stream to read the decompressed version of another stream
        	with optional log2 subsampling.
        """
        return _mupdf.FzStream_fz_open_image_decomp_stream(self, arg_1, l2factor)

    def fz_open_jbig2d(self, globals, embedded):
        r"""
        Class-aware wrapper for `::fz_open_jbig2d()`.
        	Open a filter that performs jbig2 decompression on the chained
        	stream, using the optional globals record.
        """
        return _mupdf.FzStream_fz_open_jbig2d(self, globals, embedded)

    def fz_open_leecher(self, buf):
        r"""
        Class-aware wrapper for `::fz_open_leecher()`.
        	Attach a filter to a stream that will store any
        	characters read from the stream into the supplied buffer.

        	chain: The underlying stream to leech from.

        	buf: The buffer into which the read data should be appended.
        	The buffer will be resized as required.

        	Returns pointer to newly created stream. May throw exceptions on
        	failure to allocate.
        """
        return _mupdf.FzStream_fz_open_leecher(self, buf)

    def fz_open_libarchive_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_libarchive_archive_with_stream()`.
        	Open an archive using libarchive.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.

        	An exception is thrown if the stream is not supported by libarchive.
        """
        return _mupdf.FzStream_fz_open_libarchive_archive_with_stream(self)

    def fz_open_libarchived(self):
        r"""
        Class-aware wrapper for `::fz_open_libarchived()`.
        	libarchived filter performs generic compressed decoding of data
        	in any format understood by libarchive from the chained filter.

        	This will throw an exception if libarchive is not built in, or
        	if the compression format is not recognised.
        """
        return _mupdf.FzStream_fz_open_libarchived(self)

    def fz_open_lzwd(self, early_change, min_bits, reverse_bits, old_tiff):
        r"""
        Class-aware wrapper for `::fz_open_lzwd()`.
        	lzwd filter performs LZW decoding of data read from the chained
        	filter.

        	early_change: (Default 1) specifies whether to change codes 1
        	bit early.

        	min_bits: (Default 9) specifies the minimum number of bits to
        	use.

        	reverse_bits: (Default 0) allows for compatibility with gif and
        	old style tiffs (1).

        	old_tiff: (Default 0) allows for different handling of the clear
        	code, as found in old style tiffs.
        """
        return _mupdf.FzStream_fz_open_lzwd(self, early_change, min_bits, reverse_bits, old_tiff)

    def fz_open_null_filter(self, len, offset):
        r"""
        Class-aware wrapper for `::fz_open_null_filter()`.
        	The null filter reads a specified amount of data from the
        	substream.
        """
        return _mupdf.FzStream_fz_open_null_filter(self, len, offset)

    def fz_open_predict(self, predictor, columns, colors, bpc):
        r"""
        Class-aware wrapper for `::fz_open_predict()`.
        	predict filter performs pixel prediction on data read from
        	the chained filter.

        	predictor: 1 = copy, 2 = tiff, other = inline PNG predictor

        	columns: width of image in pixels

        	colors: number of components.

        	bpc: bits per component (typically 8)
        """
        return _mupdf.FzStream_fz_open_predict(self, predictor, columns, colors, bpc)

    def fz_open_range_filter(self, ranges, nranges):
        r"""
        Class-aware wrapper for `::fz_open_range_filter()`.
        	The range filter copies data from specified ranges of the
        	chained stream.
        """
        return _mupdf.FzStream_fz_open_range_filter(self, ranges, nranges)

    def fz_open_rld(self):
        r"""
        Class-aware wrapper for `::fz_open_rld()`.
        	rld filter performs Run Length Decoding of data read
        	from the chained filter.
        """
        return _mupdf.FzStream_fz_open_rld(self)

    def fz_open_sgilog16(self, w):
        r"""
        Class-aware wrapper for `::fz_open_sgilog16()`.
        	SGI Log 16bit (greyscale) decode from the chained filter.
        	Decodes lines of w pixels to 8bpp greyscale.
        """
        return _mupdf.FzStream_fz_open_sgilog16(self, w)

    def fz_open_sgilog24(self, w):
        r"""
        Class-aware wrapper for `::fz_open_sgilog24()`.
        	SGI Log 24bit (LUV) decode from the chained filter.
        	Decodes lines of w pixels to 8bpc rgb.
        """
        return _mupdf.FzStream_fz_open_sgilog24(self, w)

    def fz_open_sgilog32(self, w):
        r"""
        Class-aware wrapper for `::fz_open_sgilog32()`.
        	SGI Log 32bit (LUV) decode from the chained filter.
        	Decodes lines of w pixels to 8bpc rgb.
        """
        return _mupdf.FzStream_fz_open_sgilog32(self, w)

    def fz_open_tar_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_tar_archive_with_stream()`.
        	Open a tar archive stream.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.

        	An exception is thrown if the stream is not a tar archive as
        	indicated by the presence of a tar signature.

        """
        return _mupdf.FzStream_fz_open_tar_archive_with_stream(self)

    def fz_open_thunder(self, w):
        r"""
        Class-aware wrapper for `::fz_open_thunder()`.
        	4bit greyscale Thunderscan decoding from the chained filter.
        	Decodes lines of w pixels to 8bpp greyscale.
        """
        return _mupdf.FzStream_fz_open_thunder(self, w)

    def fz_open_zip_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_zip_archive_with_stream()`.
        	Open a zip archive stream.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.

        	An exception is thrown if the stream is not a zip archive as
        	indicated by the presence of a zip signature.

        """
        return _mupdf.FzStream_fz_open_zip_archive_with_stream(self)

    def fz_parse_xml_stream(self, preserve_white):
        r"""
        Class-aware wrapper for `::fz_parse_xml_stream()`.
        	Parse the contents of buffer into a tree of xml nodes.

        	preserve_white: whether to keep or delete all-whitespace nodes.
        """
        return _mupdf.FzStream_fz_parse_xml_stream(self, preserve_white)

    def fz_peek_byte(self):
        r"""
        Class-aware wrapper for `::fz_peek_byte()`.
        	Peek at the next byte in a stream.

        	stm: The stream to peek at.

        	Returns -1 for EOF, or the next byte that will be read.
        """
        return _mupdf.FzStream_fz_peek_byte(self)

    def fz_read(self, data, len):
        r"""
        Class-aware wrapper for `::fz_read()`.
        	Read from a stream into a given data block.

        	stm: The stream to read from.

        	data: The data block to read into.

        	len: The length of the data block (in bytes).

        	Returns the number of bytes read. May throw exceptions.
        """
        return _mupdf.FzStream_fz_read(self, data, len)

    def fz_read_all(self, initial):
        r"""
        Class-aware wrapper for `::fz_read_all()`.
        	Read all of a stream into a buffer.

        	stm: The stream to read from

        	initial: Suggested initial size for the buffer.

        	Returns a buffer created from reading from the stream. May throw
        	exceptions on failure to allocate.
        """
        return _mupdf.FzStream_fz_read_all(self, initial)

    def fz_read_best(self, initial, truncated, worst_case):
        r"""
        Class-aware wrapper for `::fz_read_best()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_read_best(size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`

        	Attempt to read a stream into a buffer. If truncated
        	is NULL behaves as fz_read_all, sets a truncated flag in case of
        	error.

        	stm: The stream to read from.

        	initial: Suggested initial size for the buffer.

        	truncated: Flag to store success/failure indication in.

        	worst_case: 0 for unknown, otherwise an upper bound for the
        	size of the stream.

        	Returns a buffer created from reading from the stream.
        """
        return _mupdf.FzStream_fz_read_best(self, initial, truncated, worst_case)

    def fz_read_bits(self, n):
        r"""
        Class-aware wrapper for `::fz_read_bits()`.
        	Read the next n bits from a stream (assumed to
        	be packed most significant bit first).

        	stm: The stream to read from.

        	n: The number of bits to read, between 1 and 8*sizeof(int)
        	inclusive.

        	Returns -1 for EOF, or the required number of bits.
        """
        return _mupdf.FzStream_fz_read_bits(self, n)

    def fz_read_byte(self):
        r"""
        Class-aware wrapper for `::fz_read_byte()`.
        	Read the next byte from a stream.

        	stm: The stream t read from.

        	Returns -1 for end of stream, or the next byte. May
        	throw exceptions.
        """
        return _mupdf.FzStream_fz_read_byte(self)

    def fz_read_float(self):
        r"""Class-aware wrapper for `::fz_read_float()`."""
        return _mupdf.FzStream_fz_read_float(self)

    def fz_read_float_le(self):
        r"""Class-aware wrapper for `::fz_read_float_le()`."""
        return _mupdf.FzStream_fz_read_float_le(self)

    def fz_read_int16(self):
        r"""Class-aware wrapper for `::fz_read_int16()`."""
        return _mupdf.FzStream_fz_read_int16(self)

    def fz_read_int16_le(self):
        r"""Class-aware wrapper for `::fz_read_int16_le()`."""
        return _mupdf.FzStream_fz_read_int16_le(self)

    def fz_read_int32(self):
        r"""Class-aware wrapper for `::fz_read_int32()`."""
        return _mupdf.FzStream_fz_read_int32(self)

    def fz_read_int32_le(self):
        r"""Class-aware wrapper for `::fz_read_int32_le()`."""
        return _mupdf.FzStream_fz_read_int32_le(self)

    def fz_read_int64(self):
        r"""Class-aware wrapper for `::fz_read_int64()`."""
        return _mupdf.FzStream_fz_read_int64(self)

    def fz_read_int64_le(self):
        r"""Class-aware wrapper for `::fz_read_int64_le()`."""
        return _mupdf.FzStream_fz_read_int64_le(self)

    def fz_read_line(self, buf, max):
        r"""
        Class-aware wrapper for `::fz_read_line()`.
        	Read a line from stream into the buffer until either a
        	terminating newline or EOF, which it replaces with a null byte
        	('').

        	Returns buf on success, and NULL when end of file occurs while
        	no characters have been read.
        """
        return _mupdf.FzStream_fz_read_line(self, buf, max)

    def fz_read_rbits(self, n):
        r"""
        Class-aware wrapper for `::fz_read_rbits()`.
        	Read the next n bits from a stream (assumed to
        	be packed least significant bit first).

        	stm: The stream to read from.

        	n: The number of bits to read, between 1 and 8*sizeof(int)
        	inclusive.

        	Returns (unsigned int)-1 for EOF, or the required number of bits.
        """
        return _mupdf.FzStream_fz_read_rbits(self, n)

    def fz_read_rune(self):
        r"""
        Class-aware wrapper for `::fz_read_rune()`.
        	Read a utf-8 rune from a stream.

        	In the event of encountering badly formatted utf-8 codes
        	(such as a leading code with an unexpected number of following
        	codes) no error/exception is given, but undefined values may be
        	returned.
        """
        return _mupdf.FzStream_fz_read_rune(self)

    def fz_read_string(self, buffer, len):
        r"""
        Class-aware wrapper for `::fz_read_string()`.
        	Read a null terminated string from the stream into
        	a buffer of a given length. The buffer will be null terminated.
        	Throws on failure (including the failure to fit the entire
        	string including the terminator into the buffer).
        """
        return _mupdf.FzStream_fz_read_string(self, buffer, len)

    def fz_read_uint16(self):
        r"""
        Class-aware wrapper for `::fz_read_uint16()`.
        	fz_read_[u]int(16|24|32|64)(_le)?

        	Read a 16/32/64 bit signed/unsigned integer from stream,
        	in big or little-endian byte orders.

        	Throws an exception if EOF is encountered.
        """
        return _mupdf.FzStream_fz_read_uint16(self)

    def fz_read_uint16_le(self):
        r"""Class-aware wrapper for `::fz_read_uint16_le()`."""
        return _mupdf.FzStream_fz_read_uint16_le(self)

    def fz_read_uint24(self):
        r"""Class-aware wrapper for `::fz_read_uint24()`."""
        return _mupdf.FzStream_fz_read_uint24(self)

    def fz_read_uint24_le(self):
        r"""Class-aware wrapper for `::fz_read_uint24_le()`."""
        return _mupdf.FzStream_fz_read_uint24_le(self)

    def fz_read_uint32(self):
        r"""Class-aware wrapper for `::fz_read_uint32()`."""
        return _mupdf.FzStream_fz_read_uint32(self)

    def fz_read_uint32_le(self):
        r"""Class-aware wrapper for `::fz_read_uint32_le()`."""
        return _mupdf.FzStream_fz_read_uint32_le(self)

    def fz_read_uint64(self):
        r"""Class-aware wrapper for `::fz_read_uint64()`."""
        return _mupdf.FzStream_fz_read_uint64(self)

    def fz_read_uint64_le(self):
        r"""Class-aware wrapper for `::fz_read_uint64_le()`."""
        return _mupdf.FzStream_fz_read_uint64_le(self)

    def fz_read_utf16_be(self):
        r"""Class-aware wrapper for `::fz_read_utf16_be()`."""
        return _mupdf.FzStream_fz_read_utf16_be(self)

    def fz_read_utf16_le(self):
        r"""
        Class-aware wrapper for `::fz_read_utf16_le()`.
        	Read a utf-16 rune from a stream. (little endian and
        	big endian respectively).

        	In the event of encountering badly formatted utf-16 codes
        	(mismatched surrogates) no error/exception is given, but
        	undefined values may be returned.
        """
        return _mupdf.FzStream_fz_read_utf16_le(self)

    def fz_seek(self, offset, whence):
        r"""
        Class-aware wrapper for `::fz_seek()`.
        	Seek within a stream.

        	stm: The stream to seek within.

        	offset: The offset to seek to.

        	whence: From where the offset is measured (see fseek).
        	SEEK_SET - start of stream.
        	SEEK_CUR - current position.
        	SEEK_END - end of stream.

        """
        return _mupdf.FzStream_fz_seek(self, offset, whence)

    def fz_skip(self, len):
        r"""
        Class-aware wrapper for `::fz_skip()`.
        	Read from a stream discarding data.

        	stm: The stream to read from.

        	len: The number of bytes to read.

        	Returns the number of bytes read. May throw exceptions.
        """
        return _mupdf.FzStream_fz_skip(self, len)

    def fz_skip_space(self):
        r"""
        Class-aware wrapper for `::fz_skip_space()`.
        	Skip over whitespace (bytes <= 32) in a stream.
        """
        return _mupdf.FzStream_fz_skip_space(self)

    def fz_skip_string(self, str):
        r"""
        Class-aware wrapper for `::fz_skip_string()`.
        	Skip over a given string in a stream. Return 0 if successfully
        	skipped, non-zero otherwise. As many characters will be skipped
        	over as matched in the string.
        """
        return _mupdf.FzStream_fz_skip_string(self, str)

    def fz_stream_filename(self):
        r"""
        Class-aware wrapper for `::fz_stream_filename()`.
        	Return the filename (UTF-8 encoded) from which a stream was opened.

        	Returns NULL if the filename is not available (or the stream was
        	opened from a source other than a file).
        """
        return _mupdf.FzStream_fz_stream_filename(self)

    def fz_sync_bits(self):
        r"""
        Class-aware wrapper for `::fz_sync_bits()`.
        	Called after reading bits to tell the stream
        	that we are about to return to reading bytewise. Resyncs
        	the stream to whole byte boundaries.
        """
        return _mupdf.FzStream_fz_sync_bits(self)

    def fz_tell(self):
        r"""
        Class-aware wrapper for `::fz_tell()`.
        	return the current reading position within a stream
        """
        return _mupdf.FzStream_fz_tell(self)

    def fz_try_open_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_try_open_archive_with_stream()`.
        	Open zip or tar archive stream.

        	Does the same as fz_open_archive_with_stream, but will not throw
        	an error in the event of failing to recognise the format. Will
        	still throw errors in other cases though!
        """
        return _mupdf.FzStream_fz_try_open_archive_with_stream(self)

    def fz_unpack_stream(self, depth, w, h, n, indexed, pad, skip):
        r"""Class-aware wrapper for `::fz_unpack_stream()`."""
        return _mupdf.FzStream_fz_unpack_stream(self, depth, w, h, n, indexed, pad, skip)

    def fz_unread_byte(self):
        r"""
        Class-aware wrapper for `::fz_unread_byte()`.
        	Unread the single last byte successfully
        	read from a stream. Do not call this without having
        	successfully read a byte.

        	stm: The stream to operate upon.
        """
        return _mupdf.FzStream_fz_unread_byte(self)

    def pdf_load_cmap(self):
        r"""Class-aware wrapper for `::pdf_load_cmap()`."""
        return _mupdf.FzStream_pdf_load_cmap(self)

    def pdf_open_crypt(self, crypt, num, gen):
        r"""Class-aware wrapper for `::pdf_open_crypt()`."""
        return _mupdf.FzStream_pdf_open_crypt(self, crypt, num, gen)

    def pdf_open_crypt_with_filter(self, crypt, name, num, gen):
        r"""Class-aware wrapper for `::pdf_open_crypt_with_filter()`."""
        return _mupdf.FzStream_pdf_open_crypt_with_filter(self, crypt, name, num, gen)

    def pdf_open_document_with_stream(self):
        r"""Class-aware wrapper for `::pdf_open_document_with_stream()`."""
        return _mupdf.FzStream_pdf_open_document_with_stream(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_stream()`.
        		Create a new stream object with the given
        		internal state and function pointers.

        		state: Internal state (opaque to everything but implementation).

        		next: Should provide the next set of bytes (up to max) of stream
        		data. Return the number of bytes read, or EOF when there is no
        		more data.

        		drop: Should clean up and free the internal state. May not
        		throw exceptions.


        |

        *Overload 2:*
         Constructor using `fz_open_file()`.
        		Open the named file and wrap it in a stream.

        		filename: Path to a file. On non-Windows machines the filename
        		should be exactly as it would be passed to fopen(2). On Windows
        		machines, the path should be UTF-8 encoded so that non-ASCII
        		characters can be represented. Other platforms do the encoding
        		as standard anyway (and in most cases, particularly for MacOS
        		and Linux, the encoding they use is UTF-8 anyway).


        |

        *Overload 3:*
         Constructor using `fz_open_file_ptr_no_close()`.
        		Create a stream from a FILE * that will not be closed
        		when the stream is dropped.


        |

        *Overload 4:*
         Constructor using `fz_open_memory()`.
        		Open a block of memory as a stream.

        		data: Pointer to start of data block. Ownership of the data
        		block is NOT passed in.

        		len: Number of bytes in data block.

        		Returns pointer to newly created stream. May throw exceptions on
        		failure to allocate.


        |

        *Overload 5:*
         Construct using fz_open_file().

        |

        *Overload 6:*
         Copy constructor using `fz_keep_stream()`.

        |

        *Overload 7:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 8:*
         Constructor using raw copy of pre-existing `::fz_stream`.
        """
        _mupdf.FzStream_swiginit(self, _mupdf.new_FzStream(*args))
    __swig_destroy__ = _mupdf.delete_FzStream

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStream_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStream___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStream_m_internal_get, _mupdf.FzStream_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStream_s_num_instances_get, _mupdf.FzStream_s_num_instances_set)

# Register FzStream in _mupdf:
_mupdf.FzStream_swigregister(FzStream)
class FzString(object):
    r"""Wrapper class for struct `fz_string`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_new_string()`.

        |

        *Overload 2:*
        Copy constructor using `fz_keep_string()`.

        |

        *Overload 3:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_string`.
        """
        _mupdf.FzString_swiginit(self, _mupdf.new_FzString(*args))
    __swig_destroy__ = _mupdf.delete_FzString

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzString_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzString___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzString_m_internal_get, _mupdf.FzString_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzString_s_num_instances_get, _mupdf.FzString_s_num_instances_set)

# Register FzString in _mupdf:
_mupdf.FzString_swigregister(FzString)
class FzStrokeState(object):
    r"""Wrapper class for struct `fz_stroke_state`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_clone_stroke_state(self):
        r"""
        Class-aware wrapper for `::fz_clone_stroke_state()`.
        	Create an identical stroke_state structure and return a
        	reference to it.

        	stroke: The stroke state reference to clone.

        	Exceptions may be thrown in the event of a failure to
        	allocate.
        """
        return _mupdf.FzStrokeState_fz_clone_stroke_state(self)

    def fz_unshare_stroke_state(self):
        r"""
        Class-aware wrapper for `::fz_unshare_stroke_state()`.
        	Given a reference to a (possibly) shared stroke_state structure,
        	return a reference to an equivalent stroke_state structure
        	that is guaranteed to be unshared (i.e. one that can
        	safely be modified).

        	shared: The reference to a (possibly) shared structure
        	to unshare. Ownership of this reference is passed in
        	to this function, even in the case of exceptions being
        	thrown.

        	Exceptions may be thrown in the event of failure to
        	allocate if required.
        """
        return _mupdf.FzStrokeState_fz_unshare_stroke_state(self)

    def fz_unshare_stroke_state_with_dash_len(self, len):
        r"""
        Class-aware wrapper for `::fz_unshare_stroke_state_with_dash_len()`.
        	Given a reference to a (possibly) shared stroke_state structure,
        	return a reference to a stroke_state structure (with room for a
        	given amount of dash data) that is guaranteed to be unshared
        	(i.e. one that can safely be modified).

        	shared: The reference to a (possibly) shared structure
        	to unshare. Ownership of this reference is passed in
        	to this function, even in the case of exceptions being
        	thrown.

        	Exceptions may be thrown in the event of failure to
        	allocate if required.
        """
        return _mupdf.FzStrokeState_fz_unshare_stroke_state_with_dash_len(self, len)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_stroke_state()`.
        		Create a new (empty) stroke state structure (with no dash
        		data) and return a reference to it.

        		Throws exception on failure to allocate.


        |

        *Overload 2:*
         Constructor using `fz_new_stroke_state_with_dash_len()`.
        		Create a new (empty) stroke state structure, with room for
        		dash data of the given length, and return a reference to it.

        		len: The number of dash elements to allow room for.

        		Throws exception on failure to allocate.


        |

        *Overload 3:*
         Copy constructor using `fz_keep_stroke_state()`.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_stroke_state`.
        """
        _mupdf.FzStrokeState_swiginit(self, _mupdf.new_FzStrokeState(*args))
    __swig_destroy__ = _mupdf.delete_FzStrokeState

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStrokeState_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStrokeState___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStrokeState_m_internal_get, _mupdf.FzStrokeState_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStrokeState_s_num_instances_get, _mupdf.FzStrokeState_s_num_instances_set)

# Register FzStrokeState in _mupdf:
_mupdf.FzStrokeState_swigregister(FzStrokeState)
class FzStyleContext(object):
    r"""Wrapper class for struct `fz_style_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_style_context`.
        """
        _mupdf.FzStyleContext_swiginit(self, _mupdf.new_FzStyleContext(*args))
    __swig_destroy__ = _mupdf.delete_FzStyleContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStyleContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStyleContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStyleContext_m_internal_get, _mupdf.FzStyleContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStyleContext_s_num_instances_get, _mupdf.FzStyleContext_s_num_instances_set)

# Register FzStyleContext in _mupdf:
_mupdf.FzStyleContext_swigregister(FzStyleContext)
class FzText(object):
    r"""Wrapper class for struct `fz_text`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bound_text(self, stroke, ctm):
        r"""
        Class-aware wrapper for `::fz_bound_text()`.
        	Find the bounds of a given text object.

        	text: The text object to find the bounds of.

        	stroke: Pointer to the stroke attributes (for stroked
        	text), or NULL (for filled text).

        	ctm: The matrix in use.

        	r: pointer to storage for the bounds.

        	Returns a pointer to r, which is updated to contain the
        	bounding box for the text object.
        """
        return _mupdf.FzText_fz_bound_text(self, stroke, ctm)

    def fz_show_glyph(self, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language):
        r"""
        Class-aware wrapper for `::fz_show_glyph()`.
        	Add a glyph/unicode value to a text object.

        	text: Text object to add to.

        	font: The font the glyph should be added in.

        	trm: The transform to use for the glyph.

        	glyph: The glyph id to add.

        	unicode: The unicode character for the glyph.

        	cid: The CJK CID value or raw character code.

        	wmode: 1 for vertical mode, 0 for horizontal.

        	bidi_level: The bidirectional level for this glyph.

        	markup_dir: The direction of the text as specified in the
        	markup.

        	language: The language in use (if known, 0 otherwise)
        	(e.g. FZ_LANG_zh_Hans).

        	Throws exception on failure to allocate.
        """
        return _mupdf.FzText_fz_show_glyph(self, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language)

    def fz_show_glyph_aux(self, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang):
        r"""Class-aware wrapper for `::fz_show_glyph_aux()`."""
        return _mupdf.FzText_fz_show_glyph_aux(self, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang)

    def fz_show_string(self, font, trm, s, wmode, bidi_level, markup_dir, language):
        r"""
        Class-aware wrapper for `::fz_show_string()`.
        	Add a UTF8 string to a text object.

        	text: Text object to add to.

        	font: The font the string should be added in.

        	trm: The transform to use.

        	s: The utf-8 string to add.

        	wmode: 1 for vertical mode, 0 for horizontal.

        	bidi_level: The bidirectional level for this glyph.

        	markup_dir: The direction of the text as specified in the markup.

        	language: The language in use (if known, 0 otherwise)
        		(e.g. FZ_LANG_zh_Hans).

        	Returns the transform updated with the advance width of the
        	string.
        """
        return _mupdf.FzText_fz_show_string(self, font, trm, s, wmode, bidi_level, markup_dir, language)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_text()`.
        		Create a new empty fz_text object.

        		Throws exception on failure to allocate.


        |

        *Overload 2:*
         Copy constructor using `fz_keep_text()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_text`.
        """
        _mupdf.FzText_swiginit(self, _mupdf.new_FzText(*args))
    __swig_destroy__ = _mupdf.delete_FzText

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzText_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzText___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzText_m_internal_get, _mupdf.FzText_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzText_s_num_instances_get, _mupdf.FzText_s_num_instances_set)

# Register FzText in _mupdf:
_mupdf.FzText_swigregister(FzText)
class FzTextDecoder(object):
    r"""
     Wrapper class for struct `fz_text_decoder`. Not copyable or assignable.
    A text decoder (to read arbitrary encodings and convert to unicode).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_init_text_decoder(self, encoding):
        r"""Class-aware wrapper for `::fz_init_text_decoder()`."""
        return _mupdf.FzTextDecoder_fz_init_text_decoder(self, encoding)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_text_decoder`.
        """
        _mupdf.FzTextDecoder_swiginit(self, _mupdf.new_FzTextDecoder(*args))
    __swig_destroy__ = _mupdf.delete_FzTextDecoder

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTextDecoder_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzTextDecoder___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzTextDecoder_m_internal_get, _mupdf.FzTextDecoder_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTextDecoder_s_num_instances_get, _mupdf.FzTextDecoder_s_num_instances_set)

# Register FzTextDecoder in _mupdf:
_mupdf.FzTextDecoder_swigregister(FzTextDecoder)
class FzTextItem(object):
    r"""
    Wrapper class for struct `fz_text_item`. Not copyable or assignable.
    Text buffer.

    The trm field contains the a, b, c and d coefficients.
    The e and f coefficients come from the individual elements,
    together they form the transform matrix for the glyph.

    Glyphs are referenced by glyph ID.
    The Unicode text equivalent is kept in a separate array
    with indexes into the glyph array.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_text_item`.
        """
        _mupdf.FzTextItem_swiginit(self, _mupdf.new_FzTextItem(*args))
    __swig_destroy__ = _mupdf.delete_FzTextItem

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTextItem_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzTextItem___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzTextItem_m_internal_get, _mupdf.FzTextItem_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTextItem_s_num_instances_get, _mupdf.FzTextItem_s_num_instances_set)

# Register FzTextItem in _mupdf:
_mupdf.FzTextItem_swigregister(FzTextItem)
class FzTextSpan(object):
    r"""Wrapper class for struct `fz_text_span`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def font(self):
        r"""Gives class-aware access to m_internal->font."""
        return _mupdf.FzTextSpan_font(self)

    def trm(self):
        r"""Gives class-aware access to m_internal->trm."""
        return _mupdf.FzTextSpan_trm(self)

    def items(self, i):
        r"""
        Gives access to m_internal->items[i].
        						Returned reference is only valid as long as `this`.
        						Provided mainly for use by SWIG bindings.
        """
        return _mupdf.FzTextSpan_items(self, i)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_text_span`.
        """
        _mupdf.FzTextSpan_swiginit(self, _mupdf.new_FzTextSpan(*args))
    __swig_destroy__ = _mupdf.delete_FzTextSpan

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTextSpan_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzTextSpan___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzTextSpan_m_internal_get, _mupdf.FzTextSpan_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTextSpan_s_num_instances_get, _mupdf.FzTextSpan_s_num_instances_set)

# Register FzTextSpan in _mupdf:
_mupdf.FzTextSpan_swigregister(FzTextSpan)
class FzTransition(object):
    r"""Wrapper class for struct `fz_transition`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_transition`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_transition`.
        """
        _mupdf.FzTransition_swiginit(self, _mupdf.new_FzTransition(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzTransition_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzTransition
    type = property(_mupdf.FzTransition_type_get, _mupdf.FzTransition_type_set)
    duration = property(_mupdf.FzTransition_duration_get, _mupdf.FzTransition_duration_set)
    vertical = property(_mupdf.FzTransition_vertical_get, _mupdf.FzTransition_vertical_set)
    outwards = property(_mupdf.FzTransition_outwards_get, _mupdf.FzTransition_outwards_set)
    direction = property(_mupdf.FzTransition_direction_get, _mupdf.FzTransition_direction_set)
    state0 = property(_mupdf.FzTransition_state0_get, _mupdf.FzTransition_state0_set)
    state1 = property(_mupdf.FzTransition_state1_get, _mupdf.FzTransition_state1_set)
    s_num_instances = property(_mupdf.FzTransition_s_num_instances_get, _mupdf.FzTransition_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzTransition_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzTransition___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.FzTransition___ne__(self, rhs)

# Register FzTransition in _mupdf:
_mupdf.FzTransition_swigregister(FzTransition)
class FzTree(object):
    r"""
    Wrapper class for struct `fz_tree`. Not copyable or assignable.
    AA-tree to look up things by strings.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_new_tree_archive(self):
        r"""
        Class-aware wrapper for `::fz_new_tree_archive()`.
        	Create an archive that holds named buffers.

        	tree can either be a preformed tree with fz_buffers as values,
        	or it can be NULL for an empty tree.
        """
        return _mupdf.FzTree_fz_new_tree_archive(self)

    def fz_tree_lookup(self, key):
        r"""
        Class-aware wrapper for `::fz_tree_lookup()`.
        	Look for the value of a node in the tree with the given key.

        	Simple pointer equivalence is used for key.

        	Returns NULL for no match.
        """
        return _mupdf.FzTree_fz_tree_lookup(self, key)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_tree`.
        """
        _mupdf.FzTree_swiginit(self, _mupdf.new_FzTree(*args))
    __swig_destroy__ = _mupdf.delete_FzTree

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTree_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzTree___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzTree_m_internal_get, _mupdf.FzTree_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTree_s_num_instances_get, _mupdf.FzTree_s_num_instances_set)

# Register FzTree in _mupdf:
_mupdf.FzTree_swigregister(FzTree)
class FzTuningContext(object):
    r"""Wrapper class for struct `fz_tuning_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_tuning_context`.
        """
        _mupdf.FzTuningContext_swiginit(self, _mupdf.new_FzTuningContext(*args))
    __swig_destroy__ = _mupdf.delete_FzTuningContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTuningContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzTuningContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzTuningContext_m_internal_get, _mupdf.FzTuningContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTuningContext_s_num_instances_get, _mupdf.FzTuningContext_s_num_instances_set)

# Register FzTuningContext in _mupdf:
_mupdf.FzTuningContext_swigregister(FzTuningContext)
class FzVertex(object):
    r"""
    Wrapper class for struct `fz_vertex`. Not copyable or assignable.
    Handy routine for processing mesh based shades
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_vertex`.
        """
        _mupdf.FzVertex_swiginit(self, _mupdf.new_FzVertex(*args))
    __swig_destroy__ = _mupdf.delete_FzVertex

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzVertex_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzVertex___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzVertex_m_internal_get, _mupdf.FzVertex_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzVertex_s_num_instances_get, _mupdf.FzVertex_s_num_instances_set)

# Register FzVertex in _mupdf:
_mupdf.FzVertex_swigregister(FzVertex)
class FzWarnContext(object):
    r"""Wrapper class for struct `fz_warn_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_warn_context`.
        """
        _mupdf.FzWarnContext_swiginit(self, _mupdf.new_FzWarnContext(*args))
    __swig_destroy__ = _mupdf.delete_FzWarnContext

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzWarnContext_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzWarnContext___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzWarnContext_m_internal_get, _mupdf.FzWarnContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzWarnContext_s_num_instances_get, _mupdf.FzWarnContext_s_num_instances_set)

# Register FzWarnContext in _mupdf:
_mupdf.FzWarnContext_swigregister(FzWarnContext)
class FzWriteStoryPosition(object):
    r"""Wrapper class for struct `fz_write_story_position`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_write_story_position`.
        """
        _mupdf.FzWriteStoryPosition_swiginit(self, _mupdf.new_FzWriteStoryPosition(*args))
    __swig_destroy__ = _mupdf.delete_FzWriteStoryPosition

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzWriteStoryPosition_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzWriteStoryPosition___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzWriteStoryPosition_m_internal_get, _mupdf.FzWriteStoryPosition_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzWriteStoryPosition_s_num_instances_get, _mupdf.FzWriteStoryPosition_s_num_instances_set)

# Register FzWriteStoryPosition in _mupdf:
_mupdf.FzWriteStoryPosition_swigregister(FzWriteStoryPosition)
class FzWriteStoryPositions(object):
    r"""Wrapper class for struct `fz_write_story_positions`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_write_story_positions`.
        """
        _mupdf.FzWriteStoryPositions_swiginit(self, _mupdf.new_FzWriteStoryPositions(*args))
    __swig_destroy__ = _mupdf.delete_FzWriteStoryPositions

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzWriteStoryPositions_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzWriteStoryPositions___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzWriteStoryPositions_m_internal_get, _mupdf.FzWriteStoryPositions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzWriteStoryPositions_s_num_instances_get, _mupdf.FzWriteStoryPositions_s_num_instances_set)

# Register FzWriteStoryPositions in _mupdf:
_mupdf.FzWriteStoryPositions_swigregister(FzWriteStoryPositions)
class FzXml(object):
    r"""
    Wrapper class for struct `fz_xml`.
    XML document model
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_debug_xml(self, level):
        r"""
        Class-aware wrapper for `::fz_debug_xml()`.
        	Pretty-print an XML tree to stdout. (Deprecated, use
        	fz_output_xml in preference).
        """
        return _mupdf.FzXml_fz_debug_xml(self, level)

    def fz_detach_xml(self):
        r"""
        Class-aware wrapper for `::fz_detach_xml()`.
        	Detach a node from the tree, unlinking it from its parent,
        	and setting the document root to the node.
        """
        return _mupdf.FzXml_fz_detach_xml(self)

    def fz_dom_add_attribute(self, att, value):
        r"""
        Class-aware wrapper for `::fz_dom_add_attribute()`.
        	Add an attribute to an element.

        	Ownership of att and value remain with the caller.
        """
        return _mupdf.FzXml_fz_dom_add_attribute(self, att, value)

    def fz_dom_append_child(self, child):
        r"""
        Class-aware wrapper for `::fz_dom_append_child()`.
        	Insert an element as the last child of a parent, unlinking the
        	child from its current position if required.
        """
        return _mupdf.FzXml_fz_dom_append_child(self, child)

    def fz_dom_attribute(self, att):
        r"""
        Class-aware wrapper for `::fz_dom_attribute()`.
        	Retrieve the value of a given attribute from a given element.

        	Returns a borrowed pointer to the value or NULL if not found.
        """
        return _mupdf.FzXml_fz_dom_attribute(self, att)

    def fz_dom_body(self):
        r"""
        Class-aware wrapper for `::fz_dom_body()`.
        	Return a borrowed reference for the 'body' element of
        	the given DOM.
        """
        return _mupdf.FzXml_fz_dom_body(self)

    def fz_dom_clone(self):
        r"""
        Class-aware wrapper for `::fz_dom_clone()`.
        	Clone an element (and its children).

        	A borrowed reference to the clone is returned. The clone is not
        	yet linked into the DOM.
        """
        return _mupdf.FzXml_fz_dom_clone(self)

    def fz_dom_create_element(self, tag):
        r"""
        Class-aware wrapper for `::fz_dom_create_element()`.
        	Create an element of a given tag type for the given DOM.

        	The element is not linked into the DOM yet.
        """
        return _mupdf.FzXml_fz_dom_create_element(self, tag)

    def fz_dom_create_text_node(self, text):
        r"""
        Class-aware wrapper for `::fz_dom_create_text_node()`.
        	Create a text node for the given DOM.

        	The element is not linked into the DOM yet.
        """
        return _mupdf.FzXml_fz_dom_create_text_node(self, text)

    def fz_dom_document_element(self):
        r"""
        Class-aware wrapper for `::fz_dom_document_element()`.
        	Return a borrowed reference for the document (the top
        	level element) of the DOM.
        """
        return _mupdf.FzXml_fz_dom_document_element(self)

    def fz_dom_find(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_dom_find()`.
        	Find the first element matching the requirements in a depth first traversal from elt.

        	The tagname must match tag, unless tag is NULL, when all tag names are considered to match.

        	If att is NULL, then all tags match.
        	Otherwise:
        		If match is NULL, then only nodes that have an att attribute match.
        		If match is non-NULL, then only nodes that have an att attribute that matches match match.

        	Returns NULL (if no match found), or a borrowed reference to the first matching element.
        """
        return _mupdf.FzXml_fz_dom_find(self, tag, att, match)

    def fz_dom_find_next(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_dom_find_next()`.
        	Find the next element matching the requirements.
        """
        return _mupdf.FzXml_fz_dom_find_next(self, tag, att, match)

    def fz_dom_first_child(self):
        r"""
        Class-aware wrapper for `::fz_dom_first_child()`.
        	Return a borrowed reference to the first child of a node,
        	or NULL if there isn't one.
        """
        return _mupdf.FzXml_fz_dom_first_child(self)

    def fz_dom_get_attribute(self, i, att):
        r"""
        Class-aware wrapper for `::fz_dom_get_attribute()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_dom_get_attribute(int i)` => `(const char *, const char *att)`

        	Enumerate through the attributes of an element.

        	Call with i=0,1,2,3... to enumerate attributes.

        	On return *att and the return value will be NULL if there are not
        	that many attributes to read. Otherwise, *att will be filled in
        	with a borrowed pointer to the attribute name, and the return
        	value will be a borrowed pointer to the value.
        """
        return _mupdf.FzXml_fz_dom_get_attribute(self, i, att)

    def fz_dom_insert_after(self, new_elt):
        r"""
        Class-aware wrapper for `::fz_dom_insert_after()`.
        	Insert an element (new_elt), after another element (node),
        	unlinking the new_elt from its current position if required.
        """
        return _mupdf.FzXml_fz_dom_insert_after(self, new_elt)

    def fz_dom_insert_before(self, new_elt):
        r"""
        Class-aware wrapper for `::fz_dom_insert_before()`.
        	Insert an element (new_elt), before another element (node),
        	unlinking the new_elt from its current position if required.
        """
        return _mupdf.FzXml_fz_dom_insert_before(self, new_elt)

    def fz_dom_next(self):
        r"""
        Class-aware wrapper for `::fz_dom_next()`.
        	Return a borrowed reference to the next sibling of a node,
        	or NULL if there isn't one.
        """
        return _mupdf.FzXml_fz_dom_next(self)

    def fz_dom_parent(self):
        r"""
        Class-aware wrapper for `::fz_dom_parent()`.
        	Return a borrowed reference to the parent of a node,
        	or NULL if there isn't one.
        """
        return _mupdf.FzXml_fz_dom_parent(self)

    def fz_dom_previous(self):
        r"""
        Class-aware wrapper for `::fz_dom_previous()`.
        	Return a borrowed reference to the previous sibling of a node,
        	or NULL if there isn't one.
        """
        return _mupdf.FzXml_fz_dom_previous(self)

    def fz_dom_remove(self):
        r"""
        Class-aware wrapper for `::fz_dom_remove()`.
        	Remove an element from the DOM. The element can be added back elsewhere
        	if required.

        	No reference counting changes for the element.
        """
        return _mupdf.FzXml_fz_dom_remove(self)

    def fz_dom_remove_attribute(self, att):
        r"""
        Class-aware wrapper for `::fz_dom_remove_attribute()`.
        	Remove an attribute from an element.
        """
        return _mupdf.FzXml_fz_dom_remove_attribute(self, att)

    def fz_new_display_list_from_svg_xml(self, xml, base_uri, dir, w, h):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_svg_xml()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_new_display_list_from_svg_xml(::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

        	Parse an SVG document into a display-list.
        """
        return _mupdf.FzXml_fz_new_display_list_from_svg_xml(self, xml, base_uri, dir, w, h)

    def fz_new_dom_node(self, tag):
        r"""
        Class-aware wrapper for `::fz_new_dom_node()`.
        	Create a new dom node.

        	This will NOT be linked in yet.
        """
        return _mupdf.FzXml_fz_new_dom_node(self, tag)

    def fz_new_dom_text_node(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_new_dom_text_node()`.
        		Create a new dom text node.

        		This will NOT be linked in yet.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_new_dom_text_node()`.
        		Create a new dom text node.

        		This will NOT be linked in yet.
        """
        return _mupdf.FzXml_fz_new_dom_text_node(self, *args)

    def fz_new_image_from_svg_xml(self, xml, base_uri, dir):
        r"""
        Class-aware wrapper for `::fz_new_image_from_svg_xml()`.
        	Create a scalable image from an SVG document.
        """
        return _mupdf.FzXml_fz_new_image_from_svg_xml(self, xml, base_uri, dir)

    def fz_save_xml(self, path, indented):
        r"""
        Class-aware wrapper for `::fz_save_xml()`.
        	As for fz_write_xml, but direct to a file.
        """
        return _mupdf.FzXml_fz_save_xml(self, path, indented)

    def fz_write_xml(self, out, indented):
        r"""
        Class-aware wrapper for `::fz_write_xml()`.
        	Write our xml structure out to an xml stream.

        	Properly formatted XML is only allowed to have a single top-level node
        	under which everything must sit. Our structures allow for multiple
        	top level nodes. If required, we will output an extra 'ROOT' node
        	at the top so that the xml is well-formed.

        	If 'indented' is non-zero then additional whitespace will be added to
        	make the XML easier to read in a text editor. It will NOT be properly
        	compliant.
        """
        return _mupdf.FzXml_fz_write_xml(self, out, indented)

    def fz_xml_att(self, att):
        r"""
        Class-aware wrapper for `::fz_xml_att()`.
        	Return the value of an attribute of an XML node.
        	NULL if the attribute doesn't exist.
        """
        return _mupdf.FzXml_fz_xml_att(self, att)

    def fz_xml_att_alt(self, one, two):
        r"""
        Class-aware wrapper for `::fz_xml_att_alt()`.
        	Return the value of an attribute of an XML node.
        	If the first attribute doesn't exist, try the second.
        	NULL if neither attribute exists.
        """
        return _mupdf.FzXml_fz_xml_att_alt(self, one, two)

    def fz_xml_att_eq(self, name, match):
        r"""
        Class-aware wrapper for `::fz_xml_att_eq()`.
        	Check for a matching attribute on an XML node.

        	If the node has the requested attribute (name), and the value
        	matches (match) then return 1. Otherwise, 0.
        """
        return _mupdf.FzXml_fz_xml_att_eq(self, name, match)

    def fz_xml_down(self):
        r"""
        Class-aware wrapper for `::fz_xml_down()`.
        	Return first child of XML node.
        """
        return _mupdf.FzXml_fz_xml_down(self)

    def fz_xml_find(self, tag):
        r"""
        Class-aware wrapper for `::fz_xml_find()`.
        	Search the siblings of XML nodes starting with item looking for
        	the first with the given tag.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find(self, tag)

    def fz_xml_find_dfs(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_dfs()`.
        	Perform a depth first search from item, returning the first
        	child that matches the given tag (or any tag if tag is NULL),
        	with the given attribute (if att is non NULL), that matches
        	match (if match is non NULL).
        """
        return _mupdf.FzXml_fz_xml_find_dfs(self, tag, att, match)

    def fz_xml_find_dfs_top(self, tag, att, match, top):
        r"""
        Class-aware wrapper for `::fz_xml_find_dfs_top()`.
        	Perform a depth first search from item, returning the first
        	child that matches the given tag (or any tag if tag is NULL),
        	with the given attribute (if att is non NULL), that matches
        	match (if match is non NULL). The search stops if it ever
        	reaches the top of the tree, or the declared 'top' item.
        """
        return _mupdf.FzXml_fz_xml_find_dfs_top(self, tag, att, match, top)

    def fz_xml_find_down(self, tag):
        r"""
        Class-aware wrapper for `::fz_xml_find_down()`.
        	Search the siblings of XML nodes starting with the first child
        	of item looking for the first with the given tag.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_down(self, tag)

    def fz_xml_find_down_match(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_down_match()`.
        	Search the siblings of XML nodes starting with the first child
        	of item looking for the first with the given tag (or any tag if
        	tag is NULL), and with a matching attribute.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_down_match(self, tag, att, match)

    def fz_xml_find_match(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_match()`.
        	Search the siblings of XML nodes starting with item looking for
        	the first with the given tag (or any tag if tag is NULL), and
        	with a matching attribute.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_match(self, tag, att, match)

    def fz_xml_find_next(self, tag):
        r"""
        Class-aware wrapper for `::fz_xml_find_next()`.
        	Search the siblings of XML nodes starting with the first sibling
        	of item looking for the first with the given tag.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_next(self, tag)

    def fz_xml_find_next_dfs(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_next_dfs()`.
        	Perform a depth first search onwards from item, returning the first
        	child that matches the given tag (or any tag if tag is NULL),
        	with the given attribute (if att is non NULL), that matches
        	match (if match is non NULL).
        """
        return _mupdf.FzXml_fz_xml_find_next_dfs(self, tag, att, match)

    def fz_xml_find_next_dfs_top(self, tag, att, match, top):
        r"""
        Class-aware wrapper for `::fz_xml_find_next_dfs_top()`.
        	Perform a depth first search onwards from item, returning the first
        	child that matches the given tag (or any tag if tag is NULL),
        	with the given attribute (if att is non NULL), that matches
        	match (if match is non NULL). The search stops if it ever reaches
        	the top of the tree, or the declared 'top' item.
        """
        return _mupdf.FzXml_fz_xml_find_next_dfs_top(self, tag, att, match, top)

    def fz_xml_find_next_match(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_next_match()`.
        	Search the siblings of XML nodes starting with the first sibling
        	of item looking for the first with the given tag (or any tag if tag
        	is NULL), and with a matching attribute.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_next_match(self, tag, att, match)

    def fz_xml_is_tag(self, name):
        r"""
        Class-aware wrapper for `::fz_xml_is_tag()`.
        	Return true if the tag name matches.
        """
        return _mupdf.FzXml_fz_xml_is_tag(self, name)

    def fz_xml_next(self):
        r"""
        Class-aware wrapper for `::fz_xml_next()`.
        	Return next sibling of XML node.
        """
        return _mupdf.FzXml_fz_xml_next(self)

    def fz_xml_prev(self):
        r"""
        Class-aware wrapper for `::fz_xml_prev()`.
        	Return previous sibling of XML node.
        """
        return _mupdf.FzXml_fz_xml_prev(self)

    def fz_xml_root(self):
        r"""
        Class-aware wrapper for `::fz_xml_root()`.
        	Return the topmost XML node of a document.
        """
        return _mupdf.FzXml_fz_xml_root(self)

    def fz_xml_tag(self):
        r"""
        Class-aware wrapper for `::fz_xml_tag()`.
        	Return tag of XML node. Return NULL for text nodes.
        """
        return _mupdf.FzXml_fz_xml_tag(self)

    def fz_xml_text(self):
        r"""
        Class-aware wrapper for `::fz_xml_text()`.
        	Return the text content of an XML node.
        	Return NULL if the node is a tag.
        """
        return _mupdf.FzXml_fz_xml_text(self)

    def fz_xml_up(self):
        r"""
        Class-aware wrapper for `::fz_xml_up()`.
        	Return parent of XML node.
        """
        return _mupdf.FzXml_fz_xml_up(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_dom()`.
        		Make new xml dom root element.


        |

        *Overload 2:*
         Constructor using `fz_new_dom_node()`.
        		Create a new dom node.

        		This will NOT be linked in yet.


        |

        *Overload 3:*
         Copy constructor using `fz_keep_xml()`.

        |

        *Overload 4:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_xml`.
        """
        _mupdf.FzXml_swiginit(self, _mupdf.new_FzXml(*args))
    __swig_destroy__ = _mupdf.delete_FzXml

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzXml_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzXml___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzXml_m_internal_get, _mupdf.FzXml_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzXml_s_num_instances_get, _mupdf.FzXml_s_num_instances_set)

# Register FzXml in _mupdf:
_mupdf.FzXml_swigregister(FzXml)
class FzXmlDoc(object):
    r"""Wrapper class for struct `fz_xml_doc`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_xml_doc`.
        """
        _mupdf.FzXmlDoc_swiginit(self, _mupdf.new_FzXmlDoc(*args))
    __swig_destroy__ = _mupdf.delete_FzXmlDoc

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzXmlDoc_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzXmlDoc___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzXmlDoc_m_internal_get, _mupdf.FzXmlDoc_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzXmlDoc_s_num_instances_get, _mupdf.FzXmlDoc_s_num_instances_set)

# Register FzXmlDoc in _mupdf:
_mupdf.FzXmlDoc_swigregister(FzXmlDoc)
class FzZipWriter(object):
    r"""
    Wrapper class for struct `fz_zip_writer`. Not copyable or assignable.
    fz_zip_writer offers methods for creating and writing zip files.
    It can be seen as the reverse of the fz_archive zip
    implementation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_close_zip_writer(self):
        r"""
        Class-aware wrapper for `::fz_close_zip_writer()`.
        	Close the zip file for writing.

        	This flushes any pending data to the file. This can throw
        	exceptions.
        """
        return _mupdf.FzZipWriter_fz_close_zip_writer(self)

    def fz_write_zip_entry(self, name, buf, compress):
        r"""
        Class-aware wrapper for `::fz_write_zip_entry()`.
        	Given a buffer of data, (optionally) compress it, and add it to
        	the zip file with the given name.
        """
        return _mupdf.FzZipWriter_fz_write_zip_entry(self, name, buf, compress)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_zip_writer()`.
        		Create a new zip writer that writes to a given file.

        		Open an archive using a seekable stream object rather than
        		opening a file or directory on disk.


        |

        *Overload 2:*
         Constructor using `fz_new_zip_writer_with_output()`.
        		Create a new zip writer that writes to a given output stream.

        		Ownership of out passes in immediately upon calling this function.
        		The caller should never drop the fz_output, even if this function throws
        		an exception.


        |

        *Overload 3:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_zip_writer`.
        """
        _mupdf.FzZipWriter_swiginit(self, _mupdf.new_FzZipWriter(*args))
    __swig_destroy__ = _mupdf.delete_FzZipWriter

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzZipWriter_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzZipWriter___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzZipWriter_m_internal_get, _mupdf.FzZipWriter_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzZipWriter_s_num_instances_get, _mupdf.FzZipWriter_s_num_instances_set)

# Register FzZipWriter in _mupdf:
_mupdf.FzZipWriter_swigregister(FzZipWriter)
class PdfAlertEvent(object):
    r"""Wrapper class for struct `pdf_alert_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_alert_event`.
        """
        _mupdf.PdfAlertEvent_swiginit(self, _mupdf.new_PdfAlertEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfAlertEvent

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfAlertEvent_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfAlertEvent___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfAlertEvent_m_internal_get, _mupdf.PdfAlertEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfAlertEvent_s_num_instances_get, _mupdf.PdfAlertEvent_s_num_instances_set)

# Register PdfAlertEvent in _mupdf:
_mupdf.PdfAlertEvent_swigregister(PdfAlertEvent)
class PdfAnnot(object):
    r"""Wrapper class for struct `pdf_annot`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_add_annot_border_dash_item(self, length):
        r"""Class-aware wrapper for `::pdf_add_annot_border_dash_item()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_border_dash_item(self, length)

    def pdf_add_annot_ink_list_stroke(self):
        r"""Class-aware wrapper for `::pdf_add_annot_ink_list_stroke()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_ink_list_stroke(self)

    def pdf_add_annot_ink_list_stroke_vertex(self, p):
        r"""Class-aware wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_ink_list_stroke_vertex(self, p)

    def pdf_add_annot_quad_point(self, quad):
        r"""Class-aware wrapper for `::pdf_add_annot_quad_point()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_quad_point(self, quad)

    def pdf_add_annot_vertex(self, p):
        r"""Class-aware wrapper for `::pdf_add_annot_vertex()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_vertex(self, p)

    def pdf_annot_MK_BC(self, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_MK_BC()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_MK_BC(float color[4])` => int n
        """
        return _mupdf.PdfAnnot_pdf_annot_MK_BC(self, n, color)

    def pdf_annot_MK_BC_rgb(self, rgb):
        r"""Class-aware wrapper for `::pdf_annot_MK_BC_rgb()`."""
        return _mupdf.PdfAnnot_pdf_annot_MK_BC_rgb(self, rgb)

    def pdf_annot_MK_BG(self, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_MK_BG()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_MK_BG(float color[4])` => int n
        """
        return _mupdf.PdfAnnot_pdf_annot_MK_BG(self, n, color)

    def pdf_annot_MK_BG_rgb(self, rgb):
        r"""Class-aware wrapper for `::pdf_annot_MK_BG_rgb()`."""
        return _mupdf.PdfAnnot_pdf_annot_MK_BG_rgb(self, rgb)

    def pdf_annot_active(self):
        r"""Class-aware wrapper for `::pdf_annot_active()`."""
        return _mupdf.PdfAnnot_pdf_annot_active(self)

    def pdf_annot_ap(self):
        r"""Class-aware wrapper for `::pdf_annot_ap()`."""
        return _mupdf.PdfAnnot_pdf_annot_ap(self)

    def pdf_annot_author(self):
        r"""Class-aware wrapper for `::pdf_annot_author()`."""
        return _mupdf.PdfAnnot_pdf_annot_author(self)

    def pdf_annot_border(self):
        r"""Class-aware wrapper for `::pdf_annot_border()`."""
        return _mupdf.PdfAnnot_pdf_annot_border(self)

    def pdf_annot_border_dash_count(self):
        r"""Class-aware wrapper for `::pdf_annot_border_dash_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_dash_count(self)

    def pdf_annot_border_dash_item(self, i):
        r"""Class-aware wrapper for `::pdf_annot_border_dash_item()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_dash_item(self, i)

    def pdf_annot_border_effect(self):
        r"""Class-aware wrapper for `::pdf_annot_border_effect()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_effect(self)

    def pdf_annot_border_effect_intensity(self):
        r"""Class-aware wrapper for `::pdf_annot_border_effect_intensity()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_effect_intensity(self)

    def pdf_annot_border_style(self):
        r"""Class-aware wrapper for `::pdf_annot_border_style()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_style(self)

    def pdf_annot_border_width(self):
        r"""Class-aware wrapper for `::pdf_annot_border_width()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_width(self)

    def pdf_annot_callout_point(self):
        r"""Class-aware wrapper for `::pdf_annot_callout_point()`."""
        return _mupdf.PdfAnnot_pdf_annot_callout_point(self)

    def pdf_annot_callout_style(self):
        r"""Class-aware wrapper for `::pdf_annot_callout_style()`."""
        return _mupdf.PdfAnnot_pdf_annot_callout_style(self)

    def pdf_annot_color(self, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_color(float color[4])` => int n
        """
        return _mupdf.PdfAnnot_pdf_annot_color(self, n, color)

    def pdf_annot_contents(self):
        r"""Class-aware wrapper for `::pdf_annot_contents()`."""
        return _mupdf.PdfAnnot_pdf_annot_contents(self)

    def pdf_annot_creation_date(self):
        r"""Class-aware wrapper for `::pdf_annot_creation_date()`."""
        return _mupdf.PdfAnnot_pdf_annot_creation_date(self)

    def pdf_annot_default_appearance(self, font, size, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_default_appearance()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_default_appearance(float color[4])` => `(const char *font, float size, int n)`
        """
        return _mupdf.PdfAnnot_pdf_annot_default_appearance(self, font, size, n, color)

    def pdf_annot_default_appearance_unmapped(self, font_name, font_name_len, size, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_default_appearance_unmapped()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_default_appearance_unmapped(char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
        """
        return _mupdf.PdfAnnot_pdf_annot_default_appearance_unmapped(self, font_name, font_name_len, size, n, color)

    def pdf_annot_ensure_local_xref(self):
        r"""Class-aware wrapper for `::pdf_annot_ensure_local_xref()`."""
        return _mupdf.PdfAnnot_pdf_annot_ensure_local_xref(self)

    def pdf_annot_event_blur(self):
        r"""Class-aware wrapper for `::pdf_annot_event_blur()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_blur(self)

    def pdf_annot_event_down(self):
        r"""Class-aware wrapper for `::pdf_annot_event_down()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_down(self)

    def pdf_annot_event_enter(self):
        r"""Class-aware wrapper for `::pdf_annot_event_enter()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_enter(self)

    def pdf_annot_event_exit(self):
        r"""Class-aware wrapper for `::pdf_annot_event_exit()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_exit(self)

    def pdf_annot_event_focus(self):
        r"""Class-aware wrapper for `::pdf_annot_event_focus()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_focus(self)

    def pdf_annot_event_page_close(self):
        r"""Class-aware wrapper for `::pdf_annot_event_page_close()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_page_close(self)

    def pdf_annot_event_page_invisible(self):
        r"""Class-aware wrapper for `::pdf_annot_event_page_invisible()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_page_invisible(self)

    def pdf_annot_event_page_open(self):
        r"""Class-aware wrapper for `::pdf_annot_event_page_open()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_page_open(self)

    def pdf_annot_event_page_visible(self):
        r"""Class-aware wrapper for `::pdf_annot_event_page_visible()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_page_visible(self)

    def pdf_annot_event_up(self):
        r"""Class-aware wrapper for `::pdf_annot_event_up()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_up(self)

    def pdf_annot_field_flags(self):
        r"""Class-aware wrapper for `::pdf_annot_field_flags()`."""
        return _mupdf.PdfAnnot_pdf_annot_field_flags(self)

    def pdf_annot_field_label(self):
        r"""Class-aware wrapper for `::pdf_annot_field_label()`."""
        return _mupdf.PdfAnnot_pdf_annot_field_label(self)

    def pdf_annot_field_value(self):
        r"""Class-aware wrapper for `::pdf_annot_field_value()`."""
        return _mupdf.PdfAnnot_pdf_annot_field_value(self)

    def pdf_annot_filespec(self):
        r"""Class-aware wrapper for `::pdf_annot_filespec()`."""
        return _mupdf.PdfAnnot_pdf_annot_filespec(self)

    def pdf_annot_flags(self):
        r"""Class-aware wrapper for `::pdf_annot_flags()`."""
        return _mupdf.PdfAnnot_pdf_annot_flags(self)

    def pdf_annot_has_author(self):
        r"""Class-aware wrapper for `::pdf_annot_has_author()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_author(self)

    def pdf_annot_has_border(self):
        r"""Class-aware wrapper for `::pdf_annot_has_border()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_border(self)

    def pdf_annot_has_border_effect(self):
        r"""Class-aware wrapper for `::pdf_annot_has_border_effect()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_border_effect(self)

    def pdf_annot_has_callout(self):
        r"""Class-aware wrapper for `::pdf_annot_has_callout()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_callout(self)

    def pdf_annot_has_filespec(self):
        r"""Class-aware wrapper for `::pdf_annot_has_filespec()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_filespec(self)

    def pdf_annot_has_icon_name(self):
        r"""Class-aware wrapper for `::pdf_annot_has_icon_name()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_icon_name(self)

    def pdf_annot_has_ink_list(self):
        r"""Class-aware wrapper for `::pdf_annot_has_ink_list()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_ink_list(self)

    def pdf_annot_has_intent(self):
        r"""Class-aware wrapper for `::pdf_annot_has_intent()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_intent(self)

    def pdf_annot_has_interior_color(self):
        r"""Class-aware wrapper for `::pdf_annot_has_interior_color()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_interior_color(self)

    def pdf_annot_has_line(self):
        r"""Class-aware wrapper for `::pdf_annot_has_line()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_line(self)

    def pdf_annot_has_line_ending_styles(self):
        r"""Class-aware wrapper for `::pdf_annot_has_line_ending_styles()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_line_ending_styles(self)

    def pdf_annot_has_open(self):
        r"""Class-aware wrapper for `::pdf_annot_has_open()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_open(self)

    def pdf_annot_has_popup(self):
        r"""Class-aware wrapper for `::pdf_annot_has_popup()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_popup(self)

    def pdf_annot_has_quad_points(self):
        r"""Class-aware wrapper for `::pdf_annot_has_quad_points()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_quad_points(self)

    def pdf_annot_has_quadding(self):
        r"""Class-aware wrapper for `::pdf_annot_has_quadding()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_quadding(self)

    def pdf_annot_has_rect(self):
        r"""Class-aware wrapper for `::pdf_annot_has_rect()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_rect(self)

    def pdf_annot_has_vertices(self):
        r"""Class-aware wrapper for `::pdf_annot_has_vertices()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_vertices(self)

    def pdf_annot_hidden_for_editing(self):
        r"""Class-aware wrapper for `::pdf_annot_hidden_for_editing()`."""
        return _mupdf.PdfAnnot_pdf_annot_hidden_for_editing(self)

    def pdf_annot_hot(self):
        r"""Class-aware wrapper for `::pdf_annot_hot()`."""
        return _mupdf.PdfAnnot_pdf_annot_hot(self)

    def pdf_annot_icon_name(self):
        r"""Class-aware wrapper for `::pdf_annot_icon_name()`."""
        return _mupdf.PdfAnnot_pdf_annot_icon_name(self)

    def pdf_annot_ink_list_count(self):
        r"""Class-aware wrapper for `::pdf_annot_ink_list_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_ink_list_count(self)

    def pdf_annot_ink_list_stroke_count(self, i):
        r"""Class-aware wrapper for `::pdf_annot_ink_list_stroke_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_ink_list_stroke_count(self, i)

    def pdf_annot_ink_list_stroke_vertex(self, i, k):
        r"""Class-aware wrapper for `::pdf_annot_ink_list_stroke_vertex()`."""
        return _mupdf.PdfAnnot_pdf_annot_ink_list_stroke_vertex(self, i, k)

    def pdf_annot_intent(self):
        r"""Class-aware wrapper for `::pdf_annot_intent()`."""
        return _mupdf.PdfAnnot_pdf_annot_intent(self)

    def pdf_annot_interior_color(self, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_interior_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_interior_color(float color[4])` => int n
        """
        return _mupdf.PdfAnnot_pdf_annot_interior_color(self, n, color)

    def pdf_annot_is_open(self):
        r"""Class-aware wrapper for `::pdf_annot_is_open()`."""
        return _mupdf.PdfAnnot_pdf_annot_is_open(self)

    def pdf_annot_is_standard_stamp(self):
        r"""Class-aware wrapper for `::pdf_annot_is_standard_stamp()`."""
        return _mupdf.PdfAnnot_pdf_annot_is_standard_stamp(self)

    def pdf_annot_line(self, a, b):
        r"""Class-aware wrapper for `::pdf_annot_line()`."""
        return _mupdf.PdfAnnot_pdf_annot_line(self, a, b)

    def pdf_annot_line_caption(self):
        r"""Class-aware wrapper for `::pdf_annot_line_caption()`."""
        return _mupdf.PdfAnnot_pdf_annot_line_caption(self)

    def pdf_annot_line_caption_offset(self):
        r"""Class-aware wrapper for `::pdf_annot_line_caption_offset()`."""
        return _mupdf.PdfAnnot_pdf_annot_line_caption_offset(self)

    def pdf_annot_line_end_style(self):
        r"""Class-aware wrapper for `::pdf_annot_line_end_style()`."""
        return _mupdf.PdfAnnot_pdf_annot_line_end_style(self)

    def pdf_annot_line_ending_styles(self, start_style, end_style):
        r"""
        Class-aware wrapper for `::pdf_annot_line_ending_styles()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_line_ending_styles()` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
        """
        return _mupdf.PdfAnnot_pdf_annot_line_ending_styles(self, start_style, end_style)

    def pdf_annot_line_leader(self):
        r"""Class-aware wrapper for `::pdf_annot_line_leader()`."""
        return _mupdf.PdfAnnot_pdf_annot_line_leader(self)

    def pdf_annot_line_leader_extension(self):
        r"""Class-aware wrapper for `::pdf_annot_line_leader_extension()`."""
        return _mupdf.PdfAnnot_pdf_annot_line_leader_extension(self)

    def pdf_annot_line_leader_offset(self):
        r"""Class-aware wrapper for `::pdf_annot_line_leader_offset()`."""
        return _mupdf.PdfAnnot_pdf_annot_line_leader_offset(self)

    def pdf_annot_line_start_style(self):
        r"""Class-aware wrapper for `::pdf_annot_line_start_style()`."""
        return _mupdf.PdfAnnot_pdf_annot_line_start_style(self)

    def pdf_annot_modification_date(self):
        r"""Class-aware wrapper for `::pdf_annot_modification_date()`."""
        return _mupdf.PdfAnnot_pdf_annot_modification_date(self)

    def pdf_annot_needs_resynthesis(self):
        r"""Class-aware wrapper for `::pdf_annot_needs_resynthesis()`."""
        return _mupdf.PdfAnnot_pdf_annot_needs_resynthesis(self)

    def pdf_annot_obj(self):
        r"""Class-aware wrapper for `::pdf_annot_obj()`."""
        return _mupdf.PdfAnnot_pdf_annot_obj(self)

    def pdf_annot_opacity(self):
        r"""Class-aware wrapper for `::pdf_annot_opacity()`."""
        return _mupdf.PdfAnnot_pdf_annot_opacity(self)

    def pdf_annot_page(self):
        r"""Class-aware wrapper for `::pdf_annot_page()`."""
        return _mupdf.PdfAnnot_pdf_annot_page(self)

    def pdf_annot_pop_and_discard_local_xref(self):
        r"""Class-aware wrapper for `::pdf_annot_pop_and_discard_local_xref()`."""
        return _mupdf.PdfAnnot_pdf_annot_pop_and_discard_local_xref(self)

    def pdf_annot_pop_local_xref(self):
        r"""Class-aware wrapper for `::pdf_annot_pop_local_xref()`."""
        return _mupdf.PdfAnnot_pdf_annot_pop_local_xref(self)

    def pdf_annot_popup(self):
        r"""Class-aware wrapper for `::pdf_annot_popup()`."""
        return _mupdf.PdfAnnot_pdf_annot_popup(self)

    def pdf_annot_push_local_xref(self):
        r"""Class-aware wrapper for `::pdf_annot_push_local_xref()`."""
        return _mupdf.PdfAnnot_pdf_annot_push_local_xref(self)

    def pdf_annot_quad_point(self, i):
        r"""Class-aware wrapper for `::pdf_annot_quad_point()`."""
        return _mupdf.PdfAnnot_pdf_annot_quad_point(self, i)

    def pdf_annot_quad_point_count(self):
        r"""Class-aware wrapper for `::pdf_annot_quad_point_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_quad_point_count(self)

    def pdf_annot_quadding(self):
        r"""Class-aware wrapper for `::pdf_annot_quadding()`."""
        return _mupdf.PdfAnnot_pdf_annot_quadding(self)

    def pdf_annot_rect(self):
        r"""Class-aware wrapper for `::pdf_annot_rect()`."""
        return _mupdf.PdfAnnot_pdf_annot_rect(self)

    def pdf_annot_request_resynthesis(self):
        r"""Class-aware wrapper for `::pdf_annot_request_resynthesis()`."""
        return _mupdf.PdfAnnot_pdf_annot_request_resynthesis(self)

    def pdf_annot_request_synthesis(self):
        r"""Class-aware wrapper for `::pdf_annot_request_synthesis()`."""
        return _mupdf.PdfAnnot_pdf_annot_request_synthesis(self)

    def pdf_annot_transform(self):
        r"""Class-aware wrapper for `::pdf_annot_transform()`."""
        return _mupdf.PdfAnnot_pdf_annot_transform(self)

    def pdf_annot_type(self):
        r"""Class-aware wrapper for `::pdf_annot_type()`."""
        return _mupdf.PdfAnnot_pdf_annot_type(self)

    def pdf_annot_vertex(self, i):
        r"""Class-aware wrapper for `::pdf_annot_vertex()`."""
        return _mupdf.PdfAnnot_pdf_annot_vertex(self, i)

    def pdf_annot_vertex_count(self):
        r"""Class-aware wrapper for `::pdf_annot_vertex_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_vertex_count(self)

    def pdf_apply_redaction(self, opts):
        r"""Class-aware wrapper for `::pdf_apply_redaction()`."""
        return _mupdf.PdfAnnot_pdf_apply_redaction(self, opts)

    def pdf_bound_annot(self):
        r"""Class-aware wrapper for `::pdf_bound_annot()`."""
        return _mupdf.PdfAnnot_pdf_bound_annot(self)

    def pdf_bound_widget(self):
        r"""Class-aware wrapper for `::pdf_bound_widget()`."""
        return _mupdf.PdfAnnot_pdf_bound_widget(self)

    def pdf_choice_widget_is_multiselect(self):
        r"""Class-aware wrapper for `::pdf_choice_widget_is_multiselect()`."""
        return _mupdf.PdfAnnot_pdf_choice_widget_is_multiselect(self)

    def pdf_choice_widget_options(self, exportval, opts):
        r"""Class-aware wrapper for `::pdf_choice_widget_options()`."""
        return _mupdf.PdfAnnot_pdf_choice_widget_options(self, exportval, opts)

    def pdf_choice_widget_options2(self, exportval):
        r"""
        Class-aware wrapper for `::pdf_choice_widget_options2()`.   Swig-friendly wrapper for pdf_choice_widget_options(), returns the
        options directly in a vector.
        """
        return _mupdf.PdfAnnot_pdf_choice_widget_options2(self, exportval)

    def pdf_choice_widget_set_value(self, n, opts):
        r"""Class-aware wrapper for `::pdf_choice_widget_set_value()`."""
        return _mupdf.PdfAnnot_pdf_choice_widget_set_value(self, n, opts)

    def pdf_choice_widget_value(self, opts):
        r"""Class-aware wrapper for `::pdf_choice_widget_value()`."""
        return _mupdf.PdfAnnot_pdf_choice_widget_value(self, opts)

    def pdf_clear_annot_border_dash(self):
        r"""Class-aware wrapper for `::pdf_clear_annot_border_dash()`."""
        return _mupdf.PdfAnnot_pdf_clear_annot_border_dash(self)

    def pdf_clear_annot_ink_list(self):
        r"""Class-aware wrapper for `::pdf_clear_annot_ink_list()`."""
        return _mupdf.PdfAnnot_pdf_clear_annot_ink_list(self)

    def pdf_clear_annot_quad_points(self):
        r"""Class-aware wrapper for `::pdf_clear_annot_quad_points()`."""
        return _mupdf.PdfAnnot_pdf_clear_annot_quad_points(self)

    def pdf_clear_annot_vertices(self):
        r"""Class-aware wrapper for `::pdf_clear_annot_vertices()`."""
        return _mupdf.PdfAnnot_pdf_clear_annot_vertices(self)

    def pdf_clear_signature(self):
        r"""Class-aware wrapper for `::pdf_clear_signature()`."""
        return _mupdf.PdfAnnot_pdf_clear_signature(self)

    def pdf_dirty_annot(self):
        r"""Class-aware wrapper for `::pdf_dirty_annot()`."""
        return _mupdf.PdfAnnot_pdf_dirty_annot(self)

    def pdf_edit_text_field_value(self, value, change, selStart, selEnd, newvalue):
        r"""
        Class-aware wrapper for `::pdf_edit_text_field_value()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_edit_text_field_value(const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
        """
        return _mupdf.PdfAnnot_pdf_edit_text_field_value(self, value, change, selStart, selEnd, newvalue)

    def pdf_get_widget_editing_state(self):
        r"""Class-aware wrapper for `::pdf_get_widget_editing_state()`."""
        return _mupdf.PdfAnnot_pdf_get_widget_editing_state(self)

    def pdf_incremental_change_since_signing_widget(self):
        r"""Class-aware wrapper for `::pdf_incremental_change_since_signing_widget()`."""
        return _mupdf.PdfAnnot_pdf_incremental_change_since_signing_widget(self)

    def pdf_new_display_list_from_annot(self):
        r"""Class-aware wrapper for `::pdf_new_display_list_from_annot()`."""
        return _mupdf.PdfAnnot_pdf_new_display_list_from_annot(self)

    def pdf_new_pixmap_from_annot(self, ctm, cs, seps, alpha):
        r"""Class-aware wrapper for `::pdf_new_pixmap_from_annot()`."""
        return _mupdf.PdfAnnot_pdf_new_pixmap_from_annot(self, ctm, cs, seps, alpha)

    def pdf_next_annot(self):
        r"""Class-aware wrapper for `::pdf_next_annot()`."""
        return _mupdf.PdfAnnot_pdf_next_annot(self)

    def pdf_next_widget(self):
        r"""Class-aware wrapper for `::pdf_next_widget()`."""
        return _mupdf.PdfAnnot_pdf_next_widget(self)

    def pdf_run_annot(self, dev, ctm, cookie):
        r"""Class-aware wrapper for `::pdf_run_annot()`."""
        return _mupdf.PdfAnnot_pdf_run_annot(self, dev, ctm, cookie)

    def pdf_set_annot_active(self, active):
        r"""Class-aware wrapper for `::pdf_set_annot_active()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_active(self, active)

    def pdf_set_annot_appearance(self, appearance, state, ctm, bbox, res, contents):
        r"""Class-aware wrapper for `::pdf_set_annot_appearance()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_appearance(self, appearance, state, ctm, bbox, res, contents)

    def pdf_set_annot_appearance_from_display_list(self, appearance, state, ctm, list):
        r"""Class-aware wrapper for `::pdf_set_annot_appearance_from_display_list()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_appearance_from_display_list(self, appearance, state, ctm, list)

    def pdf_set_annot_author(self, author):
        r"""Class-aware wrapper for `::pdf_set_annot_author()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_author(self, author)

    def pdf_set_annot_border(self, width):
        r"""Class-aware wrapper for `::pdf_set_annot_border()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border(self, width)

    def pdf_set_annot_border_effect(self, effect):
        r"""Class-aware wrapper for `::pdf_set_annot_border_effect()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border_effect(self, effect)

    def pdf_set_annot_border_effect_intensity(self, intensity):
        r"""Class-aware wrapper for `::pdf_set_annot_border_effect_intensity()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border_effect_intensity(self, intensity)

    def pdf_set_annot_border_style(self, style):
        r"""Class-aware wrapper for `::pdf_set_annot_border_style()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border_style(self, style)

    def pdf_set_annot_border_width(self, width):
        r"""Class-aware wrapper for `::pdf_set_annot_border_width()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border_width(self, width)

    def pdf_set_annot_callout_line2(self, callout):
        r"""Class-aware wrapper for `::pdf_set_annot_callout_line2()`.   SWIG-friendly wrapper for pdf_set_annot_callout_line()."""
        return _mupdf.PdfAnnot_pdf_set_annot_callout_line2(self, callout)

    def pdf_set_annot_callout_point(self, p):
        r"""Class-aware wrapper for `::pdf_set_annot_callout_point()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_callout_point(self, p)

    def pdf_set_annot_callout_style(self, style):
        r"""Class-aware wrapper for `::pdf_set_annot_callout_style()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_callout_style(self, style)

    def pdf_set_annot_color(self, n, color):
        r"""Class-aware wrapper for `::pdf_set_annot_color()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_color(self, n, color)

    def pdf_set_annot_contents(self, text):
        r"""Class-aware wrapper for `::pdf_set_annot_contents()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_contents(self, text)

    def pdf_set_annot_creation_date(self, time):
        r"""Class-aware wrapper for `::pdf_set_annot_creation_date()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_creation_date(self, time)

    def pdf_set_annot_default_appearance(self, font, size, n, color):
        r"""Class-aware wrapper for `::pdf_set_annot_default_appearance()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_default_appearance(self, font, size, n, color)

    def pdf_set_annot_filespec(self, obj):
        r"""Class-aware wrapper for `::pdf_set_annot_filespec()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_filespec(self, obj)

    def pdf_set_annot_flags(self, flags):
        r"""Class-aware wrapper for `::pdf_set_annot_flags()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_flags(self, flags)

    def pdf_set_annot_hidden_for_editing(self, hidden):
        r"""Class-aware wrapper for `::pdf_set_annot_hidden_for_editing()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_hidden_for_editing(self, hidden)

    def pdf_set_annot_hot(self, hot):
        r"""Class-aware wrapper for `::pdf_set_annot_hot()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_hot(self, hot)

    def pdf_set_annot_icon_name(self, name):
        r"""Class-aware wrapper for `::pdf_set_annot_icon_name()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_icon_name(self, name)

    def pdf_set_annot_ink_list(self, n, count, v):
        r"""Class-aware wrapper for `::pdf_set_annot_ink_list()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_ink_list(self, n, count, v)

    def pdf_set_annot_intent(self, it):
        r"""Class-aware wrapper for `::pdf_set_annot_intent()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_intent(self, it)

    def pdf_set_annot_interior_color(self, n, color):
        r"""Class-aware wrapper for `::pdf_set_annot_interior_color()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_interior_color(self, n, color)

    def pdf_set_annot_is_open(self, is_open):
        r"""Class-aware wrapper for `::pdf_set_annot_is_open()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_is_open(self, is_open)

    def pdf_set_annot_language(self, lang):
        r"""Class-aware wrapper for `::pdf_set_annot_language()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_language(self, lang)

    def pdf_set_annot_line(self, a, b):
        r"""Class-aware wrapper for `::pdf_set_annot_line()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line(self, a, b)

    def pdf_set_annot_line_caption(self, cap):
        r"""Class-aware wrapper for `::pdf_set_annot_line_caption()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_caption(self, cap)

    def pdf_set_annot_line_caption_offset(self, offset):
        r"""Class-aware wrapper for `::pdf_set_annot_line_caption_offset()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_caption_offset(self, offset)

    def pdf_set_annot_line_end_style(self, e):
        r"""Class-aware wrapper for `::pdf_set_annot_line_end_style()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_end_style(self, e)

    def pdf_set_annot_line_ending_styles(self, start_style, end_style):
        r"""Class-aware wrapper for `::pdf_set_annot_line_ending_styles()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_ending_styles(self, start_style, end_style)

    def pdf_set_annot_line_leader(self, ll):
        r"""Class-aware wrapper for `::pdf_set_annot_line_leader()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_leader(self, ll)

    def pdf_set_annot_line_leader_extension(self, lle):
        r"""Class-aware wrapper for `::pdf_set_annot_line_leader_extension()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_leader_extension(self, lle)

    def pdf_set_annot_line_leader_offset(self, llo):
        r"""Class-aware wrapper for `::pdf_set_annot_line_leader_offset()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_leader_offset(self, llo)

    def pdf_set_annot_line_start_style(self, s):
        r"""Class-aware wrapper for `::pdf_set_annot_line_start_style()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_start_style(self, s)

    def pdf_set_annot_modification_date(self, time):
        r"""Class-aware wrapper for `::pdf_set_annot_modification_date()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_modification_date(self, time)

    def pdf_set_annot_opacity(self, opacity):
        r"""Class-aware wrapper for `::pdf_set_annot_opacity()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_opacity(self, opacity)

    def pdf_set_annot_popup(self, rect):
        r"""Class-aware wrapper for `::pdf_set_annot_popup()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_popup(self, rect)

    def pdf_set_annot_quad_points(self, n, qv):
        r"""Class-aware wrapper for `::pdf_set_annot_quad_points()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_quad_points(self, n, qv)

    def pdf_set_annot_quadding(self, q):
        r"""Class-aware wrapper for `::pdf_set_annot_quadding()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_quadding(self, q)

    def pdf_set_annot_rect(self, rect):
        r"""Class-aware wrapper for `::pdf_set_annot_rect()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_rect(self, rect)

    def pdf_set_annot_resynthesised(self):
        r"""Class-aware wrapper for `::pdf_set_annot_resynthesised()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_resynthesised(self)

    def pdf_set_annot_stamp_image(self, image):
        r"""Class-aware wrapper for `::pdf_set_annot_stamp_image()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_stamp_image(self, image)

    def pdf_set_annot_vertex(self, i, p):
        r"""Class-aware wrapper for `::pdf_set_annot_vertex()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_vertex(self, i, p)

    def pdf_set_annot_vertices(self, n, v):
        r"""Class-aware wrapper for `::pdf_set_annot_vertices()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_vertices(self, n, v)

    def pdf_set_choice_field_value(self, value):
        r"""Class-aware wrapper for `::pdf_set_choice_field_value()`."""
        return _mupdf.PdfAnnot_pdf_set_choice_field_value(self, value)

    def pdf_set_text_field_value(self, value):
        r"""Class-aware wrapper for `::pdf_set_text_field_value()`."""
        return _mupdf.PdfAnnot_pdf_set_text_field_value(self, value)

    def pdf_set_widget_editing_state(self, editing):
        r"""Class-aware wrapper for `::pdf_set_widget_editing_state()`."""
        return _mupdf.PdfAnnot_pdf_set_widget_editing_state(self, editing)

    def pdf_sign_signature(self, signer, appearance_flags, graphic, reason, location):
        r"""Class-aware wrapper for `::pdf_sign_signature()`."""
        return _mupdf.PdfAnnot_pdf_sign_signature(self, signer, appearance_flags, graphic, reason, location)

    def pdf_sign_signature_with_appearance(self, signer, date, disp_list):
        r"""Class-aware wrapper for `::pdf_sign_signature_with_appearance()`."""
        return _mupdf.PdfAnnot_pdf_sign_signature_with_appearance(self, signer, date, disp_list)

    def pdf_text_widget_format(self):
        r"""Class-aware wrapper for `::pdf_text_widget_format()`."""
        return _mupdf.PdfAnnot_pdf_text_widget_format(self)

    def pdf_text_widget_max_len(self):
        r"""Class-aware wrapper for `::pdf_text_widget_max_len()`."""
        return _mupdf.PdfAnnot_pdf_text_widget_max_len(self)

    def pdf_toggle_widget(self):
        r"""Class-aware wrapper for `::pdf_toggle_widget()`."""
        return _mupdf.PdfAnnot_pdf_toggle_widget(self)

    def pdf_update_annot(self):
        r"""Class-aware wrapper for `::pdf_update_annot()`."""
        return _mupdf.PdfAnnot_pdf_update_annot(self)

    def pdf_update_widget(self):
        r"""Class-aware wrapper for `::pdf_update_widget()`."""
        return _mupdf.PdfAnnot_pdf_update_widget(self)

    def pdf_validate_signature(self):
        r"""Class-aware wrapper for `::pdf_validate_signature()`."""
        return _mupdf.PdfAnnot_pdf_validate_signature(self)

    def pdf_widget_is_readonly(self):
        r"""Class-aware wrapper for `::pdf_widget_is_readonly()`."""
        return _mupdf.PdfAnnot_pdf_widget_is_readonly(self)

    def pdf_widget_is_signed(self):
        r"""Class-aware wrapper for `::pdf_widget_is_signed()`."""
        return _mupdf.PdfAnnot_pdf_widget_is_signed(self)

    def pdf_widget_type(self):
        r"""Class-aware wrapper for `::pdf_widget_type()`."""
        return _mupdf.PdfAnnot_pdf_widget_type(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `pdf_keep_annot()`.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_annot`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_annot`.
        """
        _mupdf.PdfAnnot_swiginit(self, _mupdf.new_PdfAnnot(*args))
    __swig_destroy__ = _mupdf.delete_PdfAnnot

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfAnnot_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfAnnot___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfAnnot_m_internal_get, _mupdf.PdfAnnot_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfAnnot_s_num_instances_get, _mupdf.PdfAnnot_s_num_instances_set)

# Register PdfAnnot in _mupdf:
_mupdf.PdfAnnot_swigregister(PdfAnnot)
class PdfCleanOptions(object):
    r"""Wrapper class for struct `pdf_clean_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def write_opwd_utf8_set(self, text):
        r"""Copies <text> into write.opwd_utf8[]."""
        return _mupdf.PdfCleanOptions_write_opwd_utf8_set(self, text)

    def write_upwd_utf8_set(self, text):
        r"""Copies <text> into upwd_utf8[]."""
        return _mupdf.PdfCleanOptions_write_upwd_utf8_set(self, text)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, makes copy of pdf_default_write_options.

        |

        *Overload 2:*
        Copy constructor using raw memcopy().

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_clean_options`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_clean_options`.
        """
        _mupdf.PdfCleanOptions_swiginit(self, _mupdf.new_PdfCleanOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfCleanOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfCleanOptions
    write = property(_mupdf.PdfCleanOptions_write_get, _mupdf.PdfCleanOptions_write_set)
    image = property(_mupdf.PdfCleanOptions_image_get, _mupdf.PdfCleanOptions_image_set)
    subset_fonts = property(_mupdf.PdfCleanOptions_subset_fonts_get, _mupdf.PdfCleanOptions_subset_fonts_set)
    structure = property(_mupdf.PdfCleanOptions_structure_get, _mupdf.PdfCleanOptions_structure_set)
    s_num_instances = property(_mupdf.PdfCleanOptions_s_num_instances_get, _mupdf.PdfCleanOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfCleanOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfCleanOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfCleanOptions___ne__(self, rhs)

# Register PdfCleanOptions in _mupdf:
_mupdf.PdfCleanOptions_swigregister(PdfCleanOptions)
class PdfCmap(object):
    r"""Wrapper class for struct `pdf_cmap`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_add_codespace(self, low, high, n):
        r"""Class-aware wrapper for `::pdf_add_codespace()`."""
        return _mupdf.PdfCmap_pdf_add_codespace(self, low, high, n)

    def pdf_cmap_size(self):
        r"""Class-aware wrapper for `::pdf_cmap_size()`."""
        return _mupdf.PdfCmap_pdf_cmap_size(self)

    def pdf_cmap_wmode(self):
        r"""Class-aware wrapper for `::pdf_cmap_wmode()`."""
        return _mupdf.PdfCmap_pdf_cmap_wmode(self)

    def pdf_decode_cmap(self, s, e, cpt):
        r"""
        Class-aware wrapper for `::pdf_decode_cmap()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_decode_cmap(unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
        """
        return _mupdf.PdfCmap_pdf_decode_cmap(self, s, e, cpt)

    def pdf_lookup_cmap(self, cpt):
        r"""Class-aware wrapper for `::pdf_lookup_cmap()`."""
        return _mupdf.PdfCmap_pdf_lookup_cmap(self, cpt)

    def pdf_lookup_cmap_full(self, cpt, out):
        r"""
        Class-aware wrapper for `::pdf_lookup_cmap_full()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_lookup_cmap_full(unsigned int cpt)` => `(int, int out)`
        """
        return _mupdf.PdfCmap_pdf_lookup_cmap_full(self, cpt, out)

    def pdf_map_one_to_many(self, one, many, len):
        r"""
        Class-aware wrapper for `::pdf_map_one_to_many()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_map_one_to_many(unsigned int one, size_t len)` => int many
        """
        return _mupdf.PdfCmap_pdf_map_one_to_many(self, one, many, len)

    def pdf_map_range_to_range(self, srclo, srchi, dstlo):
        r"""Class-aware wrapper for `::pdf_map_range_to_range()`."""
        return _mupdf.PdfCmap_pdf_map_range_to_range(self, srclo, srchi, dstlo)

    def pdf_set_cmap_wmode(self, wmode):
        r"""Class-aware wrapper for `::pdf_set_cmap_wmode()`."""
        return _mupdf.PdfCmap_pdf_set_cmap_wmode(self, wmode)

    def pdf_set_usecmap(self, usecmap):
        r"""Class-aware wrapper for `::pdf_set_usecmap()`."""
        return _mupdf.PdfCmap_pdf_set_usecmap(self, usecmap)

    def pdf_sort_cmap(self):
        r"""Class-aware wrapper for `::pdf_sort_cmap()`."""
        return _mupdf.PdfCmap_pdf_sort_cmap(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_cmap()`.

        |

        *Overload 2:*
        Constructor using `pdf_new_identity_cmap()`.

        |

        *Overload 3:*
        Copy constructor using `pdf_keep_cmap()`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_cmap`.
        """
        _mupdf.PdfCmap_swiginit(self, _mupdf.new_PdfCmap(*args))
    __swig_destroy__ = _mupdf.delete_PdfCmap

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfCmap_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfCmap___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfCmap_m_internal_get, _mupdf.PdfCmap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfCmap_s_num_instances_get, _mupdf.PdfCmap_s_num_instances_set)

# Register PdfCmap in _mupdf:
_mupdf.PdfCmap_swigregister(PdfCmap)
class PdfColorFilterOptions(object):
    r"""Wrapper class for struct `pdf_color_filter_options`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_color_filter_options`.
        """
        _mupdf.PdfColorFilterOptions_swiginit(self, _mupdf.new_PdfColorFilterOptions(*args))
    __swig_destroy__ = _mupdf.delete_PdfColorFilterOptions

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfColorFilterOptions_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfColorFilterOptions___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfColorFilterOptions_m_internal_get, _mupdf.PdfColorFilterOptions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfColorFilterOptions_s_num_instances_get, _mupdf.PdfColorFilterOptions_s_num_instances_set)

# Register PdfColorFilterOptions in _mupdf:
_mupdf.PdfColorFilterOptions_swigregister(PdfColorFilterOptions)
class PdfCrypt(object):
    r"""Wrapper class for struct `pdf_crypt`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_crypt_encrypt_metadata(self):
        r"""Class-aware wrapper for `::pdf_crypt_encrypt_metadata()`."""
        return _mupdf.PdfCrypt_pdf_crypt_encrypt_metadata(self)

    def pdf_crypt_key(self):
        r"""Class-aware wrapper for `::pdf_crypt_key()`."""
        return _mupdf.PdfCrypt_pdf_crypt_key(self)

    def pdf_crypt_length(self):
        r"""Class-aware wrapper for `::pdf_crypt_length()`."""
        return _mupdf.PdfCrypt_pdf_crypt_length(self)

    def pdf_crypt_method(self):
        r"""Class-aware wrapper for `::pdf_crypt_method()`."""
        return _mupdf.PdfCrypt_pdf_crypt_method(self)

    def pdf_crypt_obj(self, obj, num, gen):
        r"""Class-aware wrapper for `::pdf_crypt_obj()`."""
        return _mupdf.PdfCrypt_pdf_crypt_obj(self, obj, num, gen)

    def pdf_crypt_owner_encryption(self):
        r"""Class-aware wrapper for `::pdf_crypt_owner_encryption()`."""
        return _mupdf.PdfCrypt_pdf_crypt_owner_encryption(self)

    def pdf_crypt_owner_password(self):
        r"""Class-aware wrapper for `::pdf_crypt_owner_password()`."""
        return _mupdf.PdfCrypt_pdf_crypt_owner_password(self)

    def pdf_crypt_permissions(self):
        r"""Class-aware wrapper for `::pdf_crypt_permissions()`."""
        return _mupdf.PdfCrypt_pdf_crypt_permissions(self)

    def pdf_crypt_permissions_encryption(self):
        r"""Class-aware wrapper for `::pdf_crypt_permissions_encryption()`."""
        return _mupdf.PdfCrypt_pdf_crypt_permissions_encryption(self)

    def pdf_crypt_revision(self):
        r"""Class-aware wrapper for `::pdf_crypt_revision()`."""
        return _mupdf.PdfCrypt_pdf_crypt_revision(self)

    def pdf_crypt_stream_method(self):
        r"""Class-aware wrapper for `::pdf_crypt_stream_method()`."""
        return _mupdf.PdfCrypt_pdf_crypt_stream_method(self)

    def pdf_crypt_string_method(self):
        r"""Class-aware wrapper for `::pdf_crypt_string_method()`."""
        return _mupdf.PdfCrypt_pdf_crypt_string_method(self)

    def pdf_crypt_user_encryption(self):
        r"""Class-aware wrapper for `::pdf_crypt_user_encryption()`."""
        return _mupdf.PdfCrypt_pdf_crypt_user_encryption(self)

    def pdf_crypt_user_password(self):
        r"""Class-aware wrapper for `::pdf_crypt_user_password()`."""
        return _mupdf.PdfCrypt_pdf_crypt_user_password(self)

    def pdf_crypt_version(self):
        r"""Class-aware wrapper for `::pdf_crypt_version()`."""
        return _mupdf.PdfCrypt_pdf_crypt_version(self)

    def pdf_encrypt_data(self, num, gen, fmt_str_out, arg, s, n):
        r"""Class-aware wrapper for `::pdf_encrypt_data()`."""
        return _mupdf.PdfCrypt_pdf_encrypt_data(self, num, gen, fmt_str_out, arg, s, n)

    def pdf_encrypted_len(self, num, gen, len):
        r"""Class-aware wrapper for `::pdf_encrypted_len()`."""
        return _mupdf.PdfCrypt_pdf_encrypted_len(self, num, gen, len)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_crypt()`.

        |

        *Overload 2:*
        Constructor using `pdf_new_encrypt()`.

        |

        *Overload 3:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_crypt`.
        """
        _mupdf.PdfCrypt_swiginit(self, _mupdf.new_PdfCrypt(*args))
    __swig_destroy__ = _mupdf.delete_PdfCrypt

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfCrypt_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfCrypt___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfCrypt_m_internal_get, _mupdf.PdfCrypt_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfCrypt_s_num_instances_get, _mupdf.PdfCrypt_s_num_instances_set)

# Register PdfCrypt in _mupdf:
_mupdf.PdfCrypt_swigregister(PdfCrypt)
class PdfCsi(object):
    r"""Wrapper class for struct `pdf_csi`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_csi`.
        """
        _mupdf.PdfCsi_swiginit(self, _mupdf.new_PdfCsi(*args))
    __swig_destroy__ = _mupdf.delete_PdfCsi

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfCsi_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfCsi___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfCsi_m_internal_get, _mupdf.PdfCsi_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfCsi_s_num_instances_get, _mupdf.PdfCsi_s_num_instances_set)

# Register PdfCsi in _mupdf:
_mupdf.PdfCsi_swigregister(PdfCsi)
class PdfCycleList(object):
    r"""Wrapper class for struct `pdf_cycle_list`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_cycle(self, prev, obj):
        r"""Class-aware wrapper for `::pdf_cycle()`."""
        return _mupdf.PdfCycleList_pdf_cycle(self, prev, obj)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_cycle_list`.
        """
        _mupdf.PdfCycleList_swiginit(self, _mupdf.new_PdfCycleList(*args))
    __swig_destroy__ = _mupdf.delete_PdfCycleList

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfCycleList_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfCycleList___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfCycleList_m_internal_get, _mupdf.PdfCycleList_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfCycleList_s_num_instances_get, _mupdf.PdfCycleList_s_num_instances_set)

# Register PdfCycleList in _mupdf:
_mupdf.PdfCycleList_swigregister(PdfCycleList)
class PdfDocEvent(object):
    r"""Wrapper class for struct `pdf_doc_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_access_exec_menu_item_event(self):
        r"""Class-aware wrapper for `::pdf_access_exec_menu_item_event()`."""
        return _mupdf.PdfDocEvent_pdf_access_exec_menu_item_event(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_doc_event`.
        """
        _mupdf.PdfDocEvent_swiginit(self, _mupdf.new_PdfDocEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfDocEvent

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfDocEvent_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfDocEvent___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfDocEvent_m_internal_get, _mupdf.PdfDocEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfDocEvent_s_num_instances_get, _mupdf.PdfDocEvent_s_num_instances_set)

# Register PdfDocEvent in _mupdf:
_mupdf.PdfDocEvent_swigregister(PdfDocEvent)
class PdfDocument(object):
    r"""Wrapper class for struct `pdf_document`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_abandon_operation(self):
        r"""Class-aware wrapper for `::pdf_abandon_operation()`."""
        return _mupdf.PdfDocument_pdf_abandon_operation(self)

    def pdf_add_cid_font(self, font):
        r"""Class-aware wrapper for `::pdf_add_cid_font()`."""
        return _mupdf.PdfDocument_pdf_add_cid_font(self, font)

    def pdf_add_cjk_font(self, font, script, wmode, serif):
        r"""Class-aware wrapper for `::pdf_add_cjk_font()`."""
        return _mupdf.PdfDocument_pdf_add_cjk_font(self, font, script, wmode, serif)

    def pdf_add_embedded_file(self, filename, mimetype, contents, created, modifed, add_checksum):
        r"""Class-aware wrapper for `::pdf_add_embedded_file()`."""
        return _mupdf.PdfDocument_pdf_add_embedded_file(self, filename, mimetype, contents, created, modifed, add_checksum)

    def pdf_add_image(self, image):
        r"""Class-aware wrapper for `::pdf_add_image()`."""
        return _mupdf.PdfDocument_pdf_add_image(self, image)

    def pdf_add_journal_fragment(self, parent, copy, copy_stream, newobj):
        r"""Class-aware wrapper for `::pdf_add_journal_fragment()`."""
        return _mupdf.PdfDocument_pdf_add_journal_fragment(self, parent, copy, copy_stream, newobj)

    def pdf_add_new_array(self, initial):
        r"""Class-aware wrapper for `::pdf_add_new_array()`."""
        return _mupdf.PdfDocument_pdf_add_new_array(self, initial)

    def pdf_add_new_dict(self, initial):
        r"""Class-aware wrapper for `::pdf_add_new_dict()`."""
        return _mupdf.PdfDocument_pdf_add_new_dict(self, initial)

    def pdf_add_object(self, obj):
        r"""Class-aware wrapper for `::pdf_add_object()`."""
        return _mupdf.PdfDocument_pdf_add_object(self, obj)

    def pdf_add_page(self, mediabox, rotate, resources, contents):
        r"""Class-aware wrapper for `::pdf_add_page()`."""
        return _mupdf.PdfDocument_pdf_add_page(self, mediabox, rotate, resources, contents)

    def pdf_add_simple_font(self, font, encoding):
        r"""Class-aware wrapper for `::pdf_add_simple_font()`."""
        return _mupdf.PdfDocument_pdf_add_simple_font(self, font, encoding)

    def pdf_add_stream(self, buf, obj, compressed):
        r"""Class-aware wrapper for `::pdf_add_stream()`."""
        return _mupdf.PdfDocument_pdf_add_stream(self, buf, obj, compressed)

    def pdf_add_substitute_font(self, font):
        r"""Class-aware wrapper for `::pdf_add_substitute_font()`."""
        return _mupdf.PdfDocument_pdf_add_substitute_font(self, font)

    def pdf_annot_field_event_keystroke(self, annot, evt):
        r"""Class-aware wrapper for `::pdf_annot_field_event_keystroke()`."""
        return _mupdf.PdfDocument_pdf_annot_field_event_keystroke(self, annot, evt)

    def pdf_authenticate_password(self, pw):
        r"""Class-aware wrapper for `::pdf_authenticate_password()`."""
        return _mupdf.PdfDocument_pdf_authenticate_password(self, pw)

    def pdf_bake_document(self, bake_annots, bake_widgets):
        r"""Class-aware wrapper for `::pdf_bake_document()`."""
        return _mupdf.PdfDocument_pdf_bake_document(self, bake_annots, bake_widgets)

    def pdf_begin_implicit_operation(self):
        r"""Class-aware wrapper for `::pdf_begin_implicit_operation()`."""
        return _mupdf.PdfDocument_pdf_begin_implicit_operation(self)

    def pdf_begin_operation(self, operation):
        r"""Class-aware wrapper for `::pdf_begin_operation()`."""
        return _mupdf.PdfDocument_pdf_begin_operation(self, operation)

    def pdf_calculate_form(self):
        r"""Class-aware wrapper for `::pdf_calculate_form()`."""
        return _mupdf.PdfDocument_pdf_calculate_form(self)

    def pdf_can_be_saved_incrementally(self):
        r"""Class-aware wrapper for `::pdf_can_be_saved_incrementally()`."""
        return _mupdf.PdfDocument_pdf_can_be_saved_incrementally(self)

    def pdf_can_redo(self):
        r"""Class-aware wrapper for `::pdf_can_redo()`."""
        return _mupdf.PdfDocument_pdf_can_redo(self)

    def pdf_can_undo(self):
        r"""Class-aware wrapper for `::pdf_can_undo()`."""
        return _mupdf.PdfDocument_pdf_can_undo(self)

    def pdf_clear_xref(self):
        r"""Class-aware wrapper for `::pdf_clear_xref()`."""
        return _mupdf.PdfDocument_pdf_clear_xref(self)

    def pdf_clear_xref_to_mark(self):
        r"""Class-aware wrapper for `::pdf_clear_xref_to_mark()`."""
        return _mupdf.PdfDocument_pdf_clear_xref_to_mark(self)

    def pdf_count_document_associated_files(self):
        r"""Class-aware wrapper for `::pdf_count_document_associated_files()`."""
        return _mupdf.PdfDocument_pdf_count_document_associated_files(self)

    def pdf_count_layer_config_ui(self):
        r"""Class-aware wrapper for `::pdf_count_layer_config_ui()`."""
        return _mupdf.PdfDocument_pdf_count_layer_config_ui(self)

    def pdf_count_layer_configs(self):
        r"""Class-aware wrapper for `::pdf_count_layer_configs()`."""
        return _mupdf.PdfDocument_pdf_count_layer_configs(self)

    def pdf_count_layers(self):
        r"""Class-aware wrapper for `::pdf_count_layers()`."""
        return _mupdf.PdfDocument_pdf_count_layers(self)

    def pdf_count_objects(self):
        r"""Class-aware wrapper for `::pdf_count_objects()`."""
        return _mupdf.PdfDocument_pdf_count_objects(self)

    def pdf_count_pages(self):
        r"""Class-aware wrapper for `::pdf_count_pages()`."""
        return _mupdf.PdfDocument_pdf_count_pages(self)

    def pdf_count_q_balance(self, res, stm, prepend, append):
        r"""
        Class-aware wrapper for `::pdf_count_q_balance()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_count_q_balance(::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
        """
        return _mupdf.PdfDocument_pdf_count_q_balance(self, res, stm, prepend, append)

    def pdf_count_signatures(self):
        r"""Class-aware wrapper for `::pdf_count_signatures()`."""
        return _mupdf.PdfDocument_pdf_count_signatures(self)

    def pdf_count_unsaved_versions(self):
        r"""Class-aware wrapper for `::pdf_count_unsaved_versions()`."""
        return _mupdf.PdfDocument_pdf_count_unsaved_versions(self)

    def pdf_count_versions(self):
        r"""Class-aware wrapper for `::pdf_count_versions()`."""
        return _mupdf.PdfDocument_pdf_count_versions(self)

    def pdf_create_field_name(self, prefix, buf, len):
        r"""Class-aware wrapper for `::pdf_create_field_name()`."""
        return _mupdf.PdfDocument_pdf_create_field_name(self, prefix, buf, len)

    def pdf_create_object(self):
        r"""Class-aware wrapper for `::pdf_create_object()`."""
        return _mupdf.PdfDocument_pdf_create_object(self)

    def pdf_debug_doc_changes(self):
        r"""Class-aware wrapper for `::pdf_debug_doc_changes()`."""
        return _mupdf.PdfDocument_pdf_debug_doc_changes(self)

    def pdf_delete_object(self, num):
        r"""Class-aware wrapper for `::pdf_delete_object()`."""
        return _mupdf.PdfDocument_pdf_delete_object(self, num)

    def pdf_delete_page(self, number):
        r"""Class-aware wrapper for `::pdf_delete_page()`."""
        return _mupdf.PdfDocument_pdf_delete_page(self, number)

    def pdf_delete_page_labels(self, index):
        r"""Class-aware wrapper for `::pdf_delete_page_labels()`."""
        return _mupdf.PdfDocument_pdf_delete_page_labels(self, index)

    def pdf_delete_page_range(self, start, end):
        r"""Class-aware wrapper for `::pdf_delete_page_range()`."""
        return _mupdf.PdfDocument_pdf_delete_page_range(self, start, end)

    def pdf_deselect_layer_config_ui(self, ui):
        r"""Class-aware wrapper for `::pdf_deselect_layer_config_ui()`."""
        return _mupdf.PdfDocument_pdf_deselect_layer_config_ui(self, ui)

    def pdf_deserialise_journal(self, stm):
        r"""Class-aware wrapper for `::pdf_deserialise_journal()`."""
        return _mupdf.PdfDocument_pdf_deserialise_journal(self, stm)

    def pdf_disable_js(self):
        r"""Class-aware wrapper for `::pdf_disable_js()`."""
        return _mupdf.PdfDocument_pdf_disable_js(self)

    def pdf_doc_was_linearized(self):
        r"""Class-aware wrapper for `::pdf_doc_was_linearized()`."""
        return _mupdf.PdfDocument_pdf_doc_was_linearized(self)

    def pdf_document_associated_file(self, idx):
        r"""Class-aware wrapper for `::pdf_document_associated_file()`."""
        return _mupdf.PdfDocument_pdf_document_associated_file(self, idx)

    def pdf_document_event_did_print(self):
        r"""Class-aware wrapper for `::pdf_document_event_did_print()`."""
        return _mupdf.PdfDocument_pdf_document_event_did_print(self)

    def pdf_document_event_did_save(self):
        r"""Class-aware wrapper for `::pdf_document_event_did_save()`."""
        return _mupdf.PdfDocument_pdf_document_event_did_save(self)

    def pdf_document_event_will_close(self):
        r"""Class-aware wrapper for `::pdf_document_event_will_close()`."""
        return _mupdf.PdfDocument_pdf_document_event_will_close(self)

    def pdf_document_event_will_print(self):
        r"""Class-aware wrapper for `::pdf_document_event_will_print()`."""
        return _mupdf.PdfDocument_pdf_document_event_will_print(self)

    def pdf_document_event_will_save(self):
        r"""Class-aware wrapper for `::pdf_document_event_will_save()`."""
        return _mupdf.PdfDocument_pdf_document_event_will_save(self)

    def pdf_document_output_intent(self):
        r"""Class-aware wrapper for `::pdf_document_output_intent()`."""
        return _mupdf.PdfDocument_pdf_document_output_intent(self)

    def pdf_document_permissions(self):
        r"""Class-aware wrapper for `::pdf_document_permissions()`."""
        return _mupdf.PdfDocument_pdf_document_permissions(self)

    def pdf_empty_store(self):
        r"""Class-aware wrapper for `::pdf_empty_store()`."""
        return _mupdf.PdfDocument_pdf_empty_store(self)

    def pdf_enable_journal(self):
        r"""Class-aware wrapper for `::pdf_enable_journal()`."""
        return _mupdf.PdfDocument_pdf_enable_journal(self)

    def pdf_enable_js(self):
        r"""Class-aware wrapper for `::pdf_enable_js()`."""
        return _mupdf.PdfDocument_pdf_enable_js(self)

    def pdf_enable_layer(self, layer, enabled):
        r"""Class-aware wrapper for `::pdf_enable_layer()`."""
        return _mupdf.PdfDocument_pdf_enable_layer(self, layer, enabled)

    def pdf_end_operation(self):
        r"""Class-aware wrapper for `::pdf_end_operation()`."""
        return _mupdf.PdfDocument_pdf_end_operation(self)

    def pdf_ensure_solid_xref(self, num):
        r"""Class-aware wrapper for `::pdf_ensure_solid_xref()`."""
        return _mupdf.PdfDocument_pdf_ensure_solid_xref(self, num)

    def pdf_event_issue_alert(self, evt):
        r"""Class-aware wrapper for `::pdf_event_issue_alert()`."""
        return _mupdf.PdfDocument_pdf_event_issue_alert(self, evt)

    def pdf_event_issue_exec_menu_item(self, item):
        r"""Class-aware wrapper for `::pdf_event_issue_exec_menu_item()`."""
        return _mupdf.PdfDocument_pdf_event_issue_exec_menu_item(self, item)

    def pdf_event_issue_launch_url(self, url, new_frame):
        r"""Class-aware wrapper for `::pdf_event_issue_launch_url()`."""
        return _mupdf.PdfDocument_pdf_event_issue_launch_url(self, url, new_frame)

    def pdf_event_issue_mail_doc(self, evt):
        r"""Class-aware wrapper for `::pdf_event_issue_mail_doc()`."""
        return _mupdf.PdfDocument_pdf_event_issue_mail_doc(self, evt)

    def pdf_event_issue_print(self):
        r"""Class-aware wrapper for `::pdf_event_issue_print()`."""
        return _mupdf.PdfDocument_pdf_event_issue_print(self)

    def pdf_field_event_calculate(self, field):
        r"""Class-aware wrapper for `::pdf_field_event_calculate()`."""
        return _mupdf.PdfDocument_pdf_field_event_calculate(self, field)

    def pdf_field_event_format(self, field):
        r"""Class-aware wrapper for `::pdf_field_event_format()`."""
        return _mupdf.PdfDocument_pdf_field_event_format(self, field)

    def pdf_field_event_keystroke(self, field, evt):
        r"""Class-aware wrapper for `::pdf_field_event_keystroke()`."""
        return _mupdf.PdfDocument_pdf_field_event_keystroke(self, field, evt)

    def pdf_field_event_validate(self, field, value, newvalue):
        r"""
        Class-aware wrapper for `::pdf_field_event_validate()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_field_event_validate(::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
        """
        return _mupdf.PdfDocument_pdf_field_event_validate(self, field, value, newvalue)

    def pdf_field_reset(self, field):
        r"""Class-aware wrapper for `::pdf_field_reset()`."""
        return _mupdf.PdfDocument_pdf_field_reset(self, field)

    def pdf_filter_annot_contents(self, annot, options):
        r"""Class-aware wrapper for `::pdf_filter_annot_contents()`."""
        return _mupdf.PdfDocument_pdf_filter_annot_contents(self, annot, options)

    def pdf_filter_page_contents(self, page, options):
        r"""Class-aware wrapper for `::pdf_filter_page_contents()`."""
        return _mupdf.PdfDocument_pdf_filter_page_contents(self, page, options)

    def pdf_find_font_resource(self, type, encoding, item, key):
        r"""Class-aware wrapper for `::pdf_find_font_resource()`."""
        return _mupdf.PdfDocument_pdf_find_font_resource(self, type, encoding, item, key)

    def pdf_find_version_for_obj(self, obj):
        r"""Class-aware wrapper for `::pdf_find_version_for_obj()`."""
        return _mupdf.PdfDocument_pdf_find_version_for_obj(self, obj)

    def pdf_forget_xref(self):
        r"""Class-aware wrapper for `::pdf_forget_xref()`."""
        return _mupdf.PdfDocument_pdf_forget_xref(self)

    def pdf_get_doc_event_callback_data(self):
        r"""Class-aware wrapper for `::pdf_get_doc_event_callback_data()`."""
        return _mupdf.PdfDocument_pdf_get_doc_event_callback_data(self)

    def pdf_graft_object(self, obj):
        r"""Class-aware wrapper for `::pdf_graft_object()`."""
        return _mupdf.PdfDocument_pdf_graft_object(self, obj)

    def pdf_graft_page(self, page_to, src, page_from):
        r"""Class-aware wrapper for `::pdf_graft_page()`."""
        return _mupdf.PdfDocument_pdf_graft_page(self, page_to, src, page_from)

    def pdf_has_permission(self, p):
        r"""Class-aware wrapper for `::pdf_has_permission()`."""
        return _mupdf.PdfDocument_pdf_has_permission(self, p)

    def pdf_has_unsaved_changes(self):
        r"""Class-aware wrapper for `::pdf_has_unsaved_changes()`."""
        return _mupdf.PdfDocument_pdf_has_unsaved_changes(self)

    def pdf_has_unsaved_sigs(self):
        r"""Class-aware wrapper for `::pdf_has_unsaved_sigs()`."""
        return _mupdf.PdfDocument_pdf_has_unsaved_sigs(self)

    def pdf_insert_font_resource(self, key, obj):
        r"""Class-aware wrapper for `::pdf_insert_font_resource()`."""
        return _mupdf.PdfDocument_pdf_insert_font_resource(self, key, obj)

    def pdf_insert_page(self, at, page):
        r"""Class-aware wrapper for `::pdf_insert_page()`."""
        return _mupdf.PdfDocument_pdf_insert_page(self, at, page)

    def pdf_invalidate_xfa(self):
        r"""Class-aware wrapper for `::pdf_invalidate_xfa()`."""
        return _mupdf.PdfDocument_pdf_invalidate_xfa(self)

    def pdf_is_local_object(self, obj):
        r"""Class-aware wrapper for `::pdf_is_local_object()`."""
        return _mupdf.PdfDocument_pdf_is_local_object(self, obj)

    def pdf_is_ocg_hidden(self, rdb, usage, ocg):
        r"""Class-aware wrapper for `::pdf_is_ocg_hidden()`."""
        return _mupdf.PdfDocument_pdf_is_ocg_hidden(self, rdb, usage, ocg)

    def pdf_js_set_console(self, console, user):
        r"""Class-aware wrapper for `::pdf_js_set_console()`."""
        return _mupdf.PdfDocument_pdf_js_set_console(self, console, user)

    def pdf_js_supported(self):
        r"""Class-aware wrapper for `::pdf_js_supported()`."""
        return _mupdf.PdfDocument_pdf_js_supported(self)

    def pdf_layer_config_info(self, config_num, info):
        r"""Class-aware wrapper for `::pdf_layer_config_info()`."""
        return _mupdf.PdfDocument_pdf_layer_config_info(self, config_num, info)

    def pdf_layer_config_ui_info(self, ui, info):
        r"""Class-aware wrapper for `::pdf_layer_config_ui_info()`."""
        return _mupdf.PdfDocument_pdf_layer_config_ui_info(self, ui, info)

    def pdf_layer_is_enabled(self, layer):
        r"""Class-aware wrapper for `::pdf_layer_is_enabled()`."""
        return _mupdf.PdfDocument_pdf_layer_is_enabled(self, layer)

    def pdf_layer_name(self, layer):
        r"""Class-aware wrapper for `::pdf_layer_name()`."""
        return _mupdf.PdfDocument_pdf_layer_name(self, layer)

    def pdf_load_compressed_inline_image(self, dict, length, cstm, indexed, image):
        r"""Class-aware wrapper for `::pdf_load_compressed_inline_image()`."""
        return _mupdf.PdfDocument_pdf_load_compressed_inline_image(self, dict, length, cstm, indexed, image)

    def pdf_load_compressed_stream(self, num, worst_case):
        r"""Class-aware wrapper for `::pdf_load_compressed_stream()`."""
        return _mupdf.PdfDocument_pdf_load_compressed_stream(self, num, worst_case)

    def pdf_load_default_colorspaces(self, page):
        r"""Class-aware wrapper for `::pdf_load_default_colorspaces()`."""
        return _mupdf.PdfDocument_pdf_load_default_colorspaces(self, page)

    def pdf_load_embedded_cmap(self, ref):
        r"""Class-aware wrapper for `::pdf_load_embedded_cmap()`."""
        return _mupdf.PdfDocument_pdf_load_embedded_cmap(self, ref)

    def pdf_load_image(self, obj):
        r"""Class-aware wrapper for `::pdf_load_image()`."""
        return _mupdf.PdfDocument_pdf_load_image(self, obj)

    def pdf_load_inline_image(self, rdb, dict, file):
        r"""Class-aware wrapper for `::pdf_load_inline_image()`."""
        return _mupdf.PdfDocument_pdf_load_inline_image(self, rdb, dict, file)

    def pdf_load_journal(self, filename):
        r"""Class-aware wrapper for `::pdf_load_journal()`."""
        return _mupdf.PdfDocument_pdf_load_journal(self, filename)

    def pdf_load_link_annots(self, arg_1, annots, pagenum, page_ctm):
        r"""Class-aware wrapper for `::pdf_load_link_annots()`."""
        return _mupdf.PdfDocument_pdf_load_link_annots(self, arg_1, annots, pagenum, page_ctm)

    def pdf_load_name_tree(self, which):
        r"""Class-aware wrapper for `::pdf_load_name_tree()`."""
        return _mupdf.PdfDocument_pdf_load_name_tree(self, which)

    def pdf_load_object(self, num):
        r"""
        Class-aware wrapper for `::pdf_load_object()`.
        	Load a given object.

        	This can cause xref reorganisations (solidifications etc) due to
        	repairs, so all held pdf_xref_entries should be considered
        	invalid after this call (other than the returned one).
        """
        return _mupdf.PdfDocument_pdf_load_object(self, num)

    def pdf_load_outline(self):
        r"""Class-aware wrapper for `::pdf_load_outline()`."""
        return _mupdf.PdfDocument_pdf_load_outline(self)

    def pdf_load_page(self, number):
        r"""Class-aware wrapper for `::pdf_load_page()`."""
        return _mupdf.PdfDocument_pdf_load_page(self, number)

    def pdf_load_page_tree(self):
        r"""Class-aware wrapper for `::pdf_load_page_tree()`."""
        return _mupdf.PdfDocument_pdf_load_page_tree(self)

    def pdf_load_pattern(self, obj):
        r"""Class-aware wrapper for `::pdf_load_pattern()`."""
        return _mupdf.PdfDocument_pdf_load_pattern(self, obj)

    def pdf_load_raw_stream_number(self, num):
        r"""Class-aware wrapper for `::pdf_load_raw_stream_number()`."""
        return _mupdf.PdfDocument_pdf_load_raw_stream_number(self, num)

    def pdf_load_shading(self, obj):
        r"""Class-aware wrapper for `::pdf_load_shading()`."""
        return _mupdf.PdfDocument_pdf_load_shading(self, obj)

    def pdf_load_stream_number(self, num):
        r"""Class-aware wrapper for `::pdf_load_stream_number()`."""
        return _mupdf.PdfDocument_pdf_load_stream_number(self, num)

    def pdf_load_to_unicode(self, font, strings, collection, cmapstm):
        r"""
        Class-aware wrapper for `::pdf_load_to_unicode()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_load_to_unicode(::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
        """
        return _mupdf.PdfDocument_pdf_load_to_unicode(self, font, strings, collection, cmapstm)

    def pdf_load_type3_glyphs(self, fontdesc):
        r"""Class-aware wrapper for `::pdf_load_type3_glyphs()`."""
        return _mupdf.PdfDocument_pdf_load_type3_glyphs(self, fontdesc)

    def pdf_load_unencrypted_object(self, num):
        r"""Class-aware wrapper for `::pdf_load_unencrypted_object()`."""
        return _mupdf.PdfDocument_pdf_load_unencrypted_object(self, num)

    def pdf_lookup_dest(self, needle):
        r"""Class-aware wrapper for `::pdf_lookup_dest()`."""
        return _mupdf.PdfDocument_pdf_lookup_dest(self, needle)

    def pdf_lookup_metadata(self, key, ptr, size):
        r"""Class-aware wrapper for `::pdf_lookup_metadata()`."""
        return _mupdf.PdfDocument_pdf_lookup_metadata(self, key, ptr, size)

    def pdf_lookup_metadata2(self, key):
        r"""
        Class-aware wrapper for `::pdf_lookup_metadata2()`.
        C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
        or calls `fz_throw()` if not found.
        """
        return _mupdf.PdfDocument_pdf_lookup_metadata2(self, key)

    def pdf_lookup_name(self, which, needle):
        r"""Class-aware wrapper for `::pdf_lookup_name()`."""
        return _mupdf.PdfDocument_pdf_lookup_name(self, which, needle)

    def pdf_lookup_page_loc(self, needle, parentp, indexp):
        r"""
        Class-aware wrapper for `::pdf_lookup_page_loc()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_lookup_page_loc(int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
        """
        return _mupdf.PdfDocument_pdf_lookup_page_loc(self, needle, parentp, indexp)

    def pdf_lookup_page_number(self, pageobj):
        r"""Class-aware wrapper for `::pdf_lookup_page_number()`."""
        return _mupdf.PdfDocument_pdf_lookup_page_number(self, pageobj)

    def pdf_lookup_page_obj(self, needle):
        r"""Class-aware wrapper for `::pdf_lookup_page_obj()`."""
        return _mupdf.PdfDocument_pdf_lookup_page_obj(self, needle)

    def pdf_mark_xref(self):
        r"""Class-aware wrapper for `::pdf_mark_xref()`."""
        return _mupdf.PdfDocument_pdf_mark_xref(self)

    def pdf_metadata(self):
        r"""Class-aware wrapper for `::pdf_metadata()`."""
        return _mupdf.PdfDocument_pdf_metadata(self)

    def pdf_minimize_document(self):
        r"""Class-aware wrapper for `::pdf_minimize_document()`."""
        return _mupdf.PdfDocument_pdf_minimize_document(self)

    def pdf_needs_password(self):
        r"""Class-aware wrapper for `::pdf_needs_password()`."""
        return _mupdf.PdfDocument_pdf_needs_password(self)

    def pdf_new_action_from_link(self, uri):
        r"""Class-aware wrapper for `::pdf_new_action_from_link()`."""
        return _mupdf.PdfDocument_pdf_new_action_from_link(self, uri)

    def pdf_new_array(self, initialcap):
        r"""Class-aware wrapper for `::pdf_new_array()`."""
        return _mupdf.PdfDocument_pdf_new_array(self, initialcap)

    def pdf_new_color_filter(self, chain, struct_parents, transform, options, copts):
        r"""Class-aware wrapper for `::pdf_new_color_filter()`."""
        return _mupdf.PdfDocument_pdf_new_color_filter(self, chain, struct_parents, transform, options, copts)

    def pdf_new_date(self, time):
        r"""Class-aware wrapper for `::pdf_new_date()`."""
        return _mupdf.PdfDocument_pdf_new_date(self, time)

    def pdf_new_dest_from_link(self, uri, is_remote):
        r"""Class-aware wrapper for `::pdf_new_dest_from_link()`."""
        return _mupdf.PdfDocument_pdf_new_dest_from_link(self, uri, is_remote)

    def pdf_new_dict(self, initialcap):
        r"""Class-aware wrapper for `::pdf_new_dict()`."""
        return _mupdf.PdfDocument_pdf_new_dict(self, initialcap)

    def pdf_new_graft_map(self):
        r"""Class-aware wrapper for `::pdf_new_graft_map()`."""
        return _mupdf.PdfDocument_pdf_new_graft_map(self)

    def pdf_new_indirect(self, num, gen):
        r"""Class-aware wrapper for `::pdf_new_indirect()`."""
        return _mupdf.PdfDocument_pdf_new_indirect(self, num, gen)

    def pdf_new_matrix(self, mtx):
        r"""Class-aware wrapper for `::pdf_new_matrix()`."""
        return _mupdf.PdfDocument_pdf_new_matrix(self, mtx)

    def pdf_new_pdf_device(self, topctm, resources, contents):
        r"""Class-aware wrapper for `::pdf_new_pdf_device()`."""
        return _mupdf.PdfDocument_pdf_new_pdf_device(self, topctm, resources, contents)

    def pdf_new_point(self, point):
        r"""Class-aware wrapper for `::pdf_new_point()`."""
        return _mupdf.PdfDocument_pdf_new_point(self, point)

    def pdf_new_rect(self, rect):
        r"""Class-aware wrapper for `::pdf_new_rect()`."""
        return _mupdf.PdfDocument_pdf_new_rect(self, rect)

    def pdf_new_run_processor(self, dev, ctm, struct_parent, usage, gstate, default_cs, cookie):
        r"""Class-aware wrapper for `::pdf_new_run_processor()`."""
        return _mupdf.PdfDocument_pdf_new_run_processor(self, dev, ctm, struct_parent, usage, gstate, default_cs, cookie)

    def pdf_new_sanitize_filter(self, chain, struct_parents, transform, options, sopts):
        r"""Class-aware wrapper for `::pdf_new_sanitize_filter()`."""
        return _mupdf.PdfDocument_pdf_new_sanitize_filter(self, chain, struct_parents, transform, options, sopts)

    def pdf_new_xobject(self, bbox, matrix, res, buffer):
        r"""Class-aware wrapper for `::pdf_new_xobject()`."""
        return _mupdf.PdfDocument_pdf_new_xobject(self, bbox, matrix, res, buffer)

    def pdf_obj_num_is_stream(self, num):
        r"""Class-aware wrapper for `::pdf_obj_num_is_stream()`."""
        return _mupdf.PdfDocument_pdf_obj_num_is_stream(self, num)

    def pdf_open_contents_stream(self, obj):
        r"""Class-aware wrapper for `::pdf_open_contents_stream()`."""
        return _mupdf.PdfDocument_pdf_open_contents_stream(self, obj)

    def pdf_open_inline_stream(self, stmobj, length, chain, params):
        r"""Class-aware wrapper for `::pdf_open_inline_stream()`."""
        return _mupdf.PdfDocument_pdf_open_inline_stream(self, stmobj, length, chain, params)

    def pdf_open_raw_stream_number(self, num):
        r"""Class-aware wrapper for `::pdf_open_raw_stream_number()`."""
        return _mupdf.PdfDocument_pdf_open_raw_stream_number(self, num)

    def pdf_open_stream_number(self, num):
        r"""Class-aware wrapper for `::pdf_open_stream_number()`."""
        return _mupdf.PdfDocument_pdf_open_stream_number(self, num)

    def pdf_open_stream_with_offset(self, num, dict, stm_ofs):
        r"""Class-aware wrapper for `::pdf_open_stream_with_offset()`."""
        return _mupdf.PdfDocument_pdf_open_stream_with_offset(self, num, dict, stm_ofs)

    def pdf_page_label(self, page, buf, size):
        r"""Class-aware wrapper for `::pdf_page_label()`."""
        return _mupdf.PdfDocument_pdf_page_label(self, page, buf, size)

    def pdf_page_write(self, mediabox, presources, pcontents):
        r"""
        Class-aware wrapper for `::pdf_page_write()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_page_write(::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
        """
        return _mupdf.PdfDocument_pdf_page_write(self, mediabox, presources, pcontents)

    def pdf_parse_array(self, f, buf):
        r"""Class-aware wrapper for `::pdf_parse_array()`."""
        return _mupdf.PdfDocument_pdf_parse_array(self, f, buf)

    def pdf_parse_dict(self, f, buf):
        r"""Class-aware wrapper for `::pdf_parse_dict()`."""
        return _mupdf.PdfDocument_pdf_parse_dict(self, f, buf)

    def pdf_parse_ind_obj(self, f, num, gen, stm_ofs, try_repair):
        r"""
        Class-aware wrapper for `::pdf_parse_ind_obj()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_parse_ind_obj(::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
        """
        return _mupdf.PdfDocument_pdf_parse_ind_obj(self, f, num, gen, stm_ofs, try_repair)

    def pdf_parse_journal_obj(self, stm, onum, ostm, newobj):
        r"""
        Class-aware wrapper for `::pdf_parse_journal_obj()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_parse_journal_obj(::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
        """
        return _mupdf.PdfDocument_pdf_parse_journal_obj(self, stm, onum, ostm, newobj)

    def pdf_parse_stm_obj(self, f, buf):
        r"""Class-aware wrapper for `::pdf_parse_stm_obj()`."""
        return _mupdf.PdfDocument_pdf_parse_stm_obj(self, f, buf)

    def pdf_progressive_advance(self, pagenum):
        r"""Class-aware wrapper for `::pdf_progressive_advance()`."""
        return _mupdf.PdfDocument_pdf_progressive_advance(self, pagenum)

    def pdf_purge_local_font_resources(self):
        r"""Class-aware wrapper for `::pdf_purge_local_font_resources()`."""
        return _mupdf.PdfDocument_pdf_purge_local_font_resources(self)

    def pdf_purge_locals_from_store(self):
        r"""Class-aware wrapper for `::pdf_purge_locals_from_store()`."""
        return _mupdf.PdfDocument_pdf_purge_locals_from_store(self)

    def pdf_purge_object_from_store(self, num):
        r"""Class-aware wrapper for `::pdf_purge_object_from_store()`."""
        return _mupdf.PdfDocument_pdf_purge_object_from_store(self, num)

    def pdf_read_journal(self, stm):
        r"""Class-aware wrapper for `::pdf_read_journal()`."""
        return _mupdf.PdfDocument_pdf_read_journal(self, stm)

    def pdf_rearrange_pages(self, count, pages, structure):
        r"""Class-aware wrapper for `::pdf_rearrange_pages()`."""
        return _mupdf.PdfDocument_pdf_rearrange_pages(self, count, pages, structure)

    def pdf_rearrange_pages2(self, pages, structure):
        r"""Class-aware wrapper for `::pdf_rearrange_pages2()`.   Swig-friendly wrapper for pdf_rearrange_pages()."""
        return _mupdf.PdfDocument_pdf_rearrange_pages2(self, pages, structure)

    def pdf_recolor_page(self, pagenum, opts):
        r"""Class-aware wrapper for `::pdf_recolor_page()`."""
        return _mupdf.PdfDocument_pdf_recolor_page(self, pagenum, opts)

    def pdf_redact_page(self, page, opts):
        r"""Class-aware wrapper for `::pdf_redact_page()`."""
        return _mupdf.PdfDocument_pdf_redact_page(self, page, opts)

    def pdf_redo(self):
        r"""Class-aware wrapper for `::pdf_redo()`."""
        return _mupdf.PdfDocument_pdf_redo(self)

    def pdf_remove_output_intents(self):
        r"""Class-aware wrapper for `::pdf_remove_output_intents()`."""
        return _mupdf.PdfDocument_pdf_remove_output_intents(self)

    def pdf_repair_obj(self, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root):
        r"""
        Class-aware wrapper for `::pdf_repair_obj()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_repair_obj(::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
        """
        return _mupdf.PdfDocument_pdf_repair_obj(self, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root)

    def pdf_repair_obj_stms(self):
        r"""Class-aware wrapper for `::pdf_repair_obj_stms()`."""
        return _mupdf.PdfDocument_pdf_repair_obj_stms(self)

    def pdf_repair_trailer(self):
        r"""Class-aware wrapper for `::pdf_repair_trailer()`."""
        return _mupdf.PdfDocument_pdf_repair_trailer(self)

    def pdf_repair_xref(self):
        r"""Class-aware wrapper for `::pdf_repair_xref()`."""
        return _mupdf.PdfDocument_pdf_repair_xref(self)

    def pdf_replace_xref(self, entries, n):
        r"""Class-aware wrapper for `::pdf_replace_xref()`."""
        return _mupdf.PdfDocument_pdf_replace_xref(self, entries, n)

    def pdf_reset_form(self, fields, exclude):
        r"""Class-aware wrapper for `::pdf_reset_form()`."""
        return _mupdf.PdfDocument_pdf_reset_form(self, fields, exclude)

    def pdf_resolve_link(self, uri, xp, yp):
        r"""
        Class-aware wrapper for `::pdf_resolve_link()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_resolve_link(const char *uri)` => `(int, float xp, float yp)`
        """
        return _mupdf.PdfDocument_pdf_resolve_link(self, uri, xp, yp)

    def pdf_rewrite_images(self, opts):
        r"""Class-aware wrapper for `::pdf_rewrite_images()`."""
        return _mupdf.PdfDocument_pdf_rewrite_images(self, opts)

    def pdf_run_document_structure(self, dev, cookie):
        r"""Class-aware wrapper for `::pdf_run_document_structure()`."""
        return _mupdf.PdfDocument_pdf_run_document_structure(self, dev, cookie)

    def pdf_run_glyph(self, resources, contents, dev, ctm, gstate, default_cs):
        r"""Class-aware wrapper for `::pdf_run_glyph()`."""
        return _mupdf.PdfDocument_pdf_run_glyph(self, resources, contents, dev, ctm, gstate, default_cs)

    def pdf_save_document(self, filename, opts):
        r"""Class-aware wrapper for `::pdf_save_document()`."""
        return _mupdf.PdfDocument_pdf_save_document(self, filename, opts)

    def pdf_save_journal(self, filename):
        r"""Class-aware wrapper for `::pdf_save_journal()`."""
        return _mupdf.PdfDocument_pdf_save_journal(self, filename)

    def pdf_save_snapshot(self, filename):
        r"""Class-aware wrapper for `::pdf_save_snapshot()`."""
        return _mupdf.PdfDocument_pdf_save_snapshot(self, filename)

    def pdf_select_layer_config(self, config_num):
        r"""Class-aware wrapper for `::pdf_select_layer_config()`."""
        return _mupdf.PdfDocument_pdf_select_layer_config(self, config_num)

    def pdf_select_layer_config_ui(self, ui):
        r"""Class-aware wrapper for `::pdf_select_layer_config_ui()`."""
        return _mupdf.PdfDocument_pdf_select_layer_config_ui(self, ui)

    def pdf_serialise_journal(self, out):
        r"""Class-aware wrapper for `::pdf_serialise_journal()`."""
        return _mupdf.PdfDocument_pdf_serialise_journal(self, out)

    def pdf_set_annot_field_value(self, widget, text, ignore_trigger_events):
        r"""Class-aware wrapper for `::pdf_set_annot_field_value()`."""
        return _mupdf.PdfDocument_pdf_set_annot_field_value(self, widget, text, ignore_trigger_events)

    def pdf_set_doc_event_callback(self, event_cb, free_event_data_cb, data):
        r"""Class-aware wrapper for `::pdf_set_doc_event_callback()`."""
        return _mupdf.PdfDocument_pdf_set_doc_event_callback(self, event_cb, free_event_data_cb, data)

    def pdf_set_document_language(self, lang):
        r"""Class-aware wrapper for `::pdf_set_document_language()`."""
        return _mupdf.PdfDocument_pdf_set_document_language(self, lang)

    def pdf_set_field_value(self, field, text, ignore_trigger_events):
        r"""Class-aware wrapper for `::pdf_set_field_value()`."""
        return _mupdf.PdfDocument_pdf_set_field_value(self, field, text, ignore_trigger_events)

    def pdf_set_layer_config_as_default(self):
        r"""Class-aware wrapper for `::pdf_set_layer_config_as_default()`."""
        return _mupdf.PdfDocument_pdf_set_layer_config_as_default(self)

    def pdf_set_page_labels(self, index, style, prefix, start):
        r"""Class-aware wrapper for `::pdf_set_page_labels()`."""
        return _mupdf.PdfDocument_pdf_set_page_labels(self, index, style, prefix, start)

    def pdf_set_populating_xref_trailer(self, trailer):
        r"""Class-aware wrapper for `::pdf_set_populating_xref_trailer()`."""
        return _mupdf.PdfDocument_pdf_set_populating_xref_trailer(self, trailer)

    def pdf_signature_byte_range(self, signature, byte_range):
        r"""Class-aware wrapper for `::pdf_signature_byte_range()`."""
        return _mupdf.PdfDocument_pdf_signature_byte_range(self, signature, byte_range)

    def pdf_signature_contents(self, signature, contents):
        r"""
        Class-aware wrapper for `::pdf_signature_contents()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_signature_contents(::pdf_obj *signature)` => `(size_t, char *contents)`
        """
        return _mupdf.PdfDocument_pdf_signature_contents(self, signature, contents)

    def pdf_signature_hash_bytes(self, signature):
        r"""Class-aware wrapper for `::pdf_signature_hash_bytes()`."""
        return _mupdf.PdfDocument_pdf_signature_hash_bytes(self, signature)

    def pdf_signature_incremental_change_since_signing(self, signature):
        r"""Class-aware wrapper for `::pdf_signature_incremental_change_since_signing()`."""
        return _mupdf.PdfDocument_pdf_signature_incremental_change_since_signing(self, signature)

    def pdf_signature_is_signed(self, field):
        r"""Class-aware wrapper for `::pdf_signature_is_signed()`."""
        return _mupdf.PdfDocument_pdf_signature_is_signed(self, field)

    def pdf_signature_set_value(self, field, signer, stime):
        r"""Class-aware wrapper for `::pdf_signature_set_value()`."""
        return _mupdf.PdfDocument_pdf_signature_set_value(self, field, signer, stime)

    def pdf_subset_fonts(self, pages_len, pages):
        r"""Class-aware wrapper for `::pdf_subset_fonts()`."""
        return _mupdf.PdfDocument_pdf_subset_fonts(self, pages_len, pages)

    def pdf_subset_fonts2(self, pages):
        r"""Class-aware wrapper for `::pdf_subset_fonts2()`.   Swig-friendly wrapper for pdf_subset_fonts()."""
        return _mupdf.PdfDocument_pdf_subset_fonts2(self, pages)

    def pdf_sync_open_pages(self):
        r"""Class-aware wrapper for `::pdf_sync_open_pages()`."""
        return _mupdf.PdfDocument_pdf_sync_open_pages(self)

    def pdf_toggle_layer_config_ui(self, ui):
        r"""Class-aware wrapper for `::pdf_toggle_layer_config_ui()`."""
        return _mupdf.PdfDocument_pdf_toggle_layer_config_ui(self, ui)

    def pdf_trailer(self):
        r"""Class-aware wrapper for `::pdf_trailer()`."""
        return _mupdf.PdfDocument_pdf_trailer(self)

    def pdf_undo(self):
        r"""Class-aware wrapper for `::pdf_undo()`."""
        return _mupdf.PdfDocument_pdf_undo(self)

    def pdf_undoredo_state(self, steps):
        r"""
        Class-aware wrapper for `::pdf_undoredo_state()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_undoredo_state()` => `(int, int steps)`
        """
        return _mupdf.PdfDocument_pdf_undoredo_state(self, steps)

    def pdf_undoredo_step(self, step):
        r"""Class-aware wrapper for `::pdf_undoredo_step()`."""
        return _mupdf.PdfDocument_pdf_undoredo_step(self, step)

    def pdf_update_object(self, num, obj):
        r"""Class-aware wrapper for `::pdf_update_object()`."""
        return _mupdf.PdfDocument_pdf_update_object(self, num, obj)

    def pdf_update_stream(self, ref, buf, compressed):
        r"""Class-aware wrapper for `::pdf_update_stream()`."""
        return _mupdf.PdfDocument_pdf_update_stream(self, ref, buf, compressed)

    def pdf_update_xobject(self, xobj, bbox, mat, res, buffer):
        r"""Class-aware wrapper for `::pdf_update_xobject()`."""
        return _mupdf.PdfDocument_pdf_update_xobject(self, xobj, bbox, mat, res, buffer)

    def pdf_validate_change_history(self):
        r"""Class-aware wrapper for `::pdf_validate_change_history()`."""
        return _mupdf.PdfDocument_pdf_validate_change_history(self)

    def pdf_validate_changes(self, version):
        r"""Class-aware wrapper for `::pdf_validate_changes()`."""
        return _mupdf.PdfDocument_pdf_validate_changes(self, version)

    def pdf_version(self):
        r"""Class-aware wrapper for `::pdf_version()`."""
        return _mupdf.PdfDocument_pdf_version(self)

    def pdf_was_pure_xfa(self):
        r"""Class-aware wrapper for `::pdf_was_pure_xfa()`."""
        return _mupdf.PdfDocument_pdf_was_pure_xfa(self)

    def pdf_was_repaired(self):
        r"""Class-aware wrapper for `::pdf_was_repaired()`."""
        return _mupdf.PdfDocument_pdf_was_repaired(self)

    def pdf_write_document(self, out, opts):
        r"""Class-aware wrapper for `::pdf_write_document()`."""
        return _mupdf.PdfDocument_pdf_write_document(self, out, opts)

    def pdf_write_journal(self, out):
        r"""Class-aware wrapper for `::pdf_write_journal()`."""
        return _mupdf.PdfDocument_pdf_write_journal(self, out)

    def pdf_write_snapshot(self, out):
        r"""Class-aware wrapper for `::pdf_write_snapshot()`."""
        return _mupdf.PdfDocument_pdf_write_snapshot(self, out)

    def pdf_xref_ensure_incremental_object(self, num):
        r"""Class-aware wrapper for `::pdf_xref_ensure_incremental_object()`."""
        return _mupdf.PdfDocument_pdf_xref_ensure_incremental_object(self, num)

    def pdf_xref_ensure_local_object(self, num):
        r"""Class-aware wrapper for `::pdf_xref_ensure_local_object()`."""
        return _mupdf.PdfDocument_pdf_xref_ensure_local_object(self, num)

    def pdf_xref_entry_map(self, fn, arg):
        r"""Class-aware wrapper for `::pdf_xref_entry_map()`."""
        return _mupdf.PdfDocument_pdf_xref_entry_map(self, fn, arg)

    def pdf_xref_is_incremental(self, num):
        r"""Class-aware wrapper for `::pdf_xref_is_incremental()`."""
        return _mupdf.PdfDocument_pdf_xref_is_incremental(self, num)

    def pdf_xref_len(self):
        r"""Class-aware wrapper for `::pdf_xref_len()`."""
        return _mupdf.PdfDocument_pdf_xref_len(self)

    def pdf_xref_obj_is_unsaved_signature(self, obj):
        r"""Class-aware wrapper for `::pdf_xref_obj_is_unsaved_signature()`."""
        return _mupdf.PdfDocument_pdf_xref_obj_is_unsaved_signature(self, obj)

    def pdf_xref_remove_unsaved_signature(self, field):
        r"""Class-aware wrapper for `::pdf_xref_remove_unsaved_signature()`."""
        return _mupdf.PdfDocument_pdf_xref_remove_unsaved_signature(self, field)

    def pdf_xref_store_unsaved_signature(self, field, signer):
        r"""Class-aware wrapper for `::pdf_xref_store_unsaved_signature()`."""
        return _mupdf.PdfDocument_pdf_xref_store_unsaved_signature(self, field, signer)

    def pdf_zugferd_profile(self, version):
        r"""
        Class-aware wrapper for `::pdf_zugferd_profile()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_zugferd_profile()` => `(enum pdf_zugferd_profile, float version)`
        """
        return _mupdf.PdfDocument_pdf_zugferd_profile(self, version)

    def pdf_zugferd_xml(self):
        r"""Class-aware wrapper for `::pdf_zugferd_xml()`."""
        return _mupdf.PdfDocument_pdf_zugferd_xml(self)

    def super(self):
        r"""Returns wrapper for .super member."""
        return _mupdf.PdfDocument_super(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_create_document()`.

        |

        *Overload 2:*
        Constructor using `pdf_document_from_fz_document()`.

        |

        *Overload 3:*
        Constructor using `pdf_open_document()`.

        |

        *Overload 4:*
        Constructor using `pdf_open_document_with_stream()`.

        |

        *Overload 5:*
        Copy constructor using `pdf_keep_document()`.

        |

        *Overload 6:*
        Constructor using raw copy of pre-existing `::pdf_document`.
        """
        _mupdf.PdfDocument_swiginit(self, _mupdf.new_PdfDocument(*args))
    __swig_destroy__ = _mupdf.delete_PdfDocument

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfDocument_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfDocument___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfDocument_m_internal_get, _mupdf.PdfDocument_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfDocument_s_num_instances_get, _mupdf.PdfDocument_s_num_instances_set)

# Register PdfDocument in _mupdf:
_mupdf.PdfDocument_swigregister(PdfDocument)
class PdfEmbeddedFileParams(object):
    r"""Wrapper class for struct `pdf_embedded_file_params`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_embedded_file_params`.
        """
        _mupdf.PdfEmbeddedFileParams_swiginit(self, _mupdf.new_PdfEmbeddedFileParams(*args))
    __swig_destroy__ = _mupdf.delete_PdfEmbeddedFileParams

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfEmbeddedFileParams_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfEmbeddedFileParams___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfEmbeddedFileParams_m_internal_get, _mupdf.PdfEmbeddedFileParams_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfEmbeddedFileParams_s_num_instances_get, _mupdf.PdfEmbeddedFileParams_s_num_instances_set)

# Register PdfEmbeddedFileParams in _mupdf:
_mupdf.PdfEmbeddedFileParams_swigregister(PdfEmbeddedFileParams)
class PdfFilespecParams(object):
    r"""Wrapper class for struct `pdf_filespec_params`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_filespec_params`.
        """
        _mupdf.PdfFilespecParams_swiginit(self, _mupdf.new_PdfFilespecParams(*args))
    __swig_destroy__ = _mupdf.delete_PdfFilespecParams

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfFilespecParams_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfFilespecParams___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfFilespecParams_m_internal_get, _mupdf.PdfFilespecParams_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfFilespecParams_s_num_instances_get, _mupdf.PdfFilespecParams_s_num_instances_set)

# Register PdfFilespecParams in _mupdf:
_mupdf.PdfFilespecParams_swigregister(PdfFilespecParams)
class PdfFilterFactory(object):
    r"""Wrapper class for struct `pdf_filter_factory`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_filter_factory`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_filter_factory`.
        """
        _mupdf.PdfFilterFactory_swiginit(self, _mupdf.new_PdfFilterFactory(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfFilterFactory_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfFilterFactory
    filter = property(_mupdf.PdfFilterFactory_filter_get, _mupdf.PdfFilterFactory_filter_set)
    options = property(_mupdf.PdfFilterFactory_options_get, _mupdf.PdfFilterFactory_options_set)
    s_num_instances = property(_mupdf.PdfFilterFactory_s_num_instances_get, _mupdf.PdfFilterFactory_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfFilterFactory_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfFilterFactory___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfFilterFactory___ne__(self, rhs)

# Register PdfFilterFactory in _mupdf:
_mupdf.PdfFilterFactory_swigregister(PdfFilterFactory)
class PdfFilterFactory2(PdfFilterFactory):
    r"""Wrapper class for struct pdf_filter_factory with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""== Constructor."""
        if self.__class__ == PdfFilterFactory2:
            _self = None
        else:
            _self = self
        _mupdf.PdfFilterFactory2_swiginit(self, _mupdf.new_PdfFilterFactory2(_self, ))
    __swig_destroy__ = _mupdf.delete_PdfFilterFactory2

    def use_virtual_filter(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.PdfFilterFactory2_use_virtual_filter(self, use)

    def filter(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5):
        r"""Default virtual method implementations; these all throw an exception."""
        return _mupdf.PdfFilterFactory2_filter(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_PdfFilterFactory2(self)
        return weakref.proxy(self)

# Register PdfFilterFactory2 in _mupdf:
_mupdf.PdfFilterFactory2_swigregister(PdfFilterFactory2)
class PdfFilterOptions(object):
    r"""Wrapper class for struct `pdf_filter_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def add_factory(self, factory):
        r"""We use default copy constructor and operator=.  Appends `factory` to internal vector and updates this->filters."""
        return _mupdf.PdfFilterOptions_add_factory(self, factory)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor initialises all fields to null/zero.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_filter_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_filter_options`.
        """
        _mupdf.PdfFilterOptions_swiginit(self, _mupdf.new_PdfFilterOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfFilterOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfFilterOptions
    recurse = property(_mupdf.PdfFilterOptions_recurse_get, _mupdf.PdfFilterOptions_recurse_set)
    instance_forms = property(_mupdf.PdfFilterOptions_instance_forms_get, _mupdf.PdfFilterOptions_instance_forms_set)
    ascii = property(_mupdf.PdfFilterOptions_ascii_get, _mupdf.PdfFilterOptions_ascii_set)
    no_update = property(_mupdf.PdfFilterOptions_no_update_get, _mupdf.PdfFilterOptions_no_update_set)
    opaque = property(_mupdf.PdfFilterOptions_opaque_get, _mupdf.PdfFilterOptions_opaque_set)
    complete = property(_mupdf.PdfFilterOptions_complete_get, _mupdf.PdfFilterOptions_complete_set)
    filters = property(_mupdf.PdfFilterOptions_filters_get, _mupdf.PdfFilterOptions_filters_set)
    newlines = property(_mupdf.PdfFilterOptions_newlines_get, _mupdf.PdfFilterOptions_newlines_set)
    s_num_instances = property(_mupdf.PdfFilterOptions_s_num_instances_get, _mupdf.PdfFilterOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfFilterOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfFilterOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfFilterOptions___ne__(self, rhs)
    m_filters = property(_mupdf.PdfFilterOptions_m_filters_get, _mupdf.PdfFilterOptions_m_filters_set)

# Register PdfFilterOptions in _mupdf:
_mupdf.PdfFilterOptions_swigregister(PdfFilterOptions)
class PdfFilterOptions2(PdfFilterOptions):
    r"""Wrapper class for struct pdf_filter_options with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""== Constructor."""
        if self.__class__ == PdfFilterOptions2:
            _self = None
        else:
            _self = self
        _mupdf.PdfFilterOptions2_swiginit(self, _mupdf.new_PdfFilterOptions2(_self, ))
    __swig_destroy__ = _mupdf.delete_PdfFilterOptions2

    def use_virtual_complete(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.PdfFilterOptions2_use_virtual_complete(self, use)

    def complete(self, arg_0, arg_1):
        r"""Default virtual method implementations; these all throw an exception."""
        return _mupdf.PdfFilterOptions2_complete(self, arg_0, arg_1)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_PdfFilterOptions2(self)
        return weakref.proxy(self)

# Register PdfFilterOptions2 in _mupdf:
_mupdf.PdfFilterOptions2_swigregister(PdfFilterOptions2)
class PdfFontDesc(object):
    r"""Wrapper class for struct `pdf_font_desc`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_add_hmtx(self, lo, hi, w):
        r"""Class-aware wrapper for `::pdf_add_hmtx()`."""
        return _mupdf.PdfFontDesc_pdf_add_hmtx(self, lo, hi, w)

    def pdf_add_vmtx(self, lo, hi, x, y, w):
        r"""Class-aware wrapper for `::pdf_add_vmtx()`."""
        return _mupdf.PdfFontDesc_pdf_add_vmtx(self, lo, hi, x, y, w)

    def pdf_end_hmtx(self):
        r"""Class-aware wrapper for `::pdf_end_hmtx()`."""
        return _mupdf.PdfFontDesc_pdf_end_hmtx(self)

    def pdf_end_vmtx(self):
        r"""Class-aware wrapper for `::pdf_end_vmtx()`."""
        return _mupdf.PdfFontDesc_pdf_end_vmtx(self)

    def pdf_font_cid_to_gid(self, cid):
        r"""Class-aware wrapper for `::pdf_font_cid_to_gid()`."""
        return _mupdf.PdfFontDesc_pdf_font_cid_to_gid(self, cid)

    def pdf_set_default_hmtx(self, w):
        r"""Class-aware wrapper for `::pdf_set_default_hmtx()`."""
        return _mupdf.PdfFontDesc_pdf_set_default_hmtx(self, w)

    def pdf_set_default_vmtx(self, y, w):
        r"""Class-aware wrapper for `::pdf_set_default_vmtx()`."""
        return _mupdf.PdfFontDesc_pdf_set_default_vmtx(self, y, w)

    def pdf_set_font_wmode(self, wmode):
        r"""Class-aware wrapper for `::pdf_set_font_wmode()`."""
        return _mupdf.PdfFontDesc_pdf_set_font_wmode(self, wmode)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_font_desc()`.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_font_desc`.
        """
        _mupdf.PdfFontDesc_swiginit(self, _mupdf.new_PdfFontDesc(*args))
    __swig_destroy__ = _mupdf.delete_PdfFontDesc

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfFontDesc_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfFontDesc___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfFontDesc_m_internal_get, _mupdf.PdfFontDesc_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfFontDesc_s_num_instances_get, _mupdf.PdfFontDesc_s_num_instances_set)

# Register PdfFontDesc in _mupdf:
_mupdf.PdfFontDesc_swigregister(PdfFontDesc)
class PdfFontResourceKey(object):
    r"""Wrapper class for struct `pdf_font_resource_key`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_font_resource_key`.
        """
        _mupdf.PdfFontResourceKey_swiginit(self, _mupdf.new_PdfFontResourceKey(*args))
    __swig_destroy__ = _mupdf.delete_PdfFontResourceKey

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfFontResourceKey_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfFontResourceKey___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfFontResourceKey_m_internal_get, _mupdf.PdfFontResourceKey_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfFontResourceKey_s_num_instances_get, _mupdf.PdfFontResourceKey_s_num_instances_set)

# Register PdfFontResourceKey in _mupdf:
_mupdf.PdfFontResourceKey_swigregister(PdfFontResourceKey)
class PdfFunction(object):
    r"""Wrapper class for struct `pdf_function`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_eval_function(self, _in, inlen, out, outlen):
        r"""
        Class-aware wrapper for `::pdf_eval_function()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_eval_function(const float *in, int inlen, int outlen)` => float out
        """
        return _mupdf.PdfFunction_pdf_eval_function(self, _in, inlen, out, outlen)

    def pdf_function_size(self):
        r"""Class-aware wrapper for `::pdf_function_size()`."""
        return _mupdf.PdfFunction_pdf_function_size(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `pdf_keep_function()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_function`.
        """
        _mupdf.PdfFunction_swiginit(self, _mupdf.new_PdfFunction(*args))
    __swig_destroy__ = _mupdf.delete_PdfFunction

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfFunction_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfFunction___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfFunction_m_internal_get, _mupdf.PdfFunction_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfFunction_s_num_instances_get, _mupdf.PdfFunction_s_num_instances_set)

# Register PdfFunction in _mupdf:
_mupdf.PdfFunction_swigregister(PdfFunction)
class PdfGraftMap(object):
    r"""Wrapper class for struct `pdf_graft_map`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_graft_mapped_object(self, obj):
        r"""Class-aware wrapper for `::pdf_graft_mapped_object()`."""
        return _mupdf.PdfGraftMap_pdf_graft_mapped_object(self, obj)

    def pdf_graft_mapped_page(self, page_to, src, page_from):
        r"""Class-aware wrapper for `::pdf_graft_mapped_page()`."""
        return _mupdf.PdfGraftMap_pdf_graft_mapped_page(self, page_to, src, page_from)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_graft_map()`.

        |

        *Overload 2:*
        Copy constructor using `pdf_keep_graft_map()`.

        |

        *Overload 3:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_graft_map`.
        """
        _mupdf.PdfGraftMap_swiginit(self, _mupdf.new_PdfGraftMap(*args))
    __swig_destroy__ = _mupdf.delete_PdfGraftMap

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfGraftMap_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfGraftMap___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfGraftMap_m_internal_get, _mupdf.PdfGraftMap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfGraftMap_s_num_instances_get, _mupdf.PdfGraftMap_s_num_instances_set)

# Register PdfGraftMap in _mupdf:
_mupdf.PdfGraftMap_swigregister(PdfGraftMap)
class PdfGstate(object):
    r"""Wrapper class for struct `pdf_gstate`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_gstate`.
        """
        _mupdf.PdfGstate_swiginit(self, _mupdf.new_PdfGstate(*args))
    __swig_destroy__ = _mupdf.delete_PdfGstate

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfGstate_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfGstate___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfGstate_m_internal_get, _mupdf.PdfGstate_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfGstate_s_num_instances_get, _mupdf.PdfGstate_s_num_instances_set)

# Register PdfGstate in _mupdf:
_mupdf.PdfGstate_swigregister(PdfGstate)
class PdfHintPage(object):
    r"""Wrapper class for struct `pdf_hint_page`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_hint_page`.
        """
        _mupdf.PdfHintPage_swiginit(self, _mupdf.new_PdfHintPage(*args))
    __swig_destroy__ = _mupdf.delete_PdfHintPage

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfHintPage_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfHintPage___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfHintPage_m_internal_get, _mupdf.PdfHintPage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfHintPage_s_num_instances_get, _mupdf.PdfHintPage_s_num_instances_set)

# Register PdfHintPage in _mupdf:
_mupdf.PdfHintPage_swigregister(PdfHintPage)
class PdfHintShared(object):
    r"""Wrapper class for struct `pdf_hint_shared`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_hint_shared`.
        """
        _mupdf.PdfHintShared_swiginit(self, _mupdf.new_PdfHintShared(*args))
    __swig_destroy__ = _mupdf.delete_PdfHintShared

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfHintShared_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfHintShared___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfHintShared_m_internal_get, _mupdf.PdfHintShared_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfHintShared_s_num_instances_get, _mupdf.PdfHintShared_s_num_instances_set)

# Register PdfHintShared in _mupdf:
_mupdf.PdfHintShared_swigregister(PdfHintShared)
class PdfHmtx(object):
    r"""Wrapper class for struct `pdf_hmtx`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_hmtx`.
        """
        _mupdf.PdfHmtx_swiginit(self, _mupdf.new_PdfHmtx(*args))
    __swig_destroy__ = _mupdf.delete_PdfHmtx

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfHmtx_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfHmtx___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfHmtx_m_internal_get, _mupdf.PdfHmtx_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfHmtx_s_num_instances_get, _mupdf.PdfHmtx_s_num_instances_set)

# Register PdfHmtx in _mupdf:
_mupdf.PdfHmtx_swigregister(PdfHmtx)
class PdfImageRewriterOptions(object):
    r"""Wrapper class for struct `pdf_image_rewriter_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_image_rewriter_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_image_rewriter_options`.
        """
        _mupdf.PdfImageRewriterOptions_swiginit(self, _mupdf.new_PdfImageRewriterOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfImageRewriterOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfImageRewriterOptions
    color_lossless_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_method_set)
    color_lossy_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_method_set)
    color_lossless_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_threshold_set)
    color_lossless_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_to_set)
    color_lossy_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_threshold_set)
    color_lossy_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_to_set)
    color_lossless_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_method_set)
    color_lossy_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_method_set)
    color_lossy_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_quality_set)
    color_lossless_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_quality_set)
    gray_lossless_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_method_set)
    gray_lossy_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_method_set)
    gray_lossless_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_threshold_set)
    gray_lossless_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_to_set)
    gray_lossy_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_threshold_set)
    gray_lossy_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_to_set)
    gray_lossless_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_method_set)
    gray_lossy_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_method_set)
    gray_lossy_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_quality_set)
    gray_lossless_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_quality_set)
    bitonal_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_bitonal_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_bitonal_image_subsample_method_set)
    bitonal_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_bitonal_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_bitonal_image_subsample_threshold_set)
    bitonal_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_bitonal_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_bitonal_image_subsample_to_set)
    bitonal_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_bitonal_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_bitonal_image_recompress_method_set)
    bitonal_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_bitonal_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_bitonal_image_recompress_quality_set)
    s_num_instances = property(_mupdf.PdfImageRewriterOptions_s_num_instances_get, _mupdf.PdfImageRewriterOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfImageRewriterOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfImageRewriterOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfImageRewriterOptions___ne__(self, rhs)

# Register PdfImageRewriterOptions in _mupdf:
_mupdf.PdfImageRewriterOptions_swigregister(PdfImageRewriterOptions)
class PdfJournal(object):
    r"""Wrapper class for struct `pdf_journal`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_discard_journal(self):
        r"""Class-aware wrapper for `::pdf_discard_journal()`."""
        return _mupdf.PdfJournal_pdf_discard_journal(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_journal`.
        """
        _mupdf.PdfJournal_swiginit(self, _mupdf.new_PdfJournal(*args))
    __swig_destroy__ = _mupdf.delete_PdfJournal

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfJournal_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfJournal___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfJournal_m_internal_get, _mupdf.PdfJournal_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfJournal_s_num_instances_get, _mupdf.PdfJournal_s_num_instances_set)

# Register PdfJournal in _mupdf:
_mupdf.PdfJournal_swigregister(PdfJournal)
class PdfJs(object):
    r"""Wrapper class for struct `pdf_js`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_js_event_init(self, target, value, willCommit):
        r"""Class-aware wrapper for `::pdf_js_event_init()`."""
        return _mupdf.PdfJs_pdf_js_event_init(self, target, value, willCommit)

    def pdf_js_event_init_keystroke(self, target, evt):
        r"""Class-aware wrapper for `::pdf_js_event_init_keystroke()`."""
        return _mupdf.PdfJs_pdf_js_event_init_keystroke(self, target, evt)

    def pdf_js_event_result(self):
        r"""Class-aware wrapper for `::pdf_js_event_result()`."""
        return _mupdf.PdfJs_pdf_js_event_result(self)

    def pdf_js_event_result_keystroke(self, evt):
        r"""Class-aware wrapper for `::pdf_js_event_result_keystroke()`."""
        return _mupdf.PdfJs_pdf_js_event_result_keystroke(self, evt)

    def pdf_js_event_result_validate(self, newvalue):
        r"""
        Class-aware wrapper for `::pdf_js_event_result_validate()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_js_event_result_validate()` => `(int, char *newvalue)`
        """
        return _mupdf.PdfJs_pdf_js_event_result_validate(self, newvalue)

    def pdf_js_event_value(self):
        r"""Class-aware wrapper for `::pdf_js_event_value()`."""
        return _mupdf.PdfJs_pdf_js_event_value(self)

    def pdf_js_execute(self, name, code, result):
        r"""
        Class-aware wrapper for `::pdf_js_execute()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_js_execute(const char *name, const char *code)` => char *result
        """
        return _mupdf.PdfJs_pdf_js_execute(self, name, code, result)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_js`.
        """
        _mupdf.PdfJs_swiginit(self, _mupdf.new_PdfJs(*args))
    __swig_destroy__ = _mupdf.delete_PdfJs

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfJs_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfJs___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfJs_m_internal_get, _mupdf.PdfJs_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfJs_s_num_instances_get, _mupdf.PdfJs_s_num_instances_set)

# Register PdfJs in _mupdf:
_mupdf.PdfJs_swigregister(PdfJs)
class PdfJsConsole(object):
    r"""Wrapper class for struct `pdf_js_console`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_js_console`.
        """
        _mupdf.PdfJsConsole_swiginit(self, _mupdf.new_PdfJsConsole(*args))
    __swig_destroy__ = _mupdf.delete_PdfJsConsole

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfJsConsole_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfJsConsole___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfJsConsole_m_internal_get, _mupdf.PdfJsConsole_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfJsConsole_s_num_instances_get, _mupdf.PdfJsConsole_s_num_instances_set)

# Register PdfJsConsole in _mupdf:
_mupdf.PdfJsConsole_swigregister(PdfJsConsole)
class PdfKeystrokeEvent(object):
    r"""Wrapper class for struct `pdf_keystroke_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_keystroke_event`.
        """
        _mupdf.PdfKeystrokeEvent_swiginit(self, _mupdf.new_PdfKeystrokeEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfKeystrokeEvent

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfKeystrokeEvent_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfKeystrokeEvent___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfKeystrokeEvent_m_internal_get, _mupdf.PdfKeystrokeEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfKeystrokeEvent_s_num_instances_get, _mupdf.PdfKeystrokeEvent_s_num_instances_set)

# Register PdfKeystrokeEvent in _mupdf:
_mupdf.PdfKeystrokeEvent_swigregister(PdfKeystrokeEvent)
class PdfLaunchUrlEvent(object):
    r"""Wrapper class for struct `pdf_launch_url_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_launch_url_event`.
        """
        _mupdf.PdfLaunchUrlEvent_swiginit(self, _mupdf.new_PdfLaunchUrlEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfLaunchUrlEvent

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfLaunchUrlEvent_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfLaunchUrlEvent___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfLaunchUrlEvent_m_internal_get, _mupdf.PdfLaunchUrlEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfLaunchUrlEvent_s_num_instances_get, _mupdf.PdfLaunchUrlEvent_s_num_instances_set)

# Register PdfLaunchUrlEvent in _mupdf:
_mupdf.PdfLaunchUrlEvent_swigregister(PdfLaunchUrlEvent)
class PdfLayerConfig(object):
    r"""Wrapper class for struct `pdf_layer_config`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_layer_config`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_layer_config`.
        """
        _mupdf.PdfLayerConfig_swiginit(self, _mupdf.new_PdfLayerConfig(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfLayerConfig_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfLayerConfig
    name = property(_mupdf.PdfLayerConfig_name_get, _mupdf.PdfLayerConfig_name_set)
    creator = property(_mupdf.PdfLayerConfig_creator_get, _mupdf.PdfLayerConfig_creator_set)
    s_num_instances = property(_mupdf.PdfLayerConfig_s_num_instances_get, _mupdf.PdfLayerConfig_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfLayerConfig_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfLayerConfig___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfLayerConfig___ne__(self, rhs)

# Register PdfLayerConfig in _mupdf:
_mupdf.PdfLayerConfig_swigregister(PdfLayerConfig)
class PdfLayerConfigUi(object):
    r"""Wrapper class for struct `pdf_layer_config_ui`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor sets .text to null, .type to PDF_LAYER_UI_LABEL, and other fields to zero.

        |

        *Overload 2:*
        We use default copy constructor and operator=.  Constructor using raw copy of pre-existing `::pdf_layer_config_ui`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_layer_config_ui`.
        """
        _mupdf.PdfLayerConfigUi_swiginit(self, _mupdf.new_PdfLayerConfigUi(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfLayerConfigUi_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfLayerConfigUi
    text = property(_mupdf.PdfLayerConfigUi_text_get, _mupdf.PdfLayerConfigUi_text_set)
    depth = property(_mupdf.PdfLayerConfigUi_depth_get, _mupdf.PdfLayerConfigUi_depth_set)
    type = property(_mupdf.PdfLayerConfigUi_type_get, _mupdf.PdfLayerConfigUi_type_set)
    selected = property(_mupdf.PdfLayerConfigUi_selected_get, _mupdf.PdfLayerConfigUi_selected_set)
    locked = property(_mupdf.PdfLayerConfigUi_locked_get, _mupdf.PdfLayerConfigUi_locked_set)
    s_num_instances = property(_mupdf.PdfLayerConfigUi_s_num_instances_get, _mupdf.PdfLayerConfigUi_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfLayerConfigUi_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfLayerConfigUi___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfLayerConfigUi___ne__(self, rhs)

# Register PdfLayerConfigUi in _mupdf:
_mupdf.PdfLayerConfigUi_swigregister(PdfLayerConfigUi)
class PdfLexbuf(object):
    r"""Wrapper class for struct `pdf_lexbuf`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_lexbuf_fin(self):
        r"""Class-aware wrapper for `::pdf_lexbuf_fin()`."""
        return _mupdf.PdfLexbuf_pdf_lexbuf_fin(self)

    def pdf_lexbuf_grow(self):
        r"""Class-aware wrapper for `::pdf_lexbuf_grow()`."""
        return _mupdf.PdfLexbuf_pdf_lexbuf_grow(self)

    def pdf_lexbuf_init(self, size):
        r"""Class-aware wrapper for `::pdf_lexbuf_init()`."""
        return _mupdf.PdfLexbuf_pdf_lexbuf_init(self, size)
    __swig_destroy__ = _mupdf.delete_PdfLexbuf

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that calls pdf_lexbuf_init(size).

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_lexbuf`.
        """
        _mupdf.PdfLexbuf_swiginit(self, _mupdf.new_PdfLexbuf(*args))

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfLexbuf_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfLexbuf___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfLexbuf_m_internal_get, _mupdf.PdfLexbuf_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfLexbuf_s_num_instances_get, _mupdf.PdfLexbuf_s_num_instances_set)

# Register PdfLexbuf in _mupdf:
_mupdf.PdfLexbuf_swigregister(PdfLexbuf)
class PdfLexbufLarge(object):
    r"""Wrapper class for struct `pdf_lexbuf_large`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_lexbuf_large`.
        """
        _mupdf.PdfLexbufLarge_swiginit(self, _mupdf.new_PdfLexbufLarge(*args))
    __swig_destroy__ = _mupdf.delete_PdfLexbufLarge

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfLexbufLarge_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfLexbufLarge___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfLexbufLarge_m_internal_get, _mupdf.PdfLexbufLarge_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfLexbufLarge_s_num_instances_get, _mupdf.PdfLexbufLarge_s_num_instances_set)

# Register PdfLexbufLarge in _mupdf:
_mupdf.PdfLexbufLarge_swigregister(PdfLexbufLarge)
class PdfLockedFields(object):
    r"""Wrapper class for struct `pdf_locked_fields`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_is_field_locked(self, name):
        r"""Class-aware wrapper for `::pdf_is_field_locked()`."""
        return _mupdf.PdfLockedFields_pdf_is_field_locked(self, name)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_locked_fields`.
        """
        _mupdf.PdfLockedFields_swiginit(self, _mupdf.new_PdfLockedFields(*args))
    __swig_destroy__ = _mupdf.delete_PdfLockedFields

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfLockedFields_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfLockedFields___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfLockedFields_m_internal_get, _mupdf.PdfLockedFields_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfLockedFields_s_num_instances_get, _mupdf.PdfLockedFields_s_num_instances_set)

# Register PdfLockedFields in _mupdf:
_mupdf.PdfLockedFields_swigregister(PdfLockedFields)
class PdfMailDocEvent(object):
    r"""Wrapper class for struct `pdf_mail_doc_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_mail_doc_event`.
        """
        _mupdf.PdfMailDocEvent_swiginit(self, _mupdf.new_PdfMailDocEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfMailDocEvent

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfMailDocEvent_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfMailDocEvent___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfMailDocEvent_m_internal_get, _mupdf.PdfMailDocEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfMailDocEvent_s_num_instances_get, _mupdf.PdfMailDocEvent_s_num_instances_set)

# Register PdfMailDocEvent in _mupdf:
_mupdf.PdfMailDocEvent_swigregister(PdfMailDocEvent)
class PdfMarkBits(object):
    r"""Wrapper class for struct `pdf_mark_bits`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_mark_bits_reset(self):
        r"""Class-aware wrapper for `::pdf_mark_bits_reset()`."""
        return _mupdf.PdfMarkBits_pdf_mark_bits_reset(self)

    def pdf_mark_bits_set(self, obj):
        r"""Class-aware wrapper for `::pdf_mark_bits_set()`."""
        return _mupdf.PdfMarkBits_pdf_mark_bits_set(self, obj)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_mark_bits()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_mark_bits`.
        """
        _mupdf.PdfMarkBits_swiginit(self, _mupdf.new_PdfMarkBits(*args))
    __swig_destroy__ = _mupdf.delete_PdfMarkBits

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfMarkBits_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfMarkBits___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfMarkBits_m_internal_get, _mupdf.PdfMarkBits_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfMarkBits_s_num_instances_get, _mupdf.PdfMarkBits_s_num_instances_set)

# Register PdfMarkBits in _mupdf:
_mupdf.PdfMarkBits_swigregister(PdfMarkBits)
class PdfMarkList(object):
    r"""Wrapper class for struct `pdf_mark_list`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_mark_list_check(self, obj):
        r"""Class-aware wrapper for `::pdf_mark_list_check()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_check(self, obj)

    def pdf_mark_list_free(self):
        r"""Class-aware wrapper for `::pdf_mark_list_free()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_free(self)

    def pdf_mark_list_init(self):
        r"""Class-aware wrapper for `::pdf_mark_list_init()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_init(self)

    def pdf_mark_list_pop(self):
        r"""Class-aware wrapper for `::pdf_mark_list_pop()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_pop(self)

    def pdf_mark_list_push(self, obj):
        r"""Class-aware wrapper for `::pdf_mark_list_push()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_push(self, obj)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_mark_list`.
        """
        _mupdf.PdfMarkList_swiginit(self, _mupdf.new_PdfMarkList(*args))
    __swig_destroy__ = _mupdf.delete_PdfMarkList

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfMarkList_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfMarkList___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfMarkList_m_internal_get, _mupdf.PdfMarkList_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfMarkList_s_num_instances_get, _mupdf.PdfMarkList_s_num_instances_set)

# Register PdfMarkList in _mupdf:
_mupdf.PdfMarkList_swigregister(PdfMarkList)
class PdfMrange(object):
    r"""Wrapper class for struct `pdf_mrange`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_mrange`.
        """
        _mupdf.PdfMrange_swiginit(self, _mupdf.new_PdfMrange(*args))
    __swig_destroy__ = _mupdf.delete_PdfMrange

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfMrange_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfMrange___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfMrange_m_internal_get, _mupdf.PdfMrange_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfMrange_s_num_instances_get, _mupdf.PdfMrange_s_num_instances_set)

# Register PdfMrange in _mupdf:
_mupdf.PdfMrange_swigregister(PdfMrange)
class PdfObj(object):
    r"""Wrapper class for struct `pdf_obj`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def pdf_new_text_string(s):
        r"""Class-aware wrapper for `::pdf_new_text_string()`."""
        return _mupdf.PdfObj_pdf_new_text_string(s)

    @staticmethod
    def pdf_new_dict(doc, initialcap):
        r"""Class-aware wrapper for `::pdf_new_dict()`."""
        return _mupdf.PdfObj_pdf_new_dict(doc, initialcap)

    def pdf_array_contains(self, obj):
        r"""Class-aware wrapper for `::pdf_array_contains()`."""
        return _mupdf.PdfObj_pdf_array_contains(self, obj)

    def pdf_array_delete(self, index):
        r"""Class-aware wrapper for `::pdf_array_delete()`."""
        return _mupdf.PdfObj_pdf_array_delete(self, index)

    def pdf_array_find(self, obj):
        r"""Class-aware wrapper for `::pdf_array_find()`."""
        return _mupdf.PdfObj_pdf_array_find(self, obj)

    def pdf_array_get(self, i):
        r"""Class-aware wrapper for `::pdf_array_get()`."""
        return _mupdf.PdfObj_pdf_array_get(self, i)

    def pdf_array_get_bool(self, index):
        r"""Class-aware wrapper for `::pdf_array_get_bool()`."""
        return _mupdf.PdfObj_pdf_array_get_bool(self, index)

    def pdf_array_get_int(self, index):
        r"""Class-aware wrapper for `::pdf_array_get_int()`."""
        return _mupdf.PdfObj_pdf_array_get_int(self, index)

    def pdf_array_get_matrix(self, index):
        r"""Class-aware wrapper for `::pdf_array_get_matrix()`."""
        return _mupdf.PdfObj_pdf_array_get_matrix(self, index)

    def pdf_array_get_name(self, index):
        r"""Class-aware wrapper for `::pdf_array_get_name()`."""
        return _mupdf.PdfObj_pdf_array_get_name(self, index)

    def pdf_array_get_real(self, index):
        r"""Class-aware wrapper for `::pdf_array_get_real()`."""
        return _mupdf.PdfObj_pdf_array_get_real(self, index)

    def pdf_array_get_rect(self, index):
        r"""Class-aware wrapper for `::pdf_array_get_rect()`."""
        return _mupdf.PdfObj_pdf_array_get_rect(self, index)

    def pdf_array_get_string(self, index, sizep):
        r"""
        Class-aware wrapper for `::pdf_array_get_string()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_array_get_string(int index)` => `(const char *, size_t sizep)`
        """
        return _mupdf.PdfObj_pdf_array_get_string(self, index, sizep)

    def pdf_array_get_text_string(self, index):
        r"""Class-aware wrapper for `::pdf_array_get_text_string()`."""
        return _mupdf.PdfObj_pdf_array_get_text_string(self, index)

    def pdf_array_insert(self, obj, index):
        r"""Class-aware wrapper for `::pdf_array_insert()`."""
        return _mupdf.PdfObj_pdf_array_insert(self, obj, index)

    def pdf_array_len(self):
        r"""Class-aware wrapper for `::pdf_array_len()`."""
        return _mupdf.PdfObj_pdf_array_len(self)

    def pdf_array_push(self, obj):
        r"""Class-aware wrapper for `::pdf_array_push()`."""
        return _mupdf.PdfObj_pdf_array_push(self, obj)

    def pdf_array_push_array(self, initial):
        r"""Class-aware wrapper for `::pdf_array_push_array()`."""
        return _mupdf.PdfObj_pdf_array_push_array(self, initial)

    def pdf_array_push_bool(self, x):
        r"""Class-aware wrapper for `::pdf_array_push_bool()`."""
        return _mupdf.PdfObj_pdf_array_push_bool(self, x)

    def pdf_array_push_dict(self, initial):
        r"""Class-aware wrapper for `::pdf_array_push_dict()`."""
        return _mupdf.PdfObj_pdf_array_push_dict(self, initial)

    def pdf_array_push_int(self, x):
        r"""Class-aware wrapper for `::pdf_array_push_int()`."""
        return _mupdf.PdfObj_pdf_array_push_int(self, x)

    def pdf_array_push_name(self, x):
        r"""Class-aware wrapper for `::pdf_array_push_name()`."""
        return _mupdf.PdfObj_pdf_array_push_name(self, x)

    def pdf_array_push_real(self, x):
        r"""Class-aware wrapper for `::pdf_array_push_real()`."""
        return _mupdf.PdfObj_pdf_array_push_real(self, x)

    def pdf_array_push_string(self, x, n):
        r"""Class-aware wrapper for `::pdf_array_push_string()`."""
        return _mupdf.PdfObj_pdf_array_push_string(self, x, n)

    def pdf_array_push_text_string(self, x):
        r"""Class-aware wrapper for `::pdf_array_push_text_string()`."""
        return _mupdf.PdfObj_pdf_array_push_text_string(self, x)

    def pdf_array_put(self, i, obj):
        r"""Class-aware wrapper for `::pdf_array_put()`."""
        return _mupdf.PdfObj_pdf_array_put(self, i, obj)

    def pdf_array_put_array(self, i, initial):
        r"""Class-aware wrapper for `::pdf_array_put_array()`."""
        return _mupdf.PdfObj_pdf_array_put_array(self, i, initial)

    def pdf_array_put_bool(self, i, x):
        r"""Class-aware wrapper for `::pdf_array_put_bool()`."""
        return _mupdf.PdfObj_pdf_array_put_bool(self, i, x)

    def pdf_array_put_dict(self, i, initial):
        r"""Class-aware wrapper for `::pdf_array_put_dict()`."""
        return _mupdf.PdfObj_pdf_array_put_dict(self, i, initial)

    def pdf_array_put_int(self, i, x):
        r"""Class-aware wrapper for `::pdf_array_put_int()`."""
        return _mupdf.PdfObj_pdf_array_put_int(self, i, x)

    def pdf_array_put_name(self, i, x):
        r"""Class-aware wrapper for `::pdf_array_put_name()`."""
        return _mupdf.PdfObj_pdf_array_put_name(self, i, x)

    def pdf_array_put_real(self, i, x):
        r"""Class-aware wrapper for `::pdf_array_put_real()`."""
        return _mupdf.PdfObj_pdf_array_put_real(self, i, x)

    def pdf_array_put_string(self, i, x, n):
        r"""Class-aware wrapper for `::pdf_array_put_string()`."""
        return _mupdf.PdfObj_pdf_array_put_string(self, i, x, n)

    def pdf_array_put_text_string(self, i, x):
        r"""Class-aware wrapper for `::pdf_array_put_text_string()`."""
        return _mupdf.PdfObj_pdf_array_put_text_string(self, i, x)

    def pdf_button_field_on_state(self):
        r"""Class-aware wrapper for `::pdf_button_field_on_state()`."""
        return _mupdf.PdfObj_pdf_button_field_on_state(self)

    def pdf_choice_field_option(self, exportval, i):
        r"""Class-aware wrapper for `::pdf_choice_field_option()`."""
        return _mupdf.PdfObj_pdf_choice_field_option(self, exportval, i)

    def pdf_choice_field_option_count(self):
        r"""Class-aware wrapper for `::pdf_choice_field_option_count()`."""
        return _mupdf.PdfObj_pdf_choice_field_option_count(self)

    def pdf_clean_obj(self):
        r"""Class-aware wrapper for `::pdf_clean_obj()`."""
        return _mupdf.PdfObj_pdf_clean_obj(self)

    def pdf_copy_array(self):
        r"""Class-aware wrapper for `::pdf_copy_array()`."""
        return _mupdf.PdfObj_pdf_copy_array(self)

    def pdf_copy_dict(self):
        r"""Class-aware wrapper for `::pdf_copy_dict()`."""
        return _mupdf.PdfObj_pdf_copy_dict(self)

    def pdf_debug_obj(self):
        r"""Class-aware wrapper for `::pdf_debug_obj()`."""
        return _mupdf.PdfObj_pdf_debug_obj(self)

    def pdf_debug_ref(self):
        r"""Class-aware wrapper for `::pdf_debug_ref()`."""
        return _mupdf.PdfObj_pdf_debug_ref(self)

    def pdf_deep_copy_obj(self):
        r"""Class-aware wrapper for `::pdf_deep_copy_obj()`."""
        return _mupdf.PdfObj_pdf_deep_copy_obj(self)

    def pdf_dict_del(self, key):
        r"""Class-aware wrapper for `::pdf_dict_del()`."""
        return _mupdf.PdfObj_pdf_dict_del(self, key)

    def pdf_dict_dels(self, key):
        r"""Class-aware wrapper for `::pdf_dict_dels()`."""
        return _mupdf.PdfObj_pdf_dict_dels(self, key)

    def pdf_dict_get_bool(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_bool()`."""
        return _mupdf.PdfObj_pdf_dict_get_bool(self, key)

    def pdf_dict_get_bool_default(self, key, _def):
        r"""Class-aware wrapper for `::pdf_dict_get_bool_default()`."""
        return _mupdf.PdfObj_pdf_dict_get_bool_default(self, key, _def)

    def pdf_dict_get_date(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_date()`."""
        return _mupdf.PdfObj_pdf_dict_get_date(self, key)

    def pdf_dict_get_inheritable(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable(self, key)

    def pdf_dict_get_inheritable_bool(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable_bool()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_bool(self, key)

    def pdf_dict_get_inheritable_date(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable_date()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_date(self, key)

    def pdf_dict_get_inheritable_int(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable_int()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_int(self, key)

    def pdf_dict_get_inheritable_int64(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable_int64()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_int64(self, key)

    def pdf_dict_get_inheritable_matrix(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable_matrix()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_matrix(self, key)

    def pdf_dict_get_inheritable_name(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable_name()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_name(self, key)

    def pdf_dict_get_inheritable_real(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable_real()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_real(self, key)

    def pdf_dict_get_inheritable_rect(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable_rect()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_rect(self, key)

    def pdf_dict_get_inheritable_string(self, key, sizep):
        r"""
        Class-aware wrapper for `::pdf_dict_get_inheritable_string()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_dict_get_inheritable_string(::pdf_obj *key)` => `(const char *, size_t sizep)`
        """
        return _mupdf.PdfObj_pdf_dict_get_inheritable_string(self, key, sizep)

    def pdf_dict_get_inheritable_text_string(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_inheritable_text_string()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_text_string(self, key)

    def pdf_dict_get_int(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_int()`."""
        return _mupdf.PdfObj_pdf_dict_get_int(self, key)

    def pdf_dict_get_int64(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_int64()`."""
        return _mupdf.PdfObj_pdf_dict_get_int64(self, key)

    def pdf_dict_get_int_default(self, key, _def):
        r"""Class-aware wrapper for `::pdf_dict_get_int_default()`."""
        return _mupdf.PdfObj_pdf_dict_get_int_default(self, key, _def)

    def pdf_dict_get_key(self, idx):
        r"""Class-aware wrapper for `::pdf_dict_get_key()`."""
        return _mupdf.PdfObj_pdf_dict_get_key(self, idx)

    def pdf_dict_get_matrix(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_matrix()`."""
        return _mupdf.PdfObj_pdf_dict_get_matrix(self, key)

    def pdf_dict_get_name(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_name()`."""
        return _mupdf.PdfObj_pdf_dict_get_name(self, key)

    def pdf_dict_get_point(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_point()`."""
        return _mupdf.PdfObj_pdf_dict_get_point(self, key)

    def pdf_dict_get_real(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_real()`."""
        return _mupdf.PdfObj_pdf_dict_get_real(self, key)

    def pdf_dict_get_real_default(self, key, _def):
        r"""Class-aware wrapper for `::pdf_dict_get_real_default()`."""
        return _mupdf.PdfObj_pdf_dict_get_real_default(self, key, _def)

    def pdf_dict_get_rect(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_rect()`."""
        return _mupdf.PdfObj_pdf_dict_get_rect(self, key)

    def pdf_dict_get_string(self, key, sizep):
        r"""
        Class-aware wrapper for `::pdf_dict_get_string()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_dict_get_string(::pdf_obj *key)` => `(const char *, size_t sizep)`
        """
        return _mupdf.PdfObj_pdf_dict_get_string(self, key, sizep)

    def pdf_dict_get_text_string(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_text_string()`."""
        return _mupdf.PdfObj_pdf_dict_get_text_string(self, key)

    def pdf_dict_get_text_string_opt(self, key):
        r"""Class-aware wrapper for `::pdf_dict_get_text_string_opt()`."""
        return _mupdf.PdfObj_pdf_dict_get_text_string_opt(self, key)

    def pdf_dict_get_val(self, idx):
        r"""Class-aware wrapper for `::pdf_dict_get_val()`."""
        return _mupdf.PdfObj_pdf_dict_get_val(self, idx)

    def pdf_dict_geta(self, key, abbrev):
        r"""Class-aware wrapper for `::pdf_dict_geta()`."""
        return _mupdf.PdfObj_pdf_dict_geta(self, key, abbrev)

    def pdf_dict_getp(self, path):
        r"""Class-aware wrapper for `::pdf_dict_getp()`."""
        return _mupdf.PdfObj_pdf_dict_getp(self, path)

    def pdf_dict_getp_inheritable(self, path):
        r"""Class-aware wrapper for `::pdf_dict_getp_inheritable()`."""
        return _mupdf.PdfObj_pdf_dict_getp_inheritable(self, path)

    def pdf_dict_gets(self, key):
        r"""Class-aware wrapper for `::pdf_dict_gets()`."""
        return _mupdf.PdfObj_pdf_dict_gets(self, key)

    def pdf_dict_gets_inheritable(self, key):
        r"""Class-aware wrapper for `::pdf_dict_gets_inheritable()`."""
        return _mupdf.PdfObj_pdf_dict_gets_inheritable(self, key)

    def pdf_dict_getsa(self, key, abbrev):
        r"""Class-aware wrapper for `::pdf_dict_getsa()`."""
        return _mupdf.PdfObj_pdf_dict_getsa(self, key, abbrev)

    def pdf_dict_len(self):
        r"""Class-aware wrapper for `::pdf_dict_len()`."""
        return _mupdf.PdfObj_pdf_dict_len(self)

    def pdf_dict_put(self, key, val):
        r"""Class-aware wrapper for `::pdf_dict_put()`."""
        return _mupdf.PdfObj_pdf_dict_put(self, key, val)

    def pdf_dict_put_array(self, key, initial):
        r"""Class-aware wrapper for `::pdf_dict_put_array()`."""
        return _mupdf.PdfObj_pdf_dict_put_array(self, key, initial)

    def pdf_dict_put_bool(self, key, x):
        r"""Class-aware wrapper for `::pdf_dict_put_bool()`."""
        return _mupdf.PdfObj_pdf_dict_put_bool(self, key, x)

    def pdf_dict_put_date(self, key, time):
        r"""Class-aware wrapper for `::pdf_dict_put_date()`."""
        return _mupdf.PdfObj_pdf_dict_put_date(self, key, time)

    def pdf_dict_put_dict(self, key, initial):
        r"""Class-aware wrapper for `::pdf_dict_put_dict()`."""
        return _mupdf.PdfObj_pdf_dict_put_dict(self, key, initial)

    def pdf_dict_put_indirect(self, key, num):
        r"""Class-aware wrapper for `::pdf_dict_put_indirect()`."""
        return _mupdf.PdfObj_pdf_dict_put_indirect(self, key, num)

    def pdf_dict_put_int(self, key, x):
        r"""Class-aware wrapper for `::pdf_dict_put_int()`."""
        return _mupdf.PdfObj_pdf_dict_put_int(self, key, x)

    def pdf_dict_put_matrix(self, key, x):
        r"""Class-aware wrapper for `::pdf_dict_put_matrix()`."""
        return _mupdf.PdfObj_pdf_dict_put_matrix(self, key, x)

    def pdf_dict_put_name(self, key, x):
        r"""Class-aware wrapper for `::pdf_dict_put_name()`."""
        return _mupdf.PdfObj_pdf_dict_put_name(self, key, x)

    def pdf_dict_put_point(self, key, x):
        r"""Class-aware wrapper for `::pdf_dict_put_point()`."""
        return _mupdf.PdfObj_pdf_dict_put_point(self, key, x)

    def pdf_dict_put_real(self, key, x):
        r"""Class-aware wrapper for `::pdf_dict_put_real()`."""
        return _mupdf.PdfObj_pdf_dict_put_real(self, key, x)

    def pdf_dict_put_rect(self, key, x):
        r"""Class-aware wrapper for `::pdf_dict_put_rect()`."""
        return _mupdf.PdfObj_pdf_dict_put_rect(self, key, x)

    def pdf_dict_put_string(self, key, x, n):
        r"""Class-aware wrapper for `::pdf_dict_put_string()`."""
        return _mupdf.PdfObj_pdf_dict_put_string(self, key, x, n)

    def pdf_dict_put_text_string(self, key, x):
        r"""Class-aware wrapper for `::pdf_dict_put_text_string()`."""
        return _mupdf.PdfObj_pdf_dict_put_text_string(self, key, x)

    def pdf_dict_put_val_null(self, idx):
        r"""Class-aware wrapper for `::pdf_dict_put_val_null()`."""
        return _mupdf.PdfObj_pdf_dict_put_val_null(self, idx)

    def pdf_dict_putp(self, path, val):
        r"""Class-aware wrapper for `::pdf_dict_putp()`."""
        return _mupdf.PdfObj_pdf_dict_putp(self, path, val)

    def pdf_dict_puts(self, key, val):
        r"""Class-aware wrapper for `::pdf_dict_puts()`."""
        return _mupdf.PdfObj_pdf_dict_puts(self, key, val)

    def pdf_dict_puts_dict(self, key, initial):
        r"""Class-aware wrapper for `::pdf_dict_puts_dict()`."""
        return _mupdf.PdfObj_pdf_dict_puts_dict(self, key, initial)

    def pdf_dirty_obj(self):
        r"""Class-aware wrapper for `::pdf_dirty_obj()`."""
        return _mupdf.PdfObj_pdf_dirty_obj(self)

    def pdf_field_border_style(self):
        r"""Class-aware wrapper for `::pdf_field_border_style()`."""
        return _mupdf.PdfObj_pdf_field_border_style(self)

    def pdf_field_display(self):
        r"""Class-aware wrapper for `::pdf_field_display()`."""
        return _mupdf.PdfObj_pdf_field_display(self)

    def pdf_field_flags(self):
        r"""Class-aware wrapper for `::pdf_field_flags()`."""
        return _mupdf.PdfObj_pdf_field_flags(self)

    def pdf_field_label(self):
        r"""Class-aware wrapper for `::pdf_field_label()`."""
        return _mupdf.PdfObj_pdf_field_label(self)

    def pdf_field_set_border_style(self, text):
        r"""Class-aware wrapper for `::pdf_field_set_border_style()`."""
        return _mupdf.PdfObj_pdf_field_set_border_style(self, text)

    def pdf_field_set_button_caption(self, text):
        r"""Class-aware wrapper for `::pdf_field_set_button_caption()`."""
        return _mupdf.PdfObj_pdf_field_set_button_caption(self, text)

    def pdf_field_set_display(self, d):
        r"""Class-aware wrapper for `::pdf_field_set_display()`."""
        return _mupdf.PdfObj_pdf_field_set_display(self, d)

    def pdf_field_set_fill_color(self, col):
        r"""Class-aware wrapper for `::pdf_field_set_fill_color()`."""
        return _mupdf.PdfObj_pdf_field_set_fill_color(self, col)

    def pdf_field_set_text_color(self, col):
        r"""Class-aware wrapper for `::pdf_field_set_text_color()`."""
        return _mupdf.PdfObj_pdf_field_set_text_color(self, col)

    def pdf_field_type(self):
        r"""Class-aware wrapper for `::pdf_field_type()`."""
        return _mupdf.PdfObj_pdf_field_type(self)

    def pdf_field_type_string(self):
        r"""Class-aware wrapper for `::pdf_field_type_string()`."""
        return _mupdf.PdfObj_pdf_field_type_string(self)

    def pdf_field_value(self):
        r"""Class-aware wrapper for `::pdf_field_value()`."""
        return _mupdf.PdfObj_pdf_field_value(self)

    def pdf_filter_xobject_instance(self, page_res, ctm, options, cycle_up):
        r"""Class-aware wrapper for `::pdf_filter_xobject_instance()`."""
        return _mupdf.PdfObj_pdf_filter_xobject_instance(self, page_res, ctm, options, cycle_up)

    def pdf_flatten_inheritable_page_items(self):
        r"""Class-aware wrapper for `::pdf_flatten_inheritable_page_items()`."""
        return _mupdf.PdfObj_pdf_flatten_inheritable_page_items(self)

    def pdf_get_bound_document(self):
        r"""Class-aware wrapper for `::pdf_get_bound_document()`."""
        return _mupdf.PdfObj_pdf_get_bound_document(self)

    def pdf_get_embedded_file_params(self, out):
        r"""Class-aware wrapper for `::pdf_get_embedded_file_params()`."""
        return _mupdf.PdfObj_pdf_get_embedded_file_params(self, out)

    def pdf_get_filespec_params(self, out):
        r"""Class-aware wrapper for `::pdf_get_filespec_params()`."""
        return _mupdf.PdfObj_pdf_get_filespec_params(self, out)

    def pdf_get_indirect_document(self):
        r"""Class-aware wrapper for `::pdf_get_indirect_document()`."""
        return _mupdf.PdfObj_pdf_get_indirect_document(self)

    def pdf_intent_from_name(self):
        r"""Class-aware wrapper for `::pdf_intent_from_name()`."""
        return _mupdf.PdfObj_pdf_intent_from_name(self)

    def pdf_is_array(self):
        r"""Class-aware wrapper for `::pdf_is_array()`."""
        return _mupdf.PdfObj_pdf_is_array(self)

    def pdf_is_bool(self):
        r"""Class-aware wrapper for `::pdf_is_bool()`."""
        return _mupdf.PdfObj_pdf_is_bool(self)

    def pdf_is_dict(self):
        r"""Class-aware wrapper for `::pdf_is_dict()`."""
        return _mupdf.PdfObj_pdf_is_dict(self)

    def pdf_is_embedded_file(self):
        r"""Class-aware wrapper for `::pdf_is_embedded_file()`."""
        return _mupdf.PdfObj_pdf_is_embedded_file(self)

    def pdf_is_filespec(self):
        r"""Class-aware wrapper for `::pdf_is_filespec()`."""
        return _mupdf.PdfObj_pdf_is_filespec(self)

    def pdf_is_indirect(self):
        r"""Class-aware wrapper for `::pdf_is_indirect()`."""
        return _mupdf.PdfObj_pdf_is_indirect(self)

    def pdf_is_int(self):
        r"""Class-aware wrapper for `::pdf_is_int()`."""
        return _mupdf.PdfObj_pdf_is_int(self)

    def pdf_is_jpx_image(self):
        r"""Class-aware wrapper for `::pdf_is_jpx_image()`."""
        return _mupdf.PdfObj_pdf_is_jpx_image(self)

    def pdf_is_name(self):
        r"""Class-aware wrapper for `::pdf_is_name()`."""
        return _mupdf.PdfObj_pdf_is_name(self)

    def pdf_is_null(self):
        r"""Class-aware wrapper for `::pdf_is_null()`."""
        return _mupdf.PdfObj_pdf_is_null(self)

    def pdf_is_number(self):
        r"""Class-aware wrapper for `::pdf_is_number()`."""
        return _mupdf.PdfObj_pdf_is_number(self)

    def pdf_is_real(self):
        r"""Class-aware wrapper for `::pdf_is_real()`."""
        return _mupdf.PdfObj_pdf_is_real(self)

    def pdf_is_stream(self):
        r"""Class-aware wrapper for `::pdf_is_stream()`."""
        return _mupdf.PdfObj_pdf_is_stream(self)

    def pdf_is_string(self):
        r"""Class-aware wrapper for `::pdf_is_string()`."""
        return _mupdf.PdfObj_pdf_is_string(self)

    def pdf_line_ending_from_name(self):
        r"""Class-aware wrapper for `::pdf_line_ending_from_name()`."""
        return _mupdf.PdfObj_pdf_line_ending_from_name(self)

    def pdf_load_colorspace(self):
        r"""Class-aware wrapper for `::pdf_load_colorspace()`."""
        return _mupdf.PdfObj_pdf_load_colorspace(self)

    def pdf_load_embedded_file_contents(self):
        r"""Class-aware wrapper for `::pdf_load_embedded_file_contents()`."""
        return _mupdf.PdfObj_pdf_load_embedded_file_contents(self)

    def pdf_load_field_name(self):
        r"""Class-aware wrapper for `::pdf_load_field_name()`."""
        return _mupdf.PdfObj_pdf_load_field_name(self)

    def pdf_load_function(self, _in, out):
        r"""Class-aware wrapper for `::pdf_load_function()`."""
        return _mupdf.PdfObj_pdf_load_function(self, _in, out)

    def pdf_load_raw_stream(self):
        r"""Class-aware wrapper for `::pdf_load_raw_stream()`."""
        return _mupdf.PdfObj_pdf_load_raw_stream(self)

    def pdf_load_stream(self):
        r"""Class-aware wrapper for `::pdf_load_stream()`."""
        return _mupdf.PdfObj_pdf_load_stream(self)

    def pdf_load_stream_or_string_as_utf8(self):
        r"""Class-aware wrapper for `::pdf_load_stream_or_string_as_utf8()`."""
        return _mupdf.PdfObj_pdf_load_stream_or_string_as_utf8(self)

    def pdf_lookup_field(self, name):
        r"""Class-aware wrapper for `::pdf_lookup_field()`."""
        return _mupdf.PdfObj_pdf_lookup_field(self, name)

    def pdf_lookup_number(self, needle):
        r"""Class-aware wrapper for `::pdf_lookup_number()`."""
        return _mupdf.PdfObj_pdf_lookup_number(self, needle)

    def pdf_mark_obj(self):
        r"""Class-aware wrapper for `::pdf_mark_obj()`."""
        return _mupdf.PdfObj_pdf_mark_obj(self)

    def pdf_name_eq(self, b):
        r"""Class-aware wrapper for `::pdf_name_eq()`."""
        return _mupdf.PdfObj_pdf_name_eq(self, b)

    def pdf_new_utf8_from_pdf_stream_obj(self):
        r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`."""
        return _mupdf.PdfObj_pdf_new_utf8_from_pdf_stream_obj(self)

    def pdf_new_utf8_from_pdf_string_obj(self):
        r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_string_obj()`."""
        return _mupdf.PdfObj_pdf_new_utf8_from_pdf_string_obj(self)

    def pdf_obj_is_dirty(self):
        r"""Class-aware wrapper for `::pdf_obj_is_dirty()`."""
        return _mupdf.PdfObj_pdf_obj_is_dirty(self)

    def pdf_obj_is_incremental(self):
        r"""Class-aware wrapper for `::pdf_obj_is_incremental()`."""
        return _mupdf.PdfObj_pdf_obj_is_incremental(self)

    def pdf_obj_marked(self):
        r"""Class-aware wrapper for `::pdf_obj_marked()`."""
        return _mupdf.PdfObj_pdf_obj_marked(self)

    def pdf_obj_memo(self, bit, memo):
        r"""
        Class-aware wrapper for `::pdf_obj_memo()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_obj_memo(int bit)` => `(int, int memo)`
        """
        return _mupdf.PdfObj_pdf_obj_memo(self, bit, memo)

    def pdf_obj_parent_num(self):
        r"""Class-aware wrapper for `::pdf_obj_parent_num()`."""
        return _mupdf.PdfObj_pdf_obj_parent_num(self)

    def pdf_obj_refs(self):
        r"""Class-aware wrapper for `::pdf_obj_refs()`."""
        return _mupdf.PdfObj_pdf_obj_refs(self)

    def pdf_objcmp(self, b):
        r"""Class-aware wrapper for `::pdf_objcmp()`."""
        return _mupdf.PdfObj_pdf_objcmp(self, b)

    def pdf_objcmp_deep(self, b):
        r"""Class-aware wrapper for `::pdf_objcmp_deep()`."""
        return _mupdf.PdfObj_pdf_objcmp_deep(self, b)

    def pdf_objcmp_resolve(self, b):
        r"""Class-aware wrapper for `::pdf_objcmp_resolve()`."""
        return _mupdf.PdfObj_pdf_objcmp_resolve(self, b)

    def pdf_open_raw_stream(self):
        r"""Class-aware wrapper for `::pdf_open_raw_stream()`."""
        return _mupdf.PdfObj_pdf_open_raw_stream(self)

    def pdf_open_stream(self):
        r"""Class-aware wrapper for `::pdf_open_stream()`."""
        return _mupdf.PdfObj_pdf_open_stream(self)

    def pdf_page_obj_transform(self, outbox, outctm):
        r"""Class-aware wrapper for `::pdf_page_obj_transform()`."""
        return _mupdf.PdfObj_pdf_page_obj_transform(self, outbox, outctm)

    def pdf_page_obj_transform_box(self, outbox, out, box):
        r"""Class-aware wrapper for `::pdf_page_obj_transform_box()`."""
        return _mupdf.PdfObj_pdf_page_obj_transform_box(self, outbox, out, box)

    def pdf_pin_document(self):
        r"""Class-aware wrapper for `::pdf_pin_document()`."""
        return _mupdf.PdfObj_pdf_pin_document(self)

    def pdf_recolor_shade(self, reshade, opaque):
        r"""
        Class-aware wrapper for `::pdf_recolor_shade()`.
        	Recolor a shade.
        """
        return _mupdf.PdfObj_pdf_recolor_shade(self, reshade, opaque)

    def pdf_resolve_indirect(self):
        r"""
        Class-aware wrapper for `::pdf_resolve_indirect()`.
        	Resolve an indirect object (or chain of objects).

        	This can cause xref reorganisations (solidifications etc) due to
        	repairs, so all held pdf_xref_entries should be considered
        	invalid after this call (other than the returned one).
        """
        return _mupdf.PdfObj_pdf_resolve_indirect(self)

    def pdf_resolve_indirect_chain(self):
        r"""Class-aware wrapper for `::pdf_resolve_indirect_chain()`."""
        return _mupdf.PdfObj_pdf_resolve_indirect_chain(self)

    def pdf_set_int(self, i):
        r"""Class-aware wrapper for `::pdf_set_int()`."""
        return _mupdf.PdfObj_pdf_set_int(self, i)

    def pdf_set_obj_memo(self, bit, memo):
        r"""Class-aware wrapper for `::pdf_set_obj_memo()`."""
        return _mupdf.PdfObj_pdf_set_obj_memo(self, bit, memo)

    def pdf_set_obj_parent(self, num):
        r"""Class-aware wrapper for `::pdf_set_obj_parent()`."""
        return _mupdf.PdfObj_pdf_set_obj_parent(self, num)

    def pdf_set_str_len(self, newlen):
        r"""Class-aware wrapper for `::pdf_set_str_len()`."""
        return _mupdf.PdfObj_pdf_set_str_len(self, newlen)

    def pdf_sort_dict(self):
        r"""Class-aware wrapper for `::pdf_sort_dict()`."""
        return _mupdf.PdfObj_pdf_sort_dict(self)

    def pdf_store_item(self, val, itemsize):
        r"""Class-aware wrapper for `::pdf_store_item()`."""
        return _mupdf.PdfObj_pdf_store_item(self, val, itemsize)

    def pdf_to_bool(self):
        r"""Class-aware wrapper for `::pdf_to_bool()`."""
        return _mupdf.PdfObj_pdf_to_bool(self)

    def pdf_to_bool_default(self, _def):
        r"""Class-aware wrapper for `::pdf_to_bool_default()`."""
        return _mupdf.PdfObj_pdf_to_bool_default(self, _def)

    def pdf_to_date(self):
        r"""Class-aware wrapper for `::pdf_to_date()`."""
        return _mupdf.PdfObj_pdf_to_date(self)

    def pdf_to_gen(self):
        r"""Class-aware wrapper for `::pdf_to_gen()`."""
        return _mupdf.PdfObj_pdf_to_gen(self)

    def pdf_to_int(self):
        r"""Class-aware wrapper for `::pdf_to_int()`."""
        return _mupdf.PdfObj_pdf_to_int(self)

    def pdf_to_int64(self):
        r"""Class-aware wrapper for `::pdf_to_int64()`."""
        return _mupdf.PdfObj_pdf_to_int64(self)

    def pdf_to_int_default(self, _def):
        r"""Class-aware wrapper for `::pdf_to_int_default()`."""
        return _mupdf.PdfObj_pdf_to_int_default(self, _def)

    def pdf_to_matrix(self):
        r"""Class-aware wrapper for `::pdf_to_matrix()`."""
        return _mupdf.PdfObj_pdf_to_matrix(self)

    def pdf_to_name(self):
        r"""Class-aware wrapper for `::pdf_to_name()`."""
        return _mupdf.PdfObj_pdf_to_name(self)

    def pdf_to_num(self):
        r"""Class-aware wrapper for `::pdf_to_num()`."""
        return _mupdf.PdfObj_pdf_to_num(self)

    def pdf_to_point(self, offset):
        r"""Class-aware wrapper for `::pdf_to_point()`."""
        return _mupdf.PdfObj_pdf_to_point(self, offset)

    def pdf_to_quad(self, offset):
        r"""Class-aware wrapper for `::pdf_to_quad()`."""
        return _mupdf.PdfObj_pdf_to_quad(self, offset)

    def pdf_to_real(self):
        r"""Class-aware wrapper for `::pdf_to_real()`."""
        return _mupdf.PdfObj_pdf_to_real(self)

    def pdf_to_real_default(self, _def):
        r"""Class-aware wrapper for `::pdf_to_real_default()`."""
        return _mupdf.PdfObj_pdf_to_real_default(self, _def)

    def pdf_to_rect(self):
        r"""Class-aware wrapper for `::pdf_to_rect()`."""
        return _mupdf.PdfObj_pdf_to_rect(self)

    def pdf_to_str_buf(self):
        r"""Class-aware wrapper for `::pdf_to_str_buf()`."""
        return _mupdf.PdfObj_pdf_to_str_buf(self)

    def pdf_to_str_len(self):
        r"""Class-aware wrapper for `::pdf_to_str_len()`."""
        return _mupdf.PdfObj_pdf_to_str_len(self)

    def pdf_to_string(self, sizep):
        r"""
        Class-aware wrapper for `::pdf_to_string()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_to_string()` => `(const char *, size_t sizep)`
        """
        return _mupdf.PdfObj_pdf_to_string(self, sizep)

    def pdf_to_text_string(self):
        r"""Class-aware wrapper for `::pdf_to_text_string()`."""
        return _mupdf.PdfObj_pdf_to_text_string(self)

    def pdf_unmark_obj(self):
        r"""Class-aware wrapper for `::pdf_unmark_obj()`."""
        return _mupdf.PdfObj_pdf_unmark_obj(self)

    def pdf_verify_embedded_file_checksum(self):
        r"""Class-aware wrapper for `::pdf_verify_embedded_file_checksum()`."""
        return _mupdf.PdfObj_pdf_verify_embedded_file_checksum(self)

    def pdf_walk_tree(self, kid_name, arrive, leave, arg, names, values):
        r"""
        Class-aware wrapper for `::pdf_walk_tree()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_walk_tree(::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
        """
        return _mupdf.PdfObj_pdf_walk_tree(self, kid_name, arrive, leave, arg, names, values)

    def pdf_xobject_bbox(self):
        r"""Class-aware wrapper for `::pdf_xobject_bbox()`."""
        return _mupdf.PdfObj_pdf_xobject_bbox(self)

    def pdf_xobject_colorspace(self):
        r"""Class-aware wrapper for `::pdf_xobject_colorspace()`."""
        return _mupdf.PdfObj_pdf_xobject_colorspace(self)

    def pdf_xobject_isolated(self):
        r"""Class-aware wrapper for `::pdf_xobject_isolated()`."""
        return _mupdf.PdfObj_pdf_xobject_isolated(self)

    def pdf_xobject_knockout(self):
        r"""Class-aware wrapper for `::pdf_xobject_knockout()`."""
        return _mupdf.PdfObj_pdf_xobject_knockout(self)

    def pdf_xobject_matrix(self):
        r"""Class-aware wrapper for `::pdf_xobject_matrix()`."""
        return _mupdf.PdfObj_pdf_xobject_matrix(self)

    def pdf_xobject_resources(self):
        r"""Class-aware wrapper for `::pdf_xobject_resources()`."""
        return _mupdf.PdfObj_pdf_xobject_resources(self)

    def pdf_xobject_transparency(self):
        r"""Class-aware wrapper for `::pdf_xobject_transparency()`."""
        return _mupdf.PdfObj_pdf_xobject_transparency(self)

    def pdf_dict_get(self, *args):
        r"""
        *Overload 1:*
        Class-aware wrapper for `::pdf_dict_get()`.

        |

        *Overload 2:*
        Typesafe wrapper for looking up things such as PDF_ENUM_NAME_Annots.
        """
        return _mupdf.PdfObj_pdf_dict_get(self, *args)

    def pdf_load_field_name2(self):
        r"""Alternative to `pdf_load_field_name()` that returns a std::string."""
        return _mupdf.PdfObj_pdf_load_field_name2(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_action_from_link()`.

        |

        *Overload 2:*
        Constructor using `pdf_new_array()`.

        |

        *Overload 3:*
        Constructor using `pdf_new_date()`.

        |

        *Overload 4:*
        Constructor using `pdf_new_dest_from_link()`.

        |

        *Overload 5:*
        Constructor using `pdf_new_indirect()`.

        |

        *Overload 6:*
        Constructor using `pdf_new_int()`.

        |

        *Overload 7:*
        Constructor using `pdf_new_matrix()`.

        |

        *Overload 8:*
        Constructor using `pdf_new_name()`.

        |

        *Overload 9:*
        Constructor using `pdf_new_point()`.

        |

        *Overload 10:*
        Constructor using `pdf_new_real()`.

        |

        *Overload 11:*
        Constructor using `pdf_new_rect()`.

        |

        *Overload 12:*
        Constructor using `pdf_new_string()`.

        |

        *Overload 13:*
        Constructor using `pdf_new_xobject()`.

        |

        *Overload 14:*
        Copy constructor using `pdf_keep_obj()`.

        |

        *Overload 15:*
        Constructor using raw copy of pre-existing `::pdf_obj`.

        |

        *Overload 16:*
        Constructor using raw copy of pre-existing `::pdf_obj`.
        """
        _mupdf.PdfObj_swiginit(self, _mupdf.new_PdfObj(*args))
    __swig_destroy__ = _mupdf.delete_PdfObj

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfObj_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfObj___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfObj_m_internal_get, _mupdf.PdfObj_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfObj_s_num_instances_get, _mupdf.PdfObj_s_num_instances_set)

# Register PdfObj in _mupdf:
_mupdf.PdfObj_swigregister(PdfObj)
class PdfOcgDescriptor(object):
    r"""Wrapper class for struct `pdf_ocg_descriptor`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_ocg_descriptor`.
        """
        _mupdf.PdfOcgDescriptor_swiginit(self, _mupdf.new_PdfOcgDescriptor(*args))
    __swig_destroy__ = _mupdf.delete_PdfOcgDescriptor

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfOcgDescriptor_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfOcgDescriptor___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfOcgDescriptor_m_internal_get, _mupdf.PdfOcgDescriptor_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfOcgDescriptor_s_num_instances_get, _mupdf.PdfOcgDescriptor_s_num_instances_set)

# Register PdfOcgDescriptor in _mupdf:
_mupdf.PdfOcgDescriptor_swigregister(PdfOcgDescriptor)
class PdfPage(object):
    r"""Wrapper class for struct `pdf_page`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_bound_page(self, box):
        r"""Class-aware wrapper for `::pdf_bound_page()`."""
        return _mupdf.PdfPage_pdf_bound_page(self, box)

    def pdf_count_page_associated_files(self):
        r"""Class-aware wrapper for `::pdf_count_page_associated_files()`."""
        return _mupdf.PdfPage_pdf_count_page_associated_files(self)

    def pdf_create_annot(self, type):
        r"""Class-aware wrapper for `::pdf_create_annot()`."""
        return _mupdf.PdfPage_pdf_create_annot(self, type)

    def pdf_create_annot_raw(self, type):
        r"""Class-aware wrapper for `::pdf_create_annot_raw()`."""
        return _mupdf.PdfPage_pdf_create_annot_raw(self, type)

    def pdf_create_link(self, bbox, uri):
        r"""Class-aware wrapper for `::pdf_create_link()`."""
        return _mupdf.PdfPage_pdf_create_link(self, bbox, uri)

    def pdf_create_signature_widget(self, name):
        r"""Class-aware wrapper for `::pdf_create_signature_widget()`."""
        return _mupdf.PdfPage_pdf_create_signature_widget(self, name)

    def pdf_delete_annot(self, annot):
        r"""Class-aware wrapper for `::pdf_delete_annot()`."""
        return _mupdf.PdfPage_pdf_delete_annot(self, annot)

    def pdf_delete_link(self, link):
        r"""Class-aware wrapper for `::pdf_delete_link()`."""
        return _mupdf.PdfPage_pdf_delete_link(self, link)

    def pdf_first_annot(self):
        r"""Class-aware wrapper for `::pdf_first_annot()`."""
        return _mupdf.PdfPage_pdf_first_annot(self)

    def pdf_first_widget(self):
        r"""Class-aware wrapper for `::pdf_first_widget()`."""
        return _mupdf.PdfPage_pdf_first_widget(self)

    def pdf_load_links(self):
        r"""Class-aware wrapper for `::pdf_load_links()`."""
        return _mupdf.PdfPage_pdf_load_links(self)

    def pdf_new_link(self, rect, uri, obj):
        r"""Class-aware wrapper for `::pdf_new_link()`."""
        return _mupdf.PdfPage_pdf_new_link(self, rect, uri, obj)

    def pdf_new_pixmap_from_page_contents_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box):
        r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`."""
        return _mupdf.PdfPage_pdf_new_pixmap_from_page_contents_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box)

    def pdf_new_pixmap_from_page_contents_with_usage(self, ctm, cs, alpha, usage, box):
        r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`."""
        return _mupdf.PdfPage_pdf_new_pixmap_from_page_contents_with_usage(self, ctm, cs, alpha, usage, box)

    def pdf_new_pixmap_from_page_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box):
        r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
        return _mupdf.PdfPage_pdf_new_pixmap_from_page_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box)

    def pdf_new_pixmap_from_page_with_usage(self, ctm, cs, alpha, usage, box):
        r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
        return _mupdf.PdfPage_pdf_new_pixmap_from_page_with_usage(self, ctm, cs, alpha, usage, box)

    def pdf_nuke_annots(self):
        r"""Class-aware wrapper for `::pdf_nuke_annots()`."""
        return _mupdf.PdfPage_pdf_nuke_annots(self)

    def pdf_nuke_links(self):
        r"""Class-aware wrapper for `::pdf_nuke_links()`."""
        return _mupdf.PdfPage_pdf_nuke_links(self)

    def pdf_nuke_page(self):
        r"""Class-aware wrapper for `::pdf_nuke_page()`."""
        return _mupdf.PdfPage_pdf_nuke_page(self)

    def pdf_page_associated_file(self, idx):
        r"""Class-aware wrapper for `::pdf_page_associated_file()`."""
        return _mupdf.PdfPage_pdf_page_associated_file(self, idx)

    def pdf_page_contents(self):
        r"""Class-aware wrapper for `::pdf_page_contents()`."""
        return _mupdf.PdfPage_pdf_page_contents(self)

    def pdf_page_event_close(self):
        r"""Class-aware wrapper for `::pdf_page_event_close()`."""
        return _mupdf.PdfPage_pdf_page_event_close(self)

    def pdf_page_event_open(self):
        r"""Class-aware wrapper for `::pdf_page_event_open()`."""
        return _mupdf.PdfPage_pdf_page_event_open(self)

    def pdf_page_group(self):
        r"""Class-aware wrapper for `::pdf_page_group()`."""
        return _mupdf.PdfPage_pdf_page_group(self)

    def pdf_page_has_transparency(self):
        r"""Class-aware wrapper for `::pdf_page_has_transparency()`."""
        return _mupdf.PdfPage_pdf_page_has_transparency(self)

    def pdf_page_presentation(self, transition, duration):
        r"""
        Class-aware wrapper for `::pdf_page_presentation()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_page_presentation(::fz_transition *transition)` => `(fz_transition *, float duration)`
        """
        return _mupdf.PdfPage_pdf_page_presentation(self, transition, duration)

    def pdf_page_resources(self):
        r"""Class-aware wrapper for `::pdf_page_resources()`."""
        return _mupdf.PdfPage_pdf_page_resources(self)

    def pdf_page_separations(self):
        r"""Class-aware wrapper for `::pdf_page_separations()`."""
        return _mupdf.PdfPage_pdf_page_separations(self)

    def pdf_page_transform(self, mediabox, ctm):
        r"""Class-aware wrapper for `::pdf_page_transform()`."""
        return _mupdf.PdfPage_pdf_page_transform(self, mediabox, ctm)

    def pdf_page_transform_box(self, mediabox, ctm, box):
        r"""Class-aware wrapper for `::pdf_page_transform_box()`."""
        return _mupdf.PdfPage_pdf_page_transform_box(self, mediabox, ctm, box)

    def pdf_run_page(self, dev, ctm, cookie):
        r"""Class-aware wrapper for `::pdf_run_page()`."""
        return _mupdf.PdfPage_pdf_run_page(self, dev, ctm, cookie)

    def pdf_run_page_annots(self, dev, ctm, cookie):
        r"""Class-aware wrapper for `::pdf_run_page_annots()`."""
        return _mupdf.PdfPage_pdf_run_page_annots(self, dev, ctm, cookie)

    def pdf_run_page_annots_with_usage(self, dev, ctm, usage, cookie):
        r"""Class-aware wrapper for `::pdf_run_page_annots_with_usage()`."""
        return _mupdf.PdfPage_pdf_run_page_annots_with_usage(self, dev, ctm, usage, cookie)

    def pdf_run_page_contents(self, dev, ctm, cookie):
        r"""Class-aware wrapper for `::pdf_run_page_contents()`."""
        return _mupdf.PdfPage_pdf_run_page_contents(self, dev, ctm, cookie)

    def pdf_run_page_contents_with_usage(self, dev, ctm, usage, cookie):
        r"""Class-aware wrapper for `::pdf_run_page_contents_with_usage()`."""
        return _mupdf.PdfPage_pdf_run_page_contents_with_usage(self, dev, ctm, usage, cookie)

    def pdf_run_page_widgets(self, dev, ctm, cookie):
        r"""Class-aware wrapper for `::pdf_run_page_widgets()`."""
        return _mupdf.PdfPage_pdf_run_page_widgets(self, dev, ctm, cookie)

    def pdf_run_page_widgets_with_usage(self, dev, ctm, usage, cookie):
        r"""Class-aware wrapper for `::pdf_run_page_widgets_with_usage()`."""
        return _mupdf.PdfPage_pdf_run_page_widgets_with_usage(self, dev, ctm, usage, cookie)

    def pdf_run_page_with_usage(self, dev, ctm, usage, cookie):
        r"""Class-aware wrapper for `::pdf_run_page_with_usage()`."""
        return _mupdf.PdfPage_pdf_run_page_with_usage(self, dev, ctm, usage, cookie)

    def pdf_set_page_box(self, box, rect):
        r"""Class-aware wrapper for `::pdf_set_page_box()`."""
        return _mupdf.PdfPage_pdf_set_page_box(self, box, rect)

    def pdf_sync_annots(self):
        r"""Class-aware wrapper for `::pdf_sync_annots()`."""
        return _mupdf.PdfPage_pdf_sync_annots(self)

    def pdf_sync_links(self):
        r"""Class-aware wrapper for `::pdf_sync_links()`."""
        return _mupdf.PdfPage_pdf_sync_links(self)

    def pdf_sync_page(self):
        r"""Class-aware wrapper for `::pdf_sync_page()`."""
        return _mupdf.PdfPage_pdf_sync_page(self)

    def pdf_update_page(self):
        r"""Class-aware wrapper for `::pdf_update_page()`."""
        return _mupdf.PdfPage_pdf_update_page(self)

    def super(self):
        r"""Returns wrapper for .super member."""
        return _mupdf.PdfPage_super(self)

    def doc(self):
        r"""Returns wrapper for .doc member."""
        return _mupdf.PdfPage_doc(self)

    def obj(self):
        r"""Returns wrapper for .obj member."""
        return _mupdf.PdfPage_obj(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `pdf_keep_page()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_page`.
        """
        _mupdf.PdfPage_swiginit(self, _mupdf.new_PdfPage(*args))
    __swig_destroy__ = _mupdf.delete_PdfPage

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPage_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfPage___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfPage_m_internal_get, _mupdf.PdfPage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPage_s_num_instances_get, _mupdf.PdfPage_s_num_instances_set)

# Register PdfPage in _mupdf:
_mupdf.PdfPage_swigregister(PdfPage)
class PdfPattern(object):
    r"""Wrapper class for struct `pdf_pattern`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `pdf_keep_pattern()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_pattern`.
        """
        _mupdf.PdfPattern_swiginit(self, _mupdf.new_PdfPattern(*args))
    __swig_destroy__ = _mupdf.delete_PdfPattern

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPattern_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfPattern___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfPattern_m_internal_get, _mupdf.PdfPattern_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPattern_s_num_instances_get, _mupdf.PdfPattern_s_num_instances_set)

# Register PdfPattern in _mupdf:
_mupdf.PdfPattern_swigregister(PdfPattern)
class PdfPkcs7DistinguishedName(object):
    r"""Wrapper class for struct `pdf_pkcs7_distinguished_name`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_signature_drop_distinguished_name(self):
        r"""Class-aware wrapper for `::pdf_signature_drop_distinguished_name()`."""
        return _mupdf.PdfPkcs7DistinguishedName_pdf_signature_drop_distinguished_name(self)

    def pdf_signature_format_distinguished_name(self):
        r"""Class-aware wrapper for `::pdf_signature_format_distinguished_name()`."""
        return _mupdf.PdfPkcs7DistinguishedName_pdf_signature_format_distinguished_name(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_pkcs7_distinguished_name`.
        """
        _mupdf.PdfPkcs7DistinguishedName_swiginit(self, _mupdf.new_PdfPkcs7DistinguishedName(*args))
    __swig_destroy__ = _mupdf.delete_PdfPkcs7DistinguishedName

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPkcs7DistinguishedName_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfPkcs7DistinguishedName___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfPkcs7DistinguishedName_m_internal_get, _mupdf.PdfPkcs7DistinguishedName_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPkcs7DistinguishedName_s_num_instances_get, _mupdf.PdfPkcs7DistinguishedName_s_num_instances_set)

# Register PdfPkcs7DistinguishedName in _mupdf:
_mupdf.PdfPkcs7DistinguishedName_swigregister(PdfPkcs7DistinguishedName)
class PdfPkcs7Signer(object):
    r"""Wrapper class for struct `pdf_pkcs7_signer`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_pkcs7_signer`.
        """
        _mupdf.PdfPkcs7Signer_swiginit(self, _mupdf.new_PdfPkcs7Signer(*args))
    __swig_destroy__ = _mupdf.delete_PdfPkcs7Signer

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPkcs7Signer_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfPkcs7Signer___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfPkcs7Signer_m_internal_get, _mupdf.PdfPkcs7Signer_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPkcs7Signer_s_num_instances_get, _mupdf.PdfPkcs7Signer_s_num_instances_set)

# Register PdfPkcs7Signer in _mupdf:
_mupdf.PdfPkcs7Signer_swigregister(PdfPkcs7Signer)
class PdfPkcs7Verifier(object):
    r"""Wrapper class for struct `pdf_pkcs7_verifier`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_pkcs7_verifier`.
        """
        _mupdf.PdfPkcs7Verifier_swiginit(self, _mupdf.new_PdfPkcs7Verifier(*args))
    __swig_destroy__ = _mupdf.delete_PdfPkcs7Verifier

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPkcs7Verifier_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfPkcs7Verifier___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfPkcs7Verifier_m_internal_get, _mupdf.PdfPkcs7Verifier_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPkcs7Verifier_s_num_instances_get, _mupdf.PdfPkcs7Verifier_s_num_instances_set)

# Register PdfPkcs7Verifier in _mupdf:
_mupdf.PdfPkcs7Verifier_swigregister(PdfPkcs7Verifier)
class PdfProcessor(object):
    r"""Wrapper class for struct `pdf_processor`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts):
        r"""Class-aware wrapper for `::pdf_new_color_filter()`."""
        return _mupdf.PdfProcessor_pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts)

    def pdf_close_processor(self):
        r"""Class-aware wrapper for `::pdf_close_processor()`."""
        return _mupdf.PdfProcessor_pdf_close_processor(self)

    def pdf_process_annot(self, annot, cookie):
        r"""Class-aware wrapper for `::pdf_process_annot()`."""
        return _mupdf.PdfProcessor_pdf_process_annot(self, annot, cookie)

    def pdf_process_contents(self, doc, res, stm, cookie, out_res):
        r"""
        Class-aware wrapper for `::pdf_process_contents()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_process_contents(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` =>
        """
        return _mupdf.PdfProcessor_pdf_process_contents(self, doc, res, stm, cookie, out_res)

    def pdf_process_glyph(self, doc, resources, contents):
        r"""Class-aware wrapper for `::pdf_process_glyph()`."""
        return _mupdf.PdfProcessor_pdf_process_glyph(self, doc, resources, contents)

    def pdf_process_raw_contents(self, doc, rdb, stmobj, cookie):
        r"""Class-aware wrapper for `::pdf_process_raw_contents()`."""
        return _mupdf.PdfProcessor_pdf_process_raw_contents(self, doc, rdb, stmobj, cookie)

    def pdf_processor_pop_resources(self):
        r"""Class-aware wrapper for `::pdf_processor_pop_resources()`."""
        return _mupdf.PdfProcessor_pdf_processor_pop_resources(self)

    def pdf_processor_push_resources(self, res):
        r"""Class-aware wrapper for `::pdf_processor_push_resources()`."""
        return _mupdf.PdfProcessor_pdf_processor_push_resources(self, res)

    def pdf_reset_processor(self):
        r"""Class-aware wrapper for `::pdf_reset_processor()`."""
        return _mupdf.PdfProcessor_pdf_reset_processor(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_buffer_processor()`.

        |

        *Overload 2:*
        Constructor using `pdf_new_output_processor()`.

        |

        *Overload 3:*
        Constructor using `pdf_new_run_processor()`.

        |

        *Overload 4:*
        Constructor using `pdf_new_sanitize_filter()`.

        |

        *Overload 5:*
        Copy constructor using `pdf_keep_processor()`.

        |

        *Overload 6:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 7:*
        Constructor using raw copy of pre-existing `::pdf_processor`.
        """
        _mupdf.PdfProcessor_swiginit(self, _mupdf.new_PdfProcessor(*args))
    __swig_destroy__ = _mupdf.delete_PdfProcessor

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfProcessor_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfProcessor___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfProcessor_m_internal_get, _mupdf.PdfProcessor_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfProcessor_s_num_instances_get, _mupdf.PdfProcessor_s_num_instances_set)

# Register PdfProcessor in _mupdf:
_mupdf.PdfProcessor_swigregister(PdfProcessor)
class PdfProcessor2(PdfProcessor):
    r"""Wrapper class for struct pdf_processor with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""== Constructor."""
        if self.__class__ == PdfProcessor2:
            _self = None
        else:
            _self = self
        _mupdf.PdfProcessor2_swiginit(self, _mupdf.new_PdfProcessor2(_self, ))
    __swig_destroy__ = _mupdf.delete_PdfProcessor2

    def use_virtual_close_processor(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.PdfProcessor2_use_virtual_close_processor(self, use)

    def use_virtual_drop_processor(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_drop_processor(self, use)

    def use_virtual_reset_processor(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_reset_processor(self, use)

    def use_virtual_push_resources(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_push_resources(self, use)

    def use_virtual_pop_resources(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_pop_resources(self, use)

    def use_virtual_op_w(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_w(self, use)

    def use_virtual_op_j(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_j(self, use)

    def use_virtual_op_J(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_J(self, use)

    def use_virtual_op_M(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_M(self, use)

    def use_virtual_op_d(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_d(self, use)

    def use_virtual_op_ri(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_ri(self, use)

    def use_virtual_op_i(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_i(self, use)

    def use_virtual_op_gs_begin(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_begin(self, use)

    def use_virtual_op_gs_BM(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_BM(self, use)

    def use_virtual_op_gs_ca(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_ca(self, use)

    def use_virtual_op_gs_CA(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_CA(self, use)

    def use_virtual_op_gs_SMask(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_SMask(self, use)

    def use_virtual_op_gs_end(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_end(self, use)

    def use_virtual_op_q(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_q(self, use)

    def use_virtual_op_Q(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Q(self, use)

    def use_virtual_op_cm(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_cm(self, use)

    def use_virtual_op_m(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_m(self, use)

    def use_virtual_op_l(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_l(self, use)

    def use_virtual_op_c(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_c(self, use)

    def use_virtual_op_v(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_v(self, use)

    def use_virtual_op_y(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_y(self, use)

    def use_virtual_op_h(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_h(self, use)

    def use_virtual_op_re(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_re(self, use)

    def use_virtual_op_S(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_S(self, use)

    def use_virtual_op_s(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_s(self, use)

    def use_virtual_op_F(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_F(self, use)

    def use_virtual_op_f(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_f(self, use)

    def use_virtual_op_fstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_fstar(self, use)

    def use_virtual_op_B(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_B(self, use)

    def use_virtual_op_Bstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Bstar(self, use)

    def use_virtual_op_b(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_b(self, use)

    def use_virtual_op_bstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_bstar(self, use)

    def use_virtual_op_n(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_n(self, use)

    def use_virtual_op_W(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_W(self, use)

    def use_virtual_op_Wstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Wstar(self, use)

    def use_virtual_op_BT(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BT(self, use)

    def use_virtual_op_ET(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_ET(self, use)

    def use_virtual_op_Tc(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tc(self, use)

    def use_virtual_op_Tw(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tw(self, use)

    def use_virtual_op_Tz(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tz(self, use)

    def use_virtual_op_TL(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_TL(self, use)

    def use_virtual_op_Tf(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tf(self, use)

    def use_virtual_op_Tr(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tr(self, use)

    def use_virtual_op_Ts(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Ts(self, use)

    def use_virtual_op_Td(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Td(self, use)

    def use_virtual_op_TD(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_TD(self, use)

    def use_virtual_op_Tm(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tm(self, use)

    def use_virtual_op_Tstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tstar(self, use)

    def use_virtual_op_TJ(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_TJ(self, use)

    def use_virtual_op_Tj(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tj(self, use)

    def use_virtual_op_squote(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_squote(self, use)

    def use_virtual_op_dquote(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_dquote(self, use)

    def use_virtual_op_d0(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_d0(self, use)

    def use_virtual_op_d1(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_d1(self, use)

    def use_virtual_op_CS(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_CS(self, use)

    def use_virtual_op_cs(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_cs(self, use)

    def use_virtual_op_SC_pattern(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_SC_pattern(self, use)

    def use_virtual_op_sc_pattern(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_sc_pattern(self, use)

    def use_virtual_op_SC_shade(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_SC_shade(self, use)

    def use_virtual_op_sc_shade(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_sc_shade(self, use)

    def use_virtual_op_SC_color(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_SC_color(self, use)

    def use_virtual_op_sc_color(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_sc_color(self, use)

    def use_virtual_op_G(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_G(self, use)

    def use_virtual_op_g(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_g(self, use)

    def use_virtual_op_RG(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_RG(self, use)

    def use_virtual_op_rg(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_rg(self, use)

    def use_virtual_op_K(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_K(self, use)

    def use_virtual_op_k(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_k(self, use)

    def use_virtual_op_BI(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BI(self, use)

    def use_virtual_op_sh(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_sh(self, use)

    def use_virtual_op_Do_image(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Do_image(self, use)

    def use_virtual_op_Do_form(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Do_form(self, use)

    def use_virtual_op_MP(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_MP(self, use)

    def use_virtual_op_DP(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_DP(self, use)

    def use_virtual_op_BMC(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BMC(self, use)

    def use_virtual_op_BDC(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BDC(self, use)

    def use_virtual_op_EMC(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_EMC(self, use)

    def use_virtual_op_BX(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BX(self, use)

    def use_virtual_op_EX(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_EX(self, use)

    def use_virtual_op_gs_OP(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_OP(self, use)

    def use_virtual_op_gs_op(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_op(self, use)

    def use_virtual_op_gs_OPM(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_OPM(self, use)

    def use_virtual_op_gs_UseBlackPtComp(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_UseBlackPtComp(self, use)

    def use_virtual_op_EOD(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_EOD(self, use)

    def use_virtual_op_END(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_END(self, use)

    def close_processor(self, arg_0):
        r"""Default virtual method implementations; these all throw an exception."""
        return _mupdf.PdfProcessor2_close_processor(self, arg_0)

    def drop_processor(self, arg_0):
        return _mupdf.PdfProcessor2_drop_processor(self, arg_0)

    def reset_processor(self, arg_0):
        return _mupdf.PdfProcessor2_reset_processor(self, arg_0)

    def push_resources(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_push_resources(self, arg_0, arg_2)

    def pop_resources(self, arg_0):
        return _mupdf.PdfProcessor2_pop_resources(self, arg_0)

    def op_w(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_w(self, arg_0, arg_2)

    def op_j(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_j(self, arg_0, arg_2)

    def op_J(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_J(self, arg_0, arg_2)

    def op_M(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_M(self, arg_0, arg_2)

    def op_d(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_d(self, arg_0, arg_2, arg_3)

    def op_ri(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_ri(self, arg_0, arg_2)

    def op_i(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_i(self, arg_0, arg_2)

    def op_gs_begin(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_gs_begin(self, arg_0, arg_2, arg_3)

    def op_gs_BM(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_BM(self, arg_0, arg_2)

    def op_gs_ca(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_ca(self, arg_0, arg_2)

    def op_gs_CA(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_CA(self, arg_0, arg_2)

    def op_gs_SMask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6):
        return _mupdf.PdfProcessor2_op_gs_SMask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6)

    def op_gs_end(self, arg_0):
        return _mupdf.PdfProcessor2_op_gs_end(self, arg_0)

    def op_q(self, arg_0):
        return _mupdf.PdfProcessor2_op_q(self, arg_0)

    def op_Q(self, arg_0):
        return _mupdf.PdfProcessor2_op_Q(self, arg_0)

    def op_cm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.PdfProcessor2_op_cm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def op_m(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_m(self, arg_0, arg_2, arg_3)

    def op_l(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_l(self, arg_0, arg_2, arg_3)

    def op_c(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.PdfProcessor2_op_c(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def op_v(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_v(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_y(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_y(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_h(self, arg_0):
        return _mupdf.PdfProcessor2_op_h(self, arg_0)

    def op_re(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_re(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_S(self, arg_0):
        return _mupdf.PdfProcessor2_op_S(self, arg_0)

    def op_s(self, arg_0):
        return _mupdf.PdfProcessor2_op_s(self, arg_0)

    def op_F(self, arg_0):
        return _mupdf.PdfProcessor2_op_F(self, arg_0)

    def op_f(self, arg_0):
        return _mupdf.PdfProcessor2_op_f(self, arg_0)

    def op_fstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_fstar(self, arg_0)

    def op_B(self, arg_0):
        return _mupdf.PdfProcessor2_op_B(self, arg_0)

    def op_Bstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_Bstar(self, arg_0)

    def op_b(self, arg_0):
        return _mupdf.PdfProcessor2_op_b(self, arg_0)

    def op_bstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_bstar(self, arg_0)

    def op_n(self, arg_0):
        return _mupdf.PdfProcessor2_op_n(self, arg_0)

    def op_W(self, arg_0):
        return _mupdf.PdfProcessor2_op_W(self, arg_0)

    def op_Wstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_Wstar(self, arg_0)

    def op_BT(self, arg_0):
        return _mupdf.PdfProcessor2_op_BT(self, arg_0)

    def op_ET(self, arg_0):
        return _mupdf.PdfProcessor2_op_ET(self, arg_0)

    def op_Tc(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Tc(self, arg_0, arg_2)

    def op_Tw(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Tw(self, arg_0, arg_2)

    def op_Tz(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Tz(self, arg_0, arg_2)

    def op_TL(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_TL(self, arg_0, arg_2)

    def op_Tf(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_Tf(self, arg_0, arg_2, arg_3, arg_4)

    def op_Tr(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Tr(self, arg_0, arg_2)

    def op_Ts(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Ts(self, arg_0, arg_2)

    def op_Td(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_Td(self, arg_0, arg_2, arg_3)

    def op_TD(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_TD(self, arg_0, arg_2, arg_3)

    def op_Tm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.PdfProcessor2_op_Tm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def op_Tstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_Tstar(self, arg_0)

    def op_TJ(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_TJ(self, arg_0, arg_2)

    def op_Tj(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_Tj(self, arg_0, arg_2, arg_3)

    def op_squote(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_squote(self, arg_0, arg_2, arg_3)

    def op_dquote(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_dquote(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_d0(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_d0(self, arg_0, arg_2, arg_3)

    def op_d1(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.PdfProcessor2_op_d1(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def op_CS(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_CS(self, arg_0, arg_2, arg_3)

    def op_cs(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_cs(self, arg_0, arg_2, arg_3)

    def op_SC_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_SC_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_sc_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_sc_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_SC_shade(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_SC_shade(self, arg_0, arg_2, arg_3)

    def op_sc_shade(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_sc_shade(self, arg_0, arg_2, arg_3)

    def op_SC_color(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_SC_color(self, arg_0, arg_2, arg_3)

    def op_sc_color(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_sc_color(self, arg_0, arg_2, arg_3)

    def op_G(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_G(self, arg_0, arg_2)

    def op_g(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_g(self, arg_0, arg_2)

    def op_RG(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_RG(self, arg_0, arg_2, arg_3, arg_4)

    def op_rg(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_rg(self, arg_0, arg_2, arg_3, arg_4)

    def op_K(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_K(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_k(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_k(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_BI(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_BI(self, arg_0, arg_2, arg_3)

    def op_sh(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_sh(self, arg_0, arg_2, arg_3)

    def op_Do_image(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_Do_image(self, arg_0, arg_2, arg_3)

    def op_Do_form(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_Do_form(self, arg_0, arg_2, arg_3)

    def op_MP(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_MP(self, arg_0, arg_2)

    def op_DP(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_DP(self, arg_0, arg_2, arg_3, arg_4)

    def op_BMC(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_BMC(self, arg_0, arg_2)

    def op_BDC(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_BDC(self, arg_0, arg_2, arg_3, arg_4)

    def op_EMC(self, arg_0):
        return _mupdf.PdfProcessor2_op_EMC(self, arg_0)

    def op_BX(self, arg_0):
        return _mupdf.PdfProcessor2_op_BX(self, arg_0)

    def op_EX(self, arg_0):
        return _mupdf.PdfProcessor2_op_EX(self, arg_0)

    def op_gs_OP(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_OP(self, arg_0, arg_2)

    def op_gs_op(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_op(self, arg_0, arg_2)

    def op_gs_OPM(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_OPM(self, arg_0, arg_2)

    def op_gs_UseBlackPtComp(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_UseBlackPtComp(self, arg_0, arg_2)

    def op_EOD(self, arg_0):
        return _mupdf.PdfProcessor2_op_EOD(self, arg_0)

    def op_END(self, arg_0):
        return _mupdf.PdfProcessor2_op_END(self, arg_0)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_PdfProcessor2(self)
        return weakref.proxy(self)

# Register PdfProcessor2 in _mupdf:
_mupdf.PdfProcessor2_swigregister(PdfProcessor2)
class PdfRange(object):
    r"""Wrapper class for struct `pdf_range`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_range`.
        """
        _mupdf.PdfRange_swiginit(self, _mupdf.new_PdfRange(*args))
    __swig_destroy__ = _mupdf.delete_PdfRange

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfRange_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfRange___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfRange_m_internal_get, _mupdf.PdfRange_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfRange_s_num_instances_get, _mupdf.PdfRange_s_num_instances_set)

# Register PdfRange in _mupdf:
_mupdf.PdfRange_swigregister(PdfRange)
class PdfRecolorOptions(object):
    r"""Wrapper class for struct `pdf_recolor_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_recolor_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_recolor_options`.
        """
        _mupdf.PdfRecolorOptions_swiginit(self, _mupdf.new_PdfRecolorOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfRecolorOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfRecolorOptions
    num_comp = property(_mupdf.PdfRecolorOptions_num_comp_get, _mupdf.PdfRecolorOptions_num_comp_set)
    s_num_instances = property(_mupdf.PdfRecolorOptions_s_num_instances_get, _mupdf.PdfRecolorOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfRecolorOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfRecolorOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfRecolorOptions___ne__(self, rhs)

# Register PdfRecolorOptions in _mupdf:
_mupdf.PdfRecolorOptions_swigregister(PdfRecolorOptions)
class PdfRedactOptions(object):
    r"""Wrapper class for struct `pdf_redact_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_redact_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_redact_options`.
        """
        _mupdf.PdfRedactOptions_swiginit(self, _mupdf.new_PdfRedactOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfRedactOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfRedactOptions
    black_boxes = property(_mupdf.PdfRedactOptions_black_boxes_get, _mupdf.PdfRedactOptions_black_boxes_set)
    image_method = property(_mupdf.PdfRedactOptions_image_method_get, _mupdf.PdfRedactOptions_image_method_set)
    line_art = property(_mupdf.PdfRedactOptions_line_art_get, _mupdf.PdfRedactOptions_line_art_set)
    text = property(_mupdf.PdfRedactOptions_text_get, _mupdf.PdfRedactOptions_text_set)
    s_num_instances = property(_mupdf.PdfRedactOptions_s_num_instances_get, _mupdf.PdfRedactOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfRedactOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfRedactOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfRedactOptions___ne__(self, rhs)

# Register PdfRedactOptions in _mupdf:
_mupdf.PdfRedactOptions_swigregister(PdfRedactOptions)
class PdfRevPageMap(object):
    r"""Wrapper class for struct `pdf_rev_page_map`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_rev_page_map`.
        """
        _mupdf.PdfRevPageMap_swiginit(self, _mupdf.new_PdfRevPageMap(*args))
    __swig_destroy__ = _mupdf.delete_PdfRevPageMap

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfRevPageMap_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfRevPageMap___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfRevPageMap_m_internal_get, _mupdf.PdfRevPageMap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfRevPageMap_s_num_instances_get, _mupdf.PdfRevPageMap_s_num_instances_set)

# Register PdfRevPageMap in _mupdf:
_mupdf.PdfRevPageMap_swigregister(PdfRevPageMap)
class PdfSanitizeFilterOptions(object):
    r"""Wrapper class for struct `pdf_sanitize_filter_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_sanitize_filter_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_sanitize_filter_options`.
        """
        _mupdf.PdfSanitizeFilterOptions_swiginit(self, _mupdf.new_PdfSanitizeFilterOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfSanitizeFilterOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfSanitizeFilterOptions
    opaque = property(_mupdf.PdfSanitizeFilterOptions_opaque_get, _mupdf.PdfSanitizeFilterOptions_opaque_set)
    image_filter = property(_mupdf.PdfSanitizeFilterOptions_image_filter_get, _mupdf.PdfSanitizeFilterOptions_image_filter_set)
    text_filter = property(_mupdf.PdfSanitizeFilterOptions_text_filter_get, _mupdf.PdfSanitizeFilterOptions_text_filter_set)
    after_text_object = property(_mupdf.PdfSanitizeFilterOptions_after_text_object_get, _mupdf.PdfSanitizeFilterOptions_after_text_object_set)
    culler = property(_mupdf.PdfSanitizeFilterOptions_culler_get, _mupdf.PdfSanitizeFilterOptions_culler_set)
    s_num_instances = property(_mupdf.PdfSanitizeFilterOptions_s_num_instances_get, _mupdf.PdfSanitizeFilterOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfSanitizeFilterOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfSanitizeFilterOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfSanitizeFilterOptions___ne__(self, rhs)

# Register PdfSanitizeFilterOptions in _mupdf:
_mupdf.PdfSanitizeFilterOptions_swigregister(PdfSanitizeFilterOptions)
class PdfSanitizeFilterOptions2(PdfSanitizeFilterOptions):
    r"""Wrapper class for struct pdf_sanitize_filter_options with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""== Constructor."""
        if self.__class__ == PdfSanitizeFilterOptions2:
            _self = None
        else:
            _self = self
        _mupdf.PdfSanitizeFilterOptions2_swiginit(self, _mupdf.new_PdfSanitizeFilterOptions2(_self, ))
    __swig_destroy__ = _mupdf.delete_PdfSanitizeFilterOptions2

    def use_virtual_image_filter(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.PdfSanitizeFilterOptions2_use_virtual_image_filter(self, use)

    def use_virtual_text_filter(self, use=True):
        return _mupdf.PdfSanitizeFilterOptions2_use_virtual_text_filter(self, use)

    def use_virtual_after_text_object(self, use=True):
        return _mupdf.PdfSanitizeFilterOptions2_use_virtual_after_text_object(self, use)

    def use_virtual_culler(self, use=True):
        return _mupdf.PdfSanitizeFilterOptions2_use_virtual_culler(self, use)

    def image_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        r"""Default virtual method implementations; these all throw an exception."""
        return _mupdf.PdfSanitizeFilterOptions2_image_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def text_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6):
        return _mupdf.PdfSanitizeFilterOptions2_text_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6)

    def after_text_object(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfSanitizeFilterOptions2_after_text_object(self, arg_0, arg_2, arg_3, arg_4)

    def culler(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfSanitizeFilterOptions2_culler(self, arg_0, arg_2, arg_3)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_PdfSanitizeFilterOptions2(self)
        return weakref.proxy(self)

# Register PdfSanitizeFilterOptions2 in _mupdf:
_mupdf.PdfSanitizeFilterOptions2_swigregister(PdfSanitizeFilterOptions2)
class PdfTextObjectState(object):
    r"""Wrapper class for struct `pdf_text_object_state`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_tos_get_text(self):
        r"""Class-aware wrapper for `::pdf_tos_get_text()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_get_text(self)

    def pdf_tos_make_trm(self, text, fontdesc, cid, trm, adv):
        r"""
        Class-aware wrapper for `::pdf_tos_make_trm()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_tos_make_trm(::pdf_text_state *text, ::pdf_font_desc *fontdesc, int cid, ::fz_matrix *trm)` => `(int, float adv)`
        """
        return _mupdf.PdfTextObjectState_pdf_tos_make_trm(self, text, fontdesc, cid, trm, adv)

    def pdf_tos_move_after_char(self):
        r"""Class-aware wrapper for `::pdf_tos_move_after_char()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_move_after_char(self)

    def pdf_tos_newline(self, leading):
        r"""Class-aware wrapper for `::pdf_tos_newline()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_newline(self, leading)

    def pdf_tos_reset(self, render):
        r"""Class-aware wrapper for `::pdf_tos_reset()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_reset(self, render)

    def pdf_tos_set_matrix(self, a, b, c, d, e, f):
        r"""Class-aware wrapper for `::pdf_tos_set_matrix()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_set_matrix(self, a, b, c, d, e, f)

    def pdf_tos_translate(self, tx, ty):
        r"""Class-aware wrapper for `::pdf_tos_translate()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_translate(self, tx, ty)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_text_object_state`.
        """
        _mupdf.PdfTextObjectState_swiginit(self, _mupdf.new_PdfTextObjectState(*args))
    __swig_destroy__ = _mupdf.delete_PdfTextObjectState

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfTextObjectState_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfTextObjectState___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfTextObjectState_m_internal_get, _mupdf.PdfTextObjectState_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfTextObjectState_s_num_instances_get, _mupdf.PdfTextObjectState_s_num_instances_set)

# Register PdfTextObjectState in _mupdf:
_mupdf.PdfTextObjectState_swigregister(PdfTextObjectState)
class PdfTextState(object):
    r"""Wrapper class for struct `pdf_text_state`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_text_state`.
        """
        _mupdf.PdfTextState_swiginit(self, _mupdf.new_PdfTextState(*args))
    __swig_destroy__ = _mupdf.delete_PdfTextState

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfTextState_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfTextState___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfTextState_m_internal_get, _mupdf.PdfTextState_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfTextState_s_num_instances_get, _mupdf.PdfTextState_s_num_instances_set)

# Register PdfTextState in _mupdf:
_mupdf.PdfTextState_swigregister(PdfTextState)
class PdfUnsavedSig(object):
    r"""Wrapper class for struct `pdf_unsaved_sig`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_unsaved_sig`.
        """
        _mupdf.PdfUnsavedSig_swiginit(self, _mupdf.new_PdfUnsavedSig(*args))
    __swig_destroy__ = _mupdf.delete_PdfUnsavedSig

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfUnsavedSig_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfUnsavedSig___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfUnsavedSig_m_internal_get, _mupdf.PdfUnsavedSig_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfUnsavedSig_s_num_instances_get, _mupdf.PdfUnsavedSig_s_num_instances_set)

# Register PdfUnsavedSig in _mupdf:
_mupdf.PdfUnsavedSig_swigregister(PdfUnsavedSig)
class PdfVmtx(object):
    r"""Wrapper class for struct `pdf_vmtx`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_vmtx`.
        """
        _mupdf.PdfVmtx_swiginit(self, _mupdf.new_PdfVmtx(*args))
    __swig_destroy__ = _mupdf.delete_PdfVmtx

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfVmtx_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfVmtx___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfVmtx_m_internal_get, _mupdf.PdfVmtx_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfVmtx_s_num_instances_get, _mupdf.PdfVmtx_s_num_instances_set)

# Register PdfVmtx in _mupdf:
_mupdf.PdfVmtx_swigregister(PdfVmtx)
class PdfWriteOptions(object):
    r"""Wrapper class for struct `pdf_write_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_parse_write_options(self, args):
        r"""We use default copy constructor and operator=.  Class-aware wrapper for `::pdf_parse_write_options()`."""
        return _mupdf.PdfWriteOptions_pdf_parse_write_options(self, args)

    def opwd_utf8_set_value(self, text):
        r"""Copies <text> into opwd_utf8[]."""
        return _mupdf.PdfWriteOptions_opwd_utf8_set_value(self, text)

    def upwd_utf8_set_value(self, text):
        r"""Copies <text> into upwd_utf8[]."""
        return _mupdf.PdfWriteOptions_upwd_utf8_set_value(self, text)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, makes copy of pdf_default_write_options.

        |

        *Overload 2:*
        Copy constructor using raw memcopy().

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_write_options`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_write_options`.
        """
        _mupdf.PdfWriteOptions_swiginit(self, _mupdf.new_PdfWriteOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfWriteOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfWriteOptions
    do_incremental = property(_mupdf.PdfWriteOptions_do_incremental_get, _mupdf.PdfWriteOptions_do_incremental_set)
    do_pretty = property(_mupdf.PdfWriteOptions_do_pretty_get, _mupdf.PdfWriteOptions_do_pretty_set)
    do_ascii = property(_mupdf.PdfWriteOptions_do_ascii_get, _mupdf.PdfWriteOptions_do_ascii_set)
    do_compress = property(_mupdf.PdfWriteOptions_do_compress_get, _mupdf.PdfWriteOptions_do_compress_set)
    do_compress_images = property(_mupdf.PdfWriteOptions_do_compress_images_get, _mupdf.PdfWriteOptions_do_compress_images_set)
    do_compress_fonts = property(_mupdf.PdfWriteOptions_do_compress_fonts_get, _mupdf.PdfWriteOptions_do_compress_fonts_set)
    do_decompress = property(_mupdf.PdfWriteOptions_do_decompress_get, _mupdf.PdfWriteOptions_do_decompress_set)
    do_garbage = property(_mupdf.PdfWriteOptions_do_garbage_get, _mupdf.PdfWriteOptions_do_garbage_set)
    do_linear = property(_mupdf.PdfWriteOptions_do_linear_get, _mupdf.PdfWriteOptions_do_linear_set)
    do_clean = property(_mupdf.PdfWriteOptions_do_clean_get, _mupdf.PdfWriteOptions_do_clean_set)
    do_sanitize = property(_mupdf.PdfWriteOptions_do_sanitize_get, _mupdf.PdfWriteOptions_do_sanitize_set)
    do_appearance = property(_mupdf.PdfWriteOptions_do_appearance_get, _mupdf.PdfWriteOptions_do_appearance_set)
    do_encrypt = property(_mupdf.PdfWriteOptions_do_encrypt_get, _mupdf.PdfWriteOptions_do_encrypt_set)
    dont_regenerate_id = property(_mupdf.PdfWriteOptions_dont_regenerate_id_get, _mupdf.PdfWriteOptions_dont_regenerate_id_set)
    permissions = property(_mupdf.PdfWriteOptions_permissions_get, _mupdf.PdfWriteOptions_permissions_set)
    opwd_utf8 = property(_mupdf.PdfWriteOptions_opwd_utf8_get, _mupdf.PdfWriteOptions_opwd_utf8_set)
    upwd_utf8 = property(_mupdf.PdfWriteOptions_upwd_utf8_get, _mupdf.PdfWriteOptions_upwd_utf8_set)
    do_snapshot = property(_mupdf.PdfWriteOptions_do_snapshot_get, _mupdf.PdfWriteOptions_do_snapshot_set)
    do_preserve_metadata = property(_mupdf.PdfWriteOptions_do_preserve_metadata_get, _mupdf.PdfWriteOptions_do_preserve_metadata_set)
    do_use_objstms = property(_mupdf.PdfWriteOptions_do_use_objstms_get, _mupdf.PdfWriteOptions_do_use_objstms_set)
    compression_effort = property(_mupdf.PdfWriteOptions_compression_effort_get, _mupdf.PdfWriteOptions_compression_effort_set)
    s_num_instances = property(_mupdf.PdfWriteOptions_s_num_instances_get, _mupdf.PdfWriteOptions_s_num_instances_set)

    def to_string(self):
        r"""Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfWriteOptions_to_string(self)

    def __eq__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfWriteOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r"""Comparison method."""
        return _mupdf.PdfWriteOptions___ne__(self, rhs)

# Register PdfWriteOptions in _mupdf:
_mupdf.PdfWriteOptions_swigregister(PdfWriteOptions)
class PdfXrange(object):
    r"""Wrapper class for struct `pdf_xrange`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_xrange`.
        """
        _mupdf.PdfXrange_swiginit(self, _mupdf.new_PdfXrange(*args))
    __swig_destroy__ = _mupdf.delete_PdfXrange

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfXrange_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfXrange___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfXrange_m_internal_get, _mupdf.PdfXrange_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfXrange_s_num_instances_get, _mupdf.PdfXrange_s_num_instances_set)

# Register PdfXrange in _mupdf:
_mupdf.PdfXrange_swigregister(PdfXrange)
class PdfXref(object):
    r"""Wrapper class for struct `pdf_xref`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_local_xref()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_xref`.
        """
        _mupdf.PdfXref_swiginit(self, _mupdf.new_PdfXref(*args))
    __swig_destroy__ = _mupdf.delete_PdfXref

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfXref_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfXref___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfXref_m_internal_get, _mupdf.PdfXref_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfXref_s_num_instances_get, _mupdf.PdfXref_s_num_instances_set)

# Register PdfXref in _mupdf:
_mupdf.PdfXref_swigregister(PdfXref)
class PdfXrefEntry(object):
    r"""Wrapper class for struct `pdf_xref_entry`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_xref_entry`.
        """
        _mupdf.PdfXrefEntry_swiginit(self, _mupdf.new_PdfXrefEntry(*args))
    __swig_destroy__ = _mupdf.delete_PdfXrefEntry

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfXrefEntry_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfXrefEntry___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfXrefEntry_m_internal_get, _mupdf.PdfXrefEntry_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfXrefEntry_s_num_instances_get, _mupdf.PdfXrefEntry_s_num_instances_set)

# Register PdfXrefEntry in _mupdf:
_mupdf.PdfXrefEntry_swigregister(PdfXrefEntry)
class PdfXrefSubsec(object):
    r"""Wrapper class for struct `pdf_xref_subsec`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_xref_subsec`.
        """
        _mupdf.PdfXrefSubsec_swiginit(self, _mupdf.new_PdfXrefSubsec(*args))
    __swig_destroy__ = _mupdf.delete_PdfXrefSubsec

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfXrefSubsec_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.PdfXrefSubsec___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.PdfXrefSubsec_m_internal_get, _mupdf.PdfXrefSubsec_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfXrefSubsec_s_num_instances_get, _mupdf.PdfXrefSubsec_s_num_instances_set)

# Register PdfXrefSubsec in _mupdf:
_mupdf.PdfXrefSubsec_swigregister(PdfXrefSubsec)

def num_instances():
    r"""Returns map from class name (for example FzDocument) to s_num_instances."""
    return _mupdf.num_instances()
class FzLinkIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, item):
        _mupdf.FzLinkIterator_swiginit(self, _mupdf.new_FzLinkIterator(item))

    def __increment__(self):
        return _mupdf.FzLinkIterator___increment__(self)

    def __eq__(self, rhs):
        return _mupdf.FzLinkIterator___eq__(self, rhs)

    def __ne__(self, rhs):
        return _mupdf.FzLinkIterator___ne__(self, rhs)

    def __ref__(self):
        return _mupdf.FzLinkIterator___ref__(self)

    def __deref__(self):
        return _mupdf.FzLinkIterator___deref__(self)
    __swig_destroy__ = _mupdf.delete_FzLinkIterator

    def fz_set_link_rect(self, rect):
        r"""Class-aware wrapper for `::fz_set_link_rect()`."""
        return _mupdf.FzLinkIterator_fz_set_link_rect(self, rect)

    def fz_set_link_uri(self, uri):
        r"""Class-aware wrapper for `::fz_set_link_uri()`."""
        return _mupdf.FzLinkIterator_fz_set_link_uri(self, uri)

    def begin(self):
        r"""Used for iteration over linked list of FzLink items starting at fz_link::."""
        return _mupdf.FzLinkIterator_begin(self)

    def end(self):
        r"""Used for iteration over linked list of FzLink items starting at fz_link::."""
        return _mupdf.FzLinkIterator_end(self)

    def refs(self):
        return _mupdf.FzLinkIterator_refs(self)

    def next(self):
        return _mupdf.FzLinkIterator_next(self)

    def rect(self):
        return _mupdf.FzLinkIterator_rect(self)

    def uri(self):
        return _mupdf.FzLinkIterator_uri(self)

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLinkIterator_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzLinkIterator___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzLinkIterator_m_internal_get, _mupdf.FzLinkIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLinkIterator_s_num_instances_get, _mupdf.FzLinkIterator_s_num_instances_set)

# Register FzLinkIterator in _mupdf:
_mupdf.FzLinkIterator_swigregister(FzLinkIterator)
class FzStextBlockIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, item):
        _mupdf.FzStextBlockIterator_swiginit(self, _mupdf.new_FzStextBlockIterator(item))

    def __increment__(self):
        return _mupdf.FzStextBlockIterator___increment__(self)

    def __eq__(self, rhs):
        return _mupdf.FzStextBlockIterator___eq__(self, rhs)

    def __ne__(self, rhs):
        return _mupdf.FzStextBlockIterator___ne__(self, rhs)

    def __ref__(self):
        return _mupdf.FzStextBlockIterator___ref__(self)

    def __deref__(self):
        return _mupdf.FzStextBlockIterator___deref__(self)
    __swig_destroy__ = _mupdf.delete_FzStextBlockIterator

    def begin(self):
        r"""Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
        return _mupdf.FzStextBlockIterator_begin(self)

    def end(self):
        r"""Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
        return _mupdf.FzStextBlockIterator_end(self)

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextBlockIterator_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStextBlockIterator___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStextBlockIterator_m_internal_get, _mupdf.FzStextBlockIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextBlockIterator_s_num_instances_get, _mupdf.FzStextBlockIterator_s_num_instances_set)

# Register FzStextBlockIterator in _mupdf:
_mupdf.FzStextBlockIterator_swigregister(FzStextBlockIterator)
class FzStextLineIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, item):
        _mupdf.FzStextLineIterator_swiginit(self, _mupdf.new_FzStextLineIterator(item))

    def __increment__(self):
        return _mupdf.FzStextLineIterator___increment__(self)

    def __eq__(self, rhs):
        return _mupdf.FzStextLineIterator___eq__(self, rhs)

    def __ne__(self, rhs):
        return _mupdf.FzStextLineIterator___ne__(self, rhs)

    def __ref__(self):
        return _mupdf.FzStextLineIterator___ref__(self)

    def __deref__(self):
        return _mupdf.FzStextLineIterator___deref__(self)
    __swig_destroy__ = _mupdf.delete_FzStextLineIterator

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextLineIterator_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStextLineIterator___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStextLineIterator_m_internal_get, _mupdf.FzStextLineIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextLineIterator_s_num_instances_get, _mupdf.FzStextLineIterator_s_num_instances_set)

# Register FzStextLineIterator in _mupdf:
_mupdf.FzStextLineIterator_swigregister(FzStextLineIterator)
class FzStextPageIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, item):
        _mupdf.FzStextPageIterator_swiginit(self, _mupdf.new_FzStextPageIterator(item))

    def __increment__(self):
        return _mupdf.FzStextPageIterator___increment__(self)

    def __eq__(self, rhs):
        return _mupdf.FzStextPageIterator___eq__(self, rhs)

    def __ne__(self, rhs):
        return _mupdf.FzStextPageIterator___ne__(self, rhs)

    def __ref__(self):
        return _mupdf.FzStextPageIterator___ref__(self)

    def __deref__(self):
        return _mupdf.FzStextPageIterator___deref__(self)
    __swig_destroy__ = _mupdf.delete_FzStextPageIterator

    def i_transform(self):
        r"""Returns m_internal.u.i.transform if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
        return _mupdf.FzStextPageIterator_i_transform(self)

    def i_image(self):
        r"""Returns m_internal.u.i.image if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
        return _mupdf.FzStextPageIterator_i_image(self)

    def begin(self):
        r"""Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
        return _mupdf.FzStextPageIterator_begin(self)

    def end(self):
        r"""Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
        return _mupdf.FzStextPageIterator_end(self)

    def m_internal_value(self):
        r"""Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextPageIterator_m_internal_value(self)

    def __nonzero__(self):
        return _mupdf.FzStextPageIterator___nonzero__(self)
    __bool__ = __nonzero__


    m_internal = property(_mupdf.FzStextPageIterator_m_internal_get, _mupdf.FzStextPageIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextPageIterator_s_num_instances_get, _mupdf.FzStextPageIterator_s_num_instances_set)

# Register FzStextPageIterator in _mupdf:
_mupdf.FzStextPageIterator_swigregister(FzStextPageIterator)

def fz_aa_level():
    r"""
    Class-aware wrapper for `::fz_aa_level()`.
    	Get the number of bits of antialiasing we are
    	using (for graphics). Between 0 and 8.
    """
    return _mupdf.fz_aa_level()

def fz_abs(f):
    r"""
    Class-aware wrapper for `::fz_abs()`.
    	Some standard math functions, done as static inlines for speed.
    	People with compilers that do not adequately implement inline
    	may like to reimplement these using macros.
    """
    return _mupdf.fz_abs(f)

def fz_absi(i):
    r"""Class-aware wrapper for `::fz_absi()`."""
    return _mupdf.fz_absi(i)

def fz_add_layout_char(block, x, w, p):
    r"""
    Class-aware wrapper for `::fz_add_layout_char()`.
    	Add a new char to the line at the end of the layout block.
    """
    return _mupdf.fz_add_layout_char(block, x, w, p)

def fz_add_layout_line(block, x, y, h, p):
    r"""
    Class-aware wrapper for `::fz_add_layout_line()`.
    	Add a new line to the end of the layout block.
    """
    return _mupdf.fz_add_layout_line(block, x, y, h, p)

def fz_add_separation(sep, name, cs, cs_channel):
    r"""
    Class-aware wrapper for `::fz_add_separation()`.
    	Add a separation (null terminated name, colorspace)
    """
    return _mupdf.fz_add_separation(sep, name, cs, cs_channel)

def fz_add_separation_equivalents(sep, rgba, cmyk, name):
    r"""
    Class-aware wrapper for `::fz_add_separation_equivalents()`.
    	Add a separation with equivalents (null terminated name,
    	colorspace)

    	(old, deprecated)
    """
    return _mupdf.fz_add_separation_equivalents(sep, rgba, cmyk, name)

def fz_adjust_rect_for_stroke(rect, stroke, ctm):
    r"""
    Class-aware wrapper for `::fz_adjust_rect_for_stroke()`.
    	Given a rectangle (assumed to be the bounding box for a path),
    	expand it to allow for the expansion of the bbox that would be
    	seen by stroking the path with the given stroke state and
    	transform.
    """
    return _mupdf.fz_adjust_rect_for_stroke(rect, stroke, ctm)

def fz_advance_glyph(font, glyph, wmode):
    r"""
    Class-aware wrapper for `::fz_advance_glyph()`.
    	Return the advance for a given glyph.

    	font: The font to look for the glyph in.

    	glyph: The glyph to find the advance for.

    	wmode: 1 for vertical mode, 0 for horizontal.

    	Returns the advance for the glyph.
    """
    return _mupdf.fz_advance_glyph(font, glyph, wmode)

def fz_aes_crypt_cbc(ctx, mode, length, iv, input, output):
    r"""
    Class-aware wrapper for `::fz_aes_crypt_cbc()`.
    	AES block processing. Encrypts or Decrypts (according to mode,
    	which must match what was initially set up) length bytes (which
    	must be a multiple of 16), using (and modifying) the insertion
    	vector iv, reading from input, and writing to output.

    	Never throws an exception.
    """
    return _mupdf.fz_aes_crypt_cbc(ctx, mode, length, iv, input, output)

def fz_aes_setkey_dec(ctx, key, keysize):
    r"""
    Class-aware wrapper for `::fz_aes_setkey_dec()`.
    	AES decryption intialisation. Fills in the supplied context
    	and prepares for decryption using the given key.

    	Returns non-zero for error (key size other than 128/192/256).

    	Never throws an exception.
    """
    return _mupdf.fz_aes_setkey_dec(ctx, key, keysize)

def fz_aes_setkey_enc(ctx, key, keysize):
    r"""
    Class-aware wrapper for `::fz_aes_setkey_enc()`.
    	AES encryption intialisation. Fills in the supplied context
    	and prepares for encryption using the given key.

    	Returns non-zero for error (key size other than 128/192/256).

    	Never throws an exception.
    """
    return _mupdf.fz_aes_setkey_enc(ctx, key, keysize)

def fz_alpha_from_gray(gray):
    r"""Class-aware wrapper for `::fz_alpha_from_gray()`."""
    return _mupdf.fz_alpha_from_gray(gray)

def fz_append_base64(out, data, size, newline):
    r"""
    Class-aware wrapper for `::fz_append_base64()`.
    	Write a base64 encoded data block, optionally with periodic newlines.
    """
    return _mupdf.fz_append_base64(out, data, size, newline)

def fz_append_base64_buffer(out, data, newline):
    r"""
    Class-aware wrapper for `::fz_append_base64_buffer()`.
    	Append a base64 encoded fz_buffer, optionally with periodic newlines.
    """
    return _mupdf.fz_append_base64_buffer(out, data, newline)

def fz_append_bits(buf, value, count):
    r"""Class-aware wrapper for `::fz_append_bits()`."""
    return _mupdf.fz_append_bits(buf, value, count)

def fz_append_bits_pad(buf):
    r"""Class-aware wrapper for `::fz_append_bits_pad()`."""
    return _mupdf.fz_append_bits_pad(buf)

def fz_append_buffer(destination, source):
    r"""
    Class-aware wrapper for `::fz_append_buffer()`.
    	Append the contents of the source buffer onto the end of the
    	destination buffer, extending automatically as required.

    	Ownership of buffers does not change.
    """
    return _mupdf.fz_append_buffer(destination, source)

def fz_append_byte(buf, c):
    r"""Class-aware wrapper for `::fz_append_byte()`."""
    return _mupdf.fz_append_byte(buf, c)

def fz_append_data(buf, data, len):
    r"""
    Class-aware wrapper for `::fz_append_data()`.
    	fz_append_*: Append data to a buffer.

    	The buffer will automatically grow as required.
    """
    return _mupdf.fz_append_data(buf, data, len)

def fz_append_image_as_data_uri(out, image):
    r"""Class-aware wrapper for `::fz_append_image_as_data_uri()`."""
    return _mupdf.fz_append_image_as_data_uri(out, image)

def fz_append_int16_be(buf, x):
    r"""Class-aware wrapper for `::fz_append_int16_be()`."""
    return _mupdf.fz_append_int16_be(buf, x)

def fz_append_int16_le(buf, x):
    r"""Class-aware wrapper for `::fz_append_int16_le()`."""
    return _mupdf.fz_append_int16_le(buf, x)

def fz_append_int32_be(buf, x):
    r"""Class-aware wrapper for `::fz_append_int32_be()`."""
    return _mupdf.fz_append_int32_be(buf, x)

def fz_append_int32_le(buf, x):
    r"""Class-aware wrapper for `::fz_append_int32_le()`."""
    return _mupdf.fz_append_int32_le(buf, x)

def fz_append_pdf_string(buffer, text):
    r"""
    Class-aware wrapper for `::fz_append_pdf_string()`.
    	fz_append_pdf_string: Append a string with PDF syntax quotes and
    	escapes.

    	The buffer will automatically grow as required.
    """
    return _mupdf.fz_append_pdf_string(buffer, text)

def fz_append_pixmap_as_data_uri(out, pixmap):
    r"""Class-aware wrapper for `::fz_append_pixmap_as_data_uri()`."""
    return _mupdf.fz_append_pixmap_as_data_uri(out, pixmap)

def fz_append_rune(buf, c):
    r"""Class-aware wrapper for `::fz_append_rune()`."""
    return _mupdf.fz_append_rune(buf, c)

def fz_append_string(buf, data):
    r"""Class-aware wrapper for `::fz_append_string()`."""
    return _mupdf.fz_append_string(buf, data)

def fz_arc4_encrypt(state, dest, src, len):
    r"""
    Class-aware wrapper for `::fz_arc4_encrypt()`.
    	RC4 block encrypt operation; encrypt src into dst (both of
    	length len) updating the RC4 state as we go.

    	Never throws an exception.
    """
    return _mupdf.fz_arc4_encrypt(state, dest, src, len)

def fz_arc4_final(state):
    r"""
    Class-aware wrapper for `::fz_arc4_final()`.
    	RC4 finalization. Zero the context.

    	Never throws an exception.
    """
    return _mupdf.fz_arc4_final(state)

def fz_arc4_init(state, key, len):
    r"""
    Class-aware wrapper for `::fz_arc4_init()`.
    	RC4 initialization. Begins an RC4 operation, writing a new
    	context.

    	Never throws an exception.
    """
    return _mupdf.fz_arc4_init(state, key, len)

def fz_archive_format(arch):
    r"""
    Class-aware wrapper for `::fz_archive_format()`.
    	Return a pointer to a string describing the format of the
    	archive.

    	The lifetime of the string is unspecified (in current
    	implementations the string will persist until the archive
    	is closed, but this is not guaranteed).
    """
    return _mupdf.fz_archive_format(arch)

def fz_atof(s):
    r"""
    Class-aware wrapper for `::fz_atof()`.
    	Range checking atof
    """
    return _mupdf.fz_atof(s)

def fz_atoi(s):
    r"""
    Class-aware wrapper for `::fz_atoi()`.
    	atoi that copes with NULL
    """
    return _mupdf.fz_atoi(s)

def fz_atoi64(s):
    r"""
    Class-aware wrapper for `::fz_atoi64()`.
    	64bit atoi that copes with NULL
    """
    return _mupdf.fz_atoi64(s)

def fz_atoz(s):
    r"""
    Class-aware wrapper for `::fz_atoz()`.
    	size_t atoi that copes with NULL.

    	NOTE: limited to 63bits. Negative numbers
    	are returned as 0.
    """
    return _mupdf.fz_atoz(s)

def fz_authenticate_password(doc, password):
    r"""
    Class-aware wrapper for `::fz_authenticate_password()`.
    	Test if the given password can decrypt the document.

    	password: The password string to be checked. Some document
    	specifications do not specify any particular text encoding, so
    	neither do we.

    	Returns 0 for failure to authenticate, non-zero for success.

    	For PDF documents, further information can be given by examining
    	the bits in the return code.

    		Bit 0 => No password required
    		Bit 1 => User password authenticated
    		Bit 2 => Owner password authenticated
    """
    return _mupdf.fz_authenticate_password(doc, password)

def fz_autowarp_pixmap(src, points):
    r"""Class-aware wrapper for `::fz_autowarp_pixmap()`."""
    return _mupdf.fz_autowarp_pixmap(src, points)

def fz_available(stm, max):
    r"""
    Class-aware wrapper for `::fz_available()`.
    	Ask how many bytes are available immediately from
    	a given stream.

    	stm: The stream to read from.

    	max: A hint for the underlying stream; the maximum number of
    	bytes that we are sure we will want to read. If you do not know
    	this number, give 1.

    	Returns the number of bytes immediately available between the
    	read and write pointers. This number is guaranteed only to be 0
    	if we have hit EOF. The number of bytes returned here need have
    	no relation to max (could be larger, could be smaller).
    """
    return _mupdf.fz_available(stm, max)

def fz_base_colorspace(cs):
    r"""
    Class-aware wrapper for `::fz_base_colorspace()`.
    	Get the 'base' colorspace for a colorspace.

    	For indexed colorspaces, this is the colorspace the index
    	decodes into. For all other colorspaces, it is the colorspace
    	itself.

    	The returned colorspace is 'borrowed' (i.e. no additional
    	references are taken or dropped).
    """
    return _mupdf.fz_base_colorspace(cs)

def fz_basename(path):
    r"""
    Class-aware wrapper for `::fz_basename()`.
    	Find the filename component in a path.
    """
    return _mupdf.fz_basename(path)

def fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha):
    r"""Class-aware wrapper for `::fz_begin_group()`."""
    return _mupdf.fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha)

def fz_begin_layer(dev, layer_name):
    r"""Class-aware wrapper for `::fz_begin_layer()`."""
    return _mupdf.fz_begin_layer(dev, layer_name)

def fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params):
    r"""Class-aware wrapper for `::fz_begin_mask()`."""
    return _mupdf.fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params)

def fz_begin_metatext(dev, meta, text):
    r"""Class-aware wrapper for `::fz_begin_metatext()`."""
    return _mupdf.fz_begin_metatext(dev, meta, text)

def fz_begin_page(wri, mediabox):
    r"""
    Class-aware wrapper for `::fz_begin_page()`.
    	Called to start the process of writing a page to
    	a document.

    	mediabox: page size rectangle in points.

    	Returns a borrowed fz_device to write page contents to. This
    	should be kept if required, and only dropped if it was kept.
    """
    return _mupdf.fz_begin_page(wri, mediabox)

def fz_begin_structure(dev, standard, raw, idx):
    r"""Class-aware wrapper for `::fz_begin_structure()`."""
    return _mupdf.fz_begin_structure(dev, standard, raw, idx)

def fz_begin_tile(dev, area, view, xstep, ystep, ctm):
    r"""Class-aware wrapper for `::fz_begin_tile()`."""
    return _mupdf.fz_begin_tile(dev, area, view, xstep, ystep, ctm)

def fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id):
    r"""Class-aware wrapper for `::fz_begin_tile_id()`."""
    return _mupdf.fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id)

def fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags):
    r"""
     Class-aware wrapper for `::fz_bidi_fragment_text()`.

    	This function has out-params. Python/C# wrappers look like:
    		`fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_fragment_fn *callback, void *arg, int flags)` => ::fz_bidi_direction baseDir

    		Partitions the given Unicode sequence into one or more
    		unidirectional fragments and invokes the given callback
    		function for each fragment.

    		For example, if directionality of text is:
    				0123456789
    				rrlllrrrrr,
    		we'll invoke callback with:
    				&text[0], length == 2
    				&text[2], length == 3
    				&text[5], length == 5

    		:type text: int, in
    :param text:	start of Unicode sequence
        		:type textlen: int, in
    :param textlen:   number of Unicodes to analyse
        		:type baseDir: int, in
    :param baseDir:   direction of paragraph (specify FZ_BIDI_NEUTRAL to force auto-detection)
        		:type callback: ::fz_bidi_fragment_fn, in
    :param callback:  function to be called for each fragment
        		:type arg: void, in
    :param arg:	data to be passed to the callback function
        		:type flags: int, in
    :param flags:     flags to control operation (see fz_bidi_flags above)
    """
    return _mupdf.fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags)

def fz_bitmap_details(bitmap, w, h, n, stride):
    r"""
    Class-aware wrapper for `::fz_bitmap_details()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_bitmap_details(::fz_bitmap *bitmap)` => `(int w, int h, int n, int stride)`

    	Retrieve details of a given bitmap.

    	bitmap: The bitmap to query.

    	w: Pointer to storage to retrieve width (or NULL).

    	h: Pointer to storage to retrieve height (or NULL).

    	n: Pointer to storage to retrieve number of color components (or
    	NULL).

    	stride: Pointer to storage to retrieve bitmap stride (or NULL).
    """
    return _mupdf.fz_bitmap_details(bitmap, w, h, n, stride)

def fz_blendmode_name(blendmode):
    r"""
    Class-aware wrapper for `::fz_blendmode_name()`.
    	Map from enumeration to blend mode string.

    	The string is static, with arbitrary lifespan.
    """
    return _mupdf.fz_blendmode_name(blendmode)

def fz_bound_display_list(list):
    r"""
    Class-aware wrapper for `::fz_bound_display_list()`.
    	Return the bounding box of the page recorded in a display list.
    """
    return _mupdf.fz_bound_display_list(list)

def fz_bound_glyph(font, gid, trm):
    r"""
    Class-aware wrapper for `::fz_bound_glyph()`.
    	Return a bbox for a given glyph in a font.

    	font: The font to look for the glyph in.

    	gid: The glyph to bound.

    	trm: The matrix to apply to the glyph before bounding.

    	Returns rectangle by value containing the bounds of the given
    	glyph.
    """
    return _mupdf.fz_bound_glyph(font, gid, trm)

def fz_bound_page(page):
    r"""
    Class-aware wrapper for `::fz_bound_page()`.
    	Determine the size of a page at 72 dpi.
    """
    return _mupdf.fz_bound_page(page)

def fz_bound_page_box(page, box):
    r"""Class-aware wrapper for `::fz_bound_page_box()`."""
    return _mupdf.fz_bound_page_box(page, box)

def fz_bound_path(path, stroke, ctm):
    r"""
    Class-aware wrapper for `::fz_bound_path()`.
    	Return a bounding rectangle for a path.

    	path: The path to bound.

    	stroke: If NULL, the bounding rectangle given is for
    	the filled path. If non-NULL the bounding rectangle
    	given is for the path stroked with the given attributes.

    	ctm: The matrix to apply to the path during stroking.

    	r: Pointer to a fz_rect which will be used to hold
    	the result.

    	Returns r, updated to contain the bounding rectangle.
    """
    return _mupdf.fz_bound_path(path, stroke, ctm)

def fz_bound_shade(shade, ctm):
    r"""
    Class-aware wrapper for `::fz_bound_shade()`.
    	Bound a given shading.

    	shade: The shade to bound.

    	ctm: The transform to apply to the shade before bounding.

    	r: Pointer to storage to put the bounds in.

    	Returns r, updated to contain the bounds for the shading.
    """
    return _mupdf.fz_bound_shade(shade, ctm)

def fz_bound_text(text, stroke, ctm):
    r"""
    Class-aware wrapper for `::fz_bound_text()`.
    	Find the bounds of a given text object.

    	text: The text object to find the bounds of.

    	stroke: Pointer to the stroke attributes (for stroked
    	text), or NULL (for filled text).

    	ctm: The matrix in use.

    	r: pointer to storage for the bounds.

    	Returns a pointer to r, which is updated to contain the
    	bounding box for the text object.
    """
    return _mupdf.fz_bound_text(text, stroke, ctm)

def fz_box_type_from_string(name):
    r"""Class-aware wrapper for `::fz_box_type_from_string()`."""
    return _mupdf.fz_box_type_from_string(name)

def fz_buffer_extract(buf, data):
    r"""
    Class-aware wrapper for `::fz_buffer_extract()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_buffer_extract(::fz_buffer *buf)` => `(size_t, unsigned char *data)`

    	Take ownership of buffer contents.

    	Performs the same task as fz_buffer_storage, but ownership of
    	the data buffer returns with this call. The buffer is left
    	empty.

    	Note: Bad things may happen if this is called on a buffer with
    	multiple references that is being used from multiple threads.

    	data: Pointer to place to retrieve data pointer.

    	Returns length of stream.
    """
    return _mupdf.fz_buffer_extract(buf, data)

def fz_buffer_storage(buf, datap):
    r"""
    Class-aware wrapper for `::fz_buffer_storage()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_buffer_storage(::fz_buffer *buf)` => `(size_t, unsigned char *datap)`

    	Retrieve internal memory of buffer.

    	datap: Output parameter that will be pointed to the data.

    	Returns the current size of the data in bytes.
    """
    return _mupdf.fz_buffer_storage(buf, datap)

def fz_calloc(count, size):
    r"""
    Class-aware wrapper for `::fz_calloc()`.
    	Allocate array of memory of count entries of size bytes.
    	Clears the memory to zero.

    	Throws exception in the event of failure to allocate.
    """
    return _mupdf.fz_calloc(count, size)

def fz_calloc_no_throw(count, size):
    r"""
    Class-aware wrapper for `::fz_calloc_no_throw()`.
    	fz_calloc equivalent that returns NULL rather than throwing
    	exceptions.
    """
    return _mupdf.fz_calloc_no_throw(count, size)

def fz_caught():
    r"""
    Class-aware wrapper for `::fz_caught()`.
    	Within an fz_catch() block, retrieve the error code for
    	the current exception.

    	This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.fz_caught()

def fz_caught_errno():
    r"""Class-aware wrapper for `::fz_caught_errno()`."""
    return _mupdf.fz_caught_errno()

def fz_caught_message():
    r"""
    Class-aware wrapper for `::fz_caught_message()`.
    	Within an fz_catch() block, retrieve the formatted message
    	string for the current exception.

    	This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.fz_caught_message()

def fz_chartorune(rune, str):
    r"""
    Class-aware wrapper for `::fz_chartorune()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_chartorune(const char *str)` => `(int, int rune)`

    	UTF8 decode a single rune from a sequence of chars.

    	rune: Pointer to an int to assign the decoded 'rune' to.

    	str: Pointer to a UTF8 encoded string.

    	Returns the number of bytes consumed.
    """
    return _mupdf.fz_chartorune(rune, str)

def fz_clamp(x, min, max):
    r"""Class-aware wrapper for `::fz_clamp()`."""
    return _mupdf.fz_clamp(x, min, max)

def fz_clamp64(x, min, max):
    r"""Class-aware wrapper for `::fz_clamp64()`."""
    return _mupdf.fz_clamp64(x, min, max)

def fz_clamp_color(cs, _in, out):
    r"""
    Class-aware wrapper for `::fz_clamp_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_clamp_color(::fz_colorspace *cs, const float *in)` => float out

    	Clamp the samples in a color to the correct ranges for a
    	given colorspace.
    """
    return _mupdf.fz_clamp_color(cs, _in, out)

def fz_clamp_location(doc, loc):
    r"""
    Class-aware wrapper for `::fz_clamp_location()`.
    	Clamps a location into valid chapter/page range. (First clamps
    	the chapter into range, then the page into range).
    """
    return _mupdf.fz_clamp_location(doc, loc)

def fz_clampd(x, min, max):
    r"""Class-aware wrapper for `::fz_clampd()`."""
    return _mupdf.fz_clampd(x, min, max)

def fz_clampi(x, min, max):
    r"""Class-aware wrapper for `::fz_clampi()`."""
    return _mupdf.fz_clampi(x, min, max)

def fz_clampp(x, min, max):
    r"""Class-aware wrapper for `::fz_clampp()`."""
    return _mupdf.fz_clampp(x, min, max)

def fz_cleanname(name):
    r"""
    Class-aware wrapper for `::fz_cleanname()`.
    	rewrite path to the shortest string that names the same path.

    	Eliminates multiple and trailing slashes, interprets "." and
    	"..". Overwrites the string in place.
    """
    return _mupdf.fz_cleanname(name)

def fz_cleanname_strdup(name):
    r"""
    Class-aware wrapper for `::fz_cleanname_strdup()`.
    	rewrite path to the shortest string that names the same path.

    	Eliminates multiple and trailing slashes, interprets "." and
    	"..". Allocates a new string that the caller must free.
    """
    return _mupdf.fz_cleanname_strdup(name)

def fz_clear_bitmap(bit):
    r"""
    Class-aware wrapper for `::fz_clear_bitmap()`.
    	Set the entire bitmap to 0.

    	Never throws exceptions.
    """
    return _mupdf.fz_clear_bitmap(bit)

def fz_clear_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_clear_buffer()`.
    	Empties the buffer. Storage is not freed, but is held ready
    	to be reused as the buffer is refilled.

    	Never throws exceptions.
    """
    return _mupdf.fz_clear_buffer(buf)

def fz_clear_pixmap(pix):
    r"""
    Class-aware wrapper for `::fz_clear_pixmap()`.
    	Sets all components (including alpha) of
    	all pixels in a pixmap to 0.

    	pix: The pixmap to clear.
    """
    return _mupdf.fz_clear_pixmap(pix)

def fz_clear_pixmap_rect_with_value(pix, value, r):
    r"""
    Class-aware wrapper for `::fz_clear_pixmap_rect_with_value()`.
    	Clears a subrect of a pixmap with the given value.

    	pix: The pixmap to clear.

    	value: Values in the range 0 to 255 are valid. Each component
    	sample for each pixel in the pixmap will be set to this value,
    	while alpha will always be set to 255 (non-transparent).

    	r: the rectangle.
    """
    return _mupdf.fz_clear_pixmap_rect_with_value(pix, value, r)

def fz_clear_pixmap_with_value(pix, value):
    r"""
    Class-aware wrapper for `::fz_clear_pixmap_with_value()`.
    	Clears a pixmap with the given value.

    	pix: The pixmap to clear.

    	value: Values in the range 0 to 255 are valid. Each component
    	sample for each pixel in the pixmap will be set to this value,
    	while alpha will always be set to 255 (non-transparent).

    	This function is horrible, and should be removed from the
    	API and replaced with a less magic one.
    """
    return _mupdf.fz_clear_pixmap_with_value(pix, value)

def fz_clip_image_mask(dev, image, ctm, scissor):
    r"""Class-aware wrapper for `::fz_clip_image_mask()`."""
    return _mupdf.fz_clip_image_mask(dev, image, ctm, scissor)

def fz_clip_path(dev, path, even_odd, ctm, scissor):
    r"""Class-aware wrapper for `::fz_clip_path()`."""
    return _mupdf.fz_clip_path(dev, path, even_odd, ctm, scissor)

def fz_clip_stroke_path(dev, path, stroke, ctm, scissor):
    r"""Class-aware wrapper for `::fz_clip_stroke_path()`."""
    return _mupdf.fz_clip_stroke_path(dev, path, stroke, ctm, scissor)

def fz_clip_stroke_text(dev, text, stroke, ctm, scissor):
    r"""Class-aware wrapper for `::fz_clip_stroke_text()`."""
    return _mupdf.fz_clip_stroke_text(dev, text, stroke, ctm, scissor)

def fz_clip_text(dev, text, ctm, scissor):
    r"""Class-aware wrapper for `::fz_clip_text()`."""
    return _mupdf.fz_clip_text(dev, text, ctm, scissor)

def fz_clone_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_clone_buffer()`.
    	Make a new buffer, containing a copy of the data used in
    	the original.
    """
    return _mupdf.fz_clone_buffer(buf)

def fz_clone_default_colorspaces(base):
    r"""
    Class-aware wrapper for `::fz_clone_default_colorspaces()`.
    	Returns a reference to a newly cloned default colorspaces
    	structure.

    	The new clone may safely be altered without fear of race
    	conditions as the caller is the only reference holder.
    """
    return _mupdf.fz_clone_default_colorspaces(base)

def fz_clone_path(path):
    r"""
    Class-aware wrapper for `::fz_clone_path()`.
    	Clone the data for a path.

    	This is used in preference to fz_keep_path when a whole
    	new copy of a path is required, rather than just a shared
    	pointer. This probably indicates that the path is about to
    	be modified.

    	path: path to clone.

    	Throws exceptions on failure to allocate.
    """
    return _mupdf.fz_clone_path(path)

def fz_clone_pixmap(old):
    r"""
    Class-aware wrapper for `::fz_clone_pixmap()`.
    	Clone a pixmap, copying the pixels and associated data to new
    	storage.

    	The reference count of 'old' is unchanged.
    """
    return _mupdf.fz_clone_pixmap(old)

def fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs):
    r"""Class-aware wrapper for `::fz_clone_pixmap_area_with_different_seps()`."""
    return _mupdf.fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs)

def fz_clone_separations_for_overprint(seps):
    r"""
    Class-aware wrapper for `::fz_clone_separations_for_overprint()`.
    	Return a separations object with all the spots in the input
    	separations object that are set to composite, reset to be
    	enabled. If there ARE no spots in the object, this returns
    	NULL. If the object already has all its spots enabled, then
    	just returns another handle on the same object.
    """
    return _mupdf.fz_clone_separations_for_overprint(seps)

def fz_clone_stroke_state(stroke):
    r"""
    Class-aware wrapper for `::fz_clone_stroke_state()`.
    	Create an identical stroke_state structure and return a
    	reference to it.

    	stroke: The stroke state reference to clone.

    	Exceptions may be thrown in the event of a failure to
    	allocate.
    """
    return _mupdf.fz_clone_stroke_state(stroke)

def fz_close_band_writer(writer):
    r"""
    Class-aware wrapper for `::fz_close_band_writer()`.
    	Finishes up the output and closes the band writer. After this
    	call no more headers or bands may be written.
    """
    return _mupdf.fz_close_band_writer(writer)

def fz_close_device(dev):
    r"""
    Class-aware wrapper for `::fz_close_device()`.
    	Signal the end of input, and flush any buffered output.
    	This is NOT called implicitly on fz_drop_device. This
    	may throw exceptions.
    """
    return _mupdf.fz_close_device(dev)

def fz_close_document_writer(wri):
    r"""
    Class-aware wrapper for `::fz_close_document_writer()`.
    	Called to end the process of writing
    	pages to a document.

    	This writes any file level trailers required. After this
    	completes successfully the file is up to date and complete.
    """
    return _mupdf.fz_close_document_writer(wri)

def fz_close_output(arg_0):
    r"""
    Class-aware wrapper for `::fz_close_output()`.
    	Flush pending output and close an output stream.
    """
    return _mupdf.fz_close_output(arg_0)

def fz_close_zip_writer(zip):
    r"""
    Class-aware wrapper for `::fz_close_zip_writer()`.
    	Close the zip file for writing.

    	This flushes any pending data to the file. This can throw
    	exceptions.
    """
    return _mupdf.fz_close_zip_writer(zip)

def fz_closepath(path):
    r"""
    Class-aware wrapper for `::fz_closepath()`.
    	Close the current subpath.

    	path: The path to modify.

    	Throws exceptions on failure to allocate, attempting to modify
    	a packed path, and illegal path closes (i.e. closing a non open
    	path).
    """
    return _mupdf.fz_closepath(path)

def fz_colorspace_colorant(cs, n):
    r"""
    Class-aware wrapper for `::fz_colorspace_colorant()`.
    	Retrieve a the name for a colorant.

    	Returns a pointer with the same lifespan as the colorspace.
    """
    return _mupdf.fz_colorspace_colorant(cs, n)

def fz_colorspace_device_n_has_cmyk(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_device_n_has_cmyk()`.
    	True if DeviceN color space has cyan magenta yellow or black as
    	one of its colorants.
    """
    return _mupdf.fz_colorspace_device_n_has_cmyk(cs)

def fz_colorspace_device_n_has_only_cmyk(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.
    	True if DeviceN color space has only colorants from the CMYK set.
    """
    return _mupdf.fz_colorspace_device_n_has_only_cmyk(cs)

def fz_colorspace_is_cmyk(cs):
    r"""Class-aware wrapper for `::fz_colorspace_is_cmyk()`."""
    return _mupdf.fz_colorspace_is_cmyk(cs)

def fz_colorspace_is_device(cs):
    r"""Class-aware wrapper for `::fz_colorspace_is_device()`."""
    return _mupdf.fz_colorspace_is_device(cs)

def fz_colorspace_is_device_cmyk(cs):
    r"""Class-aware wrapper for `::fz_colorspace_is_device_cmyk()`."""
    return _mupdf.fz_colorspace_is_device_cmyk(cs)

def fz_colorspace_is_device_gray(cs):
    r"""Class-aware wrapper for `::fz_colorspace_is_device_gray()`."""
    return _mupdf.fz_colorspace_is_device_gray(cs)

def fz_colorspace_is_device_n(cs):
    r"""Class-aware wrapper for `::fz_colorspace_is_device_n()`."""
    return _mupdf.fz_colorspace_is_device_n(cs)

def fz_colorspace_is_gray(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_is_gray()`.
    	Tests for particular types of colorspaces
    """
    return _mupdf.fz_colorspace_is_gray(cs)

def fz_colorspace_is_indexed(cs):
    r"""Class-aware wrapper for `::fz_colorspace_is_indexed()`."""
    return _mupdf.fz_colorspace_is_indexed(cs)

def fz_colorspace_is_lab(cs):
    r"""Class-aware wrapper for `::fz_colorspace_is_lab()`."""
    return _mupdf.fz_colorspace_is_lab(cs)

def fz_colorspace_is_lab_icc(cs):
    r"""Class-aware wrapper for `::fz_colorspace_is_lab_icc()`."""
    return _mupdf.fz_colorspace_is_lab_icc(cs)

def fz_colorspace_is_rgb(cs):
    r"""Class-aware wrapper for `::fz_colorspace_is_rgb()`."""
    return _mupdf.fz_colorspace_is_rgb(cs)

def fz_colorspace_is_subtractive(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_is_subtractive()`.
    	True for CMYK, Separation and DeviceN colorspaces.
    """
    return _mupdf.fz_colorspace_is_subtractive(cs)

def fz_colorspace_n(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_n()`.
    	Query the number of colorants in a colorspace.
    """
    return _mupdf.fz_colorspace_n(cs)

def fz_colorspace_name(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_name()`.
    	Query the name of a colorspace.

    	The returned string has the same lifespan as the colorspace
    	does. Caller should not free it.
    """
    return _mupdf.fz_colorspace_name(cs)

def fz_colorspace_name_colorant(cs, n, name):
    r"""
    Class-aware wrapper for `::fz_colorspace_name_colorant()`.
    	Assign a name for a given colorant in a colorspace.

    	Used while initially setting up a colorspace. The string is
    	copied into local storage, so need not be retained by the
    	caller.
    """
    return _mupdf.fz_colorspace_name_colorant(cs, n, name)

def fz_colorspace_type(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_type()`.
    	Query the type of colorspace.
    """
    return _mupdf.fz_colorspace_type(cs)

def fz_compare_separations(sep1, sep2):
    r"""
    Class-aware wrapper for `::fz_compare_separations()`.
    	Compare 2 separations structures (or NULLs).

    	Return 0 if identical, non-zero if not identical.
    """
    return _mupdf.fz_compare_separations(sep1, sep2)

def fz_compress_ccitt_fax_g3(data, columns, rows, stride):
    r"""
    Class-aware wrapper for `::fz_compress_ccitt_fax_g3()`.
    	Compress bitmap data as CCITT Group 3 1D fax image.
    	Creates a stream assuming the default PDF parameters,
    	except the number of columns.
    """
    return _mupdf.fz_compress_ccitt_fax_g3(data, columns, rows, stride)

def fz_compress_ccitt_fax_g4(data, columns, rows, stride):
    r"""
    Class-aware wrapper for `::fz_compress_ccitt_fax_g4()`.
    	Compress bitmap data as CCITT Group 4 2D fax image.
    	Creates a stream assuming the default PDF parameters, except
    	K=-1 and the number of columns.
    """
    return _mupdf.fz_compress_ccitt_fax_g4(data, columns, rows, stride)

def fz_compressed_buffer_size(buffer):
    r"""
    Class-aware wrapper for `::fz_compressed_buffer_size()`.
    	Return the storage size used for a buffer and its data.
    	Used in implementing store handling.

    	Never throws exceptions.
    """
    return _mupdf.fz_compressed_buffer_size(buffer)

def fz_compressed_image_buffer(image):
    r"""
    Class-aware wrapper for `::fz_compressed_image_buffer()`.
    	Retrieve the underlying compressed data for an image.

    	Returns a pointer to the underlying data buffer for an image,
    	or NULL if this image is not based upon a compressed data
    	buffer.

    	This is not a reference counted structure, so no reference is
    	returned. Lifespan is limited to that of the image itself.
    """
    return _mupdf.fz_compressed_image_buffer(image)

def fz_compressed_image_type(image):
    r"""
    Class-aware wrapper for `::fz_compressed_image_type()`.
    	Return the type of a compressed image.

    	Any non-compressed image will have the type returned as UNKNOWN.
    """
    return _mupdf.fz_compressed_image_type(image)

def fz_concat(left, right):
    r"""
    Class-aware wrapper for `::fz_concat()`.
    	Multiply two matrices.

    	The order of the two matrices are important since matrix
    	multiplication is not commutative.

    	Returns result.
    """
    return _mupdf.fz_concat(left, right)

def fz_contains_rect(a, b):
    r"""
    Class-aware wrapper for `::fz_contains_rect()`.
    	Test rectangle inclusion.

    	Return true if a entirely contains b.
    """
    return _mupdf.fz_contains_rect(a, b)

def fz_convert_color(ss, sv, ds, dv, _is, params):
    r"""
    Class-aware wrapper for `::fz_convert_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_convert_color(::fz_colorspace *ss, const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv

    	Convert color values sv from colorspace ss into colorvalues dv
    	for colorspace ds, via an optional intervening space is,
    	respecting the given color_params.
    """
    return _mupdf.fz_convert_color(ss, sv, ds, dv, _is, params)

def fz_convert_error(code):
    r"""
    Class-aware wrapper for `::fz_convert_error()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_convert_error()` => `(const char *, int code)`
    """
    return _mupdf.fz_convert_error(code)

def fz_convert_indexed_pixmap_to_base(src):
    r"""
    Class-aware wrapper for `::fz_convert_indexed_pixmap_to_base()`.
    	Convert pixmap from indexed to base colorspace.

    	This creates a new bitmap containing the converted pixmap data.
    """
    return _mupdf.fz_convert_indexed_pixmap_to_base(src)

def fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha):
    r"""
    Class-aware wrapper for `::fz_convert_pixmap()`.
    	Convert an existing pixmap to a desired
    	colorspace. Other properties of the pixmap, such as resolution
    	and position are copied to the converted pixmap.

    	pix: The pixmap to convert.

    	default_cs: If NULL pix->colorspace is used. It is possible that
    	the data may need to be interpreted as one of the color spaces
    	in default_cs.

    	cs_des: Desired colorspace, may be NULL to denote alpha-only.

    	prf: Proofing color space through which we need to convert.

    	color_params: Parameters that may be used in conversion (e.g.
    	ri).

    	keep_alpha: If 0 any alpha component is removed, otherwise
    	alpha is kept if present in the pixmap.
    """
    return _mupdf.fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha)

def fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params):
    r"""
    Class-aware wrapper for `::fz_convert_separation_colors()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_convert_separation_colors(::fz_colorspace *src_cs, const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color

    	Convert a color given in terms of one colorspace,
    	to a color in terms of another colorspace/separations.
    """
    return _mupdf.fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params)

def fz_convert_separation_pixmap_to_base(src):
    r"""
    Class-aware wrapper for `::fz_convert_separation_pixmap_to_base()`.
    	Convert pixmap from DeviceN/Separation to base colorspace.

    	This creates a new bitmap containing the converted pixmap data.
    """
    return _mupdf.fz_convert_separation_pixmap_to_base(src)

def fz_copy_option(val, dest, maxlen):
    r"""
    Class-aware wrapper for `::fz_copy_option()`.
    	Copy an option (val) into a destination buffer (dest), of maxlen
    	bytes.

    	Returns the number of bytes (including terminator) that did not
    	fit. If val is maxlen or greater bytes in size, it will be left
    	unterminated.
    """
    return _mupdf.fz_copy_option(val, dest, maxlen)

def fz_copy_pixmap_rect(dest, src, r, default_cs):
    r"""Class-aware wrapper for `::fz_copy_pixmap_rect()`."""
    return _mupdf.fz_copy_pixmap_rect(dest, src, r, default_cs)

def fz_copy_rectangle(page, area, crlf):
    r"""
    Class-aware wrapper for `::fz_copy_rectangle()`.
    	Return a newly allocated UTF-8 string with the text for a given
    	selection rectangle.

    	crlf: If true, write "\r\n" style line endings (otherwise "\n"
    	only).
    """
    return _mupdf.fz_copy_rectangle(page, area, crlf)

def fz_copy_selection(page, a, b, crlf):
    r"""
    Class-aware wrapper for `::fz_copy_selection()`.
    	Return a newly allocated UTF-8 string with the text for a given
    	selection.

    	crlf: If true, write "\r\n" style line endings (otherwise "\n"
    	only).
    """
    return _mupdf.fz_copy_selection(page, a, b, crlf)

def fz_count_active_separations(seps):
    r"""
    Class-aware wrapper for `::fz_count_active_separations()`.
    	Return the number of active separations.
    """
    return _mupdf.fz_count_active_separations(seps)

def fz_count_archive_entries(arch):
    r"""
    Class-aware wrapper for `::fz_count_archive_entries()`.
    	Number of entries in archive.

    	Will always return a value >= 0.

    	May throw an exception if this type of archive cannot count the
    	entries (such as a directory).
    """
    return _mupdf.fz_count_archive_entries(arch)

def fz_count_chapter_pages(doc, chapter):
    r"""
    Class-aware wrapper for `::fz_count_chapter_pages()`.
    	Return the number of pages in a chapter.
    	May return 0.
    """
    return _mupdf.fz_count_chapter_pages(doc, chapter)

def fz_count_chapters(doc):
    r"""
    Class-aware wrapper for `::fz_count_chapters()`.
    	Return the number of chapters in the document.
    	At least 1.
    """
    return _mupdf.fz_count_chapters(doc)

def fz_count_pages(doc):
    r"""
    Class-aware wrapper for `::fz_count_pages()`.
    	Return the number of pages in document

    	May return 0 for documents with no pages.
    """
    return _mupdf.fz_count_pages(doc)

def fz_count_separations(sep):
    r"""Class-aware wrapper for `::fz_count_separations()`."""
    return _mupdf.fz_count_separations(sep)

def fz_create_link(page, bbox, uri):
    r"""
    Class-aware wrapper for `::fz_create_link()`.
    	Create a new link on a page.
    """
    return _mupdf.fz_create_link(page, bbox, uri)

def fz_currentpoint(path):
    r"""
    Class-aware wrapper for `::fz_currentpoint()`.
    	Return the current point that a path has
    	reached or (0,0) if empty.

    	path: path to return the current point of.
    """
    return _mupdf.fz_currentpoint(path)

def fz_curveto(path, x0, y0, x1, y1, x2, y2):
    r"""
    Class-aware wrapper for `::fz_curveto()`.
    	Append a 'curveto' command to an open path. (For a
    	cubic bezier).

    	path: The path to modify.

    	x0, y0: The coordinates of the first control point for the
    	curve.

    	x1, y1: The coordinates of the second control point for the
    	curve.

    	x2, y2: The end coordinates for the curve.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_curveto(path, x0, y0, x1, y1, x2, y2)

def fz_curvetov(path, x1, y1, x2, y2):
    r"""
    Class-aware wrapper for `::fz_curvetov()`.
    	Append a 'curvetov' command to an open path. (For a
    	cubic bezier with the first control coordinate equal to
    	the start point).

    	path: The path to modify.

    	x1, y1: The coordinates of the second control point for the
    	curve.

    	x2, y2: The end coordinates for the curve.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_curvetov(path, x1, y1, x2, y2)

def fz_curvetoy(path, x0, y0, x2, y2):
    r"""
    Class-aware wrapper for `::fz_curvetoy()`.
    	Append a 'curvetoy' command to an open path. (For a
    	cubic bezier with the second control coordinate equal to
    	the end point).

    	path: The path to modify.

    	x0, y0: The coordinates of the first control point for the
    	curve.

    	x2, y2: The end coordinates for the curve (and the second
    	control coordinate).

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_curvetoy(path, x0, y0, x2, y2)

def fz_debug_store(out):
    r"""
    Class-aware wrapper for `::fz_debug_store()`.
    	Output debugging information for the current state of the store
    	to the given output channel.
    """
    return _mupdf.fz_debug_store(out)

def fz_debug_xml(item, level):
    r"""
    Class-aware wrapper for `::fz_debug_xml()`.
    	Pretty-print an XML tree to stdout. (Deprecated, use
    	fz_output_xml in preference).
    """
    return _mupdf.fz_debug_xml(item, level)

def fz_decode_tile(pix, decode):
    r"""Class-aware wrapper for `::fz_decode_tile()`."""
    return _mupdf.fz_decode_tile(pix, decode)

def fz_decode_uri(s):
    r"""
     Class-aware wrapper for `::fz_decode_uri()`.
    Return a new string representing the unencoded version of the given URI.
    This decodes all escape sequences except those that would result in a reserved
    character that are part of the URI syntax (; / ? : @ & = + $ , #).
    """
    return _mupdf.fz_decode_uri(s)

def fz_decode_uri_component(s):
    r"""
     Class-aware wrapper for `::fz_decode_uri_component()`.
    Return a new string representing the unencoded version of the given URI component.
    This decodes all escape sequences!
    """
    return _mupdf.fz_decode_uri_component(s)

def fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra):
    r"""
    Class-aware wrapper for `::fz_decomp_image_from_stream()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_decomp_image_from_stream(::fz_stream *stm, ::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`

    	Decode a subarea of a compressed image. l2factor is the amount
    	of subsampling inbuilt to the stream (i.e. performed by the
    	decoder). If non NULL, l2extra is the extra amount of
    	subsampling that should be performed by this routine. This will
    	be updated on exit to the amount of subsampling that is still
    	required to be done.

    	Returns a kept reference.
    """
    return _mupdf.fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra)

def fz_decouple_type3_font(font, t3doc):
    r"""Class-aware wrapper for `::fz_decouple_type3_font()`."""
    return _mupdf.fz_decouple_type3_font(font, t3doc)

def fz_default_cmyk(default_cs):
    r"""Class-aware wrapper for `::fz_default_cmyk()`."""
    return _mupdf.fz_default_cmyk(default_cs)

def fz_default_error_callback(user, message):
    r"""
    Class-aware wrapper for `::fz_default_error_callback()`.
    	FIXME: Better not to expose fz_default_error_callback, and
    	fz_default_warning callback and to allow 'NULL' to be used
    	int fz_set_xxxx_callback to mean "defaults".

    	FIXME: Do we need/want functions like
    	fz_error_callback(ctx, message) to allow callers to inject
    	stuff into the error/warning streams?

    	The default error callback. Declared publicly just so that the
    	error callback can be set back to this after it has been
    	overridden.
    """
    return _mupdf.fz_default_error_callback(user, message)

def fz_default_gray(default_cs):
    r"""
    Class-aware wrapper for `::fz_default_gray()`.
    	Retrieve default colorspaces (typically page local).

    	If default_cs is non NULL, the default is retrieved from there,
    	otherwise the global default is retrieved.

    	These return borrowed references that should not be dropped,
    	unless they are kept first.
    """
    return _mupdf.fz_default_gray(default_cs)

def fz_default_halftone(num_comps):
    r"""
    Class-aware wrapper for `::fz_default_halftone()`.
    	Create a 'default' halftone structure
    	for the given number of components.

    	num_comps: The number of components to use.

    	Returns a simple default halftone. The default halftone uses
    	the same halftone tile for each plane, which may not be ideal
    	for all purposes.
    """
    return _mupdf.fz_default_halftone(num_comps)

def fz_default_output_intent(default_cs):
    r"""Class-aware wrapper for `::fz_default_output_intent()`."""
    return _mupdf.fz_default_output_intent(default_cs)

def fz_default_rgb(default_cs):
    r"""Class-aware wrapper for `::fz_default_rgb()`."""
    return _mupdf.fz_default_rgb(default_cs)

def fz_default_warning_callback(user, message):
    r"""
    Class-aware wrapper for `::fz_default_warning_callback()`.
    	The default warning callback. Declared publicly just so that
    	the warning callback can be set back to this after it has been
    	overridden.
    """
    return _mupdf.fz_default_warning_callback(user, message)

def fz_defer_reap_end():
    r"""
    Class-aware wrapper for `::fz_defer_reap_end()`.
    	Decrement the defer reap count.

    	If the defer reap count returns to 0, and the store
    	has reapable objects in, a reap pass will begin.

    	Call this at the end of a process during which you
    	potentially might drop many reapable objects.

    	It is vital that every fz_defer_reap_start is matched
    	by a fz_defer_reap_end call.
    """
    return _mupdf.fz_defer_reap_end()

def fz_defer_reap_start():
    r"""
    Class-aware wrapper for `::fz_defer_reap_start()`.
    	Increment the defer reap count.

    	No reap operations will take place (except for those
    	triggered by an immediate failed malloc) until the
    	defer reap count returns to 0.

    	Call this at the start of a process during which you
    	potentially might drop many reapable objects.

    	It is vital that every fz_defer_reap_start is matched
    	by a fz_defer_reap_end call.
    """
    return _mupdf.fz_defer_reap_start()

def fz_deflate(dest, compressed_length, source, source_length, level):
    r"""
     Class-aware wrapper for `::fz_deflate()`.

    	This function has out-params. Python/C# wrappers look like:
    		`fz_deflate(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => size_t compressed_length

    		Compress source_length bytes of data starting
    		at source, into a buffer of length *destLen, starting at dest.
    compressed_length will be updated on exit to contain the size
    		actually used.
    """
    return _mupdf.fz_deflate(dest, compressed_length, source, source_length, level)

def fz_deflate_bound(size):
    r"""
    Class-aware wrapper for `::fz_deflate_bound()`.
    	Returns the upper bound on the
    	size of flated data of length size.
    """
    return _mupdf.fz_deflate_bound(size)

def fz_delete_link(page, link):
    r"""
    Class-aware wrapper for `::fz_delete_link()`.
    	Delete an existing link on a page.
    """
    return _mupdf.fz_delete_link(page, link)

def fz_deskew_pixmap(src, degrees, border):
    r"""Class-aware wrapper for `::fz_deskew_pixmap()`."""
    return _mupdf.fz_deskew_pixmap(src, degrees, border)

def fz_detach_xml(node):
    r"""
    Class-aware wrapper for `::fz_detach_xml()`.
    	Detach a node from the tree, unlinking it from its parent,
    	and setting the document root to the node.
    """
    return _mupdf.fz_detach_xml(node)

def fz_detect_document(points, src):
    r"""Class-aware wrapper for `::fz_detect_document()`."""
    return _mupdf.fz_detect_document(points, src)

def fz_device_bgr():
    r"""Class-aware wrapper for `::fz_device_bgr()`."""
    return _mupdf.fz_device_bgr()

def fz_device_cmyk():
    r"""Class-aware wrapper for `::fz_device_cmyk()`."""
    return _mupdf.fz_device_cmyk()

def fz_device_current_scissor(dev):
    r"""
    Class-aware wrapper for `::fz_device_current_scissor()`.
    	Find current scissor region as tracked by the device.
    """
    return _mupdf.fz_device_current_scissor(dev)

def fz_device_gray():
    r"""
    Class-aware wrapper for `::fz_device_gray()`.
    	Retrieve global default colorspaces.

    	These return borrowed references that should not be dropped,
    	unless they are kept first.
    """
    return _mupdf.fz_device_gray()

def fz_device_lab():
    r"""Class-aware wrapper for `::fz_device_lab()`."""
    return _mupdf.fz_device_lab()

def fz_device_rgb():
    r"""Class-aware wrapper for `::fz_device_rgb()`."""
    return _mupdf.fz_device_rgb()

def fz_dirname(dir, path, dirsize):
    r"""
    Class-aware wrapper for `::fz_dirname()`.
    	extract the directory component from a path.
    """
    return _mupdf.fz_dirname(dir, path, dirsize)

def fz_disable_device_hints(dev, hints):
    r"""
    Class-aware wrapper for `::fz_disable_device_hints()`.
    	Disable (clear) hint bits within the hint bitfield for a device.
    """
    return _mupdf.fz_disable_device_hints(dev, hints)

def fz_disable_icc():
    r"""
    Class-aware wrapper for `::fz_disable_icc()`.
    	Disable icc profile based operation.
    """
    return _mupdf.fz_disable_icc()

def fz_display_list_is_empty(list):
    r"""
    Class-aware wrapper for `::fz_display_list_is_empty()`.
    	Check for a display list being empty

    	list: The list to check.

    	Returns true if empty, false otherwise.
    """
    return _mupdf.fz_display_list_is_empty(list)

def fz_div255(c, a):
    r"""
    Class-aware wrapper for `::fz_div255()`.
    	Undo alpha premultiplication.
    """
    return _mupdf.fz_div255(c, a)

def fz_do_always():
    r"""Class-aware wrapper for `::fz_do_always()`."""
    return _mupdf.fz_do_always()

def fz_do_catch():
    r"""Class-aware wrapper for `::fz_do_catch()`."""
    return _mupdf.fz_do_catch()

def fz_do_try():
    r"""Class-aware wrapper for `::fz_do_try()`."""
    return _mupdf.fz_do_try()

def fz_document_handler_open(handler, stream, accel, dir, recognize_state):
    r"""
    Class-aware wrapper for `::fz_document_handler_open()`.   Helper for calling `fz_document_handler::open` function pointer via
    Swig from Python/C#.
    """
    return _mupdf.fz_document_handler_open(handler, stream, accel, dir, recognize_state)

def fz_document_handler_recognize(handler, magic):
    r"""
    Class-aware wrapper for `::fz_document_handler_recognize()`.   Helper for calling a `fz_document_handler::recognize` function
    pointer via Swig from Python/C#.
    """
    return _mupdf.fz_document_handler_recognize(handler, magic)

def fz_document_output_intent(doc):
    r"""
    Class-aware wrapper for `::fz_document_output_intent()`.
    	Find the output intent colorspace if the document has defined
    	one.

    	Returns a borrowed reference that should not be dropped, unless
    	it is kept first.
    """
    return _mupdf.fz_document_output_intent(doc)

def fz_document_supports_accelerator(doc):
    r"""
    Class-aware wrapper for `::fz_document_supports_accelerator()`.
    	Query if the document supports the saving of accelerator data.
    """
    return _mupdf.fz_document_supports_accelerator(doc)

def fz_dom_add_attribute(elt, att, value):
    r"""
    Class-aware wrapper for `::fz_dom_add_attribute()`.
    	Add an attribute to an element.

    	Ownership of att and value remain with the caller.
    """
    return _mupdf.fz_dom_add_attribute(elt, att, value)

def fz_dom_append_child(parent, child):
    r"""
    Class-aware wrapper for `::fz_dom_append_child()`.
    	Insert an element as the last child of a parent, unlinking the
    	child from its current position if required.
    """
    return _mupdf.fz_dom_append_child(parent, child)

def fz_dom_attribute(elt, att):
    r"""
    Class-aware wrapper for `::fz_dom_attribute()`.
    	Retrieve the value of a given attribute from a given element.

    	Returns a borrowed pointer to the value or NULL if not found.
    """
    return _mupdf.fz_dom_attribute(elt, att)

def fz_dom_body(dom):
    r"""
    Class-aware wrapper for `::fz_dom_body()`.
    	Return a borrowed reference for the 'body' element of
    	the given DOM.
    """
    return _mupdf.fz_dom_body(dom)

def fz_dom_clone(elt):
    r"""
    Class-aware wrapper for `::fz_dom_clone()`.
    	Clone an element (and its children).

    	A borrowed reference to the clone is returned. The clone is not
    	yet linked into the DOM.
    """
    return _mupdf.fz_dom_clone(elt)

def fz_dom_create_element(dom, tag):
    r"""
    Class-aware wrapper for `::fz_dom_create_element()`.
    	Create an element of a given tag type for the given DOM.

    	The element is not linked into the DOM yet.
    """
    return _mupdf.fz_dom_create_element(dom, tag)

def fz_dom_create_text_node(dom, text):
    r"""
    Class-aware wrapper for `::fz_dom_create_text_node()`.
    	Create a text node for the given DOM.

    	The element is not linked into the DOM yet.
    """
    return _mupdf.fz_dom_create_text_node(dom, text)

def fz_dom_document_element(dom):
    r"""
    Class-aware wrapper for `::fz_dom_document_element()`.
    	Return a borrowed reference for the document (the top
    	level element) of the DOM.
    """
    return _mupdf.fz_dom_document_element(dom)

def fz_dom_find(elt, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_dom_find()`.
    	Find the first element matching the requirements in a depth first traversal from elt.

    	The tagname must match tag, unless tag is NULL, when all tag names are considered to match.

    	If att is NULL, then all tags match.
    	Otherwise:
    		If match is NULL, then only nodes that have an att attribute match.
    		If match is non-NULL, then only nodes that have an att attribute that matches match match.

    	Returns NULL (if no match found), or a borrowed reference to the first matching element.
    """
    return _mupdf.fz_dom_find(elt, tag, att, match)

def fz_dom_find_next(elt, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_dom_find_next()`.
    	Find the next element matching the requirements.
    """
    return _mupdf.fz_dom_find_next(elt, tag, att, match)

def fz_dom_first_child(elt):
    r"""
    Class-aware wrapper for `::fz_dom_first_child()`.
    	Return a borrowed reference to the first child of a node,
    	or NULL if there isn't one.
    """
    return _mupdf.fz_dom_first_child(elt)

def fz_dom_get_attribute(elt, i, att):
    r"""
    Class-aware wrapper for `::fz_dom_get_attribute()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_dom_get_attribute(::fz_xml *elt, int i)` => `(const char *, const char *att)`

    	Enumerate through the attributes of an element.

    	Call with i=0,1,2,3... to enumerate attributes.

    	On return *att and the return value will be NULL if there are not
    	that many attributes to read. Otherwise, *att will be filled in
    	with a borrowed pointer to the attribute name, and the return
    	value will be a borrowed pointer to the value.
    """
    return _mupdf.fz_dom_get_attribute(elt, i, att)

def fz_dom_insert_after(node, new_elt):
    r"""
    Class-aware wrapper for `::fz_dom_insert_after()`.
    	Insert an element (new_elt), after another element (node),
    	unlinking the new_elt from its current position if required.
    """
    return _mupdf.fz_dom_insert_after(node, new_elt)

def fz_dom_insert_before(node, new_elt):
    r"""
    Class-aware wrapper for `::fz_dom_insert_before()`.
    	Insert an element (new_elt), before another element (node),
    	unlinking the new_elt from its current position if required.
    """
    return _mupdf.fz_dom_insert_before(node, new_elt)

def fz_dom_next(elt):
    r"""
    Class-aware wrapper for `::fz_dom_next()`.
    	Return a borrowed reference to the next sibling of a node,
    	or NULL if there isn't one.
    """
    return _mupdf.fz_dom_next(elt)

def fz_dom_parent(elt):
    r"""
    Class-aware wrapper for `::fz_dom_parent()`.
    	Return a borrowed reference to the parent of a node,
    	or NULL if there isn't one.
    """
    return _mupdf.fz_dom_parent(elt)

def fz_dom_previous(elt):
    r"""
    Class-aware wrapper for `::fz_dom_previous()`.
    	Return a borrowed reference to the previous sibling of a node,
    	or NULL if there isn't one.
    """
    return _mupdf.fz_dom_previous(elt)

def fz_dom_remove(elt):
    r"""
    Class-aware wrapper for `::fz_dom_remove()`.
    	Remove an element from the DOM. The element can be added back elsewhere
    	if required.

    	No reference counting changes for the element.
    """
    return _mupdf.fz_dom_remove(elt)

def fz_dom_remove_attribute(elt, att):
    r"""
    Class-aware wrapper for `::fz_dom_remove_attribute()`.
    	Remove an attribute from an element.
    """
    return _mupdf.fz_dom_remove_attribute(elt, att)

def fz_draw_story(story, dev, ctm):
    r"""Class-aware wrapper for `::fz_draw_story()`."""
    return _mupdf.fz_draw_story(story, dev, ctm)

def fz_dump_glyph_cache_stats(out):
    r"""
    Class-aware wrapper for `::fz_dump_glyph_cache_stats()`.
    	Dump debug statistics for the glyph cache.
    """
    return _mupdf.fz_dump_glyph_cache_stats(out)

def fz_duplicate_glyph_names_from_unicode(unicode):
    r"""Class-aware wrapper for `::fz_duplicate_glyph_names_from_unicode()`."""
    return _mupdf.fz_duplicate_glyph_names_from_unicode(unicode)

def fz_empty_store():
    r"""
    Class-aware wrapper for `::fz_empty_store()`.
    	Evict every item from the store.
    """
    return _mupdf.fz_empty_store()

def fz_enable_device_hints(dev, hints):
    r"""
    Class-aware wrapper for `::fz_enable_device_hints()`.
    	Enable (set) hint bits within the hint bitfield for a device.
    """
    return _mupdf.fz_enable_device_hints(dev, hints)

def fz_enable_icc():
    r"""
    Class-aware wrapper for `::fz_enable_icc()`.
    	Enable icc profile based operation.
    """
    return _mupdf.fz_enable_icc()

def fz_encode_character(font, unicode):
    r"""
    Class-aware wrapper for `::fz_encode_character()`.
    	Find the glyph id for a given unicode
    	character within a font.

    	font: The font to look for the unicode character in.

    	unicode: The unicode character to encode.

    	Returns the glyph id for the given unicode value, or 0 if
    	unknown.
    """
    return _mupdf.fz_encode_character(font, unicode)

def fz_encode_character_by_glyph_name(font, glyphname):
    r"""
    Class-aware wrapper for `::fz_encode_character_by_glyph_name()`.
    	Encode character.

    	Either by direct lookup of glyphname within a font, or, failing
    	that, by mapping glyphname to unicode and thence to the glyph
    	index within the given font.

    	Returns zero for type3 fonts.
    """
    return _mupdf.fz_encode_character_by_glyph_name(font, glyphname)

def fz_encode_character_sc(font, unicode):
    r"""
    Class-aware wrapper for `::fz_encode_character_sc()`.
    	Encode character, preferring small-caps variant if available.

    	font: The font to look for the unicode character in.

    	unicode: The unicode character to encode.

    	Returns the glyph id for the given unicode value, or 0 if
    	unknown.
    """
    return _mupdf.fz_encode_character_sc(font, unicode)

def fz_encode_character_with_fallback(font, unicode, script, language, out_font):
    r"""
    Class-aware wrapper for `::fz_encode_character_with_fallback()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_encode_character_with_fallback(::fz_font *font, int unicode, int script, int language, ::fz_font **out_font)` => `(int)`

    	Find the glyph id for
    	a given unicode character within a font, falling back to
    	an alternative if not found.

    	font: The font to look for the unicode character in.

    	unicode: The unicode character to encode.

    	script: The script in use.

    	language: The language in use.

    	out_font: The font handle in which the given glyph represents
    	the requested unicode character. The caller does not own the
    	reference it is passed, so should call fz_keep_font if it is
    	not simply to be used immediately.

    	Returns the glyph id for the given unicode value in the supplied
    	font (and sets *out_font to font) if it is present. Otherwise
    	an alternative fallback font (based on script/language) is
    	searched for. If the glyph is found therein, *out_font is set
    	to this reference, and the glyph reference is returned. If it
    	cannot be found anywhere, the function returns 0.
    """
    return _mupdf.fz_encode_character_with_fallback(font, unicode, script, language, out_font)

def fz_encode_uri(s):
    r"""
     Class-aware wrapper for `::fz_encode_uri()`.
    Return a new string representing the provided string encoded as a URI.
    """
    return _mupdf.fz_encode_uri(s)

def fz_encode_uri_component(s):
    r"""
     Class-aware wrapper for `::fz_encode_uri_component()`.
    Return a new string representing the provided string encoded as an URI component.
    This also encodes the special reserved characters (; / ? : @ & = + $ , #).
    """
    return _mupdf.fz_encode_uri_component(s)

def fz_encode_uri_pathname(s):
    r"""
     Class-aware wrapper for `::fz_encode_uri_pathname()`.
    Return a new string representing the provided string encoded as an URI path name.
    This also encodes the special reserved characters except /.
    """
    return _mupdf.fz_encode_uri_pathname(s)

def fz_end_group(dev):
    r"""Class-aware wrapper for `::fz_end_group()`."""
    return _mupdf.fz_end_group(dev)

def fz_end_layer(dev):
    r"""Class-aware wrapper for `::fz_end_layer()`."""
    return _mupdf.fz_end_layer(dev)

def fz_end_mask(dev):
    r"""Class-aware wrapper for `::fz_end_mask()`."""
    return _mupdf.fz_end_mask(dev)

def fz_end_mask_tr(dev, fn):
    r"""Class-aware wrapper for `::fz_end_mask_tr()`."""
    return _mupdf.fz_end_mask_tr(dev, fn)

def fz_end_metatext(dev):
    r"""Class-aware wrapper for `::fz_end_metatext()`."""
    return _mupdf.fz_end_metatext(dev)

def fz_end_page(wri):
    r"""
    Class-aware wrapper for `::fz_end_page()`.
    	Called to end the process of writing a page to a
    	document.
    """
    return _mupdf.fz_end_page(wri)

def fz_end_structure(dev):
    r"""Class-aware wrapper for `::fz_end_structure()`."""
    return _mupdf.fz_end_structure(dev)

def fz_end_throw_on_repair():
    r"""Class-aware wrapper for `::fz_end_throw_on_repair()`."""
    return _mupdf.fz_end_throw_on_repair()

def fz_end_tile(dev):
    r"""Class-aware wrapper for `::fz_end_tile()`."""
    return _mupdf.fz_end_tile(dev)

def fz_enumerate_font_cmap(font, cb, opaque):
    r"""
    Class-aware wrapper for `::fz_enumerate_font_cmap()`.
    	Enumerate a cmap using a callback.
    """
    return _mupdf.fz_enumerate_font_cmap(font, cb, opaque)

def fz_enumerate_font_cmap2(font):
    r"""Class-aware wrapper for `::fz_enumerate_font_cmap2()`.   SWIG-friendly wrapper for fz_enumerate_font_cmap()."""
    return _mupdf.fz_enumerate_font_cmap2(font)

def fz_error_callback(user):
    r"""
    Class-aware wrapper for `::fz_error_callback()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_error_callback()` => `(fz_error_cb *, void *user)`

    	Retrieve the currently set error callback, or NULL if none
    	has been set. Optionally, if user is non-NULL, the user pointer
    	given when the warning callback was set is also passed back to
    	the caller.
    """
    return _mupdf.fz_error_callback(user)

def fz_eval_function(func, _in, inlen, out, outlen):
    r"""
    Class-aware wrapper for `::fz_eval_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_eval_function(::fz_function *func, const float *in, int inlen, int outlen)` => float out
    """
    return _mupdf.fz_eval_function(func, _in, inlen, out, outlen)

def fz_expand_irect(a, expand):
    r"""Class-aware wrapper for `::fz_expand_irect()`."""
    return _mupdf.fz_expand_irect(a, expand)

def fz_expand_rect(b, expand):
    r"""
    Class-aware wrapper for `::fz_expand_rect()`.
    	Expand a bbox by a given amount in all directions.
    """
    return _mupdf.fz_expand_rect(b, expand)

def fz_extract_ttf_from_ttc(font):
    r"""Class-aware wrapper for `::fz_extract_ttf_from_ttc()`."""
    return _mupdf.fz_extract_ttf_from_ttc(font)

def fz_file_exists(path):
    r"""
    Class-aware wrapper for `::fz_file_exists()`.
    	Return true if the named file exists and is readable.
    """
    return _mupdf.fz_file_exists(path)

def fz_fill_image(dev, image, ctm, alpha, color_params):
    r"""Class-aware wrapper for `::fz_fill_image()`."""
    return _mupdf.fz_fill_image(dev, image, ctm, alpha, color_params)

def fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params):
    r"""Class-aware wrapper for `::fz_fill_image_mask()`."""
    return _mupdf.fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params)

def fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params):
    r"""
    Class-aware wrapper for `::fz_fill_path()`.
    	Device calls; graphics primitives and containers.
    """
    return _mupdf.fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params)

def fz_fill_pixmap_from_display_list(list, ctm, pix):
    r"""Class-aware wrapper for `::fz_fill_pixmap_from_display_list()`."""
    return _mupdf.fz_fill_pixmap_from_display_list(list, ctm, pix)

def fz_fill_pixmap_with_color(pix, colorspace, color, color_params):
    r"""
    Class-aware wrapper for `::fz_fill_pixmap_with_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_fill_pixmap_with_color(::fz_pixmap *pix, ::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color

    	Fill pixmap with solid color.
    """
    return _mupdf.fz_fill_pixmap_with_color(pix, colorspace, color, color_params)

def fz_fill_shade(dev, shade, ctm, alpha, color_params):
    r"""Class-aware wrapper for `::fz_fill_shade()`."""
    return _mupdf.fz_fill_shade(dev, shade, ctm, alpha, color_params)

def fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params):
    r"""Class-aware wrapper for `::fz_fill_text()`."""
    return _mupdf.fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params)

def fz_filter_store(fn, arg, type):
    r"""
    Class-aware wrapper for `::fz_filter_store()`.
    	Filter every element in the store with a matching type with the
    	given function.

    	If the function returns 1 for an element, drop the element.
    """
    return _mupdf.fz_filter_store(fn, arg, type)

def fz_find_item(drop, key, type):
    r"""
    Class-aware wrapper for `::fz_find_item()`.
    	Find an item within the store.

    	drop: The function used to free the value (to ensure we get a
    	value of the correct type).

    	key: The key used to index the item.

    	type: Functions used to manipulate the key.

    	Returns NULL for not found, otherwise returns a pointer to the
    	value indexed by key to which a reference has been taken.
    """
    return _mupdf.fz_find_item(drop, key, type)

def fz_flush_output(out):
    r"""
    Class-aware wrapper for `::fz_flush_output()`.
    	Flush unwritten data.
    """
    return _mupdf.fz_flush_output(out)

def fz_flush_warnings():
    r"""
    Class-aware wrapper for `::fz_flush_warnings()`.
    	Flush any repeated warnings.

    	Repeated warnings are buffered, counted and eventually printed
    	along with the number of repetitions. Call fz_flush_warnings
    	to force printing of the latest buffered warning and the
    	number of repetitions, for example to make sure that all
    	warnings are printed before exiting an application.
    """
    return _mupdf.fz_flush_warnings()

def fz_font_ascender(font):
    r"""
    Class-aware wrapper for `::fz_font_ascender()`.
    	Retrieve font ascender in ems.
    """
    return _mupdf.fz_font_ascender(font)

def fz_font_bbox(font):
    r"""
    Class-aware wrapper for `::fz_font_bbox()`.
    	Retrieve the font bbox.

    	font: The font to query.

    	Returns the font bbox by value; it is valid only if
    	fz_font_flags(font)->invalid_bbox is zero.
    """
    return _mupdf.fz_font_bbox(font)

def fz_font_descender(font):
    r"""
    Class-aware wrapper for `::fz_font_descender()`.
    	Retrieve font descender in ems.
    """
    return _mupdf.fz_font_descender(font)

def fz_font_digest(font, digest):
    r"""
    Class-aware wrapper for `::fz_font_digest()`.
    	Retrieve the MD5 digest for the font's data.
    """
    return _mupdf.fz_font_digest(font, digest)

def fz_font_ft_face(font):
    r"""
    Class-aware wrapper for `::fz_font_ft_face()`.
    	Retrieve the FT_Face handle
    	for the font.

    	font: The font to query

    	Returns the FT_Face handle for the font, or NULL
    	if not a freetype handled font. (Cast to void *
    	to avoid nasty header exposure).
    """
    return _mupdf.fz_font_ft_face(font)

def fz_font_is_bold(font):
    r"""
    Class-aware wrapper for `::fz_font_is_bold()`.
    	Query whether the font flags say that this font is bold.
    """
    return _mupdf.fz_font_is_bold(font)

def fz_font_is_italic(font):
    r"""
    Class-aware wrapper for `::fz_font_is_italic()`.
    	Query whether the font flags say that this font is italic.
    """
    return _mupdf.fz_font_is_italic(font)

def fz_font_is_monospaced(font):
    r"""
    Class-aware wrapper for `::fz_font_is_monospaced()`.
    	Query whether the font flags say that this font is monospaced.
    """
    return _mupdf.fz_font_is_monospaced(font)

def fz_font_is_serif(font):
    r"""
    Class-aware wrapper for `::fz_font_is_serif()`.
    	Query whether the font flags say that this font is serif.
    """
    return _mupdf.fz_font_is_serif(font)

def fz_font_name(font):
    r"""
    Class-aware wrapper for `::fz_font_name()`.
    	Retrieve a pointer to the name of the font.

    	font: The font to query.

    	Returns a pointer to an internal copy of the font name.
    	Will never be NULL, but may be the empty string.
    """
    return _mupdf.fz_font_name(font)

def fz_font_t3_procs(font):
    r"""
    Class-aware wrapper for `::fz_font_t3_procs()`.
    	Retrieve the Type3 procs
    	for a font.

    	font: The font to query

    	Returns the t3_procs pointer. Will be NULL for a
    	non type-3 font.
    """
    return _mupdf.fz_font_t3_procs(font)

def fz_format_double(fmt, value):
    r"""
    Class-aware wrapper for `::fz_format_double()`.   Swig-friendly and typesafe way to do fz_snprintf(fmt, value). `fmt`
    must end with one of 'efg' otherwise we throw an exception.
    """
    return _mupdf.fz_format_double(fmt, value)

def fz_format_link_uri(doc, dest):
    r"""
    Class-aware wrapper for `::fz_format_link_uri()`.
    	Format an internal link to a page number, location, and possible viewing parameters,
    	suitable for use with fz_create_link.

    	Returns a newly allocated string that the caller must free.
    """
    return _mupdf.fz_format_link_uri(doc, dest)

def fz_format_output_path(path, size, fmt, page):
    r"""
    Class-aware wrapper for `::fz_format_output_path()`.
    	create output file name using a template.

    	If the path contains %[0-9]*d, the first such pattern will be
    	replaced with the page number. If the template does not contain
    	such a pattern, the page number will be inserted before the
    	filename extension. If the template does not have a filename
    	extension, the page number will be added to the end.
    """
    return _mupdf.fz_format_output_path(path, size, fmt, page)

def fz_free(p):
    r"""
    Class-aware wrapper for `::fz_free()`.
    	Free a previously allocated block of memory.

    	fz_free(ctx, NULL) does nothing.

    	Never throws exceptions.
    """
    return _mupdf.fz_free(p)

def fz_free_aligned(p):
    r"""
    Class-aware wrapper for `::fz_free_aligned()`.
    	fz_free equivalent, for blocks allocated via fz_malloc_aligned.
    """
    return _mupdf.fz_free_aligned(p)

def fz_ft_lock():
    r"""Class-aware wrapper for `::fz_ft_lock()`."""
    return _mupdf.fz_ft_lock()

def fz_ft_lock_held():
    r"""Class-aware wrapper for `::fz_ft_lock_held()`."""
    return _mupdf.fz_ft_lock_held()

def fz_ft_unlock():
    r"""Class-aware wrapper for `::fz_ft_unlock()`."""
    return _mupdf.fz_ft_unlock()

def fz_function_size(func):
    r"""Class-aware wrapper for `::fz_function_size()`."""
    return _mupdf.fz_function_size(func)

def fz_gamma_pixmap(pix, gamma):
    r"""
    Class-aware wrapper for `::fz_gamma_pixmap()`.
    	Apply gamma correction to a pixmap. All components
    	of all pixels are modified (except alpha, which is unchanged).

    	gamma: The gamma value to apply; 1.0 for no change.
    """
    return _mupdf.fz_gamma_pixmap(pix, gamma)

def fz_generate_transition(tpix, opix, npix, time, trans):
    r"""
    Class-aware wrapper for `::fz_generate_transition()`.
    	Generate a frame of a transition.

    	tpix: Target pixmap
    	opix: Old pixmap
    	npix: New pixmap
    	time: Position within the transition (0 to 256)
    	trans: Transition details

    	Returns 1 if successfully generated a frame.

    	Note: Pixmaps must include alpha.
    """
    return _mupdf.fz_generate_transition(tpix, opix, npix, time, trans)

def fz_get_glyph_name(font, glyph, buf, size):
    r"""
    Class-aware wrapper for `::fz_get_glyph_name()`.
    	Find the name of a glyph

    	font: The font to look for the glyph in.

    	glyph: The glyph id to look for.

    	buf: Pointer to a buffer for the name to be inserted into.

    	size: The size of the buffer.

    	If a font contains a name table, then the name of the glyph
    	will be returned in the supplied buffer. Otherwise a name
    	is synthesised. The name will be truncated to fit in
    	the buffer.
    """
    return _mupdf.fz_get_glyph_name(font, glyph, buf, size)

def fz_get_glyph_name2(font, glyph):
    r"""
    Class-aware wrapper for `::fz_get_glyph_name2()`.
    C++ alternative to fz_get_glyph_name() that returns information in a std::string.
    """
    return _mupdf.fz_get_glyph_name2(font, glyph)

def fz_get_pixmap_from_image(image, subarea, ctm, w, h):
    r"""
    Class-aware wrapper for `::fz_get_pixmap_from_image()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_get_pixmap_from_image(::fz_image *image, const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`

    	Called to get a handle to a pixmap from an image.

    	image: The image to retrieve a pixmap from.

    	subarea: The subarea of the image that we actually care about
    	(or NULL to indicate the whole image).

    	ctm: Optional, unless subarea is given. If given, then on
    	entry this is the transform that will be applied to the complete
    	image. It should be updated on exit to the transform to apply to
    	the given subarea of the image. This is used to calculate the
    	desired width/height for subsampling.

    	w: If non-NULL, a pointer to an int to be updated on exit to the
    	width (in pixels) that the scaled output will cover.

    	h: If non-NULL, a pointer to an int to be updated on exit to the
    	height (in pixels) that the scaled output will cover.

    	Returns a non NULL kept pixmap pointer. May throw exceptions.
    """
    return _mupdf.fz_get_pixmap_from_image(image, subarea, ctm, w, h)

def fz_get_unscaled_pixmap_from_image(image):
    r"""
    Class-aware wrapper for `::fz_get_unscaled_pixmap_from_image()`.
    	Calls fz_get_pixmap_from_image() with ctm, subarea, w and h all set to NULL.
    """
    return _mupdf.fz_get_unscaled_pixmap_from_image(image)

def fz_getopt(nargc, nargv, ostr):
    r"""
    Class-aware wrapper for `::fz_getopt()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_getopt(int nargc, const char *ostr)` => `(int, char *nargv)`

    	Identical to fz_getopt_long, but with a NULL longopts field, signifying no long
    	options.
    """
    return _mupdf.fz_getopt(nargc, nargv, ostr)

def fz_getopt_long(nargc, nargv, ostr, longopts):
    r"""
    Class-aware wrapper for `::fz_getopt_long()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_getopt_long(int nargc, const char *ostr, const ::fz_getopt_long_options *longopts)` => `(int, char *nargv)`

    	Simple functions/variables for use in tools.

    	ostr = option string. Comprises single letter options, followed by : if there
    	is an argument to the option.

    	longopts: NULL (indicating no long options), or a pointer to an array of
    	longoptions, terminated by an entry with option == NULL.

    	In the event of matching a single char option, this function will normally
    	return the char. The exception to this is when the option requires an
    	argument and none is supplied; in this case we return ':'.

    	In the event of matching a long option, this function returns 0, with fz_optlong
    	set to point to the matching option.

    	A long option entry may be followed with : to indicate there is an argument to the
    	option. If the need for an argument is specified in this way, and no argument is
    	given, an error will be displayed and argument processing will stop. If an argument
    	is given, and the long option record contains a non-null flag pointer, then the code
    	will decode the argument and fill in that flag pointer. Specifically,
    	case-insensitive matches to 'yes', 'no', 'true' and 'false' will cause a value of 0
    	or 1 as appropriate to be written; failing this the arg will be interpreted as a
    	decimal integer using atoi.

    	A long option entry may be followed by an list of options (e.g. myoption=foo|bar|baz)
    	and the option will be passed to fz_opt_from_list. The return value of that will be
    	placed in fz_optitem. If the return value of that function is -1, then an error will
    	be displayed and argument processing will stop.

    	In the event of reaching the end of the arg list or '--', this function returns EOF.

    	In the event of failing to match anything, an error is printed, and we return '?'.

    	If an argument is expected for the option, then fz_optarg will be returned pointing
    	at the start of the argument. Examples of supported argument formats: '-r500', '-r 500',
    	'--resolution 500', '--resolution=500'.
    """
    return _mupdf.fz_getopt_long(nargc, nargv, ostr, longopts)

def fz_glyph_bbox(glyph):
    r"""
    Class-aware wrapper for `::fz_glyph_bbox()`.
    	Return the bounding box of the glyph in pixels.
    """
    return _mupdf.fz_glyph_bbox(glyph)

def fz_glyph_bbox_no_ctx(src):
    r"""Class-aware wrapper for `::fz_glyph_bbox_no_ctx()`."""
    return _mupdf.fz_glyph_bbox_no_ctx(src)

def fz_glyph_cacheable(font, gid):
    r"""
    Class-aware wrapper for `::fz_glyph_cacheable()`.
    	Determine if a given glyph in a font
    	is cacheable. Certain glyphs in a type 3 font cannot safely
    	be cached, as their appearance depends on the enclosing
    	graphic state.

    	font: The font to look for the glyph in.

    	gif: The glyph to query.

    	Returns non-zero if cacheable, 0 if not.
    """
    return _mupdf.fz_glyph_cacheable(font, gid)

def fz_glyph_height(glyph):
    r"""
    Class-aware wrapper for `::fz_glyph_height()`.
    	Return the height of the glyph in pixels.
    """
    return _mupdf.fz_glyph_height(glyph)

def fz_glyph_name_from_unicode_sc(unicode):
    r"""Class-aware wrapper for `::fz_glyph_name_from_unicode_sc()`."""
    return _mupdf.fz_glyph_name_from_unicode_sc(unicode)

def fz_glyph_width(glyph):
    r"""
    Class-aware wrapper for `::fz_glyph_width()`.
    	Return the width of the glyph in pixels.
    """
    return _mupdf.fz_glyph_width(glyph)

def fz_graphics_aa_level():
    r"""
    Class-aware wrapper for `::fz_graphics_aa_level()`.
    	Get the number of bits of antialiasing we are
    	using for graphics. Between 0 and 8.
    """
    return _mupdf.fz_graphics_aa_level()

def fz_graphics_min_line_width():
    r"""
    Class-aware wrapper for `::fz_graphics_min_line_width()`.
    	Get the minimum line width to be
    	used for stroked lines.

    	min_line_width: The minimum line width to use (in pixels).
    """
    return _mupdf.fz_graphics_min_line_width()

def fz_gridfit_matrix(as_tiled, m):
    r"""
    Class-aware wrapper for `::fz_gridfit_matrix()`.
    	Grid fit a matrix.

    	as_tiled = 0 => adjust the matrix so that the image of the unit
    	square completely covers any pixel that was touched by the
    	image of the unit square under the original matrix.

    	as_tiled = 1 => adjust the matrix so that the corners of the
    	image of the unit square align with the closest integer corner
    	of the image of the unit square under the original matrix.
    """
    return _mupdf.fz_gridfit_matrix(as_tiled, m)

def fz_grisu(f, s, exp):
    r"""
    Class-aware wrapper for `::fz_grisu()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_grisu(float f, char *s)` => `(int, int exp)`
    """
    return _mupdf.fz_grisu(f, s, exp)

def fz_grow_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_grow_buffer()`.
    	Make some space within a buffer (i.e. ensure that
    	capacity > size).
    """
    return _mupdf.fz_grow_buffer(buf)

def fz_has_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_has_archive_entry()`.
    	Check if entry by given name exists.

    	If named entry does not exist 0 will be returned, if it does
    	exist 1 is returned.

    	name: Entry name to look for, this must be an exact match to
    	the entry name in the archive.
    """
    return _mupdf.fz_has_archive_entry(arch, name)

def fz_has_option(opts, key, val):
    r"""
    Class-aware wrapper for `::fz_has_option()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_has_option(const char *opts, const char *key)` => `(int, const char *val)`

    	Look for a given option (key) in the opts string. Return 1 if
    	it has it, and update *val to point to the value within opts.
    """
    return _mupdf.fz_has_option(opts, key, val)

def fz_has_permission(doc, p):
    r"""
    Class-aware wrapper for `::fz_has_permission()`.
    	Check permission flags on document.
    """
    return _mupdf.fz_has_permission(doc, p)

def fz_hash_filter(table, state, callback):
    r"""
    Class-aware wrapper for `::fz_hash_filter()`.
    	Iterate over the entries in a hash table, removing all the ones where callback returns true.
    	Does NOT free the value of the entry, so the caller is expected to take care of this.
    """
    return _mupdf.fz_hash_filter(table, state, callback)

def fz_hash_find(table, key):
    r"""
    Class-aware wrapper for `::fz_hash_find()`.
    	Search for a matching hash within the table, and return the
    	associated value.
    """
    return _mupdf.fz_hash_find(table, key)

def fz_hash_for_each(table, state, callback):
    r"""
    Class-aware wrapper for `::fz_hash_for_each()`.
    	Iterate over the entries in a hash table.
    """
    return _mupdf.fz_hash_for_each(table, state, callback)

def fz_hash_insert(table, key, val):
    r"""
    Class-aware wrapper for `::fz_hash_insert()`.
    	Insert a new key/value pair into the hash table.

    	If an existing entry with the same key is found, no change is
    	made to the hash table, and a pointer to the existing value is
    	returned.

    	If no existing entry with the same key is found, ownership of
    	val passes in, key is copied, and NULL is returned.
    """
    return _mupdf.fz_hash_insert(table, key, val)

def fz_hash_remove(table, key):
    r"""
    Class-aware wrapper for `::fz_hash_remove()`.
    	Remove the entry for a given key.

    	The value is NOT freed, so the caller is expected to take care
    	of this.
    """
    return _mupdf.fz_hash_remove(table, key)

def fz_hb_lock():
    r"""
    Class-aware wrapper for `::fz_hb_lock()`.
    	Lock against Harfbuzz being called
    	simultaneously in several threads. This reuses
    	FZ_LOCK_FREETYPE.
    """
    return _mupdf.fz_hb_lock()

def fz_hb_unlock():
    r"""
    Class-aware wrapper for `::fz_hb_unlock()`.
    	Unlock after a Harfbuzz call. This reuses
    	FZ_LOCK_FREETYPE.
    """
    return _mupdf.fz_hb_unlock()

def fz_highlight_selection(page, a, b, quads, max_quads):
    r"""
    Class-aware wrapper for `::fz_highlight_selection()`.
    	Return a list of quads to highlight lines inside the selection
    	points.
    """
    return _mupdf.fz_highlight_selection(page, a, b, quads, max_quads)

def fz_highlight_selection2(page, a, b, max_quads):
    r"""
    Class-aware wrapper for `::fz_highlight_selection2()`.
    C++ alternative to fz_highlight_selection() that returns quads in a
    std::vector.
    """
    return _mupdf.fz_highlight_selection2(page, a, b, max_quads)

def fz_ignore_error():
    r"""Class-aware wrapper for `::fz_ignore_error()`."""
    return _mupdf.fz_ignore_error()

def fz_ignore_text(dev, text, ctm):
    r"""Class-aware wrapper for `::fz_ignore_text()`."""
    return _mupdf.fz_ignore_text(dev, text, ctm)

def fz_image_orientation(image):
    r"""
    Class-aware wrapper for `::fz_image_orientation()`.
    	Request the natural orientation of an image.

    	This is for images (such as JPEG) that can contain internal
    	specifications of rotation/flips. This is ignored by all the
    	internal decode/rendering routines, but can be used by callers
    	(such as the image document handler) to respect such
    	specifications.

    	The values used by MuPDF are as follows, with the equivalent
    	Exif specifications given for information:

    	0: Undefined
    	1: 0 degree ccw rotation. (Exif = 1)
    	2: 90 degree ccw rotation. (Exif = 8)
    	3: 180 degree ccw rotation. (Exif = 3)
    	4: 270 degree ccw rotation. (Exif = 6)
    	5: flip on X. (Exif = 2)
    	6: flip on X, then rotate ccw by 90 degrees. (Exif = 5)
    	7: flip on X, then rotate ccw by 180 degrees. (Exif = 4)
    	8: flip on X, then rotate ccw by 270 degrees. (Exif = 7)
    """
    return _mupdf.fz_image_orientation(image)

def fz_image_orientation_matrix(image):
    r"""Class-aware wrapper for `::fz_image_orientation_matrix()`."""
    return _mupdf.fz_image_orientation_matrix(image)

def fz_image_resolution(image, xres, yres):
    r"""
    Class-aware wrapper for `::fz_image_resolution()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_image_resolution(::fz_image *image)` => `(int xres, int yres)`

    	Request the natural resolution
    	of an image.

    	xres, yres: Pointers to ints to be updated with the
    	natural resolution of an image (or a sensible default
    	if not encoded).
    """
    return _mupdf.fz_image_resolution(image, xres, yres)

def fz_image_size(im):
    r"""
    Class-aware wrapper for `::fz_image_size()`.
    	Return the size of the storage used by an image.
    """
    return _mupdf.fz_image_size(im)

def fz_image_type_name(type):
    r"""
    Class-aware wrapper for `::fz_image_type_name()`.
    	Map from FZ_IMAGE_* value to string.

    	The returned string is static and therefore must not be freed.
    """
    return _mupdf.fz_image_type_name(type)

def fz_include_point_in_rect(r, p):
    r"""
    Class-aware wrapper for `::fz_include_point_in_rect()`.
    	Expand a bbox to include a given point.
    	To create a rectangle that encompasses a sequence of points, the
    	rectangle must first be set to be the empty rectangle at one of
    	the points before including the others.
    """
    return _mupdf.fz_include_point_in_rect(r, p)

def fz_init_text_decoder(dec, encoding):
    r"""Class-aware wrapper for `::fz_init_text_decoder()`."""
    return _mupdf.fz_init_text_decoder(dec, encoding)

def fz_install_load_system_font_funcs(f, f_cjk, f_fallback):
    r"""
    Class-aware wrapper for `::fz_install_load_system_font_funcs()`.
    	Install functions to allow MuPDF to request fonts from the
    	system.

    	Only one set of hooks can be in use at a time.
    """
    return _mupdf.fz_install_load_system_font_funcs(f, f_cjk, f_fallback)

def fz_install_load_system_font_funcs2(args):
    r"""
    Class-aware wrapper for `::fz_install_load_system_font_funcs2()`.
    Alternative to fz_install_load_system_font_funcs() that takes args in a
    struct, to allow use from Python/C# via Swig Directors.
    """
    return _mupdf.fz_install_load_system_font_funcs2(args)

def fz_int2_heap_insert(heap, v):
    r"""Class-aware wrapper for `::fz_int2_heap_insert()`."""
    return _mupdf.fz_int2_heap_insert(heap, v)

def fz_int2_heap_sort(heap):
    r"""Class-aware wrapper for `::fz_int2_heap_sort()`."""
    return _mupdf.fz_int2_heap_sort(heap)

def fz_int2_heap_uniq(heap):
    r"""Class-aware wrapper for `::fz_int2_heap_uniq()`."""
    return _mupdf.fz_int2_heap_uniq(heap)

def fz_int_heap_insert(heap, v):
    r"""Class-aware wrapper for `::fz_int_heap_insert()`."""
    return _mupdf.fz_int_heap_insert(heap, v)

def fz_int_heap_sort(heap):
    r"""Class-aware wrapper for `::fz_int_heap_sort()`."""
    return _mupdf.fz_int_heap_sort(heap)

def fz_int_heap_uniq(heap):
    r"""Class-aware wrapper for `::fz_int_heap_uniq()`."""
    return _mupdf.fz_int_heap_uniq(heap)

def fz_intersect_irect(a, b):
    r"""
    Class-aware wrapper for `::fz_intersect_irect()`.
    	Compute intersection of two bounding boxes.

    	Similar to fz_intersect_rect but operates on two bounding
    	boxes instead of two rectangles.
    """
    return _mupdf.fz_intersect_irect(a, b)

def fz_intersect_rect(a, b):
    r"""
    Class-aware wrapper for `::fz_intersect_rect()`.
    	Compute intersection of two rectangles.

    	Given two rectangles, update the first to be the smallest
    	axis-aligned rectangle that covers the area covered by both
    	given rectangles. If either rectangle is empty then the
    	intersection is also empty. If either rectangle is infinite
    	then the intersection is simply the non-infinite rectangle.
    	Should both rectangles be infinite, then the intersection is
    	also infinite.
    """
    return _mupdf.fz_intersect_rect(a, b)

def fz_intptr_heap_insert(heap, v):
    r"""Class-aware wrapper for `::fz_intptr_heap_insert()`."""
    return _mupdf.fz_intptr_heap_insert(heap, v)

def fz_intptr_heap_sort(heap):
    r"""Class-aware wrapper for `::fz_intptr_heap_sort()`."""
    return _mupdf.fz_intptr_heap_sort(heap)

def fz_intptr_heap_uniq(heap):
    r"""Class-aware wrapper for `::fz_intptr_heap_uniq()`."""
    return _mupdf.fz_intptr_heap_uniq(heap)

def fz_invert_bitmap(bmp):
    r"""
    Class-aware wrapper for `::fz_invert_bitmap()`.
    	Invert bitmap.

    	Never throws exceptions.
    """
    return _mupdf.fz_invert_bitmap(bmp)

def fz_invert_matrix(matrix):
    r"""
    Class-aware wrapper for `::fz_invert_matrix()`.
    	Create an inverse matrix.

    	matrix: Matrix to invert. A degenerate matrix, where the
    	determinant is equal to zero, can not be inverted and the
    	original matrix is returned instead.

    	Returns inverse.
    """
    return _mupdf.fz_invert_matrix(matrix)

def fz_invert_pixmap(pix):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap()`.
    	Invert all the pixels in a pixmap. All components (process and
    	spots) of all pixels are inverted (except alpha, which is
    	unchanged).
    """
    return _mupdf.fz_invert_pixmap(pix)

def fz_invert_pixmap_alpha(pix):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap_alpha()`.
    	Invert the alpha fo all the pixels in a pixmap.
    """
    return _mupdf.fz_invert_pixmap_alpha(pix)

def fz_invert_pixmap_luminance(pix):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap_luminance()`.
    	Transform the pixels in a pixmap so that luminance of each
    	pixel is inverted, and the chrominance remains unchanged (as
    	much as accuracy allows).

    	All components of all pixels are inverted (except alpha, which
    	is unchanged). Only supports Grey and RGB bitmaps.
    """
    return _mupdf.fz_invert_pixmap_luminance(pix)

def fz_invert_pixmap_raw(pix):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap_raw()`.
    	Invert all the pixels in a non-premultiplied pixmap in a
    	very naive manner.
    """
    return _mupdf.fz_invert_pixmap_raw(pix)

def fz_invert_pixmap_rect(image, rect):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap_rect()`.
    	Invert all the pixels in a given rectangle of a (premultiplied)
    	pixmap. All components of all pixels in the rectangle are
    	inverted (except alpha, which is unchanged).
    """
    return _mupdf.fz_invert_pixmap_rect(image, rect)

def fz_irect_from_rect(rect):
    r"""
    Class-aware wrapper for `::fz_irect_from_rect()`.
    	Convert a rect into the minimal bounding box
    	that covers the rectangle.

    	Coordinates in a bounding box are integers, so rounding of the
    	rects coordinates takes place. The top left corner is rounded
    	upwards and left while the bottom right corner is rounded
    	downwards and to the right.
    """
    return _mupdf.fz_irect_from_rect(rect)

def fz_irect_height(r):
    r"""
    Class-aware wrapper for `::fz_irect_height()`.
    	Return the height of an irect. Invalid irects return 0.
    """
    return _mupdf.fz_irect_height(r)

def fz_irect_width(r):
    r"""
    Class-aware wrapper for `::fz_irect_width()`.
    	Return the width of an irect. Invalid irects return 0.
    """
    return _mupdf.fz_irect_width(r)

def fz_is_cfb_archive(file):
    r"""
    Class-aware wrapper for `::fz_is_cfb_archive()`.
    	Detect if stream object is a cfb archive.

    	Assumes that the stream object is seekable.
    """
    return _mupdf.fz_is_cfb_archive(file)

def fz_is_directory(path):
    r"""
    Class-aware wrapper for `::fz_is_directory()`.
    	Determine if a given path is a directory.

    	In the case of the path not existing, or having no access
    	we will return 0.
    """
    return _mupdf.fz_is_directory(path)

def fz_is_document_reflowable(doc):
    r"""
    Class-aware wrapper for `::fz_is_document_reflowable()`.
    	Is the document reflowable.

    	Returns 1 to indicate reflowable documents, otherwise 0.
    """
    return _mupdf.fz_is_document_reflowable(doc)

def fz_is_empty_irect(r):
    r"""Class-aware wrapper for `::fz_is_empty_irect()`."""
    return _mupdf.fz_is_empty_irect(r)

def fz_is_empty_quad(q):
    r"""
    Class-aware wrapper for `::fz_is_empty_quad()`.
    	Is a quad empty?
    """
    return _mupdf.fz_is_empty_quad(q)

def fz_is_empty_rect(r):
    r"""
    Class-aware wrapper for `::fz_is_empty_rect()`.
    	Check if rectangle is empty.

    	An empty rectangle is defined as one whose area is zero.
    	All invalid rectangles are empty.
    """
    return _mupdf.fz_is_empty_rect(r)

def fz_is_eof(stm):
    r"""
    Class-aware wrapper for `::fz_is_eof()`.
    	Query if the stream has reached EOF (during normal bytewise
    	reading).

    	See fz_is_eof_bits for the equivalent function for bitwise
    	reading.
    """
    return _mupdf.fz_is_eof(stm)

def fz_is_eof_bits(stm):
    r"""
    Class-aware wrapper for `::fz_is_eof_bits()`.
    	Query if the stream has reached EOF (during bitwise
    	reading).

    	See fz_is_eof for the equivalent function for bytewise
    	reading.
    """
    return _mupdf.fz_is_eof_bits(stm)

def fz_is_external_link(uri):
    r"""
    Class-aware wrapper for `::fz_is_external_link()`.
    	Query whether a link is external to a document (determined by
    	uri containing a ':', intended to match with '://' which
    	separates the scheme from the scheme specific parts in URIs).
    """
    return _mupdf.fz_is_external_link(uri)

def fz_is_identity(m):
    r"""Class-aware wrapper for `::fz_is_identity()`."""
    return _mupdf.fz_is_identity(m)

def fz_is_infinite_irect(r):
    r"""
    Class-aware wrapper for `::fz_is_infinite_irect()`.
    	Check if an integer rectangle
    	is infinite.
    """
    return _mupdf.fz_is_infinite_irect(r)

def fz_is_infinite_quad(q):
    r"""
    Class-aware wrapper for `::fz_is_infinite_quad()`.
    	Is a quad infinite?
    """
    return _mupdf.fz_is_infinite_quad(q)

def fz_is_infinite_rect(r):
    r"""
    Class-aware wrapper for `::fz_is_infinite_rect()`.
    	Check if rectangle is infinite.
    """
    return _mupdf.fz_is_infinite_rect(r)

def fz_is_libarchive_archive(file):
    r"""
    Class-aware wrapper for `::fz_is_libarchive_archive()`.
    	Detect if stream object is an archive supported by libarchive.

    	Assumes that the stream object is seekable.
    """
    return _mupdf.fz_is_libarchive_archive(file)

def fz_is_page_range(s):
    r"""
     Class-aware wrapper for `::fz_is_page_range()`.
    		Check and parse string into page ranges:
    ,?(-?+|N)(-(-?+|N))?/
    """
    return _mupdf.fz_is_page_range(s)

def fz_is_pixmap_monochrome(pixmap):
    r"""
    Class-aware wrapper for `::fz_is_pixmap_monochrome()`.
    	Check if the pixmap is a 1-channel image containing samples with
    	only values 0 and 255
    """
    return _mupdf.fz_is_pixmap_monochrome(pixmap)

def fz_is_point_inside_irect(x, y, r):
    r"""
    Class-aware wrapper for `::fz_is_point_inside_irect()`.
    	Inclusion test for irects. (Rect is assumed to be open, i.e.
    	top right corner is not included).
    """
    return _mupdf.fz_is_point_inside_irect(x, y, r)

def fz_is_point_inside_quad(p, q):
    r"""
    Class-aware wrapper for `::fz_is_point_inside_quad()`.
    	Inclusion test for quads.
    """
    return _mupdf.fz_is_point_inside_quad(p, q)

def fz_is_point_inside_rect(p, r):
    r"""
    Class-aware wrapper for `::fz_is_point_inside_rect()`.
    	Inclusion test for rects. (Rect is assumed to be open, i.e.
    	top right corner is not included).
    """
    return _mupdf.fz_is_point_inside_rect(p, r)

def fz_is_pow2(a):
    r"""Class-aware wrapper for `::fz_is_pow2()`."""
    return _mupdf.fz_is_pow2(a)

def fz_is_quad_inside_quad(needle, haystack):
    r"""
    Class-aware wrapper for `::fz_is_quad_inside_quad()`.
    	Inclusion test for quad in quad.

    	This may break down if quads are not 'well formed'.
    """
    return _mupdf.fz_is_quad_inside_quad(needle, haystack)

def fz_is_quad_intersecting_quad(a, b):
    r"""
    Class-aware wrapper for `::fz_is_quad_intersecting_quad()`.
    	Intersection test for quads.

    	This may break down if quads are not 'well formed'.
    """
    return _mupdf.fz_is_quad_intersecting_quad(a, b)

def fz_is_rectilinear(m):
    r"""
    Class-aware wrapper for `::fz_is_rectilinear()`.
    	Check if a transformation is rectilinear.

    	Rectilinear means that no shearing is present and that any
    	rotations present are a multiple of 90 degrees. Usually this
    	is used to make sure that axis-aligned rectangles before the
    	transformation are still axis-aligned rectangles afterwards.
    """
    return _mupdf.fz_is_rectilinear(m)

def fz_is_tar_archive(file):
    r"""
    Class-aware wrapper for `::fz_is_tar_archive()`.
    	Detect if stream object is a tar archive.

    	Assumes that the stream object is seekable.
    """
    return _mupdf.fz_is_tar_archive(file)

def fz_is_valid_blend_colorspace(cs):
    r"""
    Class-aware wrapper for `::fz_is_valid_blend_colorspace()`.
    	Check to see that a colorspace is appropriate to be used as
    	a blending space (i.e. only grey, rgb or cmyk).
    """
    return _mupdf.fz_is_valid_blend_colorspace(cs)

def fz_is_valid_irect(r):
    r"""
    Class-aware wrapper for `::fz_is_valid_irect()`.
    	Check if an integer rectangle is valid.
    """
    return _mupdf.fz_is_valid_irect(r)

def fz_is_valid_quad(q):
    r"""
    Class-aware wrapper for `::fz_is_valid_quad()`.
    	Is a quad valid?
    """
    return _mupdf.fz_is_valid_quad(q)

def fz_is_valid_rect(r):
    r"""
    Class-aware wrapper for `::fz_is_valid_rect()`.
    	Check if rectangle is valid.
    """
    return _mupdf.fz_is_valid_rect(r)

def fz_is_zip_archive(file):
    r"""
    Class-aware wrapper for `::fz_is_zip_archive()`.
    	Detect if stream object is a zip archive.

    	Assumes that the stream object is seekable.
    """
    return _mupdf.fz_is_zip_archive(file)

def fz_iso8859_1_from_unicode(u):
    r"""Class-aware wrapper for `::fz_iso8859_1_from_unicode()`."""
    return _mupdf.fz_iso8859_1_from_unicode(u)

def fz_iso8859_7_from_unicode(u):
    r"""Class-aware wrapper for `::fz_iso8859_7_from_unicode()`."""
    return _mupdf.fz_iso8859_7_from_unicode(u)

def fz_jbig2_globals_data(globals):
    r"""
    Class-aware wrapper for `::fz_jbig2_globals_data()`.
    	Return buffer containing jbig2 globals data stream.
    """
    return _mupdf.fz_jbig2_globals_data(globals)

def fz_koi8u_from_unicode(u):
    r"""Class-aware wrapper for `::fz_koi8u_from_unicode()`."""
    return _mupdf.fz_koi8u_from_unicode(u)

def fz_last_page(doc):
    r"""
    Class-aware wrapper for `::fz_last_page()`.
    	Function to get the location for the last page in the document.
    	Using this can be far more efficient in some cases than calling
    	fz_count_pages and using the page number.
    """
    return _mupdf.fz_last_page(doc)

def fz_layout_document(doc, w, h, em):
    r"""
    Class-aware wrapper for `::fz_layout_document()`.
    	Layout reflowable document types.

    	w, h: Page size in points.
    	em: Default font size in points.
    """
    return _mupdf.fz_layout_document(doc, w, h, em)

def fz_lineto(path, x, y):
    r"""
    Class-aware wrapper for `::fz_lineto()`.
    	Append a 'lineto' command to an open path.

    	path: The path to modify.

    	x, y: The coordinate to line to.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_lineto(path, x, y)

def fz_list_archive_entry(arch, idx):
    r"""
    Class-aware wrapper for `::fz_list_archive_entry()`.
    	Get listed name of entry position idx.

    	idx: Must be a value >= 0 < return value from
    	fz_count_archive_entries. If not in range NULL will be
    	returned.

    	May throw an exception if this type of archive cannot list the
    	entries (such as a directory).
    """
    return _mupdf.fz_list_archive_entry(arch, idx)

def fz_load_bmp_subimage(buf, len, subimage):
    r"""Class-aware wrapper for `::fz_load_bmp_subimage()`."""
    return _mupdf.fz_load_bmp_subimage(buf, len, subimage)

def fz_load_bmp_subimage_count(buf, len):
    r"""Class-aware wrapper for `::fz_load_bmp_subimage_count()`."""
    return _mupdf.fz_load_bmp_subimage_count(buf, len)

def fz_load_chapter_page(doc, chapter, page):
    r"""
    Class-aware wrapper for `::fz_load_chapter_page()`.
    	Load a page.

    	After fz_load_page is it possible to retrieve the size of the
    	page using fz_bound_page, or to render the page using
    	fz_run_page_*. Free the page by calling fz_drop_page.

    	chapter: chapter number, 0 is the first chapter of the document.
    	number: page number, 0 is the first page of the chapter.
    """
    return _mupdf.fz_load_chapter_page(doc, chapter, page)

def fz_load_fallback_font(script, language, serif, bold, italic):
    r"""
    Class-aware wrapper for `::fz_load_fallback_font()`.
    	Try to load a fallback font for the
    	given combination of font attributes. Whether a font is
    	present or not will depend on the configuration in which
    	MuPDF is built.

    	script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).

    	language: The language desired (e.g. FZ_LANG_ja).

    	serif: 1 if serif desired, 0 otherwise.

    	bold: 1 if bold desired, 0 otherwise.

    	italic: 1 if italic desired, 0 otherwise.

    	Returns a new font handle, or NULL if not available.
    """
    return _mupdf.fz_load_fallback_font(script, language, serif, bold, italic)

def fz_load_jbig2_globals(buf):
    r"""
    Class-aware wrapper for `::fz_load_jbig2_globals()`.
    	Create a jbig2 globals record from a buffer.

    	Immutable once created.
    """
    return _mupdf.fz_load_jbig2_globals(buf)

def fz_load_jbig2_subimage(buf, len, subimage):
    r"""Class-aware wrapper for `::fz_load_jbig2_subimage()`."""
    return _mupdf.fz_load_jbig2_subimage(buf, len, subimage)

def fz_load_jbig2_subimage_count(buf, len):
    r"""Class-aware wrapper for `::fz_load_jbig2_subimage_count()`."""
    return _mupdf.fz_load_jbig2_subimage_count(buf, len)

def fz_load_jpx(data, size, cs):
    r"""
    Class-aware wrapper for `::fz_load_jpx()`.
    	Exposed for PDF.
    """
    return _mupdf.fz_load_jpx(data, size, cs)

def fz_load_links(page):
    r"""
    Class-aware wrapper for `::fz_load_links()`.
    	Load the list of links for a page.

    	Returns a linked list of all the links on the page, each with
    	its clickable region and link destination. Each link is
    	reference counted so drop and free the list of links by
    	calling fz_drop_link on the pointer return from fz_load_links.

    	page: Page obtained from fz_load_page.
    """
    return _mupdf.fz_load_links(page)

def fz_load_outline(doc):
    r"""
    Class-aware wrapper for `::fz_load_outline()`.
    	Load the hierarchical document outline.

    	Should be freed by fz_drop_outline.
    """
    return _mupdf.fz_load_outline(doc)

def fz_load_outline_from_iterator(iter):
    r"""
    Class-aware wrapper for `::fz_load_outline_from_iterator()`.
    	Routine to implement the old Structure based API from an iterator.
    """
    return _mupdf.fz_load_outline_from_iterator(iter)

def fz_load_page(doc, number):
    r"""
    Class-aware wrapper for `::fz_load_page()`.
    	Load a given page number from a document. This may be much less
    	efficient than loading by location (chapter+page) for some
    	document types.
    """
    return _mupdf.fz_load_page(doc, number)

def fz_load_pnm_subimage(buf, len, subimage):
    r"""Class-aware wrapper for `::fz_load_pnm_subimage()`."""
    return _mupdf.fz_load_pnm_subimage(buf, len, subimage)

def fz_load_pnm_subimage_count(buf, len):
    r"""Class-aware wrapper for `::fz_load_pnm_subimage_count()`."""
    return _mupdf.fz_load_pnm_subimage_count(buf, len)

def fz_load_system_cjk_font(name, ordering, serif):
    r"""
    Class-aware wrapper for `::fz_load_system_cjk_font()`.
    	Attempt to load a given font from
    	the system.

    	name: The name of the desired font.

    	ordering: The ordering to load the font from (e.g. FZ_ADOBE_KOREA)

    	serif: 1 if serif desired, 0 otherwise.

    	Returns a new font handle, or NULL if no matching font was found
    	(or on error).
    """
    return _mupdf.fz_load_system_cjk_font(name, ordering, serif)

def fz_load_system_font(name, bold, italic, needs_exact_metrics):
    r"""
    Class-aware wrapper for `::fz_load_system_font()`.
    	Attempt to load a given font from the system.

    	name: The name of the desired font.

    	bold: 1 if bold desired, 0 otherwise.

    	italic: 1 if italic desired, 0 otherwise.

    	needs_exact_metrics: 1 if an exact metrical match is required,
    	0 otherwise.

    	Returns a new font handle, or NULL if no matching font was found
    	(or on error).
    """
    return _mupdf.fz_load_system_font(name, bold, italic, needs_exact_metrics)

def fz_load_tiff_subimage(buf, len, subimage):
    r"""Class-aware wrapper for `::fz_load_tiff_subimage()`."""
    return _mupdf.fz_load_tiff_subimage(buf, len, subimage)

def fz_load_tiff_subimage_count(buf, len):
    r"""
    Class-aware wrapper for `::fz_load_tiff_subimage_count()`.
    	Exposed for CBZ.
    """
    return _mupdf.fz_load_tiff_subimage_count(buf, len)

def fz_load_user_css(filename):
    r"""
    Class-aware wrapper for `::fz_load_user_css()`.
    	Set the user stylesheet by loading the source from a file.
    	If the file is missing, do nothing.
    """
    return _mupdf.fz_load_user_css(filename)

def fz_location_from_page_number(doc, number):
    r"""
    Class-aware wrapper for `::fz_location_from_page_number()`.
    	Converts from page number to chapter+page. This may cause many
    	chapters to be laid out in order to calculate the number of
    	pages within those chapters.
    """
    return _mupdf.fz_location_from_page_number(doc, number)

def fz_lock(lock):
    r"""
    Class-aware wrapper for `::fz_lock()`.
    	Lock one of the user supplied mutexes.
    """
    return _mupdf.fz_lock(lock)

def fz_log_error(str):
    r"""
    Class-aware wrapper for `::fz_log_error()`.
    	Log a (preformatted) string to the registered
    	error stream (stderr by default).
    """
    return _mupdf.fz_log_error(str)

def fz_lookup_base14_font(name, len):
    r"""
    Class-aware wrapper for `::fz_lookup_base14_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_base14_font(const char *name)` => `(const unsigned char *, int len)`

    	Search the builtin base14 fonts for a match.
    	Whether a given font is present or not will depend on the
    	configuration in which MuPDF is built.

    	name: The name of the font desired.

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_base14_font(name, len)

def fz_lookup_blendmode(name):
    r"""
    Class-aware wrapper for `::fz_lookup_blendmode()`.
    	Map from (case sensitive) blend mode string to enumeration.
    """
    return _mupdf.fz_lookup_blendmode(name)

def fz_lookup_bookmark(doc, mark):
    r"""
    Class-aware wrapper for `::fz_lookup_bookmark()`.
    	Find a bookmark and return its page number.
    """
    return _mupdf.fz_lookup_bookmark(doc, mark)

def fz_lookup_builtin_font(name, bold, italic, len):
    r"""
    Class-aware wrapper for `::fz_lookup_builtin_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_builtin_font(const char *name, int bold, int italic)` => `(const unsigned char *, int len)`

    	Search the builtin fonts for a match.
    	Whether a given font is present or not will depend on the
    	configuration in which MuPDF is built.

    	name: The name of the font desired.

    	bold: 1 if bold desired, 0 otherwise.

    	italic: 1 if italic desired, 0 otherwise.

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_builtin_font(name, bold, italic, len)

def fz_lookup_cjk_font(ordering, len, index):
    r"""
    Class-aware wrapper for `::fz_lookup_cjk_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_cjk_font(int ordering)` => `(const unsigned char *, int len, int index)`

    	Search the builtin cjk fonts for a match.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	ordering: The desired ordering of the font (e.g. FZ_ADOBE_KOREA).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_cjk_font(ordering, len, index)

def fz_lookup_cjk_font_by_language(lang, len, subfont):
    r"""
    Class-aware wrapper for `::fz_lookup_cjk_font_by_language()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_cjk_font_by_language(const char *lang)` => `(const unsigned char *, int len, int subfont)`

    	Search the builtin cjk fonts for a match for a given language.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	lang: Pointer to a (case sensitive) language string (e.g.
    	"ja", "ko", "zh-Hant" etc).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	subfont: Pointer to a place to store the subfont index of the
    	discovered font.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_cjk_font_by_language(lang, len, subfont)

def fz_lookup_cjk_ordering_by_language(name):
    r"""
    Class-aware wrapper for `::fz_lookup_cjk_ordering_by_language()`.
    	Return the matching FZ_ADOBE_* ordering
    	for the given language tag, such as "zh-Hant", "zh-Hans", "ja", or "ko".
    """
    return _mupdf.fz_lookup_cjk_ordering_by_language(name)

def fz_lookup_image_type(type):
    r"""
    Class-aware wrapper for `::fz_lookup_image_type()`.
    	Map from (case sensitive) image type string to FZ_IMAGE_*
    	type value.
    """
    return _mupdf.fz_lookup_image_type(type)

def fz_lookup_metadata(doc, key, buf, size):
    r"""
    Class-aware wrapper for `::fz_lookup_metadata()`.
    	Retrieve document meta data strings.

    	doc: The document to query.

    	key: Which meta data key to retrieve...

    	Basic information:
    		'format'	-- Document format and version.
    		'encryption'	-- Description of the encryption used.

    	From the document information dictionary:
    		'info:Title'
    		'info:Author'
    		'info:Subject'
    		'info:Keywords'
    		'info:Creator'
    		'info:Producer'
    		'info:CreationDate'
    		'info:ModDate'

    	buf: The buffer to hold the results (a nul-terminated UTF-8
    	string).

    	size: Size of 'buf'.

    	Returns the number of bytes need to store the string plus terminator
    	(will be larger than 'size' if the output was truncated), or -1 if the
    	key is not recognized or found.
    """
    return _mupdf.fz_lookup_metadata(doc, key, buf, size)

def fz_lookup_metadata2(doc, key):
    r"""
    Class-aware wrapper for `::fz_lookup_metadata2()`.
    C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
    or calls `fz_throw()` if not found.
    """
    return _mupdf.fz_lookup_metadata2(doc, key)

def fz_lookup_noto_boxes_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_boxes_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_boxes_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_boxes_font(len)

def fz_lookup_noto_emoji_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_emoji_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_emoji_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_emoji_font(len)

def fz_lookup_noto_font(script, lang, len, subfont):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_font(int script, int lang)` => `(const unsigned char *, int len, int subfont)`

    	Search the builtin noto fonts for a match.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).

    	lang: The language desired (e.g. FZ_LANG_ja).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_noto_font(script, lang, len, subfont)

def fz_lookup_noto_math_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_math_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_math_font()` => `(const unsigned char *, int len)`

    	Search the builtin noto fonts specific symbol fonts.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.
    """
    return _mupdf.fz_lookup_noto_math_font(len)

def fz_lookup_noto_music_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_music_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_music_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_music_font(len)

def fz_lookup_noto_stem_from_script(script, language):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_stem_from_script()`.
    	Look up the Noto font file name for a given script.
    	From the returned font stem, you can look for Noto fonts on the system in the form:
    		Noto(Sans|Serif)${STEM}-Regular.(otf|ttf)
    """
    return _mupdf.fz_lookup_noto_stem_from_script(script, language)

def fz_lookup_noto_symbol1_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_symbol1_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_symbol1_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_symbol1_font(len)

def fz_lookup_noto_symbol2_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_symbol2_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_symbol2_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_symbol2_font(len)

def fz_lookup_rendering_intent(name):
    r"""
    Class-aware wrapper for `::fz_lookup_rendering_intent()`.
    	Map from (case sensitive) rendering intent string to enumeration
    	value.
    """
    return _mupdf.fz_lookup_rendering_intent(name)

def fz_make_bookmark(doc, loc):
    r"""
    Class-aware wrapper for `::fz_make_bookmark()`.
    	Create a bookmark for the given page, which can be used to find
    	the same location after the document has been laid out with
    	different parameters.
    """
    return _mupdf.fz_make_bookmark(doc, loc)

def fz_make_irect(x0, y0, x1, y1):
    r"""Class-aware wrapper for `::fz_make_irect()`."""
    return _mupdf.fz_make_irect(x0, y0, x1, y1)

def fz_make_location(chapter, page):
    r"""
    Class-aware wrapper for `::fz_make_location()`.
    	Simple constructor for fz_locations.
    """
    return _mupdf.fz_make_location(chapter, page)

def fz_make_matrix(a, b, c, d, e, f):
    r"""Class-aware wrapper for `::fz_make_matrix()`."""
    return _mupdf.fz_make_matrix(a, b, c, d, e, f)

def fz_make_point(x, y):
    r"""Class-aware wrapper for `::fz_make_point()`."""
    return _mupdf.fz_make_point(x, y)

def fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y):
    r"""
    Class-aware wrapper for `::fz_make_quad()`.
    	Inline convenience construction function.
    """
    return _mupdf.fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y)

def fz_make_rect(x0, y0, x1, y1):
    r"""Class-aware wrapper for `::fz_make_rect()`."""
    return _mupdf.fz_make_rect(x0, y0, x1, y1)

def fz_malloc(size):
    r"""
    Class-aware wrapper for `::fz_malloc()`.
    	Allocate uninitialized memory of a given size.
    	Does NOT clear the memory!

    	May return NULL for size = 0.

    	Throws exception in the event of failure to allocate.
    """
    return _mupdf.fz_malloc(size)

def fz_malloc_aligned(size, align):
    r"""
    Class-aware wrapper for `::fz_malloc_aligned()`.
    	fz_malloc equivalent, except that the block is guaranteed aligned.
    	Block must be freed later using fz_free_aligned.
    """
    return _mupdf.fz_malloc_aligned(size, align)

def fz_malloc_no_throw(size):
    r"""
    Class-aware wrapper for `::fz_malloc_no_throw()`.
    	fz_malloc equivalent that returns NULL rather than throwing
    	exceptions.
    """
    return _mupdf.fz_malloc_no_throw(size)

def fz_matrix_expansion(m):
    r"""
    Class-aware wrapper for `::fz_matrix_expansion()`.
    	Calculate average scaling factor of matrix.
    """
    return _mupdf.fz_matrix_expansion(m)

def fz_matrix_max_expansion(m):
    r"""
    Class-aware wrapper for `::fz_matrix_max_expansion()`.
    	Find the largest expansion performed by this matrix.
    	(i.e. max(abs(m.a),abs(m.b),abs(m.c),abs(m.d))
    """
    return _mupdf.fz_matrix_max_expansion(m)

def fz_max(a, b):
    r"""Class-aware wrapper for `::fz_max()`."""
    return _mupdf.fz_max(a, b)

def fz_maxi(a, b):
    r"""Class-aware wrapper for `::fz_maxi()`."""
    return _mupdf.fz_maxi(a, b)

def fz_maxi64(a, b):
    r"""Class-aware wrapper for `::fz_maxi64()`."""
    return _mupdf.fz_maxi64(a, b)

def fz_maxz(a, b):
    r"""Class-aware wrapper for `::fz_maxz()`."""
    return _mupdf.fz_maxz(a, b)

def fz_md5_buffer(buffer, digest):
    r"""
    Class-aware wrapper for `::fz_md5_buffer()`.
    	Create an MD5 digest from buffer contents.

    	Never throws exceptions.
    """
    return _mupdf.fz_md5_buffer(buffer, digest)

def fz_md5_final(state, digest):
    r"""
    Class-aware wrapper for `::fz_md5_final()`.
    	MD5 finalization. Ends an MD5 message-digest operation, writing
    	the message digest and zeroizing the context.

    	Never throws an exception.
    """
    return _mupdf.fz_md5_final(state, digest)

def fz_md5_final2(md5):
    r"""
    Class-aware wrapper for `::fz_md5_final2()`.
    C++ alternative to fz_md5_final() that returns the digest by value.
    """
    return _mupdf.fz_md5_final2(md5)

def fz_md5_init(state):
    r"""
    Class-aware wrapper for `::fz_md5_init()`.
    	MD5 initialization. Begins an MD5 operation, writing a new
    	context.

    	Never throws an exception.
    """
    return _mupdf.fz_md5_init(state)

def fz_md5_pixmap(pixmap, digest):
    r"""Class-aware wrapper for `::fz_md5_pixmap()`."""
    return _mupdf.fz_md5_pixmap(pixmap, digest)

def fz_md5_pixmap2(pixmap):
    r"""
    Class-aware wrapper for `::fz_md5_pixmap2()`.
    C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
    """
    return _mupdf.fz_md5_pixmap2(pixmap)

def fz_md5_update(state, input, inlen):
    r"""
    Class-aware wrapper for `::fz_md5_update()`.
    	MD5 block update operation. Continues an MD5 message-digest
    	operation, processing another message block, and updating the
    	context.

    	Never throws an exception.
    """
    return _mupdf.fz_md5_update(state, input, inlen)

def fz_md5_update_int64(state, i):
    r"""
    Class-aware wrapper for `::fz_md5_update_int64()`.
    	MD5 block update operation. Continues an MD5 message-digest
    	operation, processing an int64, and updating the context.

    	Never throws an exception.
    """
    return _mupdf.fz_md5_update_int64(state, i)

def fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language):
    r"""
    Class-aware wrapper for `::fz_measure_string()`.
    	Measure the advance width of a UTF8 string should it be added to a text object.

    	This uses the same layout algorithms as fz_show_string, and can be used
    	to calculate text alignment adjustments.
    """
    return _mupdf.fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language)

def fz_memmem(haystack, haystacklen, needle, needlelen):
    r"""
    Class-aware wrapper for `::fz_memmem()`.
    	Find the start of the first occurrence of the substring needle in haystack.
    """
    return _mupdf.fz_memmem(haystack, haystacklen, needle, needlelen)

def fz_memrnd(block, len):
    r"""
    Class-aware wrapper for `::fz_memrnd()`.
    	Fill block with len bytes of pseudo-randomness.
    """
    return _mupdf.fz_memrnd(block, len)

def fz_min(a, b):
    r"""Class-aware wrapper for `::fz_min()`."""
    return _mupdf.fz_min(a, b)

def fz_mini(a, b):
    r"""Class-aware wrapper for `::fz_mini()`."""
    return _mupdf.fz_mini(a, b)

def fz_mini64(a, b):
    r"""Class-aware wrapper for `::fz_mini64()`."""
    return _mupdf.fz_mini64(a, b)

def fz_minz(a, b):
    r"""Class-aware wrapper for `::fz_minz()`."""
    return _mupdf.fz_minz(a, b)

def fz_mkdir(path):
    r"""Class-aware wrapper for `::fz_mkdir()`."""
    return _mupdf.fz_mkdir(path)

def fz_morph_error(fromcode, tocode):
    r"""
    Class-aware wrapper for `::fz_morph_error()`.
    	Called within a catch block this modifies the current
    	exception's code. If it's of type 'fromcode' it is
    	modified to 'tocode'. Typically used for 'downgrading'
    	exception severity.
    """
    return _mupdf.fz_morph_error(fromcode, tocode)

def fz_mount_multi_archive(arch_, sub, path):
    r"""
    Class-aware wrapper for `::fz_mount_multi_archive()`.
    	Add an archive to the set of archives handled by a multi
    	archive.

    	If path is NULL, then the archive contents will appear at the
    	top level, otherwise, the archives contents will appear prefixed
    	by path.
    """
    return _mupdf.fz_mount_multi_archive(arch_, sub, path)

def fz_moveto(path, x, y):
    r"""
    Class-aware wrapper for `::fz_moveto()`.
    	Append a 'moveto' command to a path.
    	This 'opens' a path.

    	path: The path to modify.

    	x, y: The coordinate to move to.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_moveto(path, x, y)

def fz_mul255(a, b):
    r"""
    Class-aware wrapper for `::fz_mul255()`.
    	Multiply scaled two integers in the 0..255 range
    """
    return _mupdf.fz_mul255(a, b)

def fz_needs_password(doc):
    r"""
    Class-aware wrapper for `::fz_needs_password()`.
    	Check if a document is encrypted with a
    	non-blank password.
    """
    return _mupdf.fz_needs_password(doc)

def fz_new_archive_of_size(file, size):
    r"""Class-aware wrapper for `::fz_new_archive_of_size()`."""
    return _mupdf.fz_new_archive_of_size(file, size)

def fz_new_base14_font(name):
    r"""
    Class-aware wrapper for `::fz_new_base14_font()`.
    	Create a new font from one of the built-in fonts.
    """
    return _mupdf.fz_new_base14_font(name)

def fz_new_bbox_device(rectp):
    r"""
    Class-aware wrapper for `::fz_new_bbox_device()`.
    	Create a device to compute the bounding
    	box of all marks on a page.

    	The returned bounding box will be the union of all bounding
    	boxes of all objects on a page.
    """
    return _mupdf.fz_new_bbox_device(rectp)

def fz_new_bitmap(w, h, n, xres, yres):
    r"""
    Class-aware wrapper for `::fz_new_bitmap()`.
    	Create a new bitmap.

    	w, h: Width and Height for the bitmap

    	n: Number of color components (assumed to be a divisor of 8)

    	xres, yres: X and Y resolutions (in pixels per inch).

    	Returns pointer to created bitmap structure. The bitmap
    	data is uninitialised.
    """
    return _mupdf.fz_new_bitmap(w, h, n, xres, yres)

def fz_new_bitmap_from_pixmap(pix, ht):
    r"""
    Class-aware wrapper for `::fz_new_bitmap_from_pixmap()`.
    	Make a bitmap from a pixmap and a halftone.

    	pix: The pixmap to generate from. Currently must be a single
    	color component with no alpha.

    	ht: The halftone to use. NULL implies the default halftone.

    	Returns the resultant bitmap. Throws exceptions in the case of
    	failure to allocate.
    """
    return _mupdf.fz_new_bitmap_from_pixmap(pix, ht)

def fz_new_bitmap_from_pixmap_band(pix, ht, band_start):
    r"""
    Class-aware wrapper for `::fz_new_bitmap_from_pixmap_band()`.
    	Make a bitmap from a pixmap and a
    	halftone, allowing for the position of the pixmap within an
    	overall banded rendering.

    	pix: The pixmap to generate from. Currently must be a single
    	color component with no alpha.

    	ht: The halftone to use. NULL implies the default halftone.

    	band_start: Vertical offset within the overall banded rendering
    	(in pixels)

    	Returns the resultant bitmap. Throws exceptions in the case of
    	failure to allocate.
    """
    return _mupdf.fz_new_bitmap_from_pixmap_band(pix, ht, band_start)

def fz_new_buffer(capacity):
    r"""Class-aware wrapper for `::fz_new_buffer()`."""
    return _mupdf.fz_new_buffer(capacity)

def fz_new_buffer_from_base64(data, size):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_base64()`.
    	Create a new buffer with data decoded from a base64 input string.
    """
    return _mupdf.fz_new_buffer_from_base64(data, size)

def fz_new_buffer_from_copied_data(data, size):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_copied_data()`.
    	Create a new buffer containing a copy of the passed data.
    """
    return _mupdf.fz_new_buffer_from_copied_data(data, size)

def fz_new_buffer_from_data(data, size):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_data()`.
    	Create a new buffer with existing data.

    	data: Pointer to existing data.
    	size: Size of existing data.

    	Takes ownership of data. Does not make a copy. Calls fz_free on
    	the data when the buffer is deallocated. Do not use 'data' after
    	passing to this function.

    	Returns pointer to new buffer. Throws exception on allocation
    	failure.
    """
    return _mupdf.fz_new_buffer_from_data(data, size)

def fz_new_buffer_from_display_list(list, options):
    r"""Class-aware wrapper for `::fz_new_buffer_from_display_list()`."""
    return _mupdf.fz_new_buffer_from_display_list(list, options)

def fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk):
    r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_jpeg()`."""
    return _mupdf.fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk)

def fz_new_buffer_from_image_as_jpx(image, color_params, quality):
    r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_jpx()`."""
    return _mupdf.fz_new_buffer_from_image_as_jpx(image, color_params, quality)

def fz_new_buffer_from_image_as_pam(image, color_params):
    r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`."""
    return _mupdf.fz_new_buffer_from_image_as_pam(image, color_params)

def fz_new_buffer_from_image_as_png(image, color_params):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_image_as_png()`.
    	Reencode a given image as a PNG into a buffer.

    	Ownership of the buffer is returned.
    """
    return _mupdf.fz_new_buffer_from_image_as_png(image, color_params)

def fz_new_buffer_from_image_as_pnm(image, color_params):
    r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
    return _mupdf.fz_new_buffer_from_image_as_pnm(image, color_params)

def fz_new_buffer_from_image_as_psd(image, color_params):
    r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`."""
    return _mupdf.fz_new_buffer_from_image_as_psd(image, color_params)

def fz_new_buffer_from_page(page, options):
    r"""Class-aware wrapper for `::fz_new_buffer_from_page()`."""
    return _mupdf.fz_new_buffer_from_page(page, options)

def fz_new_buffer_from_page_number(doc, number, options):
    r"""Class-aware wrapper for `::fz_new_buffer_from_page_number()`."""
    return _mupdf.fz_new_buffer_from_page_number(doc, number, options)

def fz_new_buffer_from_page_with_format(page, format, options, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_page_with_format()`.
    	Returns an fz_buffer containing a page after conversion to specified format.

    	page: The page to convert.
    	format, options: Passed to fz_new_document_writer_with_output() internally.
    	transform, cookie: Passed to fz_run_page() internally.
    """
    return _mupdf.fz_new_buffer_from_page_with_format(page, format, options, transform, cookie)

def fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk):
    r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk)

def fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality):
    r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality)

def fz_new_buffer_from_pixmap_as_pam(pixmap, color_params):
    r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_pam(pixmap, color_params)

def fz_new_buffer_from_pixmap_as_png(pixmap, color_params):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_png()`.
    	Reencode a given pixmap as a PNG into a buffer.

    	Ownership of the buffer is returned.
    """
    return _mupdf.fz_new_buffer_from_pixmap_as_png(pixmap, color_params)

def fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params):
    r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params)

def fz_new_buffer_from_pixmap_as_psd(pix, color_params):
    r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_psd(pix, color_params)

def fz_new_buffer_from_shared_data(data, size):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_shared_data()`.
    	Like fz_new_buffer, but does not take ownership.
    """
    return _mupdf.fz_new_buffer_from_shared_data(data, size)

def fz_new_buffer_from_stext_page(text):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_stext_page()`.
    	Convert structured text into plain text.
    """
    return _mupdf.fz_new_buffer_from_stext_page(text)

def fz_new_builtin_font(name, is_bold, is_italic):
    r"""Class-aware wrapper for `::fz_new_builtin_font()`."""
    return _mupdf.fz_new_builtin_font(name, is_bold, is_italic)

def fz_new_cal_gray_colorspace(wp, bp, gamma):
    r"""
    Class-aware wrapper for `::fz_new_cal_gray_colorspace()`.
    	Create a calibrated gray colorspace.

    	The returned reference should be dropped when it is finished
    	with.

    	Colorspaces are immutable once created.
    """
    return _mupdf.fz_new_cal_gray_colorspace(wp, bp, gamma)

def fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix):
    r"""
    Class-aware wrapper for `::fz_new_cal_rgb_colorspace()`.
    	Create a calibrated rgb colorspace.

    	The returned reference should be dropped when it is finished
    	with.

    	Colorspaces are immutable once created.
    """
    return _mupdf.fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix)

def fz_new_cjk_font(ordering):
    r"""Class-aware wrapper for `::fz_new_cjk_font()`."""
    return _mupdf.fz_new_cjk_font(ordering)

def fz_new_colorspace(type, flags, n, name):
    r"""
    Class-aware wrapper for `::fz_new_colorspace()`.
    	Creates a new colorspace instance and returns a reference.

    	No internal checking is done that the colorspace type (e.g.
    	CMYK) matches with the flags (e.g. FZ_COLORSPACE_HAS_CMYK) or
    	colorant count (n) or name.

    	The reference should be dropped when it is finished with.

    	Colorspaces are immutable once created (with the exception of
    	setting up colorant names for separation spaces).
    """
    return _mupdf.fz_new_colorspace(type, flags, n, name)

def fz_new_compressed_buffer():
    r"""
    Class-aware wrapper for `::fz_new_compressed_buffer()`.
    	Create a new, UNKNOWN format, compressed_buffer.
    """
    return _mupdf.fz_new_compressed_buffer()

def fz_new_default_colorspaces():
    r"""
    Class-aware wrapper for `::fz_new_default_colorspaces()`.
    	Create a new default colorspace structure with values inherited
    	from the context, and return a reference to it.

    	These can be overridden using fz_set_default_xxxx.

    	These should not be overridden while more than one caller has
    	the reference for fear of race conditions.

    	The caller should drop this reference once finished with it.
    """
    return _mupdf.fz_new_default_colorspaces()

def fz_new_deflated_data(compressed_length, source, source_length, level):
    r"""
     Class-aware wrapper for `::fz_new_deflated_data()`.

    	This function has out-params. Python/C# wrappers look like:
    		`fz_new_deflated_data(const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`

    		Compress source_length bytes of data starting
    		at source, into a new memory block malloced for that purpose.
    compressed_length is updated on exit to contain the size used.
    		Ownership of the block is returned from this function, and the
    		caller is therefore responsible for freeing it. The block may be
    		considerably larger than is actually required. The caller is
    		free to fz_realloc it down if it wants to.
    """
    return _mupdf.fz_new_deflated_data(compressed_length, source, source_length, level)

def fz_new_deflated_data_from_buffer(compressed_length, buffer, level):
    r"""
    Class-aware wrapper for `::fz_new_deflated_data_from_buffer()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_deflated_data_from_buffer(::fz_buffer *buffer, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`

    	Compress the contents of a fz_buffer into a
    	new block malloced for that purpose. *compressed_length is
    	updated on exit to contain the size used. Ownership of the block
    	is returned from this function, and the caller is therefore
    	responsible for freeing it. The block may be considerably larger
    	than is actually required. The caller is free to fz_realloc it
    	down if it wants to.
    """
    return _mupdf.fz_new_deflated_data_from_buffer(compressed_length, buffer, level)

def fz_new_device_of_size(size):
    r"""
    Class-aware wrapper for `::fz_new_device_of_size()`.
    	Devices are created by calls to device implementations, for
    	instance: foo_new_device(). These will be implemented by calling
    	fz_new_derived_device(ctx, foo_device) where foo_device is a
    	structure "derived from" fz_device, for instance
    	typedef struct { fz_device base;  ...extras...} foo_device;
    """
    return _mupdf.fz_new_device_of_size(size)

def fz_new_display_list(mediabox):
    r"""
    Class-aware wrapper for `::fz_new_display_list()`.
    	Create an empty display list.

    	A display list contains drawing commands (text, images, etc.).
    	Use fz_new_list_device for populating the list.

    	mediabox: Bounds of the page (in points) represented by the
    	display list.
    """
    return _mupdf.fz_new_display_list(mediabox)

def fz_new_display_list_from_page(page):
    r"""
    Class-aware wrapper for `::fz_new_display_list_from_page()`.
    	Create a display list.

    	Ownership of the display list is returned to the caller.
    """
    return _mupdf.fz_new_display_list_from_page(page)

def fz_new_display_list_from_page_contents(page):
    r"""
    Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.
    	Create a display list from page contents (no annotations).

    	Ownership of the display list is returned to the caller.
    """
    return _mupdf.fz_new_display_list_from_page_contents(page)

def fz_new_display_list_from_page_number(doc, number):
    r"""Class-aware wrapper for `::fz_new_display_list_from_page_number()`."""
    return _mupdf.fz_new_display_list_from_page_number(doc, number)

def fz_new_display_list_from_svg(buf, base_uri, dir, w, h):
    r"""
    Class-aware wrapper for `::fz_new_display_list_from_svg()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_display_list_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

    	Parse an SVG document into a display-list.
    """
    return _mupdf.fz_new_display_list_from_svg(buf, base_uri, dir, w, h)

def fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h):
    r"""
    Class-aware wrapper for `::fz_new_display_list_from_svg_xml()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_display_list_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

    	Parse an SVG document into a display-list.
    """
    return _mupdf.fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h)

def fz_new_document_of_size(size):
    r"""
    Class-aware wrapper for `::fz_new_document_of_size()`.
    	New documents are typically created by calls like
    	foo_new_document(fz_context *ctx, ...). These work by
    	deriving a new document type from fz_document, for instance:
    	typedef struct { fz_document base; ...extras... } foo_document;
    	These are allocated by calling
    	fz_new_derived_document(ctx, foo_document)
    """
    return _mupdf.fz_new_document_of_size(size)

def fz_new_dom(tag):
    r"""
    Class-aware wrapper for `::fz_new_dom()`.
    	Make new xml dom root element.
    """
    return _mupdf.fz_new_dom(tag)

def fz_new_dom_node(dom, tag):
    r"""
    Class-aware wrapper for `::fz_new_dom_node()`.
    	Create a new dom node.

    	This will NOT be linked in yet.
    """
    return _mupdf.fz_new_dom_node(dom, tag)

def fz_new_dom_text_node(dom, text):
    r"""
    Class-aware wrapper for `::fz_new_dom_text_node()`.
    	Create a new dom text node.

    	This will NOT be linked in yet.
    """
    return _mupdf.fz_new_dom_text_node(dom, text)

def fz_new_draw_device(transform, dest):
    r"""
    Class-aware wrapper for `::fz_new_draw_device()`.
    	Create a device to draw on a pixmap.

    	dest: Target pixmap for the draw device. See fz_new_pixmap*
    	for how to obtain a pixmap. The pixmap is not cleared by the
    	draw device, see fz_clear_pixmap* for how to clear it prior to
    	calling fz_new_draw_device. Free the device by calling
    	fz_drop_device.

    	transform: Transform from user space in points to device space
    	in pixels.
    """
    return _mupdf.fz_new_draw_device(transform, dest)

def fz_new_draw_device_type3(transform, dest):
    r"""Class-aware wrapper for `::fz_new_draw_device_type3()`."""
    return _mupdf.fz_new_draw_device_type3(transform, dest)

def fz_new_draw_device_with_bbox(transform, dest, clip):
    r"""
    Class-aware wrapper for `::fz_new_draw_device_with_bbox()`.
    	Create a device to draw on a pixmap.

    	dest: Target pixmap for the draw device. See fz_new_pixmap*
    	for how to obtain a pixmap. The pixmap is not cleared by the
    	draw device, see fz_clear_pixmap* for how to clear it prior to
    	calling fz_new_draw_device. Free the device by calling
    	fz_drop_device.

    	transform: Transform from user space in points to device space
    	in pixels.

    	clip: Bounding box to restrict any marking operations of the
    	draw device.
    """
    return _mupdf.fz_new_draw_device_with_bbox(transform, dest, clip)

def fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs):
    r"""
    Class-aware wrapper for `::fz_new_draw_device_with_bbox_proof()`.
    	Create a device to draw on a pixmap.

    	dest: Target pixmap for the draw device. See fz_new_pixmap*
    	for how to obtain a pixmap. The pixmap is not cleared by the
    	draw device, see fz_clear_pixmap* for how to clear it prior to
    	calling fz_new_draw_device. Free the device by calling
    	fz_drop_device.

    	transform: Transform from user space in points to device space
    	in pixels.

    	clip: Bounding box to restrict any marking operations of the
    	draw device.

    	proof_cs: Color space to render to prior to mapping to color
    	space defined by pixmap.
    """
    return _mupdf.fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs)

def fz_new_draw_device_with_options(options, mediabox, pixmap):
    r"""
    Class-aware wrapper for `::fz_new_draw_device_with_options()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_draw_device_with_options(const ::fz_draw_options *options, ::fz_rect mediabox, ::fz_pixmap **pixmap)` => `(fz_device *)`

    	Create a new pixmap and draw device, using the specified options.

    	options: Options to configure the draw device, and choose the
    	resolution and colorspace.

    	mediabox: The bounds of the page in points.

    	pixmap: An out parameter containing the newly created pixmap.
    """
    return _mupdf.fz_new_draw_device_with_options(options, mediabox, pixmap)

def fz_new_draw_device_with_proof(transform, dest, proof_cs):
    r"""
    Class-aware wrapper for `::fz_new_draw_device_with_proof()`.
    	Create a device to draw on a pixmap.

    	dest: Target pixmap for the draw device. See fz_new_pixmap*
    	for how to obtain a pixmap. The pixmap is not cleared by the
    	draw device, see fz_clear_pixmap* for how to clear it prior to
    	calling fz_new_draw_device. Free the device by calling
    	fz_drop_device.

    	transform: Transform from user space in points to device space
    	in pixels.

    	proof_cs: Intermediate color space to map though when mapping to
    	color space defined by pixmap.
    """
    return _mupdf.fz_new_draw_device_with_proof(transform, dest, proof_cs)

def fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox):
    r"""
    Class-aware wrapper for `::fz_new_font_from_buffer()`.
    	Create a new font from a font file in a fz_buffer.

    	Fonts created in this way, will be eligible for embedding by default.

    	name: Name of font (leave NULL to use name from font).

    	buffer: Buffer to load from.

    	index: Which font from the file to load (0 for default).

    	use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    	Returns new font handle, or throws exception on error.
    """
    return _mupdf.fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox)

def fz_new_font_from_file(name, path, index, use_glyph_bbox):
    r"""
    Class-aware wrapper for `::fz_new_font_from_file()`.
    	Create a new font from a font file.

    	Fonts created in this way, will be eligible for embedding by default.

    	name: Name of font (leave NULL to use name from font).

    	path: File path to load from.

    	index: Which font from the file to load (0 for default).

    	use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    	Returns new font handle, or throws exception on error.
    """
    return _mupdf.fz_new_font_from_file(name, path, index, use_glyph_bbox)

def fz_new_font_from_memory(name, data, len, index, use_glyph_bbox):
    r"""
    Class-aware wrapper for `::fz_new_font_from_memory()`.
    	Create a new font from a font file in memory.

    	Fonts created in this way, will be eligible for embedding by default.

    	name: Name of font (leave NULL to use name from font).

    	data: Pointer to the font file data.

    	len: Length of the font file data.

    	index: Which font from the file to load (0 for default).

    	use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    	Returns new font handle, or throws exception on error.
    """
    return _mupdf.fz_new_font_from_memory(name, data, len, index, use_glyph_bbox)

def fz_new_function_of_size(size, size2, m, n, eval, drop):
    r"""Class-aware wrapper for `::fz_new_function_of_size()`."""
    return _mupdf.fz_new_function_of_size(size, size2, m, n, eval, drop)

def fz_new_icc_colorspace(type, flags, name, buf):
    r"""
    Class-aware wrapper for `::fz_new_icc_colorspace()`.
    	Create a colorspace from an ICC profile supplied in buf.

    	Limited checking is done to ensure that the colorspace type is
    	appropriate for the supplied ICC profile.

    	An additional reference is taken to buf, which will be dropped
    	on destruction. Ownership is NOT passed in.

    	The returned reference should be dropped when it is finished
    	with.

    	Colorspaces are immutable once created.
    """
    return _mupdf.fz_new_icc_colorspace(type, flags, name, buf)

def fz_new_image_from_buffer(buffer):
    r"""
    Class-aware wrapper for `::fz_new_image_from_buffer()`.
    	Create a new image from a
    	buffer of data, inferring its type from the format
    	of the data.
    """
    return _mupdf.fz_new_image_from_buffer(buffer)

def fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
    r"""
    Class-aware wrapper for `::fz_new_image_from_compressed_buffer()`.
    	Create an image based on
    	the data in the supplied compressed buffer.

    	w,h: Width and height of the created image.

    	bpc: Bits per component.

    	colorspace: The colorspace (determines the number of components,
    	and any color conversions required while decoding).

    	xres, yres: The X and Y resolutions respectively.

    	interpolate: 1 if interpolation should be used when decoding
    	this image, 0 otherwise.

    	imagemask: 1 if this is an imagemask (i.e. transparency bitmap
    	mask), 0 otherwise.

    	decode: NULL, or a pointer to to a decode array. The default
    	decode array is [0 1] (repeated n times, for n color components).

    	colorkey: NULL, or a pointer to a colorkey array. The default
    	colorkey array is [0 255] (repeated n times, for n color
    	components).

    	buffer: Buffer of compressed data and compression parameters.
    	Ownership of this reference is passed in.

    	mask: NULL, or another image to use as a mask for this one.
    	A new reference is taken to this image. Supplying a masked
    	image as a mask to another image is illegal!
    """
    return _mupdf.fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)

def fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
    r"""
    Class-aware wrapper for `::fz_new_image_from_compressed_buffer2()`.   Swig-friendly wrapper for fz_new_image_from_compressed_buffer(),
    uses specified `decode` and `colorkey` if they are not null (in which
    case we assert that they have size `2*fz_colorspace_n(colorspace)`).
    """
    return _mupdf.fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)

def fz_new_image_from_display_list(w, h, list):
    r"""
    Class-aware wrapper for `::fz_new_image_from_display_list()`.
    	Create a new image from a display list.

    	w, h: The conceptual width/height of the image.

    	transform: The matrix that needs to be applied to the given
    	list to make it render to the unit square.

    	list: The display list.
    """
    return _mupdf.fz_new_image_from_display_list(w, h, list)

def fz_new_image_from_file(path):
    r"""
    Class-aware wrapper for `::fz_new_image_from_file()`.
    	Create a new image from the contents
    	of a file, inferring its type from the format of the
    	data.
    """
    return _mupdf.fz_new_image_from_file(path)

def fz_new_image_from_pixmap(pixmap, mask):
    r"""
    Class-aware wrapper for `::fz_new_image_from_pixmap()`.
    	Create an image from the given
    	pixmap.

    	pixmap: The pixmap to base the image upon. A new reference
    	to this is taken.

    	mask: NULL, or another image to use as a mask for this one.
    	A new reference is taken to this image. Supplying a masked
    	image as a mask to another image is illegal!
    """
    return _mupdf.fz_new_image_from_pixmap(pixmap, mask)

def fz_new_image_from_svg(buf, base_uri, dir):
    r"""
    Class-aware wrapper for `::fz_new_image_from_svg()`.
    	Create a scalable image from an SVG document.
    """
    return _mupdf.fz_new_image_from_svg(buf, base_uri, dir)

def fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir):
    r"""
    Class-aware wrapper for `::fz_new_image_from_svg_xml()`.
    	Create a scalable image from an SVG document.
    """
    return _mupdf.fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir)

def fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop):
    r"""
    Class-aware wrapper for `::fz_new_image_of_size()`.
    	Internal function to make a new fz_image structure
    	for a derived class.

    	w,h: Width and height of the created image.

    	bpc: Bits per component.

    	colorspace: The colorspace (determines the number of components,
    	and any color conversions required while decoding).

    	xres, yres: The X and Y resolutions respectively.

    	interpolate: 1 if interpolation should be used when decoding
    	this image, 0 otherwise.

    	imagemask: 1 if this is an imagemask (i.e. transparent), 0
    	otherwise.

    	decode: NULL, or a pointer to to a decode array. The default
    	decode array is [0 1] (repeated n times, for n color components).

    	colorkey: NULL, or a pointer to a colorkey array. The default
    	colorkey array is [0 255] (repeated n times, for n color
    	components).

    	mask: NULL, or another image to use as a mask for this one.
    	A new reference is taken to this image. Supplying a masked
    	image as a mask to another image is illegal!

    	size: The size of the required allocated structure (the size of
    	the derived structure).

    	get: The function to be called to obtain a decoded pixmap.

    	get_size: The function to be called to return the storage size
    	used by this image.

    	drop: The function to be called to dispose of this image once
    	the last reference is dropped.

    	Returns a pointer to an allocated structure of the required size,
    	with the first sizeof(fz_image) bytes initialised as appropriate
    	given the supplied parameters, and the other bytes set to zero.
    """
    return _mupdf.fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop)

def fz_new_indexed_colorspace(base, high, lookup):
    r"""
    Class-aware wrapper for `::fz_new_indexed_colorspace()`.
    	Create an indexed colorspace.

    	The supplied lookup table is high palette entries long. Each
    	entry is n bytes long, where n is given by the number of
    	colorants in the base colorspace, one byte per colorant.

    	Ownership of lookup is passed it; it will be freed on
    	destruction, so must be heap allocated.

    	The colorspace will keep an additional reference to the base
    	colorspace that will be dropped on destruction.

    	The returned reference should be dropped when it is finished
    	with.

    	Colorspaces are immutable once created.
    """
    return _mupdf.fz_new_indexed_colorspace(base, high, lookup)

def fz_new_link_of_size(size, rect, uri):
    r"""
    Class-aware wrapper for `::fz_new_link_of_size()`.
    	Create a new link record.

    	next is set to NULL with the expectation that the caller will
    	handle the linked list setup. Internal function.

    	Different document types will be implemented by deriving from
    	fz_link. This macro allocates such derived structures, and
    	initialises the base sections.
    """
    return _mupdf.fz_new_link_of_size(size, rect, uri)

def fz_new_list_device(list):
    r"""
    Class-aware wrapper for `::fz_new_list_device()`.
    	Create a rendering device for a display list.

    	When the device is rendering a page it will populate the
    	display list with drawing commands (text, images, etc.). The
    	display list can later be reused to render a page many times
    	without having to re-interpret the page from the document file
    	for each rendering. Once the device is no longer needed, free
    	it with fz_drop_device.

    	list: A display list that the list device takes a reference to.
    """
    return _mupdf.fz_new_list_device(list)

def fz_new_multi_archive():
    r"""
    Class-aware wrapper for `::fz_new_multi_archive()`.
    	Create a new multi archive (initially empty).
    """
    return _mupdf.fz_new_multi_archive()

def fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg):
    r"""
    Class-aware wrapper for `::fz_new_ocr_device()`.
    	Create a device to OCR the text on the page.

    	Renders the page internally to a bitmap that is then OCRd. Text
    	is then forwarded onto the target device.

    	target: The target device to receive the OCRd text.

    	ctm: The transform to apply to the mediabox to get the size for
    	the rendered page image. Also used to calculate the resolution
    	for the page image. In general, this will be the same as the CTM
    	that you pass to fz_run_page (or fz_run_display_list) to feed
    	this device.

    	mediabox: The mediabox (in points). Combined with the CTM to get
    	the bounds of the pixmap used internally for the rendered page
    	image.

    	with_list: If with_list is false, then all non-text operations
    	are forwarded instantly to the target device. This results in
    	the target device seeing all NON-text operations, followed by
    	all the text operations (derived from OCR).

    	If with_list is true, then all the marking operations are
    	collated into a display list which is then replayed to the
    	target device at the end.

    	language: NULL (for "eng"), or a pointer to a string to describe
    	the languages/scripts that should be used for OCR (e.g.
    	"eng,ara").

    	datadir: NULL (for ""), or a pointer to a path string otherwise
    	provided to Tesseract in the TESSDATA_PREFIX environment variable.

    	progress: NULL, or function to be called periodically to indicate
    	progress. Return 0 to continue, or 1 to cancel. progress_arg is
    	returned as the void *. The int is a value between 0 and 100 to
    	indicate progress.

    	progress_arg: A void * value to be parrotted back to the progress
    	function.
    """
    return _mupdf.fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg)

def fz_new_outline():
    r"""
    Class-aware wrapper for `::fz_new_outline()`.
    	Create a new outline entry with zeroed fields for the caller
    	to fill in.
    """
    return _mupdf.fz_new_outline()

def fz_new_page_of_size(size, doc):
    r"""
    Class-aware wrapper for `::fz_new_page_of_size()`.
    	Different document types will be implemented by deriving from
    	fz_page. This macro allocates such derived structures, and
    	initialises the base sections.
    """
    return _mupdf.fz_new_page_of_size(size, doc)

def fz_new_path():
    r"""
    Class-aware wrapper for `::fz_new_path()`.
    	Create a new (empty) path structure.
    """
    return _mupdf.fz_new_path()

def fz_new_pdf_document_from_fz_document(ptr):
    r"""Class-aware wrapper for `::fz_new_pdf_document_from_fz_document()`."""
    return _mupdf.fz_new_pdf_document_from_fz_document(ptr)

def fz_new_pixmap(cs, w, h, seps, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap()`.
    	Create a new pixmap, with its origin at (0,0)

    	cs: The colorspace to use for the pixmap, or NULL for an alpha
    	plane/mask.

    	w: The width of the pixmap (in pixels)

    	h: The height of the pixmap (in pixels)

    	seps: Details of separations.

    	alpha: 0 for no alpha, 1 for alpha.

    	Returns a pointer to the new pixmap. Throws exception on failure
    	to allocate.
    """
    return _mupdf.fz_new_pixmap(cs, w, h, seps, alpha)

def fz_new_pixmap_from_alpha_channel(src):
    r"""Class-aware wrapper for `::fz_new_pixmap_from_alpha_channel()`."""
    return _mupdf.fz_new_pixmap_from_alpha_channel(src)

def fz_new_pixmap_from_color_and_mask(color, mask):
    r"""Class-aware wrapper for `::fz_new_pixmap_from_color_and_mask()`."""
    return _mupdf.fz_new_pixmap_from_color_and_mask(color, mask)

def fz_new_pixmap_from_display_list(list, ctm, cs, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_from_display_list()`.
    	Render the page to a pixmap using the transform and colorspace.

    	Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.fz_new_pixmap_from_display_list(list, ctm, cs, alpha)

def fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.
    	Render the page contents with control over spot colors.

    	Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha)

def fz_new_pixmap_from_page(page, ctm, cs, alpha):
    r"""Class-aware wrapper for `::fz_new_pixmap_from_page()`."""
    return _mupdf.fz_new_pixmap_from_page(page, ctm, cs, alpha)

def fz_new_pixmap_from_page_contents(page, ctm, cs, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.
    	Render the page contents without annotations.

    	Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.fz_new_pixmap_from_page_contents(page, ctm, cs, alpha)

def fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha):
    r"""Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
    return _mupdf.fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha)

def fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha):
    r"""Class-aware wrapper for `::fz_new_pixmap_from_page_number()`."""
    return _mupdf.fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha)

def fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha):
    r"""Class-aware wrapper for `::fz_new_pixmap_from_page_number_with_separations()`."""
    return _mupdf.fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha)

def fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha):
    r"""Class-aware wrapper for `::fz_new_pixmap_from_page_with_separations()`."""
    return _mupdf.fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha)

def fz_new_pixmap_from_pixmap(pixmap, rect):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_from_pixmap()`.
    	Create a new pixmap that represents a subarea of the specified
    	pixmap. A reference is taken to this pixmap that will be dropped
    	on destruction.

    	The supplied rectangle must be wholly contained within the
    	original pixmap.

    	Returns a pointer to the new pixmap. Throws exception on failure
    	to allocate.
    """
    return _mupdf.fz_new_pixmap_from_pixmap(pixmap, rect)

def fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_with_bbox()`.
    	Create a pixmap of a given size, location and pixel format.

    	The bounding box specifies the size of the created pixmap and
    	where it will be located. The colorspace determines the number
    	of components per pixel. Alpha is always present. Pixmaps are
    	reference counted, so drop references using fz_drop_pixmap.

    	colorspace: Colorspace format used for the created pixmap. The
    	pixmap will keep a reference to the colorspace.

    	bbox: Bounding box specifying location/size of created pixmap.

    	seps: Details of separations.

    	alpha: 0 for no alpha, 1 for alpha.

    	Returns a pointer to the new pixmap. Throws exception on failure
    	to allocate.
    """
    return _mupdf.fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha)

def fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_with_bbox_and_data()`.
    	Create a pixmap of a given size, location and pixel format,
    	using the supplied data block.

    	The bounding box specifies the size of the created pixmap and
    	where it will be located. The colorspace determines the number
    	of components per pixel. Alpha is always present. Pixmaps are
    	reference counted, so drop references using fz_drop_pixmap.

    	colorspace: Colorspace format used for the created pixmap. The
    	pixmap will keep a reference to the colorspace.

    	rect: Bounding box specifying location/size of created pixmap.

    	seps: Details of separations.

    	alpha: Number of alpha planes (0 or 1).

    	samples: The data block to keep the samples in.

    	Returns a pointer to the new pixmap. Throws exception on failure
    	to allocate.
    """
    return _mupdf.fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples)

def fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_with_data()`.
    	Create a new pixmap, with its origin at
    	(0,0) using the supplied data block.

    	cs: The colorspace to use for the pixmap, or NULL for an alpha
    	plane/mask.

    	w: The width of the pixmap (in pixels)

    	h: The height of the pixmap (in pixels)

    	seps: Details of separations.

    	alpha: 0 for no alpha, 1 for alpha.

    	stride: The byte offset from the pixel data in a row to the
    	pixel data in the next row.

    	samples: The data block to keep the samples in.

    	Returns a pointer to the new pixmap. Throws exception on failure to
    	allocate.
    """
    return _mupdf.fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples)

def fz_new_separations(controllable):
    r"""
    Class-aware wrapper for `::fz_new_separations()`.
    	Create a new separations structure (initially empty)
    """
    return _mupdf.fz_new_separations(controllable)

def fz_new_stext_device(page, options):
    r"""
    Class-aware wrapper for `::fz_new_stext_device()`.
    	Create a device to extract the text on a page.

    	Gather the text on a page into blocks and lines.

    	The reading order is taken from the order the text is drawn in
    	the source file, so may not be accurate.

    	page: The text page to which content should be added. This will
    	usually be a newly created (empty) text page, but it can be one
    	containing data already (for example when merging multiple
    	pages, or watermarking).

    	options: Options to configure the stext device.
    """
    return _mupdf.fz_new_stext_device(page, options)

def fz_new_store_context(max):
    r"""
    Class-aware wrapper for `::fz_new_store_context()`.
    	Create a new store inside the context

    	max: The maximum size (in bytes) that the store is allowed to
    	grow to. FZ_STORE_UNLIMITED means no limit.
    """
    return _mupdf.fz_new_store_context(max)

def fz_new_stream(state, next, drop):
    r"""
    Class-aware wrapper for `::fz_new_stream()`.
    	Create a new stream object with the given
    	internal state and function pointers.

    	state: Internal state (opaque to everything but implementation).

    	next: Should provide the next set of bytes (up to max) of stream
    	data. Return the number of bytes read, or EOF when there is no
    	more data.

    	drop: Should clean up and free the internal state. May not
    	throw exceptions.
    """
    return _mupdf.fz_new_stream(state, next, drop)

def fz_new_string(str):
    r"""Class-aware wrapper for `::fz_new_string()`."""
    return _mupdf.fz_new_string(str)

def fz_new_stroke_state():
    r"""
    Class-aware wrapper for `::fz_new_stroke_state()`.
    	Create a new (empty) stroke state structure (with no dash
    	data) and return a reference to it.

    	Throws exception on failure to allocate.
    """
    return _mupdf.fz_new_stroke_state()

def fz_new_stroke_state_with_dash_len(len):
    r"""
    Class-aware wrapper for `::fz_new_stroke_state_with_dash_len()`.
    	Create a new (empty) stroke state structure, with room for
    	dash data of the given length, and return a reference to it.

    	len: The number of dash elements to allow room for.

    	Throws exception on failure to allocate.
    """
    return _mupdf.fz_new_stroke_state_with_dash_len(len)

def fz_new_svg_device(out, page_width, page_height, text_format, reuse_images):
    r"""
    Class-aware wrapper for `::fz_new_svg_device()`.
    	Create a device that outputs (single page) SVG files to
    	the given output stream.

    	Equivalent to fz_new_svg_device_with_id passing id = NULL.
    """
    return _mupdf.fz_new_svg_device(out, page_width, page_height, text_format, reuse_images)

def fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id):
    r"""
    Class-aware wrapper for `::fz_new_svg_device_with_id()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_svg_device_with_id(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`

    	Create a device that outputs (single page) SVG files to
    	the given output stream.

    	output: The output stream to send the constructed SVG page to.

    	page_width, page_height: The page dimensions to use (in points).

    	text_format: How to emit text. One of the following values:
    		FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
    		layout errors and mismatching fonts.
    		FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
    		visual appearance.

    	reuse_images: Share image resources using <symbol> definitions.

    	id: ID parameter to keep generated IDs unique across SVG files.
    """
    return _mupdf.fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id)

def fz_new_test_device(is_color, threshold, options, passthrough):
    r"""
    Class-aware wrapper for `::fz_new_test_device()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_test_device(float threshold, int options, ::fz_device *passthrough)` => `(fz_device *, int is_color)`

    	Create a device to test for features.

    	Currently only tests for the presence of non-grayscale colors.

    	is_color: Possible values returned:
    		0: Definitely greyscale
    		1: Probably color (all colors were grey, but there
    		were images or shadings in a non grey colorspace).
    		2: Definitely color

    	threshold: The difference from grayscale that will be tolerated.
    	Typical values to use are either 0 (be exact) and 0.02 (allow an
    	imperceptible amount of slop).

    	options: A set of bitfield options, from the FZ_TEST_OPT set.

    	passthrough: A device to pass all calls through to, or NULL.
    	If set, then the test device can both test and pass through to
    	an underlying device (like, say, the display list device). This
    	means that a display list can be created and at the end we'll
    	know if it's colored or not.

    	In the absence of a passthrough device, the device will throw
    	an exception to stop page interpretation when color is found.
    """
    return _mupdf.fz_new_test_device(is_color, threshold, options, passthrough)

def fz_new_text():
    r"""
    Class-aware wrapper for `::fz_new_text()`.
    	Create a new empty fz_text object.

    	Throws exception on failure to allocate.
    """
    return _mupdf.fz_new_text()

def fz_new_trace_device(out):
    r"""
    Class-aware wrapper for `::fz_new_trace_device()`.
    	Create a device to print a debug trace of all device calls.
    """
    return _mupdf.fz_new_trace_device(out)

def fz_new_tree_archive(tree):
    r"""
    Class-aware wrapper for `::fz_new_tree_archive()`.
    	Create an archive that holds named buffers.

    	tree can either be a preformed tree with fz_buffers as values,
    	or it can be NULL for an empty tree.
    """
    return _mupdf.fz_new_tree_archive(tree)

def fz_new_type3_font(name, matrix):
    r"""
    Class-aware wrapper for `::fz_new_type3_font()`.
    	Create a new (empty) type3 font.

    	name: Name of font (or NULL).

    	matrix: Font matrix.

    	Returns a new font handle, or throws exception on
    	allocation failure.
    """
    return _mupdf.fz_new_type3_font(name, matrix)

def fz_new_xhtml_document_from_document(old_doc, opts):
    r"""
    Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.
    	Use text extraction to convert the input document into XHTML,
    	then open the result as a new document that can be reflowed.
    """
    return _mupdf.fz_new_xhtml_document_from_document(old_doc, opts)

def fz_new_xmltext_device(out):
    r"""
    Class-aware wrapper for `::fz_new_xmltext_device()`.
    	Create a device to output raw information.
    """
    return _mupdf.fz_new_xmltext_device(out)

def fz_next_page(doc, loc):
    r"""
    Class-aware wrapper for `::fz_next_page()`.
    	Function to get the location of the next page (allowing for the
    	end of chapters etc). If at the end of the document, returns the
    	current location.
    """
    return _mupdf.fz_next_page(doc, loc)

def fz_normalize_vector(p):
    r"""
    Class-aware wrapper for `::fz_normalize_vector()`.
    	Normalize a vector to length one.
    """
    return _mupdf.fz_normalize_vector(p)

def fz_open_a85d(chain):
    r"""
    Class-aware wrapper for `::fz_open_a85d()`.
    	a85d filter performs ASCII 85 Decoding of data read
    	from the chained filter.
    """
    return _mupdf.fz_open_a85d(chain)

def fz_open_accelerated_document(filename, accel):
    r"""
    Class-aware wrapper for `::fz_open_accelerated_document()`.
    	Open a document file and read its basic structure so pages and
    	objects can be located. MuPDF will try to repair broken
    	documents (without actually changing the file contents).

    	The returned fz_document is used when calling most other
    	document related functions.

    	filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.fz_open_accelerated_document(filename, accel)

def fz_open_accelerated_document_with_stream(magic, stream, accel):
    r"""
    Class-aware wrapper for `::fz_open_accelerated_document_with_stream()`.
    	Open a document using the specified stream object rather than
    	opening a file on disk.

    	magic: a string used to detect document type; either a file name
    	or mime-type.

    	stream: a stream of the document contents.

    	accel: NULL, or a stream of the 'accelerator' contents for this document.

    	NOTE: The caller retains ownership of 'stream' and 'accel' - the document will
    	take its own references if required.
    """
    return _mupdf.fz_open_accelerated_document_with_stream(magic, stream, accel)

def fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir):
    r"""
    Class-aware wrapper for `::fz_open_accelerated_document_with_stream_and_dir()`.
    	Open a document using the specified stream object rather than
    	opening a file on disk.

    	magic: a string used to detect document type; either a file name
    	or mime-type.

    	stream: a stream of the document contents.

    	accel: NULL, or a stream of the 'accelerator' contents for this document.

    	dir: NULL, or the 'directory context' for the stream contents.

    	NOTE: The caller retains ownership of 'stream', 'accel' and 'dir' - the document will
    	take its own references if required.
    """
    return _mupdf.fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir)

def fz_open_aesd(chain, key, keylen):
    r"""
    Class-aware wrapper for `::fz_open_aesd()`.
    	aesd filter performs AES decoding of data read from the chained
    	filter using the supplied key.
    """
    return _mupdf.fz_open_aesd(chain, key, keylen)

def fz_open_ahxd(chain):
    r"""
    Class-aware wrapper for `::fz_open_ahxd()`.
    	ahxd filter performs ASCII Hex decoding of data read
    	from the chained filter.
    """
    return _mupdf.fz_open_ahxd(chain)

def fz_open_arc4(chain, key, keylen):
    r"""
    Class-aware wrapper for `::fz_open_arc4()`.
    	arc4 filter performs RC4 decoding of data read from the chained
    	filter using the supplied key.
    """
    return _mupdf.fz_open_arc4(chain, key, keylen)

def fz_open_archive(filename):
    r"""
    Class-aware wrapper for `::fz_open_archive()`.
    	Open a zip or tar archive

    	Open a file and identify its archive type based on the archive
    	signature contained inside.

    	filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.fz_open_archive(filename)

def fz_open_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_open_archive_entry()`.
    	Opens an archive entry as a stream.

    	name: Entry name to look for, this must be an exact match to
    	the entry name in the archive.

    	Throws an exception if a matching entry cannot be found.
    """
    return _mupdf.fz_open_archive_entry(arch, name)

def fz_open_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_archive_with_stream()`.
    	Open zip or tar archive stream.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.
    """
    return _mupdf.fz_open_archive_with_stream(file)

def fz_open_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_open_buffer()`.
    	Open a buffer as a stream.

    	buf: The buffer to open. Ownership of the buffer is NOT passed
    	in (this function takes its own reference).

    	Returns pointer to newly created stream. May throw exceptions on
    	failure to allocate.
    """
    return _mupdf.fz_open_buffer(buf)

def fz_open_cfb_archive(filename):
    r"""
    Class-aware wrapper for `::fz_open_cfb_archive()`.
    	Open a cfb file as an archive.

    	An exception is thrown if the file is not recognised as a cfb.

    	filename: a path to an archive file as it would be given to
    	open(2).
    """
    return _mupdf.fz_open_cfb_archive(filename)

def fz_open_cfb_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_cfb_archive_with_stream()`.
    	Open a cfb file as an archive.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.

    	An exception is thrown if the file is not recognised as a chm.
    """
    return _mupdf.fz_open_cfb_archive_with_stream(file)

def fz_open_compressed_buffer(arg_0):
    r"""
    Class-aware wrapper for `::fz_open_compressed_buffer()`.
    	Open a stream to read the decompressed version of a buffer.
    """
    return _mupdf.fz_open_compressed_buffer(arg_0)

def fz_open_concat(max, pad):
    r"""
    Class-aware wrapper for `::fz_open_concat()`.
    	Concat filter concatenates several streams into one.
    """
    return _mupdf.fz_open_concat(max, pad)

def fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables):
    r"""
    Class-aware wrapper for `::fz_open_dctd()`.
    	dctd filter performs DCT (JPEG) decoding of data read
    	from the chained filter.

    	color_transform implements the PDF color_transform option
    		use -1 for default behavior
    		use 0 to disable YUV-RGB / YCCK-CMYK transforms
    		use 1 to enable YUV-RGB / YCCK-CMYK transforms

    	invert_cmyk implements the necessary inversion for Photoshop CMYK images
    		use 0 if embedded in PDF
    		use 1 if not embedded in PDF

    	For subsampling on decode, set l2factor to the log2 of the
    	reduction required (therefore 0 = full size decode).

    	jpegtables is an optional stream from which the JPEG tables
    	can be read. Use NULL if not required.
    """
    return _mupdf.fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables)

def fz_open_directory(path):
    r"""
    Class-aware wrapper for `::fz_open_directory()`.
    	Open a directory as if it was an archive.

    	A special case where a directory is opened as if it was an
    	archive.

    	Note that for directories it is not possible to retrieve the
    	number of entries or list the entries. It is however possible
    	to check if the archive has a particular entry.

    	path: a path to a directory as it would be given to opendir(3).
    """
    return _mupdf.fz_open_directory(path)

def fz_open_document(filename):
    r"""
    Class-aware wrapper for `::fz_open_document()`.
    	Open a document file and read its basic structure so pages and
    	objects can be located. MuPDF will try to repair broken
    	documents (without actually changing the file contents).

    	The returned fz_document is used when calling most other
    	document related functions.

    	filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.fz_open_document(filename)

def fz_open_document_with_buffer(magic, buffer):
    r"""
    Class-aware wrapper for `::fz_open_document_with_buffer()`.
    	Open a document using a buffer rather than opening a file on disk.
    """
    return _mupdf.fz_open_document_with_buffer(magic, buffer)

def fz_open_document_with_stream(magic, stream):
    r"""
    Class-aware wrapper for `::fz_open_document_with_stream()`.
    	Open a document using the specified stream object rather than
    	opening a file on disk.

    	magic: a string used to detect document type; either a file name
    	or mime-type.

    	stream: a stream representing the contents of the document file.

    	NOTE: The caller retains ownership of 'stream' - the document will take its
    	own reference if required.
    """
    return _mupdf.fz_open_document_with_stream(magic, stream)

def fz_open_document_with_stream_and_dir(magic, stream, dir):
    r"""
    Class-aware wrapper for `::fz_open_document_with_stream_and_dir()`.
    	Open a document using the specified stream object rather than
    	opening a file on disk.

    	magic: a string used to detect document type; either a file name
    	or mime-type.

    	stream: a stream representing the contents of the document file.

    	dir: a 'directory context' for those filetypes that need it.

    	NOTE: The caller retains ownership of 'stream' and 'dir' - the document will
    	take its own references if required.
    """
    return _mupdf.fz_open_document_with_stream_and_dir(magic, stream, dir)

def fz_open_endstream_filter(chain, len, offset):
    r"""
    Class-aware wrapper for `::fz_open_endstream_filter()`.
    	The endstream filter reads a PDF substream, and starts to look
    	for an 'endstream' token after the specified length.
    """
    return _mupdf.fz_open_endstream_filter(chain, len, offset)

def fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1):
    r"""
    Class-aware wrapper for `::fz_open_faxd()`.
    	faxd filter performs FAX decoding of data read from
    	the chained filter.

    	k: see fax specification (fax default is 0).

    	end_of_line: whether we expect end of line markers (fax default
    	is 0).

    	encoded_byte_align: whether we align to bytes after each line
    	(fax default is 0).

    	columns: how many columns in the image (fax default is 1728).

    	rows: 0 for unspecified or the number of rows of data to expect.

    	end_of_block: whether we expect end of block markers (fax
    	default is 1).

    	black_is_1: determines the polarity of the image (fax default is
    	0).
    """
    return _mupdf.fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1)

def fz_open_file(filename):
    r"""
    Class-aware wrapper for `::fz_open_file()`.
    	Open the named file and wrap it in a stream.

    	filename: Path to a file. On non-Windows machines the filename
    	should be exactly as it would be passed to fopen(2). On Windows
    	machines, the path should be UTF-8 encoded so that non-ASCII
    	characters can be represented. Other platforms do the encoding
    	as standard anyway (and in most cases, particularly for MacOS
    	and Linux, the encoding they use is UTF-8 anyway).
    """
    return _mupdf.fz_open_file(filename)

def fz_open_file_autodelete(filename):
    r"""
    Class-aware wrapper for `::fz_open_file_autodelete()`.
    	Do the same as fz_open_file, but delete the file upon close.
    """
    return _mupdf.fz_open_file_autodelete(filename)

def fz_open_file_ptr_no_close(file):
    r"""
    Class-aware wrapper for `::fz_open_file_ptr_no_close()`.
    	Create a stream from a FILE * that will not be closed
    	when the stream is dropped.
    """
    return _mupdf.fz_open_file_ptr_no_close(file)

def fz_open_flated(chain, window_bits):
    r"""
    Class-aware wrapper for `::fz_open_flated()`.
    	flated filter performs LZ77 decoding (inflating) of data read
    	from the chained filter.

    	window_bits: How large a decompression window to use. Typically
    	15. A negative number, -n, means to use n bits, but to expect
    	raw data with no header.
    """
    return _mupdf.fz_open_flated(chain, window_bits)

def fz_open_image_decomp_stream(arg_0, arg_1, l2factor):
    r"""
    Class-aware wrapper for `::fz_open_image_decomp_stream()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_open_image_decomp_stream(::fz_stream *arg_0, ::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`

    	Open a stream to read the decompressed version of another stream
    	with optional log2 subsampling.
    """
    return _mupdf.fz_open_image_decomp_stream(arg_0, arg_1, l2factor)

def fz_open_image_decomp_stream_from_buffer(arg_0, l2factor):
    r"""
    Class-aware wrapper for `::fz_open_image_decomp_stream_from_buffer()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_open_image_decomp_stream_from_buffer(::fz_compressed_buffer *arg_0)` => `(fz_stream *, int l2factor)`

    	Open a stream to read the decompressed version of a buffer,
    	with optional log2 subsampling.

    	l2factor = NULL for no subsampling, or a pointer to an integer
    	containing the maximum log2 subsample factor acceptable (0 =
    	none, 1 = halve dimensions, 2 = quarter dimensions etc). If
    	non-NULL, then *l2factor will be updated on exit with the actual
    	log2 subsample factor achieved.
    """
    return _mupdf.fz_open_image_decomp_stream_from_buffer(arg_0, l2factor)

def fz_open_jbig2d(chain, globals, embedded):
    r"""
    Class-aware wrapper for `::fz_open_jbig2d()`.
    	Open a filter that performs jbig2 decompression on the chained
    	stream, using the optional globals record.
    """
    return _mupdf.fz_open_jbig2d(chain, globals, embedded)

def fz_open_leecher(chain, buf):
    r"""
    Class-aware wrapper for `::fz_open_leecher()`.
    	Attach a filter to a stream that will store any
    	characters read from the stream into the supplied buffer.

    	chain: The underlying stream to leech from.

    	buf: The buffer into which the read data should be appended.
    	The buffer will be resized as required.

    	Returns pointer to newly created stream. May throw exceptions on
    	failure to allocate.
    """
    return _mupdf.fz_open_leecher(chain, buf)

def fz_open_libarchive_archive(filename):
    r"""
    Class-aware wrapper for `::fz_open_libarchive_archive()`.
    	Open an archive using libarchive.

    	An exception is thrown if the file is not supported by libarchive.

    	filename: a path to an archive file as it would be given to
    	open(2).
    """
    return _mupdf.fz_open_libarchive_archive(filename)

def fz_open_libarchive_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_libarchive_archive_with_stream()`.
    	Open an archive using libarchive.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.

    	An exception is thrown if the stream is not supported by libarchive.
    """
    return _mupdf.fz_open_libarchive_archive_with_stream(file)

def fz_open_libarchived(chain):
    r"""
    Class-aware wrapper for `::fz_open_libarchived()`.
    	libarchived filter performs generic compressed decoding of data
    	in any format understood by libarchive from the chained filter.

    	This will throw an exception if libarchive is not built in, or
    	if the compression format is not recognised.
    """
    return _mupdf.fz_open_libarchived(chain)

def fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff):
    r"""
    Class-aware wrapper for `::fz_open_lzwd()`.
    	lzwd filter performs LZW decoding of data read from the chained
    	filter.

    	early_change: (Default 1) specifies whether to change codes 1
    	bit early.

    	min_bits: (Default 9) specifies the minimum number of bits to
    	use.

    	reverse_bits: (Default 0) allows for compatibility with gif and
    	old style tiffs (1).

    	old_tiff: (Default 0) allows for different handling of the clear
    	code, as found in old style tiffs.
    """
    return _mupdf.fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff)

def fz_open_memory(data, len):
    r"""
    Class-aware wrapper for `::fz_open_memory()`.
    	Open a block of memory as a stream.

    	data: Pointer to start of data block. Ownership of the data
    	block is NOT passed in.

    	len: Number of bytes in data block.

    	Returns pointer to newly created stream. May throw exceptions on
    	failure to allocate.
    """
    return _mupdf.fz_open_memory(data, len)

def fz_open_null_filter(chain, len, offset):
    r"""
    Class-aware wrapper for `::fz_open_null_filter()`.
    	The null filter reads a specified amount of data from the
    	substream.
    """
    return _mupdf.fz_open_null_filter(chain, len, offset)

def fz_open_predict(chain, predictor, columns, colors, bpc):
    r"""
    Class-aware wrapper for `::fz_open_predict()`.
    	predict filter performs pixel prediction on data read from
    	the chained filter.

    	predictor: 1 = copy, 2 = tiff, other = inline PNG predictor

    	columns: width of image in pixels

    	colors: number of components.

    	bpc: bits per component (typically 8)
    """
    return _mupdf.fz_open_predict(chain, predictor, columns, colors, bpc)

def fz_open_range_filter(chain, ranges, nranges):
    r"""
    Class-aware wrapper for `::fz_open_range_filter()`.
    	The range filter copies data from specified ranges of the
    	chained stream.
    """
    return _mupdf.fz_open_range_filter(chain, ranges, nranges)

def fz_open_reflowed_document(underdoc, opts):
    r"""Class-aware wrapper for `::fz_open_reflowed_document()`."""
    return _mupdf.fz_open_reflowed_document(underdoc, opts)

def fz_open_rld(chain):
    r"""
    Class-aware wrapper for `::fz_open_rld()`.
    	rld filter performs Run Length Decoding of data read
    	from the chained filter.
    """
    return _mupdf.fz_open_rld(chain)

def fz_open_sgilog16(chain, w):
    r"""
    Class-aware wrapper for `::fz_open_sgilog16()`.
    	SGI Log 16bit (greyscale) decode from the chained filter.
    	Decodes lines of w pixels to 8bpp greyscale.
    """
    return _mupdf.fz_open_sgilog16(chain, w)

def fz_open_sgilog24(chain, w):
    r"""
    Class-aware wrapper for `::fz_open_sgilog24()`.
    	SGI Log 24bit (LUV) decode from the chained filter.
    	Decodes lines of w pixels to 8bpc rgb.
    """
    return _mupdf.fz_open_sgilog24(chain, w)

def fz_open_sgilog32(chain, w):
    r"""
    Class-aware wrapper for `::fz_open_sgilog32()`.
    	SGI Log 32bit (LUV) decode from the chained filter.
    	Decodes lines of w pixels to 8bpc rgb.
    """
    return _mupdf.fz_open_sgilog32(chain, w)

def fz_open_tar_archive(filename):
    r"""
    Class-aware wrapper for `::fz_open_tar_archive()`.
    	Open a tar archive file.

    	An exception is thrown if the file is not a tar archive as
    	indicated by the presence of a tar signature.

    	filename: a path to a tar archive file as it would be given to
    	open(2).
    """
    return _mupdf.fz_open_tar_archive(filename)

def fz_open_tar_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_tar_archive_with_stream()`.
    	Open a tar archive stream.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.

    	An exception is thrown if the stream is not a tar archive as
    	indicated by the presence of a tar signature.

    """
    return _mupdf.fz_open_tar_archive_with_stream(file)

def fz_open_thunder(chain, w):
    r"""
    Class-aware wrapper for `::fz_open_thunder()`.
    	4bit greyscale Thunderscan decoding from the chained filter.
    	Decodes lines of w pixels to 8bpp greyscale.
    """
    return _mupdf.fz_open_thunder(chain, w)

def fz_open_zip_archive(path):
    r"""
    Class-aware wrapper for `::fz_open_zip_archive()`.
    	Open a zip archive file.

    	An exception is thrown if the file is not a zip archive as
    	indicated by the presence of a zip signature.

    	filename: a path to a zip archive file as it would be given to
    	open(2).
    """
    return _mupdf.fz_open_zip_archive(path)

def fz_open_zip_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_zip_archive_with_stream()`.
    	Open a zip archive stream.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.

    	An exception is thrown if the stream is not a zip archive as
    	indicated by the presence of a zip signature.

    """
    return _mupdf.fz_open_zip_archive_with_stream(file)

def fz_opt_from_list(opt, optlist):
    r"""
    Class-aware wrapper for `::fz_opt_from_list()`.
    	Return the index of a (case-insensitive) option within an optlist.

    	For instance for optlist = "Foo|Bar|Baz", and  opt = "bar",
    	this would return 1.

    	If the optlist ends with "|*" then that is a catch all case and
    	matches all options allowing the caller to process it itself.
    	fz_optarg will be set to point to the option, and the return
    	value will be the index of the '*' option within that list.

    	If an optlist entry ends with ':' (e.g. "Foo:") then that option
    	may have suboptions appended to it (for example "JPG:80") and
    	fz_optarg will be set to point at "80". Otherwise fz_optarg will
    	be set to NULL.

    	In the event of no-match found, prints an error and returns -1.
    """
    return _mupdf.fz_opt_from_list(opt, optlist)

def fz_option_eq(a, b):
    r"""
    Class-aware wrapper for `::fz_option_eq()`.
    	Check to see if an option, a, from a string matches a reference
    	option, b.

    	(i.e. a could be 'foo' or 'foo,bar...' etc, but b can only be
    	'foo'.)
    """
    return _mupdf.fz_option_eq(a, b)

def fz_outline_glyph(font, gid, ctm):
    r"""
    Class-aware wrapper for `::fz_outline_glyph()`.
    	Look a glyph up from a font, and return the outline of the
    	glyph using the given transform.

    	The caller owns the returned path, and so is responsible for
    	ensuring that it eventually gets dropped.
    """
    return _mupdf.fz_outline_glyph(font, gid, ctm)

def fz_outline_iterator_delete(iter):
    r"""
    Class-aware wrapper for `::fz_outline_iterator_delete()`.
    	Delete the current item.

    	This implicitly moves us to the 'next' item, and the return code is as for fz_outline_iterator_next.
    """
    return _mupdf.fz_outline_iterator_delete(iter)

def fz_outline_iterator_down(iter):
    r"""Class-aware wrapper for `::fz_outline_iterator_down()`."""
    return _mupdf.fz_outline_iterator_down(iter)

def fz_outline_iterator_item(iter):
    r"""
    Class-aware wrapper for `::fz_outline_iterator_item()`.
    	Call to get the current outline item.

    	Can return NULL. The item is only valid until the next call.
    """
    return _mupdf.fz_outline_iterator_item(iter)

def fz_outline_iterator_next(iter):
    r"""
    Class-aware wrapper for `::fz_outline_iterator_next()`.
    	Calls to move the iterator position.

    	A negative return value means we could not move as requested. Otherwise:
    	0 = the final position has a valid item.
    	1 = not a valid item, but we can insert an item here.
    """
    return _mupdf.fz_outline_iterator_next(iter)

def fz_outline_iterator_prev(iter):
    r"""Class-aware wrapper for `::fz_outline_iterator_prev()`."""
    return _mupdf.fz_outline_iterator_prev(iter)

def fz_outline_iterator_up(iter):
    r"""Class-aware wrapper for `::fz_outline_iterator_up()`."""
    return _mupdf.fz_outline_iterator_up(iter)

def fz_output_accelerator(doc, accel):
    r"""
    Class-aware wrapper for `::fz_output_accelerator()`.
    	Output accelerator data for the document to a given output
    	stream.
    """
    return _mupdf.fz_output_accelerator(doc, accel)

def fz_output_supports_stream(out):
    r"""
    Class-aware wrapper for `::fz_output_supports_stream()`.
    	Query whether a given fz_output supports fz_stream_from_output.
    """
    return _mupdf.fz_output_supports_stream(out)

def fz_output_xml(out, item, level):
    r"""
    Class-aware wrapper for `::fz_output_xml()`.
    	Pretty-print an XML tree to given output.
    """
    return _mupdf.fz_output_xml(out, item, level)

def fz_pack_path(pack, path):
    r"""
    Class-aware wrapper for `::fz_pack_path()`.
    	Pack a path into the given block.
    	To minimise the size of paths, this function allows them to be
    	packed into a buffer with other information. Paths can be used
    	interchangeably regardless of how they are packed.

    	pack: Pointer to a block of data to pack the path into. Should
    	be aligned by the caller to the same alignment as required for
    	a fz_path pointer.

    	path: The path to pack.

    	Returns the number of bytes within the block used. Callers can
    	access the packed path data by casting the value of pack on
    	entry to be a fz_path *.

    	Throws exceptions on failure to allocate.

    	Implementation details: Paths can be 'unpacked', 'flat', or
    	'open'. Standard paths, as created are 'unpacked'. Paths
    	will be packed as 'flat', unless they are too large
    	(where large indicates that they exceed some private
    	implementation defined limits, currently including having
    	more than 256 coordinates or commands).

    	Large paths are 'open' packed as a header into the given block,
    	plus pointers to other data blocks.

    	Users should not have to care about whether paths are 'open'
    	or 'flat' packed. Simply pack a path (if required), and then
    	forget about the details.
    """
    return _mupdf.fz_pack_path(pack, path)

def fz_packed_path_size(path):
    r"""
    Class-aware wrapper for `::fz_packed_path_size()`.
    	Return the number of bytes required to pack a path.
    """
    return _mupdf.fz_packed_path_size(path)

def fz_page_label(page, buf, size):
    r"""
    Class-aware wrapper for `::fz_page_label()`.
    	Get page label for a given page.
    """
    return _mupdf.fz_page_label(page, buf, size)

def fz_page_number_from_location(doc, loc):
    r"""
    Class-aware wrapper for `::fz_page_number_from_location()`.
    	Converts from chapter+page to page number. This may cause many
    	chapters to be laid out in order to calculate the number of
    	pages within those chapters.
    """
    return _mupdf.fz_page_number_from_location(doc, loc)

def fz_page_presentation(page, transition, duration):
    r"""
    Class-aware wrapper for `::fz_page_presentation()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_page_presentation(::fz_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`

    	Get the presentation details for a given page.

    	transition: A pointer to a transition struct to fill out.

    	duration: A pointer to a place to set the page duration in
    	seconds. Will be set to 0 if no transition is specified for the
    	page.

    	Returns: a pointer to the transition structure, or NULL if there
    	is no transition specified for the page.
    """
    return _mupdf.fz_page_presentation(page, transition, duration)

def fz_page_separations(page):
    r"""
    Class-aware wrapper for `::fz_page_separations()`.
    	Get the separations details for a page.
    	This will be NULL, unless the format specifically supports
    	separations (such as PDF files). May be NULL even
    	so, if there are no separations on a page.

    	Returns a reference that must be dropped.
    """
    return _mupdf.fz_page_separations(page)

def fz_page_uses_overprint(page):
    r"""
    Class-aware wrapper for `::fz_page_uses_overprint()`.
    	Query if a given page requires overprint.
    """
    return _mupdf.fz_page_uses_overprint(page)

def fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache):
    r"""
    Class-aware wrapper for `::fz_paint_shade()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_paint_shade(::fz_shade *shade, ::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` =>

    	Render a shade to a given pixmap.

    	shade: The shade to paint.

    	override_cs: NULL, or colorspace to override the shades
    	inbuilt colorspace.

    	ctm: The transform to apply.

    	dest: The pixmap to render into.

    	color_params: The color rendering settings

    	bbox: Pointer to a bounding box to limit the rendering
    	of the shade.

    	eop: NULL, or pointer to overprint bitmap.

    	cache: *cache is used to cache color information. If *cache is NULL it
    	is set to point to a new fz_shade_color_cache. If cache is NULL it is
    	ignored.
    """
    return _mupdf.fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache)

def fz_parse_page_range(s, a, b, n):
    r"""
    Class-aware wrapper for `::fz_parse_page_range()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_parse_page_range(const char *s, int n)` => `(const char *, int a, int b)`
    """
    return _mupdf.fz_parse_page_range(s, a, b, n)

def fz_parse_pdfocr_options(opts, args):
    r"""
    Class-aware wrapper for `::fz_parse_pdfocr_options()`.
    	Parse PDFOCR options.

    	Currently defined options and values are as follows:

    		compression=none: No compression
    		compression=flate: Flate compression
    		strip-height=n: Strip height (default 16)
    		ocr-language=<lang>: OCR Language (default eng)
    		ocr-datadir=<datadir>: OCR data path (default rely on TESSDATA_PREFIX)
    """
    return _mupdf.fz_parse_pdfocr_options(opts, args)

def fz_parse_stext_options(opts, string):
    r"""
    Class-aware wrapper for `::fz_parse_stext_options()`.
    	Parse stext device options from a comma separated key-value
    	string.
    """
    return _mupdf.fz_parse_stext_options(opts, string)

def fz_parse_xml(buf, preserve_white):
    r"""
    Class-aware wrapper for `::fz_parse_xml()`.
    	Parse the contents of buffer into a tree of xml nodes.

    	preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.fz_parse_xml(buf, preserve_white)

def fz_parse_xml_archive_entry(dir, filename, preserve_white):
    r"""
    Class-aware wrapper for `::fz_parse_xml_archive_entry()`.
    	Parse the contents of an archive entry into a tree of xml nodes.

    	preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.fz_parse_xml_archive_entry(dir, filename, preserve_white)

def fz_parse_xml_from_html5(buf):
    r"""
    Class-aware wrapper for `::fz_parse_xml_from_html5()`.
    	Parse the contents of a buffer into a tree of XML nodes,
    	using the HTML5 parsing algorithm.
    """
    return _mupdf.fz_parse_xml_from_html5(buf)

def fz_parse_xml_stream(stream, preserve_white):
    r"""
    Class-aware wrapper for `::fz_parse_xml_stream()`.
    	Parse the contents of buffer into a tree of xml nodes.

    	preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.fz_parse_xml_stream(stream, preserve_white)

def fz_pcl_preset(opts, preset):
    r"""
    Class-aware wrapper for `::fz_pcl_preset()`.
    	Initialize PCL option struct for a given preset.

    	Currently defined presets include:

    		generic	Generic PCL printer
    		ljet4	HP DeskJet
    		dj500	HP DeskJet 500
    		fs600	Kyocera FS-600
    		lj	HP LaserJet, HP LaserJet Plus
    		lj2	HP LaserJet IIp, HP LaserJet IId
    		lj3	HP LaserJet III
    		lj3d	HP LaserJet IIId
    		lj4	HP LaserJet 4
    		lj4pl	HP LaserJet 4 PL
    		lj4d	HP LaserJet 4d
    		lp2563b	HP 2563B line printer
    		oce9050	Oce 9050 Line printer
    """
    return _mupdf.fz_pcl_preset(opts, preset)

def fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg):
    r"""
    Class-aware wrapper for `::fz_pdfocr_band_writer_set_progress()`.
    	Set the progress callback for a pdfocr bandwriter.
    """
    return _mupdf.fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg)

def fz_pdfocr_writer_set_progress(writer, progress, arg_2):
    r"""Class-aware wrapper for `::fz_pdfocr_writer_set_progress()`."""
    return _mupdf.fz_pdfocr_writer_set_progress(writer, progress, arg_2)

def fz_peek_byte(stm):
    r"""
    Class-aware wrapper for `::fz_peek_byte()`.
    	Peek at the next byte in a stream.

    	stm: The stream to peek at.

    	Returns -1 for EOF, or the next byte that will be read.
    """
    return _mupdf.fz_peek_byte(stm)

def fz_pixmap_alpha(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_alpha()`.
    	Return the number of alpha planes in a pixmap.

    	Returns the number of alphas. Does not throw exceptions.
    """
    return _mupdf.fz_pixmap_alpha(pix)

def fz_pixmap_bbox(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_bbox()`.
    	Return the bounding box for a pixmap.
    """
    return _mupdf.fz_pixmap_bbox(pix)

def fz_pixmap_colorants(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_colorants()`.
    	Return the number of colorants in a pixmap.

    	Returns the number of colorants (components, less any spots and
    	alpha).
    """
    return _mupdf.fz_pixmap_colorants(pix)

def fz_pixmap_colorspace(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_colorspace()`.
    	Return the colorspace of a pixmap

    	Returns colorspace.
    """
    return _mupdf.fz_pixmap_colorspace(pix)

def fz_pixmap_components(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_components()`.
    	Return the number of components in a pixmap.

    	Returns the number of components (including spots and alpha).
    """
    return _mupdf.fz_pixmap_components(pix)

def fz_pixmap_height(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_height()`.
    	Return the height of the pixmap in pixels.
    """
    return _mupdf.fz_pixmap_height(pix)

def fz_pixmap_image_tile(cimg):
    r"""
    Class-aware wrapper for `::fz_pixmap_image_tile()`.
    	Retrieve the underlying fz_pixmap for an image.

    	Returns a pointer to the underlying fz_pixmap for an image,
    	or NULL if this image is not based upon an fz_pixmap.

    	No reference is returned. Lifespan is limited to that of
    	the image itself. If required, use fz_keep_pixmap to take
    	a reference to keep it longer.
    """
    return _mupdf.fz_pixmap_image_tile(cimg)

def fz_pixmap_samples(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_samples()`.
    	Returns a pointer to the pixel data of a pixmap.

    	Returns the pointer.
    """
    return _mupdf.fz_pixmap_samples(pix)

def fz_pixmap_samples_int(pixmap):
    r"""Class-aware wrapper for `::fz_pixmap_samples_int()`."""
    return _mupdf.fz_pixmap_samples_int(pixmap)

def fz_pixmap_size(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_size()`.
    	Return sizeof fz_pixmap plus size of data, in bytes.
    """
    return _mupdf.fz_pixmap_size(pix)

def fz_pixmap_spots(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_spots()`.
    	Return the number of spots in a pixmap.

    	Returns the number of spots (components, less colorants and
    	alpha). Does not throw exceptions.
    """
    return _mupdf.fz_pixmap_spots(pix)

def fz_pixmap_stride(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_stride()`.
    	Return the number of bytes in a row in the pixmap.
    """
    return _mupdf.fz_pixmap_stride(pix)

def fz_pixmap_width(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_width()`.
    	Return the width of the pixmap in pixels.
    """
    return _mupdf.fz_pixmap_width(pix)

def fz_pixmap_x(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_x()`.
    	Return the x value of the pixmap in pixels.
    """
    return _mupdf.fz_pixmap_x(pix)

def fz_pixmap_y(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_y()`.
    	Return the y value of the pixmap in pixels.
    """
    return _mupdf.fz_pixmap_y(pix)

def fz_place_story(story, where, filled):
    r"""Class-aware wrapper for `::fz_place_story()`."""
    return _mupdf.fz_place_story(story, where, filled)

def fz_place_story_flags(story, where, filled, flags):
    r"""Class-aware wrapper for `::fz_place_story_flags()`."""
    return _mupdf.fz_place_story_flags(story, where, filled, flags)

def fz_pool_alloc(pool, size):
    r"""
    Class-aware wrapper for `::fz_pool_alloc()`.
    	Allocate a block of size bytes from the pool.
    """
    return _mupdf.fz_pool_alloc(pool, size)

def fz_pool_size(pool):
    r"""
    Class-aware wrapper for `::fz_pool_size()`.
    	The current size of the pool.

    	The number of bytes of storage currently allocated to the pool.
    	This is the total of the storage used for the blocks making
    	up the pool, rather then total of the allocated blocks so far,
    	so it will increase in 'lumps'.
    	from the pool, then the pool size may still be X
    """
    return _mupdf.fz_pool_size(pool)

def fz_pool_strdup(pool, s):
    r"""
    Class-aware wrapper for `::fz_pool_strdup()`.
    	strdup equivalent allocating from the pool.
    """
    return _mupdf.fz_pool_strdup(pool, s)

def fz_pop_clip(dev):
    r"""Class-aware wrapper for `::fz_pop_clip()`."""
    return _mupdf.fz_pop_clip(dev)

def fz_post_scale(m, sx, sy):
    r"""
    Class-aware wrapper for `::fz_post_scale()`.
    	Scale a matrix by postmultiplication.

    	m: Pointer to the matrix to scale

    	sx, sy: Scaling factors along the X- and Y-axes. A scaling
    	factor of 1.0 will not cause any scaling along the relevant
    	axis.

    	Returns m (updated).
    """
    return _mupdf.fz_post_scale(m, sx, sy)

def fz_pre_rotate(m, degrees):
    r"""
    Class-aware wrapper for `::fz_pre_rotate()`.
    	Rotate a transformation by premultiplying.

    	The premultiplied matrix is of the form
    	[ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

    	m: Pointer to matrix to premultiply.

    	degrees: Degrees of counter clockwise rotation. Values less
    	than zero and greater than 360 are handled as expected.

    	Returns m (updated).
    """
    return _mupdf.fz_pre_rotate(m, degrees)

def fz_pre_scale(m, sx, sy):
    r"""
    Class-aware wrapper for `::fz_pre_scale()`.
    	Scale a matrix by premultiplication.

    	m: Pointer to the matrix to scale

    	sx, sy: Scaling factors along the X- and Y-axes. A scaling
    	factor of 1.0 will not cause any scaling along the relevant
    	axis.

    	Returns m (updated).
    """
    return _mupdf.fz_pre_scale(m, sx, sy)

def fz_pre_shear(m, sx, sy):
    r"""
    Class-aware wrapper for `::fz_pre_shear()`.
    	Premultiply a matrix with a shearing matrix.

    	The shearing matrix is of the form [ 1 sy sx 1 0 0 ].

    	m: pointer to matrix to premultiply

    	sx, sy: Shearing factors. A shearing factor of 0.0 will not
    	cause any shearing along the relevant axis.

    	Returns m (updated).
    """
    return _mupdf.fz_pre_shear(m, sx, sy)

def fz_pre_translate(m, tx, ty):
    r"""
    Class-aware wrapper for `::fz_pre_translate()`.
    	Translate a matrix by premultiplication.

    	m: The matrix to translate

    	tx, ty: Translation distances along the X- and Y-axes. A
    	translation of 0 will not cause any translation along the
    	relevant axis.

    	Returns m.
    """
    return _mupdf.fz_pre_translate(m, tx, ty)

def fz_prepare_t3_glyph(font, gid):
    r"""
    Class-aware wrapper for `::fz_prepare_t3_glyph()`.
    	Force a type3 font to cache the displaylist for a given glyph
    	id.

    	This caching can involve reading the underlying file, so must
    	happen ahead of time, so we aren't suddenly forced to read the
    	file while playing a displaylist back.
    """
    return _mupdf.fz_prepare_t3_glyph(font, gid)

def fz_previous_page(doc, loc):
    r"""
    Class-aware wrapper for `::fz_previous_page()`.
    	Function to get the location of the previous page (allowing for
    	the end of chapters etc). If already at the start of the
    	document, returns the current page.
    """
    return _mupdf.fz_previous_page(doc, loc)

def fz_print_stext_header_as_html(out):
    r"""Class-aware wrapper for `::fz_print_stext_header_as_html()`."""
    return _mupdf.fz_print_stext_header_as_html(out)

def fz_print_stext_header_as_xhtml(out):
    r"""Class-aware wrapper for `::fz_print_stext_header_as_xhtml()`."""
    return _mupdf.fz_print_stext_header_as_xhtml(out)

def fz_print_stext_page_as_html(out, page, id):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_html()`.
    	Output structured text to a file in HTML (visual) format.
    """
    return _mupdf.fz_print_stext_page_as_html(out, page, id)

def fz_print_stext_page_as_json(out, page, scale):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_json()`.
    	Output structured text to a file in JSON format.
    """
    return _mupdf.fz_print_stext_page_as_json(out, page, scale)

def fz_print_stext_page_as_text(out, page):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_text()`.
    	Output structured text to a file in plain-text UTF-8 format.
    """
    return _mupdf.fz_print_stext_page_as_text(out, page)

def fz_print_stext_page_as_xhtml(out, page, id):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_xhtml()`.
    	Output structured text to a file in XHTML (semantic) format.
    """
    return _mupdf.fz_print_stext_page_as_xhtml(out, page, id)

def fz_print_stext_page_as_xml(out, page, id):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_xml()`.
    	Output structured text to a file in XML format.
    """
    return _mupdf.fz_print_stext_page_as_xml(out, page, id)

def fz_print_stext_trailer_as_html(out):
    r"""Class-aware wrapper for `::fz_print_stext_trailer_as_html()`."""
    return _mupdf.fz_print_stext_trailer_as_html(out)

def fz_print_stext_trailer_as_xhtml(out):
    r"""Class-aware wrapper for `::fz_print_stext_trailer_as_xhtml()`."""
    return _mupdf.fz_print_stext_trailer_as_xhtml(out)

def fz_process_opened_pages(doc, process_openend_page, state):
    r"""
    Class-aware wrapper for `::fz_process_opened_pages()`.
    	Iterates over all opened pages of the document, calling the
    	provided callback for each page for processing. If the callback
    	returns non-NULL then the iteration stops and that value is returned
    	to the called of fz_process_opened_pages().

    	The state pointer provided to fz_process_opened_pages() is
    	passed on to the callback but is owned by the caller.

    	Returns the first non-NULL value returned by the callback,
    	or NULL if the callback returned NULL for all opened pages.
    """
    return _mupdf.fz_process_opened_pages(doc, process_openend_page, state)

def fz_process_shade(shade, ctm, scissor, prepare, process, process_arg):
    r"""
    Class-aware wrapper for `::fz_process_shade()`.
    	Process a shade, using supplied callback functions. This
    	decomposes the shading to a mesh (even ones that are not
    	natively meshes, such as linear or radial shadings), and
    	processes triangles from those meshes.

    	shade: The shade to process.

    	ctm: The transform to use

    	prepare: Callback function to 'prepare' each vertex.
    	This function is passed an array of floats, and populates
    	a fz_vertex structure.

    	process: This function is passed 3 pointers to vertex
    	structures, and actually performs the processing (typically
    	filling the area between the vertexes).

    	process_arg: An opaque argument passed through from caller
    	to callback functions.
    """
    return _mupdf.fz_process_shade(shade, ctm, scissor, prepare, process, process_arg)

def fz_ptr_heap_insert(heap, v, HEAP_CMP):
    r"""Class-aware wrapper for `::fz_ptr_heap_insert()`."""
    return _mupdf.fz_ptr_heap_insert(heap, v, HEAP_CMP)

def fz_ptr_heap_sort(heap, HEAP_CMP):
    r"""Class-aware wrapper for `::fz_ptr_heap_sort()`."""
    return _mupdf.fz_ptr_heap_sort(heap, HEAP_CMP)

def fz_ptr_heap_uniq(heap, HEAP_CMP):
    r"""Class-aware wrapper for `::fz_ptr_heap_uniq()`."""
    return _mupdf.fz_ptr_heap_uniq(heap, HEAP_CMP)

def fz_purge_glyph_cache():
    r"""
    Class-aware wrapper for `::fz_purge_glyph_cache()`.
    	Purge all the glyphs from the cache.
    """
    return _mupdf.fz_purge_glyph_cache()

def fz_quad_from_rect(r):
    r"""
    Class-aware wrapper for `::fz_quad_from_rect()`.
    	Convert a rect to a quad (losslessly).
    """
    return _mupdf.fz_quad_from_rect(r)

def fz_quadto(path, x0, y0, x1, y1):
    r"""
    Class-aware wrapper for `::fz_quadto()`.
    	Append a 'quadto' command to an open path. (For a
    	quadratic bezier).

    	path: The path to modify.

    	x0, y0: The control coordinates for the quadratic curve.

    	x1, y1: The end coordinates for the quadratic curve.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_quadto(path, x0, y0, x1, y1)

def fz_read(stm, data, len):
    r"""
    Class-aware wrapper for `::fz_read()`.
    	Read from a stream into a given data block.

    	stm: The stream to read from.

    	data: The data block to read into.

    	len: The length of the data block (in bytes).

    	Returns the number of bytes read. May throw exceptions.
    """
    return _mupdf.fz_read(stm, data, len)

def fz_read_all(stm, initial):
    r"""
    Class-aware wrapper for `::fz_read_all()`.
    	Read all of a stream into a buffer.

    	stm: The stream to read from

    	initial: Suggested initial size for the buffer.

    	Returns a buffer created from reading from the stream. May throw
    	exceptions on failure to allocate.
    """
    return _mupdf.fz_read_all(stm, initial)

def fz_read_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_read_archive_entry()`.
    	Reads all bytes in an archive entry
    	into a buffer.

    	name: Entry name to look for, this must be an exact match to
    	the entry name in the archive.

    	Throws an exception if a matching entry cannot be found.
    """
    return _mupdf.fz_read_archive_entry(arch, name)

def fz_read_best(stm, initial, truncated, worst_case):
    r"""
    Class-aware wrapper for `::fz_read_best()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_read_best(::fz_stream *stm, size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`

    	Attempt to read a stream into a buffer. If truncated
    	is NULL behaves as fz_read_all, sets a truncated flag in case of
    	error.

    	stm: The stream to read from.

    	initial: Suggested initial size for the buffer.

    	truncated: Flag to store success/failure indication in.

    	worst_case: 0 for unknown, otherwise an upper bound for the
    	size of the stream.

    	Returns a buffer created from reading from the stream.
    """
    return _mupdf.fz_read_best(stm, initial, truncated, worst_case)

def fz_read_bits(stm, n):
    r"""
    Class-aware wrapper for `::fz_read_bits()`.
    	Read the next n bits from a stream (assumed to
    	be packed most significant bit first).

    	stm: The stream to read from.

    	n: The number of bits to read, between 1 and 8*sizeof(int)
    	inclusive.

    	Returns -1 for EOF, or the required number of bits.
    """
    return _mupdf.fz_read_bits(stm, n)

def fz_read_byte(stm):
    r"""
    Class-aware wrapper for `::fz_read_byte()`.
    	Read the next byte from a stream.

    	stm: The stream t read from.

    	Returns -1 for end of stream, or the next byte. May
    	throw exceptions.
    """
    return _mupdf.fz_read_byte(stm)

def fz_read_file(filename):
    r"""
    Class-aware wrapper for `::fz_read_file()`.
    	Read all the contents of a file into a buffer.
    """
    return _mupdf.fz_read_file(filename)

def fz_read_float(stm):
    r"""Class-aware wrapper for `::fz_read_float()`."""
    return _mupdf.fz_read_float(stm)

def fz_read_float_le(stm):
    r"""Class-aware wrapper for `::fz_read_float_le()`."""
    return _mupdf.fz_read_float_le(stm)

def fz_read_int16(stm):
    r"""Class-aware wrapper for `::fz_read_int16()`."""
    return _mupdf.fz_read_int16(stm)

def fz_read_int16_le(stm):
    r"""Class-aware wrapper for `::fz_read_int16_le()`."""
    return _mupdf.fz_read_int16_le(stm)

def fz_read_int32(stm):
    r"""Class-aware wrapper for `::fz_read_int32()`."""
    return _mupdf.fz_read_int32(stm)

def fz_read_int32_le(stm):
    r"""Class-aware wrapper for `::fz_read_int32_le()`."""
    return _mupdf.fz_read_int32_le(stm)

def fz_read_int64(stm):
    r"""Class-aware wrapper for `::fz_read_int64()`."""
    return _mupdf.fz_read_int64(stm)

def fz_read_int64_le(stm):
    r"""Class-aware wrapper for `::fz_read_int64_le()`."""
    return _mupdf.fz_read_int64_le(stm)

def fz_read_line(stm, buf, max):
    r"""
    Class-aware wrapper for `::fz_read_line()`.
    	Read a line from stream into the buffer until either a
    	terminating newline or EOF, which it replaces with a null byte
    	('').

    	Returns buf on success, and NULL when end of file occurs while
    	no characters have been read.
    """
    return _mupdf.fz_read_line(stm, buf, max)

def fz_read_rbits(stm, n):
    r"""
    Class-aware wrapper for `::fz_read_rbits()`.
    	Read the next n bits from a stream (assumed to
    	be packed least significant bit first).

    	stm: The stream to read from.

    	n: The number of bits to read, between 1 and 8*sizeof(int)
    	inclusive.

    	Returns (unsigned int)-1 for EOF, or the required number of bits.
    """
    return _mupdf.fz_read_rbits(stm, n)

def fz_read_rune(_in):
    r"""
    Class-aware wrapper for `::fz_read_rune()`.
    	Read a utf-8 rune from a stream.

    	In the event of encountering badly formatted utf-8 codes
    	(such as a leading code with an unexpected number of following
    	codes) no error/exception is given, but undefined values may be
    	returned.
    """
    return _mupdf.fz_read_rune(_in)

def fz_read_string(stm, buffer, len):
    r"""
    Class-aware wrapper for `::fz_read_string()`.
    	Read a null terminated string from the stream into
    	a buffer of a given length. The buffer will be null terminated.
    	Throws on failure (including the failure to fit the entire
    	string including the terminator into the buffer).
    """
    return _mupdf.fz_read_string(stm, buffer, len)

def fz_read_uint16(stm):
    r"""
    Class-aware wrapper for `::fz_read_uint16()`.
    	fz_read_[u]int(16|24|32|64)(_le)?

    	Read a 16/32/64 bit signed/unsigned integer from stream,
    	in big or little-endian byte orders.

    	Throws an exception if EOF is encountered.
    """
    return _mupdf.fz_read_uint16(stm)

def fz_read_uint16_le(stm):
    r"""Class-aware wrapper for `::fz_read_uint16_le()`."""
    return _mupdf.fz_read_uint16_le(stm)

def fz_read_uint24(stm):
    r"""Class-aware wrapper for `::fz_read_uint24()`."""
    return _mupdf.fz_read_uint24(stm)

def fz_read_uint24_le(stm):
    r"""Class-aware wrapper for `::fz_read_uint24_le()`."""
    return _mupdf.fz_read_uint24_le(stm)

def fz_read_uint32(stm):
    r"""Class-aware wrapper for `::fz_read_uint32()`."""
    return _mupdf.fz_read_uint32(stm)

def fz_read_uint32_le(stm):
    r"""Class-aware wrapper for `::fz_read_uint32_le()`."""
    return _mupdf.fz_read_uint32_le(stm)

def fz_read_uint64(stm):
    r"""Class-aware wrapper for `::fz_read_uint64()`."""
    return _mupdf.fz_read_uint64(stm)

def fz_read_uint64_le(stm):
    r"""Class-aware wrapper for `::fz_read_uint64_le()`."""
    return _mupdf.fz_read_uint64_le(stm)

def fz_read_utf16_be(stm):
    r"""Class-aware wrapper for `::fz_read_utf16_be()`."""
    return _mupdf.fz_read_utf16_be(stm)

def fz_read_utf16_le(stm):
    r"""
    Class-aware wrapper for `::fz_read_utf16_le()`.
    	Read a utf-16 rune from a stream. (little endian and
    	big endian respectively).

    	In the event of encountering badly formatted utf-16 codes
    	(mismatched surrogates) no error/exception is given, but
    	undefined values may be returned.
    """
    return _mupdf.fz_read_utf16_le(stm)

def fz_realloc(p, size):
    r"""
    Class-aware wrapper for `::fz_realloc()`.
    	Reallocates a block of memory to given size. Existing contents
    	up to min(old_size,new_size) are maintained. The rest of the
    	block is uninitialised.

    	fz_realloc(ctx, NULL, size) behaves like fz_malloc(ctx, size).

    	fz_realloc(ctx, p, 0); behaves like fz_free(ctx, p).

    	Throws exception in the event of failure to allocate.
    """
    return _mupdf.fz_realloc(p, size)

def fz_realloc_no_throw(p, size):
    r"""
    Class-aware wrapper for `::fz_realloc_no_throw()`.
    	fz_realloc equivalent that returns NULL rather than throwing
    	exceptions.
    """
    return _mupdf.fz_realloc_no_throw(p, size)

def fz_realpath(path, resolved_path):
    r"""
    Class-aware wrapper for `::fz_realpath()`.
    	Resolve a path to an absolute file name.
    	The resolved path buffer must be of at least PATH_MAX size.
    """
    return _mupdf.fz_realpath(path, resolved_path)

def fz_recognize_image_format(p):
    r"""
    Class-aware wrapper for `::fz_recognize_image_format()`.
    	Recognise image format strings in the first 8 bytes from image
    	data.
    """
    return _mupdf.fz_recognize_image_format(p)

def fz_rect_from_irect(bbox):
    r"""
    Class-aware wrapper for `::fz_rect_from_irect()`.
    	Convert a bbox into a rect.

    	For our purposes, a rect can represent all the values we meet in
    	a bbox, so nothing can go wrong.

    	rect: A place to store the generated rectangle.

    	bbox: The bbox to convert.

    	Returns rect (updated).
    """
    return _mupdf.fz_rect_from_irect(bbox)

def fz_rect_from_quad(q):
    r"""
    Class-aware wrapper for `::fz_rect_from_quad()`.
    	Convert a quad to the smallest rect that covers it.
    """
    return _mupdf.fz_rect_from_quad(q)

def fz_rectto(path, x0, y0, x1, y1):
    r"""
    Class-aware wrapper for `::fz_rectto()`.
    	Append a 'rectto' command to an open path.

    	The rectangle is equivalent to:
    		moveto x0 y0
    		lineto x1 y0
    		lineto x1 y1
    		lineto x0 y1
    		closepath

    	path: The path to modify.

    	x0, y0: First corner of the rectangle.

    	x1, y1: Second corner of the rectangle.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_rectto(path, x0, y0, x1, y1)

def fz_register_archive_handler(handler):
    r"""Class-aware wrapper for `::fz_register_archive_handler()`."""
    return _mupdf.fz_register_archive_handler(handler)

def fz_register_document_handler(handler):
    r"""
    Class-aware wrapper for `::fz_register_document_handler()`.
    	Register a handler for a document type.

    	handler: The handler to register. This must live on for the duration of the
    	use of this handler. It will be passed back to the handler for calls so
    	the caller can use it to retrieve state.
    """
    return _mupdf.fz_register_document_handler(handler)

def fz_register_document_handlers():
    r"""
    Class-aware wrapper for `::fz_register_document_handlers()`.
    	Register handlers for all the standard document types supported in
    	this build.
    """
    return _mupdf.fz_register_document_handlers()

def fz_remove_item(drop, key, type):
    r"""
    Class-aware wrapper for `::fz_remove_item()`.
    	Remove an item from the store.

    	If an item indexed by the given key exists in the store, remove
    	it.

    	drop: The function used to free the value (to ensure we get a
    	value of the correct type).

    	key: The key used to find the item to remove.

    	type: Functions used to manipulate the key.
    """
    return _mupdf.fz_remove_item(drop, key, type)

def fz_render_flags(dev, set, clear):
    r"""Class-aware wrapper for `::fz_render_flags()`."""
    return _mupdf.fz_render_flags(dev, set, clear)

def fz_render_glyph_pixmap(font, gid, ctm, scissor, aa):
    r"""
    Class-aware wrapper for `::fz_render_glyph_pixmap()`.
    	Create a pixmap containing a rendered glyph.

    	Lookup gid from font, clip it with scissor, and rendering it
    	with aa bits of antialiasing into a new pixmap.

    	The caller takes ownership of the pixmap and so must free it.

    	Note: This function is no longer used for normal rendering
    	operations, and is kept around just because we use it in the
    	app. It should be considered "at risk" of removal from the API.
    """
    return _mupdf.fz_render_glyph_pixmap(font, gid, ctm, scissor, aa)

def fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs):
    r"""
    Class-aware wrapper for `::fz_render_t3_glyph_direct()`.
    	Nasty PDF interpreter specific hernia, required to allow the
    	interpreter to replay glyphs from a type3 font directly into
    	the target device.

    	This is only used in exceptional circumstances (such as type3
    	glyphs that inherit current graphics state, or nested type3
    	glyphs).
    """
    return _mupdf.fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs)

def fz_rendering_intent_name(ri):
    r"""
    Class-aware wrapper for `::fz_rendering_intent_name()`.
    	Map from enumerated rendering intent to string.

    	The returned string is static and therefore must not be freed.
    """
    return _mupdf.fz_rendering_intent_name(ri)

def fz_report_error():
    r"""Class-aware wrapper for `::fz_report_error()`."""
    return _mupdf.fz_report_error()

def fz_reset_output(arg_0):
    r"""
    Class-aware wrapper for `::fz_reset_output()`.
    	Reset a closed output stream. Returns state to
    	(broadly) that which it was in when opened. Not
    	all outputs can be reset, so this may throw an
    	exception.
    """
    return _mupdf.fz_reset_output(arg_0)

def fz_reset_story(story):
    r"""Class-aware wrapper for `::fz_reset_story()`."""
    return _mupdf.fz_reset_story(story)

def fz_resize_buffer(buf, capacity):
    r"""
    Class-aware wrapper for `::fz_resize_buffer()`.
    	Ensure that a buffer has a given capacity,
    	truncating data if required.

    	capacity: The desired capacity for the buffer. If the current
    	size of the buffer contents is smaller than capacity, it is
    	truncated.
    """
    return _mupdf.fz_resize_buffer(buf, capacity)

def fz_resolve_link(doc, uri, xp, yp):
    r"""
    Class-aware wrapper for `::fz_resolve_link()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_resolve_link(::fz_document *doc, const char *uri)` => `(fz_location, float xp, float yp)`

    	Resolve an internal link to a page number.

    	xp, yp: Pointer to store coordinate of destination on the page.

    	Returns (-1,-1) if the URI cannot be resolved.
    """
    return _mupdf.fz_resolve_link(doc, uri, xp, yp)

def fz_rethrow():
    r"""Class-aware wrapper for `::fz_rethrow()`."""
    return _mupdf.fz_rethrow()

def fz_rethrow_if(errcode):
    r"""
    Class-aware wrapper for `::fz_rethrow_if()`.
    	Within an fz_catch() block, rethrow the current exception
    	if the errcode of the current exception matches.

    	This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.fz_rethrow_if(errcode)

def fz_rethrow_unless(errcode):
    r"""Class-aware wrapper for `::fz_rethrow_unless()`."""
    return _mupdf.fz_rethrow_unless(errcode)

def fz_rotate(degrees):
    r"""
    Class-aware wrapper for `::fz_rotate()`.
    	Create a rotation matrix.

    	The returned matrix is of the form
    	[ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

    	m: Pointer to place to store matrix

    	degrees: Degrees of counter clockwise rotation. Values less
    	than zero and greater than 360 are handled as expected.

    	Returns m.
    """
    return _mupdf.fz_rotate(degrees)

def fz_round_rect(rect):
    r"""
    Class-aware wrapper for `::fz_round_rect()`.
    	Round rectangle coordinates.

    	Coordinates in a bounding box are integers, so rounding of the
    	rects coordinates takes place. The top left corner is rounded
    	upwards and left while the bottom right corner is rounded
    	downwards and to the right.

    	This differs from fz_irect_from_rect, in that fz_irect_from_rect
    	slavishly follows the numbers (i.e any slight over/under
    	calculations can cause whole extra pixels to be added).
    	fz_round_rect allows for a small amount of rounding error when
    	calculating the bbox.
    """
    return _mupdf.fz_round_rect(rect)

def fz_run_display_list(list, dev, ctm, scissor, cookie):
    r"""
    Class-aware wrapper for `::fz_run_display_list()`.
    	(Re)-run a display list through a device.

    	list: A display list, created by fz_new_display_list and
    	populated with objects from a page by running fz_run_page on a
    	device obtained from fz_new_list_device.

    	ctm: Transform to apply to display list contents. May include
    	for example scaling and rotation, see fz_scale, fz_rotate and
    	fz_concat. Set to fz_identity if no transformation is desired.

    	scissor: Only the part of the contents of the display list
    	visible within this area will be considered when the list is
    	run through the device. This does not imply for tile objects
    	contained in the display list.

    	cookie: Communication mechanism between caller and library
    	running the page. Intended for multi-threaded applications,
    	while single-threaded applications set cookie to NULL. The
    	caller may abort an ongoing page run. Cookie also communicates
    	progress information back to the caller. The fields inside
    	cookie are continually updated while the page is being run.
    """
    return _mupdf.fz_run_display_list(list, dev, ctm, scissor, cookie)

def fz_run_document_structure(doc, dev, cookie):
    r"""
    Class-aware wrapper for `::fz_run_document_structure()`.
    	Run the document structure through a device.

    	doc: Document in question.

    	dev: Device obtained from fz_new_*_device.

    	cookie: Communication mechanism between caller and library.
    	Intended for multi-threaded applications, while
    	single-threaded applications set cookie to NULL. The
    	caller may abort an ongoing rendering of a page. Cookie also
    	communicates progress information back to the caller. The
    	fields inside cookie are continually updated while the page is
    	rendering.
    """
    return _mupdf.fz_run_document_structure(doc, dev, cookie)

def fz_run_page(page, dev, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_run_page()`.
    	Run a page through a device.

    	page: Page obtained from fz_load_page.

    	dev: Device obtained from fz_new_*_device.

    	transform: Transform to apply to page. May include for example
    	scaling and rotation, see fz_scale, fz_rotate and fz_concat.
    	Set to fz_identity if no transformation is desired.

    	cookie: Communication mechanism between caller and library
    	rendering the page. Intended for multi-threaded applications,
    	while single-threaded applications set cookie to NULL. The
    	caller may abort an ongoing rendering of a page. Cookie also
    	communicates progress information back to the caller. The
    	fields inside cookie are continually updated while the page is
    	rendering.
    """
    return _mupdf.fz_run_page(page, dev, transform, cookie)

def fz_run_page_annots(page, dev, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_run_page_annots()`.
    	Run the annotations on a page through a device.
    """
    return _mupdf.fz_run_page_annots(page, dev, transform, cookie)

def fz_run_page_contents(page, dev, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_run_page_contents()`.
    	Run a page through a device. Just the main
    	page content, without the annotations, if any.

    	page: Page obtained from fz_load_page.

    	dev: Device obtained from fz_new_*_device.

    	transform: Transform to apply to page. May include for example
    	scaling and rotation, see fz_scale, fz_rotate and fz_concat.
    	Set to fz_identity if no transformation is desired.

    	cookie: Communication mechanism between caller and library
    	rendering the page. Intended for multi-threaded applications,
    	while single-threaded applications set cookie to NULL. The
    	caller may abort an ongoing rendering of a page. Cookie also
    	communicates progress information back to the caller. The
    	fields inside cookie are continually updated while the page is
    	rendering.
    """
    return _mupdf.fz_run_page_contents(page, dev, transform, cookie)

def fz_run_page_widgets(page, dev, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_run_page_widgets()`.
    	Run the widgets on a page through a device.
    """
    return _mupdf.fz_run_page_widgets(page, dev, transform, cookie)

def fz_run_t3_glyph(font, gid, trm, dev):
    r"""
    Class-aware wrapper for `::fz_run_t3_glyph()`.
    	Run a glyph from a Type3 font to
    	a given device.

    	font: The font to find the glyph in.

    	gid: The glyph to run.

    	trm: The transform to apply.

    	dev: The device to render onto.
    """
    return _mupdf.fz_run_t3_glyph(font, gid, trm, dev)

def fz_runeidx(str, p):
    r"""
    Class-aware wrapper for `::fz_runeidx()`.
    	Compute the index of a rune in a string.

    	str: Pointer to beginning of a string.

    	p: Pointer to a char in str.

    	Returns the index of the rune pointed to by p in str.
    """
    return _mupdf.fz_runeidx(str, p)

def fz_runelen(rune):
    r"""
    Class-aware wrapper for `::fz_runelen()`.
    	Count how many chars are required to represent a rune.

    	rune: The rune to encode.

    	Returns the number of bytes required to represent this run in
    	UTF8.
    """
    return _mupdf.fz_runelen(rune)

def fz_runeptr(str, idx):
    r"""
    Class-aware wrapper for `::fz_runeptr()`.
    	Obtain a pointer to the char representing the rune
    	at a given index.

    	str: Pointer to beginning of a string.

    	idx: Index of a rune to return a char pointer to.

    	Returns a pointer to the char where the desired rune starts,
    	or NULL if the string ends before the index is reached.
    """
    return _mupdf.fz_runeptr(str, idx)

def fz_runetochar(str, rune):
    r"""
    Class-aware wrapper for `::fz_runetochar()`.
    	UTF8 encode a rune to a sequence of chars.

    	str: Pointer to a place to put the UTF8 encoded character.

    	rune: Pointer to a 'rune'.

    	Returns the number of bytes the rune took to output.
    """
    return _mupdf.fz_runetochar(str, rune)

def fz_samples_get(pixmap, offset):
    r"""
    Class-aware wrapper for `::fz_samples_get()`.
    Provides simple (but slow) access to pixmap data from Python and C#.
    """
    return _mupdf.fz_samples_get(pixmap, offset)

def fz_samples_set(pixmap, offset, value):
    r"""
    Class-aware wrapper for `::fz_samples_set()`.
    Provides simple (but slow) write access to pixmap data from Python and
    C#.
    """
    return _mupdf.fz_samples_set(pixmap, offset, value)

def fz_save_accelerator(doc, accel):
    r"""
    Class-aware wrapper for `::fz_save_accelerator()`.
    	Save accelerator data for the document to a given file.
    """
    return _mupdf.fz_save_accelerator(doc, accel)

def fz_save_bitmap_as_pbm(bitmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_bitmap_as_pbm()`.
    	Save a bitmap as a pbm.
    """
    return _mupdf.fz_save_bitmap_as_pbm(bitmap, filename)

def fz_save_bitmap_as_pcl(bitmap, filename, append, pcl):
    r"""
    Class-aware wrapper for `::fz_save_bitmap_as_pcl()`.
    	Save a bitmap as mono PCL.
    """
    return _mupdf.fz_save_bitmap_as_pcl(bitmap, filename, append, pcl)

def fz_save_bitmap_as_pkm(bitmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_bitmap_as_pkm()`.
    	Save a CMYK bitmap as a pkm.
    """
    return _mupdf.fz_save_bitmap_as_pkm(bitmap, filename)

def fz_save_bitmap_as_pwg(bitmap, filename, append, pwg):
    r"""
    Class-aware wrapper for `::fz_save_bitmap_as_pwg()`.
    	Save a bitmap as a PWG.
    """
    return _mupdf.fz_save_bitmap_as_pwg(bitmap, filename, append, pwg)

def fz_save_buffer(buf, filename):
    r"""
    Class-aware wrapper for `::fz_save_buffer()`.
    	Save the contents of a buffer to a file.
    """
    return _mupdf.fz_save_buffer(buf, filename)

def fz_save_pixmap_as_jpeg(pixmap, filename, quality):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_jpeg()`.
    	Save a pixmap as a JPEG.
    """
    return _mupdf.fz_save_pixmap_as_jpeg(pixmap, filename, quality)

def fz_save_pixmap_as_jpx(pixmap, filename, q):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_jpx()`.
    	Save pixmap data as JP2K with no subsampling.

    	quality = 100 = lossless
    	otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
    """
    return _mupdf.fz_save_pixmap_as_jpx(pixmap, filename, q)

def fz_save_pixmap_as_pam(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pam()`.
    	Save a pixmap as a pnm (greyscale, rgb or cmyk, with or without
    	alpha).
    """
    return _mupdf.fz_save_pixmap_as_pam(pixmap, filename)

def fz_save_pixmap_as_pbm(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pbm()`.
    	Save a pixmap as a pbm. (Performing halftoning).
    """
    return _mupdf.fz_save_pixmap_as_pbm(pixmap, filename)

def fz_save_pixmap_as_pcl(pixmap, filename, append, pcl):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pcl()`.
    	Save an (RGB) pixmap as color PCL.
    """
    return _mupdf.fz_save_pixmap_as_pcl(pixmap, filename, append, pcl)

def fz_save_pixmap_as_pclm(pixmap, filename, append, options):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pclm()`.
    	Save a (Greyscale or RGB) pixmap as pclm.
    """
    return _mupdf.fz_save_pixmap_as_pclm(pixmap, filename, append, options)

def fz_save_pixmap_as_pdfocr(pixmap, filename, append, options):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pdfocr()`.
    	Save a (Greyscale or RGB) pixmap as pdfocr.
    """
    return _mupdf.fz_save_pixmap_as_pdfocr(pixmap, filename, append, options)

def fz_save_pixmap_as_pkm(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pkm()`.
    	Save a CMYK pixmap as a pkm. (Performing halftoning).
    """
    return _mupdf.fz_save_pixmap_as_pkm(pixmap, filename)

def fz_save_pixmap_as_png(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_png()`.
    	Save a (Greyscale or RGB) pixmap as a png.
    """
    return _mupdf.fz_save_pixmap_as_png(pixmap, filename)

def fz_save_pixmap_as_pnm(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pnm()`.
    	Save a pixmap as a pnm (greyscale or rgb, no alpha).
    """
    return _mupdf.fz_save_pixmap_as_pnm(pixmap, filename)

def fz_save_pixmap_as_ps(pixmap, filename, append):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_ps()`.
    	Save a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
    """
    return _mupdf.fz_save_pixmap_as_ps(pixmap, filename, append)

def fz_save_pixmap_as_psd(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_psd()`.
    	Save a pixmap as a PSD file.
    """
    return _mupdf.fz_save_pixmap_as_psd(pixmap, filename)

def fz_save_pixmap_as_pwg(pixmap, filename, append, pwg):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pwg()`.
    	Save a pixmap as a PWG.
    """
    return _mupdf.fz_save_pixmap_as_pwg(pixmap, filename, append, pwg)

def fz_save_xml(root, path, indented):
    r"""
    Class-aware wrapper for `::fz_save_xml()`.
    	As for fz_write_xml, but direct to a file.
    """
    return _mupdf.fz_save_xml(root, path, indented)

def fz_scale(sx, sy):
    r"""
    Class-aware wrapper for `::fz_scale()`.
    	Create a scaling matrix.

    	The returned matrix is of the form [ sx 0 0 sy 0 0 ].

    	m: Pointer to the matrix to populate

    	sx, sy: Scaling factors along the X- and Y-axes. A scaling
    	factor of 1.0 will not cause any scaling along the relevant
    	axis.

    	Returns m.
    """
    return _mupdf.fz_scale(sx, sy)

def fz_scale_pixmap(src, x, y, w, h, clip):
    r"""Class-aware wrapper for `::fz_scale_pixmap()`."""
    return _mupdf.fz_scale_pixmap(src, x, y, w, h, clip)

def fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_chapter_page_number()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_chapter_page_number(::fz_document *doc, int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max)

def fz_search_chapter_page_number_cb(doc, chapter, page, needle, cb, opaque):
    r"""Class-aware wrapper for `::fz_search_chapter_page_number_cb()`."""
    return _mupdf.fz_search_chapter_page_number_cb(doc, chapter, page, needle, cb, opaque)

def fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_display_list()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_display_list(::fz_display_list *list, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max)

def fz_search_display_list_cb(list, needle, cb, opaque):
    r"""Class-aware wrapper for `::fz_search_display_list_cb()`."""
    return _mupdf.fz_search_display_list_cb(list, needle, cb, opaque)

def fz_search_page(page, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_page()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_page(::fz_page *page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

    	Search for the 'needle' text on the page.
    	Record the hits in the hit_bbox array and return the number of
    	hits. Will stop looking once it has filled hit_max rectangles.
    """
    return _mupdf.fz_search_page(page, needle, hit_mark, hit_bbox, hit_max)

def fz_search_page2(doc, number, needle, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_page2()`.
    C++ alternative to fz_search_page() that returns information in a std::vector.
    """
    return _mupdf.fz_search_page2(doc, number, needle, hit_max)

def fz_search_page_cb(page, needle, cb, opaque):
    r"""
    Class-aware wrapper for `::fz_search_page_cb()`.
    	Search for the 'needle' text on the page.
    """
    return _mupdf.fz_search_page_cb(page, needle, cb, opaque)

def fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_page_number()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_page_number(::fz_document *doc, int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max)

def fz_search_page_number_cb(doc, number, needle, cb, opaque):
    r"""Class-aware wrapper for `::fz_search_page_number_cb()`."""
    return _mupdf.fz_search_page_number_cb(doc, number, needle, cb, opaque)

def fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_stext_page()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_stext_page(::fz_stext_page *text, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

    	Search for occurrence of 'needle' in text page.

    	Return the number of quads and store hit quads in the passed in
    	array.

    	NOTE: This is an experimental interface and subject to change
    	without notice.
    """
    return _mupdf.fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max)

def fz_search_stext_page_cb(text, needle, cb, opaque):
    r"""
    Class-aware wrapper for `::fz_search_stext_page_cb()`.
    	Search for occurrence of 'needle' in text page.

    	Call callback once for each hit. This callback will receive
    	(potentially) multiple quads for each hit.

    	Returns the number of hits - note that this is potentially
    	different from (i.e. is not greater than) the number of quads
    	as returned by the non callback API.

    	NOTE: This is an experimental interface and subject to change
    	without notice.
    """
    return _mupdf.fz_search_stext_page_cb(text, needle, cb, opaque)

def fz_seek(stm, offset, whence):
    r"""
    Class-aware wrapper for `::fz_seek()`.
    	Seek within a stream.

    	stm: The stream to seek within.

    	offset: The offset to seek to.

    	whence: From where the offset is measured (see fseek).
    	SEEK_SET - start of stream.
    	SEEK_CUR - current position.
    	SEEK_END - end of stream.

    """
    return _mupdf.fz_seek(stm, offset, whence)

def fz_seek_output(out, off, whence):
    r"""
    Class-aware wrapper for `::fz_seek_output()`.
    	Seek to the specified file position.
    	See fseek for arguments.

    	Throw an error on unseekable outputs.
    """
    return _mupdf.fz_seek_output(out, off, whence)

def fz_segment_stext_page(page):
    r"""
    Class-aware wrapper for `::fz_segment_stext_page()`.
    	Perform segmentation analysis on an (unstructured) page to look for
    	recursive subdivisions.

    	Essentially this code attempts to split the page horizontally and/or
    	vertically repeatedly into smaller and smaller "segments" (divisions).

    	Returns 0 if no changes were made to the document.

    	This is experimental code, and may change (or be removed) in future
    	versions!
    """
    return _mupdf.fz_segment_stext_page(page)

def fz_separation_current_behavior(sep, separation):
    r"""
    Class-aware wrapper for `::fz_separation_current_behavior()`.
    	Test for the current behavior of a separation.
    """
    return _mupdf.fz_separation_current_behavior(sep, separation)

def fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params):
    r"""
    Class-aware wrapper for `::fz_separation_equivalent()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_separation_equivalent(const ::fz_separations *seps, int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color

    	Get the equivalent separation color in a given colorspace.
    """
    return _mupdf.fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params)

def fz_separation_name(sep, separation):
    r"""Class-aware wrapper for `::fz_separation_name()`."""
    return _mupdf.fz_separation_name(sep, separation)

def fz_set_aa_level(bits):
    r"""
    Class-aware wrapper for `::fz_set_aa_level()`.
    	Set the number of bits of antialiasing we should
    	use (for both text and graphics).

    	bits: The number of bits of antialiasing to use (values are
    	clamped to within the 0 to 8 range).
    """
    return _mupdf.fz_set_aa_level(bits)

def fz_set_compressed_image_buffer(cimg, buf):
    r"""Class-aware wrapper for `::fz_set_compressed_image_buffer()`."""
    return _mupdf.fz_set_compressed_image_buffer(cimg, buf)

def fz_set_default_cmyk(default_cs, cs):
    r"""Class-aware wrapper for `::fz_set_default_cmyk()`."""
    return _mupdf.fz_set_default_cmyk(default_cs, cs)

def fz_set_default_colorspaces(dev, default_cs):
    r"""Class-aware wrapper for `::fz_set_default_colorspaces()`."""
    return _mupdf.fz_set_default_colorspaces(dev, default_cs)

def fz_set_default_gray(default_cs, cs):
    r"""
    Class-aware wrapper for `::fz_set_default_gray()`.
    	Set new defaults within the default colorspace structure.

    	New references are taken to the new default, and references to
    	the old defaults dropped.

    	Never throws exceptions.
    """
    return _mupdf.fz_set_default_gray(default_cs, cs)

def fz_set_default_output_intent(default_cs, cs):
    r"""Class-aware wrapper for `::fz_set_default_output_intent()`."""
    return _mupdf.fz_set_default_output_intent(default_cs, cs)

def fz_set_default_rgb(default_cs, cs):
    r"""Class-aware wrapper for `::fz_set_default_rgb()`."""
    return _mupdf.fz_set_default_rgb(default_cs, cs)

def fz_set_error_callback(error_cb, user):
    r"""
    Class-aware wrapper for `::fz_set_error_callback()`.
    	Set the error callback. This will be called as part of the
    	exception handling.

    	The callback must not throw exceptions!
    """
    return _mupdf.fz_set_error_callback(error_cb, user)

def fz_set_font_bbox(font, xmin, ymin, xmax, ymax):
    r"""
    Class-aware wrapper for `::fz_set_font_bbox()`.
    	Set the font bbox.

    	font: The font to set the bbox for.

    	xmin, ymin, xmax, ymax: The bounding box.
    """
    return _mupdf.fz_set_font_bbox(font, xmin, ymin, xmax, ymax)

def fz_set_font_embedding(font, embed):
    r"""
    Class-aware wrapper for `::fz_set_font_embedding()`.
    	Control whether a given font should be embedded or not when writing.
    """
    return _mupdf.fz_set_font_embedding(font, embed)

def fz_set_graphics_aa_level(bits):
    r"""
    Class-aware wrapper for `::fz_set_graphics_aa_level()`.
    	Set the number of bits of antialiasing we
    	should use for graphics.

    	bits: The number of bits of antialiasing to use (values are
    	clamped to within the 0 to 8 range).
    """
    return _mupdf.fz_set_graphics_aa_level(bits)

def fz_set_graphics_min_line_width(min_line_width):
    r"""
    Class-aware wrapper for `::fz_set_graphics_min_line_width()`.
    	Set the minimum line width to be
    	used for stroked lines.

    	min_line_width: The minimum line width to use (in pixels).
    """
    return _mupdf.fz_set_graphics_min_line_width(min_line_width)

def fz_set_link_rect(link, rect):
    r"""Class-aware wrapper for `::fz_set_link_rect()`."""
    return _mupdf.fz_set_link_rect(link, rect)

def fz_set_link_uri(link, uri):
    r"""Class-aware wrapper for `::fz_set_link_uri()`."""
    return _mupdf.fz_set_link_uri(link, uri)

def fz_set_metadata(doc, key, value):
    r"""Class-aware wrapper for `::fz_set_metadata()`."""
    return _mupdf.fz_set_metadata(doc, key, value)

def fz_set_pixmap_image_tile(cimg, pix):
    r"""Class-aware wrapper for `::fz_set_pixmap_image_tile()`."""
    return _mupdf.fz_set_pixmap_image_tile(cimg, pix)

def fz_set_pixmap_resolution(pix, xres, yres):
    r"""
    Class-aware wrapper for `::fz_set_pixmap_resolution()`.
    	Set the pixels per inch resolution of the pixmap.
    """
    return _mupdf.fz_set_pixmap_resolution(pix, xres, yres)

def fz_set_separation_behavior(sep, separation, behavior):
    r"""
    Class-aware wrapper for `::fz_set_separation_behavior()`.
    	Control the rendering of a given separation.
    """
    return _mupdf.fz_set_separation_behavior(sep, separation, behavior)

def fz_set_stddbg(out):
    r"""
    Class-aware wrapper for `::fz_set_stddbg()`.
    	Set the output stream to be used for fz_stddbg. Set to NULL to
    	reset to default (stderr).
    """
    return _mupdf.fz_set_stddbg(out)

def fz_set_text_aa_level(bits):
    r"""
    Class-aware wrapper for `::fz_set_text_aa_level()`.
    	Set the number of bits of antialiasing we
    	should use for text.

    	bits: The number of bits of antialiasing to use (values are
    	clamped to within the 0 to 8 range).
    """
    return _mupdf.fz_set_text_aa_level(bits)

def fz_set_use_document_css(use):
    r"""
    Class-aware wrapper for `::fz_set_use_document_css()`.
    	Toggle whether to respect document styles in HTML and EPUB.
    """
    return _mupdf.fz_set_use_document_css(use)

def fz_set_user_context(user):
    r"""
    Class-aware wrapper for `::fz_set_user_context()`.
    	Set the user field in the context.

    	NULL initially, this field can be set to any opaque value
    	required by the user. It is copied on clones.
    """
    return _mupdf.fz_set_user_context(user)

def fz_set_user_css(text):
    r"""
    Class-aware wrapper for `::fz_set_user_css()`.
    	Set the user stylesheet source text for use with HTML and EPUB.
    """
    return _mupdf.fz_set_user_css(text)

def fz_set_warning_callback(warning_cb, user):
    r"""
    Class-aware wrapper for `::fz_set_warning_callback()`.
    	Set the warning callback. This will be called as part of the
    	exception handling.

    	The callback must not throw exceptions!
    """
    return _mupdf.fz_set_warning_callback(warning_cb, user)

def fz_sha256_final(state, digest):
    r"""
    Class-aware wrapper for `::fz_sha256_final()`.
    	MD5 finalization. Ends an MD5 message-digest operation, writing
    	the message digest and zeroizing the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha256_final(state, digest)

def fz_sha256_init(state):
    r"""
    Class-aware wrapper for `::fz_sha256_init()`.
    	SHA256 initialization. Begins an SHA256 operation, initialising
    	the supplied context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha256_init(state)

def fz_sha256_update(state, input, inlen):
    r"""
    Class-aware wrapper for `::fz_sha256_update()`.
    	SHA256 block update operation. Continues an SHA256 message-
    	digest operation, processing another message block, and updating
    	the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha256_update(state, input, inlen)

def fz_sha384_final(state, digest):
    r"""
    Class-aware wrapper for `::fz_sha384_final()`.
    	SHA384 finalization. Ends an SHA384 message-digest operation,
    	writing the message digest and zeroizing the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha384_final(state, digest)

def fz_sha384_init(state):
    r"""
    Class-aware wrapper for `::fz_sha384_init()`.
    	SHA384 initialization. Begins an SHA384 operation, initialising
    	the supplied context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha384_init(state)

def fz_sha384_update(state, input, inlen):
    r"""
    Class-aware wrapper for `::fz_sha384_update()`.
    	SHA384 block update operation. Continues an SHA384 message-
    	digest operation, processing another message block, and updating
    	the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha384_update(state, input, inlen)

def fz_sha512_final(state, digest):
    r"""
    Class-aware wrapper for `::fz_sha512_final()`.
    	SHA512 finalization. Ends an SHA512 message-digest operation,
    	writing the message digest and zeroizing the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha512_final(state, digest)

def fz_sha512_init(state):
    r"""
    Class-aware wrapper for `::fz_sha512_init()`.
    	SHA512 initialization. Begins an SHA512 operation, initialising
    	the supplied context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha512_init(state)

def fz_sha512_update(state, input, inlen):
    r"""
    Class-aware wrapper for `::fz_sha512_update()`.
    	SHA512 block update operation. Continues an SHA512 message-
    	digest operation, processing another message block, and updating
    	the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha512_update(state, input, inlen)

def fz_shear(sx, sy):
    r"""
    Class-aware wrapper for `::fz_shear()`.
    	Create a shearing matrix.

    	The returned matrix is of the form [ 1 sy sx 1 0 0 ].

    	m: pointer to place to store returned matrix

    	sx, sy: Shearing factors. A shearing factor of 0.0 will not
    	cause any shearing along the relevant axis.

    	Returns m.
    """
    return _mupdf.fz_shear(sx, sy)

def fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language):
    r"""
    Class-aware wrapper for `::fz_show_glyph()`.
    	Add a glyph/unicode value to a text object.

    	text: Text object to add to.

    	font: The font the glyph should be added in.

    	trm: The transform to use for the glyph.

    	glyph: The glyph id to add.

    	unicode: The unicode character for the glyph.

    	cid: The CJK CID value or raw character code.

    	wmode: 1 for vertical mode, 0 for horizontal.

    	bidi_level: The bidirectional level for this glyph.

    	markup_dir: The direction of the text as specified in the
    	markup.

    	language: The language in use (if known, 0 otherwise)
    	(e.g. FZ_LANG_zh_Hans).

    	Throws exception on failure to allocate.
    """
    return _mupdf.fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language)

def fz_show_glyph_aux(text, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang):
    r"""Class-aware wrapper for `::fz_show_glyph_aux()`."""
    return _mupdf.fz_show_glyph_aux(text, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang)

def fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language):
    r"""
    Class-aware wrapper for `::fz_show_string()`.
    	Add a UTF8 string to a text object.

    	text: Text object to add to.

    	font: The font the string should be added in.

    	trm: The transform to use.

    	s: The utf-8 string to add.

    	wmode: 1 for vertical mode, 0 for horizontal.

    	bidi_level: The bidirectional level for this glyph.

    	markup_dir: The direction of the text as specified in the markup.

    	language: The language in use (if known, 0 otherwise)
    		(e.g. FZ_LANG_zh_Hans).

    	Returns the transform updated with the advance width of the
    	string.
    """
    return _mupdf.fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language)

def fz_shrink_store(percent):
    r"""
    Class-aware wrapper for `::fz_shrink_store()`.
    	Evict items from the store until the total size of
    	the objects in the store is reduced to a given percentage of its
    	current size.

    	percent: %age of current size to reduce the store to.

    	Returns non zero if we managed to free enough memory, zero
    	otherwise.
    """
    return _mupdf.fz_shrink_store(percent)

def fz_skew_detect(pixmap):
    r"""Class-aware wrapper for `::fz_skew_detect()`."""
    return _mupdf.fz_skew_detect(pixmap)

def fz_skip(stm, len):
    r"""
    Class-aware wrapper for `::fz_skip()`.
    	Read from a stream discarding data.

    	stm: The stream to read from.

    	len: The number of bytes to read.

    	Returns the number of bytes read. May throw exceptions.
    """
    return _mupdf.fz_skip(stm, len)

def fz_skip_space(stm):
    r"""
    Class-aware wrapper for `::fz_skip_space()`.
    	Skip over whitespace (bytes <= 32) in a stream.
    """
    return _mupdf.fz_skip_space(stm)

def fz_skip_string(stm, str):
    r"""
    Class-aware wrapper for `::fz_skip_string()`.
    	Skip over a given string in a stream. Return 0 if successfully
    	skipped, non-zero otherwise. As many characters will be skipped
    	over as matched in the string.
    """
    return _mupdf.fz_skip_string(stm, str)

def fz_slice_buffer(buf, start, end):
    r"""
    Class-aware wrapper for `::fz_slice_buffer()`.
    	Create a new buffer with a (subset of) the data from the buffer.

    	start: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

    	end: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

    """
    return _mupdf.fz_slice_buffer(buf, start, end)

def fz_snap_selection(page, ap, bp, mode):
    r"""Class-aware wrapper for `::fz_snap_selection()`."""
    return _mupdf.fz_snap_selection(page, ap, bp, mode)

def fz_start_throw_on_repair():
    r"""Class-aware wrapper for `::fz_start_throw_on_repair()`."""
    return _mupdf.fz_start_throw_on_repair()

def fz_stat_ctime(path):
    r"""Class-aware wrapper for `::fz_stat_ctime()`."""
    return _mupdf.fz_stat_ctime(path)

def fz_stat_mtime(path):
    r"""Class-aware wrapper for `::fz_stat_mtime()`."""
    return _mupdf.fz_stat_mtime(path)

def fz_store_item(key, val, itemsize, type):
    r"""
    Class-aware wrapper for `::fz_store_item()`.
    	Add an item to the store.

    	Add an item into the store, returning NULL for success. If an
    	item with the same key is found in the store, then our item will
    	not be inserted, and the function will return a pointer to that
    	value instead. This function takes its own reference to val, as
    	required (i.e. the caller maintains ownership of its own
    	reference).

    	key: The key used to index the item.

    	val: The value to store.

    	itemsize: The size in bytes of the value (as counted towards the
    	store size).

    	type: Functions used to manipulate the key.
    """
    return _mupdf.fz_store_item(key, val, itemsize, type)

def fz_store_scavenge(size, phase):
    r"""
    Class-aware wrapper for `::fz_store_scavenge()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_store_scavenge(size_t size)` => `(int, int phase)`

    	Internal function used as part of the scavenging
    	allocator; when we fail to allocate memory, before returning a
    	failure to the caller, we try to scavenge space within the store
    	by evicting at least 'size' bytes. The allocator then retries.

    	size: The number of bytes we are trying to have free.

    	phase: What phase of the scavenge we are in. Updated on exit.

    	Returns non zero if we managed to free any memory.
    """
    return _mupdf.fz_store_scavenge(size, phase)

def fz_store_scavenge_external(size, phase):
    r"""
    Class-aware wrapper for `::fz_store_scavenge_external()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_store_scavenge_external(size_t size)` => `(int, int phase)`

    	External function for callers to use
    	to scavenge while trying allocations.

    	size: The number of bytes we are trying to have free.

    	phase: What phase of the scavenge we are in. Updated on exit.

    	Returns non zero if we managed to free any memory.
    """
    return _mupdf.fz_store_scavenge_external(size, phase)

def fz_story_document(story):
    r"""Class-aware wrapper for `::fz_story_document()`."""
    return _mupdf.fz_story_document(story)

def fz_story_positions(story, cb, arg):
    r"""Class-aware wrapper for `::fz_story_positions()`."""
    return _mupdf.fz_story_positions(story, cb, arg)

def fz_story_warnings(story):
    r"""Class-aware wrapper for `::fz_story_warnings()`."""
    return _mupdf.fz_story_warnings(story)

def fz_strcasecmp(a, b):
    r"""
    Class-aware wrapper for `::fz_strcasecmp()`.
    	Case insensitive (ASCII only) string comparison.
    """
    return _mupdf.fz_strcasecmp(a, b)

def fz_strdup(s):
    r"""
    Class-aware wrapper for `::fz_strdup()`.
    	Portable strdup implementation, using fz allocators.
    """
    return _mupdf.fz_strdup(s)

def fz_stream_filename(stm):
    r"""
    Class-aware wrapper for `::fz_stream_filename()`.
    	Return the filename (UTF-8 encoded) from which a stream was opened.

    	Returns NULL if the filename is not available (or the stream was
    	opened from a source other than a file).
    """
    return _mupdf.fz_stream_filename(stm)

def fz_stream_from_output(arg_0):
    r"""
    Class-aware wrapper for `::fz_stream_from_output()`.
    	Obtain the fz_output in the form of a fz_stream.

    	This allows data to be read back from some forms of fz_output
    	object. When finished reading, the fz_stream should be released
    	by calling fz_drop_stream. Until the fz_stream is dropped, no
    	further operations should be performed on the fz_output object.
    """
    return _mupdf.fz_stream_from_output(arg_0)

def fz_string_from_box_type(box):
    r"""Class-aware wrapper for `::fz_string_from_box_type()`."""
    return _mupdf.fz_string_from_box_type(box)

def fz_string_from_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_string_from_buffer()`.
    	Ensure that a buffer's data ends in a
    	0 byte, and return a pointer to it.
    """
    return _mupdf.fz_string_from_buffer(buf)

def fz_string_from_text_language(str, lang):
    r"""
    Class-aware wrapper for `::fz_string_from_text_language()`.
    	Recover ISO 639 (639-{1,2,3,5}) language specification
    	strings losslessly from a 15 bit fz_text_language code.

    	No validation is carried out. See note above.
    """
    return _mupdf.fz_string_from_text_language(str, lang)

def fz_string_from_text_language2(lang):
    r"""
    Class-aware wrapper for `::fz_string_from_text_language2()`.
    C++ alternative to fz_string_from_text_language() that returns information in a std::string.
    """
    return _mupdf.fz_string_from_text_language2(lang)

def fz_strlcat(dst, src, n):
    r"""
    Class-aware wrapper for `::fz_strlcat()`.
    	Concatenate 2 strings, with a maximum length.

    	dst: pointer to first string in a buffer of n bytes.

    	src: pointer to string to concatenate.

    	n: Size (in bytes) of buffer that dst is in.

    	Returns the real length that a concatenated dst + src would have
    	been (not including terminator).
    """
    return _mupdf.fz_strlcat(dst, src, n)

def fz_strlcpy(dst, src, n):
    r"""
    Class-aware wrapper for `::fz_strlcpy()`.
    	Copy at most n-1 chars of a string into a destination
    	buffer with null termination, returning the real length of the
    	initial string (excluding terminator).

    	dst: Destination buffer, at least n bytes long.

    	src: C string (non-NULL).

    	n: Size of dst buffer in bytes.

    	Returns the length (excluding terminator) of src.
    """
    return _mupdf.fz_strlcpy(dst, src, n)

def fz_strncasecmp(a, b, n):
    r"""Class-aware wrapper for `::fz_strncasecmp()`."""
    return _mupdf.fz_strncasecmp(a, b, n)

def fz_strnlen(s, maxlen):
    r"""
    Class-aware wrapper for `::fz_strnlen()`.
    	Return strlen(s), if that is less than maxlen, or maxlen if
    	there is no null byte ('') among the first maxlen bytes.
    """
    return _mupdf.fz_strnlen(s, maxlen)

def fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params):
    r"""Class-aware wrapper for `::fz_stroke_path()`."""
    return _mupdf.fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params)

def fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params):
    r"""Class-aware wrapper for `::fz_stroke_text()`."""
    return _mupdf.fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params)

def fz_strsep(stringp, delim):
    r"""
    Class-aware wrapper for `::fz_strsep()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_strsep(const char *delim)` => `(char *, char *stringp)`

    	Given a pointer to a C string (or a pointer to NULL) break
    	it at the first occurrence of a delimiter char (from a given
    	set).

    	stringp: Pointer to a C string pointer (or NULL). Updated on
    	exit to point to the first char of the string after the
    	delimiter that was found. The string pointed to by stringp will
    	be corrupted by this call (as the found delimiter will be
    	overwritten by 0).

    	delim: A C string of acceptable delimiter characters.

    	Returns a pointer to a C string containing the chars of stringp
    	up to the first delimiter char (or the end of the string), or
    	NULL.
    """
    return _mupdf.fz_strsep(stringp, delim)

def fz_strtof(s, es):
    r"""
    Class-aware wrapper for `::fz_strtof()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_strtof(const char *s)` => `(float, char *es)`

    	Locale-independent decimal to binary conversion. On overflow
    	return (-)INFINITY and set errno to ERANGE. On underflow return
    	0 and set errno to ERANGE. Special inputs (case insensitive):
    	"NAN", "INF" or "INFINITY".
    """
    return _mupdf.fz_strtof(s, es)

def fz_structure_from_string(str):
    r"""Class-aware wrapper for `::fz_structure_from_string()`."""
    return _mupdf.fz_structure_from_string(str)

def fz_structure_to_string(type):
    r"""Class-aware wrapper for `::fz_structure_to_string()`."""
    return _mupdf.fz_structure_to_string(type)

def fz_subpixel_adjust(ctm, subpix_ctm, qe, qf):
    r"""
    Class-aware wrapper for `::fz_subpixel_adjust()`.
    	Perform subpixel quantisation and adjustment on a glyph matrix.

    	ctm: On entry, the desired 'ideal' transformation for a glyph.
    	On exit, adjusted to a (very similar) transformation quantised
    	for subpixel caching.

    	subpix_ctm: Initialised by the routine to the transform that
    	should be used to render the glyph.

    	qe, qf: which subpixel position we quantised to.

    	Returns: the size of the glyph.

    	Note: This is currently only exposed for use in our app. It
    	should be considered "at risk" of removal from the API.
    """
    return _mupdf.fz_subpixel_adjust(ctm, subpix_ctm, qe, qf)

def fz_subsample_pixmap(tile, factor):
    r"""Class-aware wrapper for `::fz_subsample_pixmap()`."""
    return _mupdf.fz_subsample_pixmap(tile, factor)

def fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont):
    r"""
    Class-aware wrapper for `::fz_subset_cff_for_gids()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_subset_cff_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
    """
    return _mupdf.fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont)

def fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont):
    r"""
    Class-aware wrapper for `::fz_subset_ttf_for_gids()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_subset_ttf_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
    """
    return _mupdf.fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont)

def fz_sync_bits(stm):
    r"""
    Class-aware wrapper for `::fz_sync_bits()`.
    	Called after reading bits to tell the stream
    	that we are about to return to reading bytewise. Resyncs
    	the stream to whole byte boundaries.
    """
    return _mupdf.fz_sync_bits(stm)

def fz_tell(stm):
    r"""
    Class-aware wrapper for `::fz_tell()`.
    	return the current reading position within a stream
    """
    return _mupdf.fz_tell(stm)

def fz_tell_output(out):
    r"""
    Class-aware wrapper for `::fz_tell_output()`.
    	Return the current file position.

    	Throw an error on untellable outputs.
    """
    return _mupdf.fz_tell_output(out)

def fz_terminate_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_terminate_buffer()`.
    	Zero-terminate buffer in order to use as a C string.

    	This byte is invisible and does not affect the length of the
    	buffer as returned by fz_buffer_storage. The zero byte is
    	written *after* the data, and subsequent writes will overwrite
    	the terminating byte.

    	Subsequent changes to the size of the buffer (such as by
    	fz_buffer_trim, fz_buffer_grow, fz_resize_buffer, etc) may
    	invalidate this.
    """
    return _mupdf.fz_terminate_buffer(buf)

def fz_text_aa_level():
    r"""
    Class-aware wrapper for `::fz_text_aa_level()`.
    	Get the number of bits of antialiasing we are
    	using for text. Between 0 and 8.
    """
    return _mupdf.fz_text_aa_level()

def fz_text_language_from_string(str):
    r"""
    Class-aware wrapper for `::fz_text_language_from_string()`.
    	Convert ISO 639 (639-{1,2,3,5}) language specification
    	strings losslessly to a 15 bit fz_text_language code.

    	No validation is carried out. Obviously invalid (out
    	of spec) codes will be mapped to FZ_LANG_UNSET, but
    	well-formed (but undefined) codes will be blithely
    	accepted.
    """
    return _mupdf.fz_text_language_from_string(str)

def fz_tint_pixmap(pix, black, white):
    r"""
    Class-aware wrapper for `::fz_tint_pixmap()`.
    	Tint all the pixels in an RGB, BGR, or Gray pixmap.

    	black: Map black to this hexadecimal RGB color.

    	white: Map white to this hexadecimal RGB color.
    """
    return _mupdf.fz_tint_pixmap(pix, black, white)

def fz_tolower(c):
    r"""
    Class-aware wrapper for `::fz_tolower()`.
    	Unicode aware tolower and toupper functions.
    """
    return _mupdf.fz_tolower(c)

def fz_toupper(c):
    r"""Class-aware wrapper for `::fz_toupper()`."""
    return _mupdf.fz_toupper(c)

def fz_transform_page(mediabox, resolution, rotate):
    r"""
    Class-aware wrapper for `::fz_transform_page()`.
    	Create transform matrix to draw page
    	at a given resolution and rotation. Adjusts the scaling
    	factors so that the page covers whole number of
    	pixels and adjust the page origin to be at 0,0.
    """
    return _mupdf.fz_transform_page(mediabox, resolution, rotate)

def fz_transform_path(path, transform):
    r"""
    Class-aware wrapper for `::fz_transform_path()`.
    	Transform a path by a given
    	matrix.

    	path: The path to modify (must not be a packed path).

    	transform: The transform to apply.

    	Throws exceptions if the path is packed, or on failure
    	to allocate.
    """
    return _mupdf.fz_transform_path(path, transform)

def fz_transform_point(point, m):
    r"""
    Class-aware wrapper for `::fz_transform_point()`.
    	Apply a transformation to a point.

    	transform: Transformation matrix to apply. See fz_concat,
    	fz_scale, fz_rotate and fz_translate for how to create a
    	matrix.

    	point: Pointer to point to update.

    	Returns transform (unchanged).
    """
    return _mupdf.fz_transform_point(point, m)

def fz_transform_point_xy(x, y, m):
    r"""Class-aware wrapper for `::fz_transform_point_xy()`."""
    return _mupdf.fz_transform_point_xy(x, y, m)

def fz_transform_quad(q, m):
    r"""
    Class-aware wrapper for `::fz_transform_quad()`.
    	Transform a quad by a matrix.
    """
    return _mupdf.fz_transform_quad(q, m)

def fz_transform_rect(rect, m):
    r"""
    Class-aware wrapper for `::fz_transform_rect()`.
    	Apply a transform to a rectangle.

    	After the four corner points of the axis-aligned rectangle
    	have been transformed it may not longer be axis-aligned. So a
    	new axis-aligned rectangle is created covering at least the
    	area of the transformed rectangle.

    	transform: Transformation matrix to apply. See fz_concat,
    	fz_scale and fz_rotate for how to create a matrix.

    	rect: Rectangle to be transformed. The two special cases
    	fz_empty_rect and fz_infinite_rect, may be used but are
    	returned unchanged as expected.
    """
    return _mupdf.fz_transform_rect(rect, m)

def fz_transform_vector(vector, m):
    r"""
    Class-aware wrapper for `::fz_transform_vector()`.
    	Apply a transformation to a vector.

    	transform: Transformation matrix to apply. See fz_concat,
    	fz_scale and fz_rotate for how to create a matrix. Any
    	translation will be ignored.

    	vector: Pointer to vector to update.
    """
    return _mupdf.fz_transform_vector(vector, m)

def fz_translate(tx, ty):
    r"""
    Class-aware wrapper for `::fz_translate()`.
    	Create a translation matrix.

    	The returned matrix is of the form [ 1 0 0 1 tx ty ].

    	m: A place to store the created matrix.

    	tx, ty: Translation distances along the X- and Y-axes. A
    	translation of 0 will not cause any translation along the
    	relevant axis.

    	Returns m.
    """
    return _mupdf.fz_translate(tx, ty)

def fz_translate_irect(a, xoff, yoff):
    r"""Class-aware wrapper for `::fz_translate_irect()`."""
    return _mupdf.fz_translate_irect(a, xoff, yoff)

def fz_translate_rect(a, xoff, yoff):
    r"""
    Class-aware wrapper for `::fz_translate_rect()`.
    	Translate bounding box.

    	Translate a bbox by a given x and y offset. Allows for overflow.
    """
    return _mupdf.fz_translate_rect(a, xoff, yoff)

def fz_tree_archive_add_buffer(arch_, name, buf):
    r"""
    Class-aware wrapper for `::fz_tree_archive_add_buffer()`.
    	Add a named buffer to an existing tree archive.

    	The tree will take a new reference to the buffer. Ownership
    	is not transferred.
    """
    return _mupdf.fz_tree_archive_add_buffer(arch_, name, buf)

def fz_tree_archive_add_data(arch_, name, data, size):
    r"""
    Class-aware wrapper for `::fz_tree_archive_add_data()`.
    	Add a named block of data to an existing tree archive.

    	The data will be copied into a buffer, and so the caller
    	may free it as soon as this returns.
    """
    return _mupdf.fz_tree_archive_add_data(arch_, name, data, size)

def fz_tree_lookup(node, key):
    r"""
    Class-aware wrapper for `::fz_tree_lookup()`.
    	Look for the value of a node in the tree with the given key.

    	Simple pointer equivalence is used for key.

    	Returns NULL for no match.
    """
    return _mupdf.fz_tree_lookup(node, key)

def fz_trim_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_trim_buffer()`.
    	Trim wasted capacity from a buffer by resizing internal memory.
    """
    return _mupdf.fz_trim_buffer(buf)

def fz_trim_path(path):
    r"""
    Class-aware wrapper for `::fz_trim_path()`.
    	Minimise the internal storage used by a path.

    	As paths are constructed, the internal buffers
    	grow. To avoid repeated reallocations they
    	grow with some spare space. Once a path has
    	been fully constructed, this call allows the
    	excess space to be trimmed.
    """
    return _mupdf.fz_trim_path(path)

def fz_truncate_output(arg_0):
    r"""
    Class-aware wrapper for `::fz_truncate_output()`.
    	Truncate the output at the current position.

    	This allows output streams which have seeked back from the end
    	of their storage to be truncated at the current point.
    """
    return _mupdf.fz_truncate_output(arg_0)

def fz_try_invert_matrix(inv, src):
    r"""
    Class-aware wrapper for `::fz_try_invert_matrix()`.
    	Attempt to create an inverse matrix.

    	inv: Place to store inverse matrix.

    	src: Matrix to invert. A degenerate matrix, where the
    	determinant is equal to zero, can not be inverted.

    	Returns 1 if matrix is degenerate (singular), or 0 otherwise.
    """
    return _mupdf.fz_try_invert_matrix(inv, src)

def fz_try_open_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_try_open_archive_entry()`.
    	Opens an archive entry as a stream.

    	Returns NULL if a matching entry cannot be found, otherwise
    	behaves exactly as fz_open_archive_entry.
    """
    return _mupdf.fz_try_open_archive_entry(arch, name)

def fz_try_open_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_try_open_archive_with_stream()`.
    	Open zip or tar archive stream.

    	Does the same as fz_open_archive_with_stream, but will not throw
    	an error in the event of failing to recognise the format. Will
    	still throw errors in other cases though!
    """
    return _mupdf.fz_try_open_archive_with_stream(file)

def fz_try_open_file(name):
    r"""
    Class-aware wrapper for `::fz_try_open_file()`.
    	Open the named file and wrap it in a stream.

    	Does the same as fz_open_file, but in the event the file
    	does not open, it will return NULL rather than throw an
    	exception.
    """
    return _mupdf.fz_try_open_file(name)

def fz_try_parse_xml_archive_entry(dir, filename, preserve_white):
    r"""
    Class-aware wrapper for `::fz_try_parse_xml_archive_entry()`.
    	Try and parse the contents of an archive entry into a tree of xml nodes.

    	preserve_white: whether to keep or delete all-whitespace nodes.

    	Will return NULL if the archive entry can't be found. Otherwise behaves
    	the same as fz_parse_xml_archive_entry. May throw exceptions.
    """
    return _mupdf.fz_try_parse_xml_archive_entry(dir, filename, preserve_white)

def fz_try_read_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_try_read_archive_entry()`.
    	Reads all bytes in an archive entry
    	into a buffer.

    	name: Entry name to look for, this must be an exact match to
    	the entry name in the archive.

    	Returns NULL if a matching entry cannot be found. Otherwise behaves
    	the same as fz_read_archive_entry. Exceptions may be thrown.
    """
    return _mupdf.fz_try_read_archive_entry(arch, name)

def fz_try_read_file(filename):
    r"""
    Class-aware wrapper for `::fz_try_read_file()`.
    	Read all the contents of a file into a buffer.

    	Returns NULL if the file does not exist, otherwise
    	behaves exactly as fz_read_file.
    """
    return _mupdf.fz_try_read_file(filename)

def fz_tune_image_decode(image_decode, arg):
    r"""
    Class-aware wrapper for `::fz_tune_image_decode()`.
    	Set the tuning function to use for
    	image decode.

    	image_decode: Function to use.

    	arg: Opaque argument to be passed to tuning function.
    """
    return _mupdf.fz_tune_image_decode(image_decode, arg)

def fz_tune_image_scale(image_scale, arg):
    r"""
    Class-aware wrapper for `::fz_tune_image_scale()`.
    	Set the tuning function to use for
    	image scaling.

    	image_scale: Function to use.

    	arg: Opaque argument to be passed to tuning function.
    """
    return _mupdf.fz_tune_image_scale(image_scale, arg)

def fz_unicode_from_glyph_name(name):
    r"""Class-aware wrapper for `::fz_unicode_from_glyph_name()`."""
    return _mupdf.fz_unicode_from_glyph_name(name)

def fz_unicode_from_glyph_name_strict(name):
    r"""Class-aware wrapper for `::fz_unicode_from_glyph_name_strict()`."""
    return _mupdf.fz_unicode_from_glyph_name_strict(name)

def fz_union_rect(a, b):
    r"""
    Class-aware wrapper for `::fz_union_rect()`.
    	Compute union of two rectangles.

    	Given two rectangles, update the first to be the smallest
    	axis-aligned rectangle that encompasses both given rectangles.
    	If either rectangle is infinite then the union is also infinite.
    	If either rectangle is empty then the union is simply the
    	non-empty rectangle. Should both rectangles be empty, then the
    	union is also empty.
    """
    return _mupdf.fz_union_rect(a, b)

def fz_unlock(lock):
    r"""
    Class-aware wrapper for `::fz_unlock()`.
    	Unlock one of the user supplied mutexes.
    """
    return _mupdf.fz_unlock(lock)

def fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip):
    r"""Class-aware wrapper for `::fz_unpack_stream()`."""
    return _mupdf.fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip)

def fz_unread_byte(stm):
    r"""
    Class-aware wrapper for `::fz_unread_byte()`.
    	Unread the single last byte successfully
    	read from a stream. Do not call this without having
    	successfully read a byte.

    	stm: The stream to operate upon.
    """
    return _mupdf.fz_unread_byte(stm)

def fz_unshare_stroke_state(shared):
    r"""
    Class-aware wrapper for `::fz_unshare_stroke_state()`.
    	Given a reference to a (possibly) shared stroke_state structure,
    	return a reference to an equivalent stroke_state structure
    	that is guaranteed to be unshared (i.e. one that can
    	safely be modified).

    	shared: The reference to a (possibly) shared structure
    	to unshare. Ownership of this reference is passed in
    	to this function, even in the case of exceptions being
    	thrown.

    	Exceptions may be thrown in the event of failure to
    	allocate if required.
    """
    return _mupdf.fz_unshare_stroke_state(shared)

def fz_unshare_stroke_state_with_dash_len(shared, len):
    r"""
    Class-aware wrapper for `::fz_unshare_stroke_state_with_dash_len()`.
    	Given a reference to a (possibly) shared stroke_state structure,
    	return a reference to a stroke_state structure (with room for a
    	given amount of dash data) that is guaranteed to be unshared
    	(i.e. one that can safely be modified).

    	shared: The reference to a (possibly) shared structure
    	to unshare. Ownership of this reference is passed in
    	to this function, even in the case of exceptions being
    	thrown.

    	Exceptions may be thrown in the event of failure to
    	allocate if required.
    """
    return _mupdf.fz_unshare_stroke_state_with_dash_len(shared, len)

def fz_urldecode(url):
    r"""
    Class-aware wrapper for `::fz_urldecode()`.
    	Like fz_decode_uri_component but in-place.
    """
    return _mupdf.fz_urldecode(url)

def fz_use_document_css():
    r"""
    Class-aware wrapper for `::fz_use_document_css()`.
    	Return whether to respect document styles in HTML and EPUB.
    """
    return _mupdf.fz_use_document_css()

def fz_user_context():
    r"""
    Class-aware wrapper for `::fz_user_context()`.
    	Read the user field from the context.
    """
    return _mupdf.fz_user_context()

def fz_user_css():
    r"""
    Class-aware wrapper for `::fz_user_css()`.
    	Get the user stylesheet source text.
    """
    return _mupdf.fz_user_css()

def fz_utflen(s):
    r"""
    Class-aware wrapper for `::fz_utflen()`.
    	Count how many runes the UTF-8 encoded string
    	consists of.

    	s: The UTF-8 encoded, NUL-terminated text string.

    	Returns the number of runes in the string.
    """
    return _mupdf.fz_utflen(s)

def fz_var_imp(arg_0):
    r"""Class-aware wrapper for `::fz_var_imp()`."""
    return _mupdf.fz_var_imp(arg_0)

def fz_walk_path(path, walker, arg):
    r"""
    Class-aware wrapper for `::fz_walk_path()`.
    	Walk the segments of a path, calling the
    	appropriate callback function from a given set for each
    	segment of the path.

    	path: The path to walk.

    	walker: The set of callback functions to use. The first
    	4 callback pointers in the set must be non-NULL. The
    	subsequent ones can either be supplied, or can be left
    	as NULL, in which case the top 4 functions will be
    	called as appropriate to simulate them.

    	arg: An opaque argument passed in to each callback.

    	Exceptions will only be thrown if the underlying callback
    	functions throw them.
    """
    return _mupdf.fz_walk_path(path, walker, arg)

def fz_warn(*args):
    r"""Class-aware wrapper for `::fz_warn()`."""
    return _mupdf.fz_warn(*args)

def fz_warning_callback(user):
    r"""
    Class-aware wrapper for `::fz_warning_callback()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_warning_callback()` => `(fz_warning_cb *, void *user)`

    	Retrieve the currently set warning callback, or NULL if none
    	has been set. Optionally, if user is non-NULL, the user pointer
    	given when the warning callback was set is also passed back to
    	the caller.
    """
    return _mupdf.fz_warning_callback(user)

def fz_warp_pixmap(src, points, width, height):
    r"""Class-aware wrapper for `::fz_warp_pixmap()`."""
    return _mupdf.fz_warp_pixmap(src, points, width, height)

def fz_windows_1250_from_unicode(u):
    r"""Class-aware wrapper for `::fz_windows_1250_from_unicode()`."""
    return _mupdf.fz_windows_1250_from_unicode(u)

def fz_windows_1251_from_unicode(u):
    r"""Class-aware wrapper for `::fz_windows_1251_from_unicode()`."""
    return _mupdf.fz_windows_1251_from_unicode(u)

def fz_windows_1252_from_unicode(u):
    r"""Class-aware wrapper for `::fz_windows_1252_from_unicode()`."""
    return _mupdf.fz_windows_1252_from_unicode(u)

def fz_write_band(writer, stride, band_height, samples):
    r"""
    Class-aware wrapper for `::fz_write_band()`.
    	Cause a band writer to write the next band
    	of data for an image.

    	stride: The byte offset from the first byte of the data
    	for a pixel to the first byte of the data for the same pixel
    	on the row below.

    	band_height: The number of lines in this band.

    	samples: Pointer to first byte of the data.
    """
    return _mupdf.fz_write_band(writer, stride, band_height, samples)

def fz_write_base64(out, data, size, newline):
    r"""
    Class-aware wrapper for `::fz_write_base64()`.
    	Write a base64 encoded data block, optionally with periodic
    	newlines.
    """
    return _mupdf.fz_write_base64(out, data, size, newline)

def fz_write_base64_buffer(out, data, newline):
    r"""
    Class-aware wrapper for `::fz_write_base64_buffer()`.
    	Write a base64 encoded fz_buffer, optionally with periodic
    	newlines.
    """
    return _mupdf.fz_write_base64_buffer(out, data, newline)

def fz_write_bitmap_as_pbm(out, bitmap):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pbm()`.
    	Write a bitmap as a pbm.
    """
    return _mupdf.fz_write_bitmap_as_pbm(out, bitmap)

def fz_write_bitmap_as_pcl(out, bitmap, pcl):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pcl()`.
    	Write a bitmap as mono PCL.
    """
    return _mupdf.fz_write_bitmap_as_pcl(out, bitmap, pcl)

def fz_write_bitmap_as_pkm(out, bitmap):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pkm()`.
    	Write a CMYK bitmap as a pkm.
    """
    return _mupdf.fz_write_bitmap_as_pkm(out, bitmap)

def fz_write_bitmap_as_pwg(out, bitmap, pwg):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pwg()`.
    	Write a bitmap as a PWG.
    """
    return _mupdf.fz_write_bitmap_as_pwg(out, bitmap, pwg)

def fz_write_bitmap_as_pwg_page(out, bitmap, pwg):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pwg_page()`.
    	Write a bitmap as a PWG page.

    	Caller should provide a file header by calling
    	fz_write_pwg_file_header, but can then write several pages to
    	the same file.
    """
    return _mupdf.fz_write_bitmap_as_pwg_page(out, bitmap, pwg)

def fz_write_bits(out, data, num_bits):
    r"""
    Class-aware wrapper for `::fz_write_bits()`.
    	Write num_bits of data to the end of the output stream, assumed to be packed
    	most significant bits first.
    """
    return _mupdf.fz_write_bits(out, data, num_bits)

def fz_write_bits_sync(out):
    r"""
    Class-aware wrapper for `::fz_write_bits_sync()`.
    	Sync to byte boundary after writing bits.
    """
    return _mupdf.fz_write_bits_sync(out)

def fz_write_buffer(out, data):
    r"""Class-aware wrapper for `::fz_write_buffer()`."""
    return _mupdf.fz_write_buffer(out, data)

def fz_write_byte(out, x):
    r"""Class-aware wrapper for `::fz_write_byte()`."""
    return _mupdf.fz_write_byte(out, x)

def fz_write_char(out, x):
    r"""Class-aware wrapper for `::fz_write_char()`."""
    return _mupdf.fz_write_char(out, x)

def fz_write_data(out, data, size):
    r"""
    Class-aware wrapper for `::fz_write_data()`.
    	Write data to output.

    	data: Pointer to data to write.
    	size: Size of data to write in bytes.
    """
    return _mupdf.fz_write_data(out, data, size)

def fz_write_document(wri, doc):
    r"""
    Class-aware wrapper for `::fz_write_document()`.
    	Convenience function to feed all the pages of a document to
    	fz_begin_page/fz_run_page/fz_end_page.
    """
    return _mupdf.fz_write_document(wri, doc)

def fz_write_float_be(out, f):
    r"""Class-aware wrapper for `::fz_write_float_be()`."""
    return _mupdf.fz_write_float_be(out, f)

def fz_write_float_le(out, f):
    r"""Class-aware wrapper for `::fz_write_float_le()`."""
    return _mupdf.fz_write_float_le(out, f)

def fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps):
    r"""
    Class-aware wrapper for `::fz_write_header()`.
    	Cause a band writer to write the header for
    	a banded image with the given properties/dimensions etc. This
    	also configures the bandwriter for the format of the data to be
    	passed in future calls.

    	w, h: Width and Height of the entire page.

    	n: Number of components (including spots and alphas).

    	alpha: Number of alpha components.

    	xres, yres: X and Y resolutions in dpi.

    	cs: Colorspace (NULL for bitmaps)

    	seps: Separation details (or NULL).
    """
    return _mupdf.fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps)

def fz_write_image_as_data_uri(out, image):
    r"""
    Class-aware wrapper for `::fz_write_image_as_data_uri()`.
    	Write image as a data URI (for HTML and SVG output).
    """
    return _mupdf.fz_write_image_as_data_uri(out, image)

def fz_write_int16_be(out, x):
    r"""Class-aware wrapper for `::fz_write_int16_be()`."""
    return _mupdf.fz_write_int16_be(out, x)

def fz_write_int16_le(out, x):
    r"""Class-aware wrapper for `::fz_write_int16_le()`."""
    return _mupdf.fz_write_int16_le(out, x)

def fz_write_int32_be(out, x):
    r"""
    Class-aware wrapper for `::fz_write_int32_be()`.
    	Write different sized data to an output stream.
    """
    return _mupdf.fz_write_int32_be(out, x)

def fz_write_int32_le(out, x):
    r"""Class-aware wrapper for `::fz_write_int32_le()`."""
    return _mupdf.fz_write_int32_le(out, x)

def fz_write_pixmap_as_data_uri(out, pixmap):
    r"""Class-aware wrapper for `::fz_write_pixmap_as_data_uri()`."""
    return _mupdf.fz_write_pixmap_as_data_uri(out, pixmap)

def fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_jpeg()`.
    	Write a pixmap as a JPEG.
    """
    return _mupdf.fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk)

def fz_write_pixmap_as_jpx(out, pix, quality):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_jpx()`.
    	Pixmap data as JP2K with no subsampling.

    	quality = 100 = lossless
    	otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
    """
    return _mupdf.fz_write_pixmap_as_jpx(out, pix, quality)

def fz_write_pixmap_as_pam(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pam()`.
    	Write a pixmap as a pnm (greyscale, rgb or cmyk, with or without
    	alpha).
    """
    return _mupdf.fz_write_pixmap_as_pam(out, pixmap)

def fz_write_pixmap_as_pcl(out, pixmap, pcl):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pcl()`.
    	Write an (RGB) pixmap as color PCL.
    """
    return _mupdf.fz_write_pixmap_as_pcl(out, pixmap, pcl)

def fz_write_pixmap_as_pclm(out, pixmap, options):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pclm()`.
    	Write a (Greyscale or RGB) pixmap as pclm.
    """
    return _mupdf.fz_write_pixmap_as_pclm(out, pixmap, options)

def fz_write_pixmap_as_pdfocr(out, pixmap, options):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pdfocr()`.
    	Write a (Greyscale or RGB) pixmap as pdfocr.
    """
    return _mupdf.fz_write_pixmap_as_pdfocr(out, pixmap, options)

def fz_write_pixmap_as_png(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_png()`.
    	Write a (Greyscale or RGB) pixmap as a png.
    """
    return _mupdf.fz_write_pixmap_as_png(out, pixmap)

def fz_write_pixmap_as_pnm(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pnm()`.
    	Write a pixmap as a pnm (greyscale or rgb, no alpha).
    """
    return _mupdf.fz_write_pixmap_as_pnm(out, pixmap)

def fz_write_pixmap_as_ps(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_ps()`.
    	Write a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
    """
    return _mupdf.fz_write_pixmap_as_ps(out, pixmap)

def fz_write_pixmap_as_psd(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_psd()`.
    	Write a pixmap as a PSD file.
    """
    return _mupdf.fz_write_pixmap_as_psd(out, pixmap)

def fz_write_pixmap_as_pwg(out, pixmap, pwg):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pwg()`.
    	Write a pixmap as a PWG.
    """
    return _mupdf.fz_write_pixmap_as_pwg(out, pixmap, pwg)

def fz_write_pixmap_as_pwg_page(out, pixmap, pwg):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pwg_page()`.
    	Write a pixmap as a PWG page.

    	Caller should provide a file header by calling
    	fz_write_pwg_file_header, but can then write several pages to
    	the same file.
    """
    return _mupdf.fz_write_pixmap_as_pwg_page(out, pixmap, pwg)

def fz_write_ps_file_header(out):
    r"""
    Class-aware wrapper for `::fz_write_ps_file_header()`.
    	Write the file level header for ps band writer output.
    """
    return _mupdf.fz_write_ps_file_header(out)

def fz_write_ps_file_trailer(out, pages):
    r"""
    Class-aware wrapper for `::fz_write_ps_file_trailer()`.
    	Write the file level trailer for ps band writer output.
    """
    return _mupdf.fz_write_ps_file_trailer(out, pages)

def fz_write_pwg_file_header(out):
    r"""
    Class-aware wrapper for `::fz_write_pwg_file_header()`.
    	Output the file header to a pwg stream, ready for pages to follow it.
    """
    return _mupdf.fz_write_pwg_file_header(out)

def fz_write_rune(out, rune):
    r"""
    Class-aware wrapper for `::fz_write_rune()`.
    	Write a UTF-8 encoded unicode character.
    """
    return _mupdf.fz_write_rune(out, rune)

def fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir):
    r"""Class-aware wrapper for `::fz_write_stabilized_story()`."""
    return _mupdf.fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir)

def fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref):
    r"""Class-aware wrapper for `::fz_write_story()`."""
    return _mupdf.fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref)

def fz_write_stream(out, _in):
    r"""
    Class-aware wrapper for `::fz_write_stream()`.
    	Copy the stream contents to the output.
    """
    return _mupdf.fz_write_stream(out, _in)

def fz_write_string(out, s):
    r"""
    Class-aware wrapper for `::fz_write_string()`.
    	Write a string. Does not write zero terminator.
    """
    return _mupdf.fz_write_string(out, s)

def fz_write_uint16_be(out, x):
    r"""Class-aware wrapper for `::fz_write_uint16_be()`."""
    return _mupdf.fz_write_uint16_be(out, x)

def fz_write_uint16_le(out, x):
    r"""Class-aware wrapper for `::fz_write_uint16_le()`."""
    return _mupdf.fz_write_uint16_le(out, x)

def fz_write_uint32_be(out, x):
    r"""Class-aware wrapper for `::fz_write_uint32_be()`."""
    return _mupdf.fz_write_uint32_be(out, x)

def fz_write_uint32_le(out, x):
    r"""Class-aware wrapper for `::fz_write_uint32_le()`."""
    return _mupdf.fz_write_uint32_le(out, x)

def fz_write_xml(root, out, indented):
    r"""
    Class-aware wrapper for `::fz_write_xml()`.
    	Write our xml structure out to an xml stream.

    	Properly formatted XML is only allowed to have a single top-level node
    	under which everything must sit. Our structures allow for multiple
    	top level nodes. If required, we will output an extra 'ROOT' node
    	at the top so that the xml is well-formed.

    	If 'indented' is non-zero then additional whitespace will be added to
    	make the XML easier to read in a text editor. It will NOT be properly
    	compliant.
    """
    return _mupdf.fz_write_xml(root, out, indented)

def fz_write_zip_entry(zip, name, buf, compress):
    r"""
    Class-aware wrapper for `::fz_write_zip_entry()`.
    	Given a buffer of data, (optionally) compress it, and add it to
    	the zip file with the given name.
    """
    return _mupdf.fz_write_zip_entry(zip, name, buf, compress)

def fz_xml_add_att(pool, node, key, val):
    r"""
    Class-aware wrapper for `::fz_xml_add_att()`.
    	Add an attribute to an XML node.
    """
    return _mupdf.fz_xml_add_att(pool, node, key, val)

def fz_xml_att(item, att):
    r"""
    Class-aware wrapper for `::fz_xml_att()`.
    	Return the value of an attribute of an XML node.
    	NULL if the attribute doesn't exist.
    """
    return _mupdf.fz_xml_att(item, att)

def fz_xml_att_alt(item, one, two):
    r"""
    Class-aware wrapper for `::fz_xml_att_alt()`.
    	Return the value of an attribute of an XML node.
    	If the first attribute doesn't exist, try the second.
    	NULL if neither attribute exists.
    """
    return _mupdf.fz_xml_att_alt(item, one, two)

def fz_xml_att_eq(item, name, match):
    r"""
    Class-aware wrapper for `::fz_xml_att_eq()`.
    	Check for a matching attribute on an XML node.

    	If the node has the requested attribute (name), and the value
    	matches (match) then return 1. Otherwise, 0.
    """
    return _mupdf.fz_xml_att_eq(item, name, match)

def fz_xml_down(item):
    r"""
    Class-aware wrapper for `::fz_xml_down()`.
    	Return first child of XML node.
    """
    return _mupdf.fz_xml_down(item)

def fz_xml_find(item, tag):
    r"""
    Class-aware wrapper for `::fz_xml_find()`.
    	Search the siblings of XML nodes starting with item looking for
    	the first with the given tag.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find(item, tag)

def fz_xml_find_dfs(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_dfs()`.
    	Perform a depth first search from item, returning the first
    	child that matches the given tag (or any tag if tag is NULL),
    	with the given attribute (if att is non NULL), that matches
    	match (if match is non NULL).
    """
    return _mupdf.fz_xml_find_dfs(item, tag, att, match)

def fz_xml_find_dfs_top(item, tag, att, match, top):
    r"""
    Class-aware wrapper for `::fz_xml_find_dfs_top()`.
    	Perform a depth first search from item, returning the first
    	child that matches the given tag (or any tag if tag is NULL),
    	with the given attribute (if att is non NULL), that matches
    	match (if match is non NULL). The search stops if it ever
    	reaches the top of the tree, or the declared 'top' item.
    """
    return _mupdf.fz_xml_find_dfs_top(item, tag, att, match, top)

def fz_xml_find_down(item, tag):
    r"""
    Class-aware wrapper for `::fz_xml_find_down()`.
    	Search the siblings of XML nodes starting with the first child
    	of item looking for the first with the given tag.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_down(item, tag)

def fz_xml_find_down_match(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_down_match()`.
    	Search the siblings of XML nodes starting with the first child
    	of item looking for the first with the given tag (or any tag if
    	tag is NULL), and with a matching attribute.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_down_match(item, tag, att, match)

def fz_xml_find_match(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_match()`.
    	Search the siblings of XML nodes starting with item looking for
    	the first with the given tag (or any tag if tag is NULL), and
    	with a matching attribute.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_match(item, tag, att, match)

def fz_xml_find_next(item, tag):
    r"""
    Class-aware wrapper for `::fz_xml_find_next()`.
    	Search the siblings of XML nodes starting with the first sibling
    	of item looking for the first with the given tag.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_next(item, tag)

def fz_xml_find_next_dfs(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_next_dfs()`.
    	Perform a depth first search onwards from item, returning the first
    	child that matches the given tag (or any tag if tag is NULL),
    	with the given attribute (if att is non NULL), that matches
    	match (if match is non NULL).
    """
    return _mupdf.fz_xml_find_next_dfs(item, tag, att, match)

def fz_xml_find_next_dfs_top(item, tag, att, match, top):
    r"""
    Class-aware wrapper for `::fz_xml_find_next_dfs_top()`.
    	Perform a depth first search onwards from item, returning the first
    	child that matches the given tag (or any tag if tag is NULL),
    	with the given attribute (if att is non NULL), that matches
    	match (if match is non NULL). The search stops if it ever reaches
    	the top of the tree, or the declared 'top' item.
    """
    return _mupdf.fz_xml_find_next_dfs_top(item, tag, att, match, top)

def fz_xml_find_next_match(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_next_match()`.
    	Search the siblings of XML nodes starting with the first sibling
    	of item looking for the first with the given tag (or any tag if tag
    	is NULL), and with a matching attribute.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_next_match(item, tag, att, match)

def fz_xml_is_tag(item, name):
    r"""
    Class-aware wrapper for `::fz_xml_is_tag()`.
    	Return true if the tag name matches.
    """
    return _mupdf.fz_xml_is_tag(item, name)

def fz_xml_next(item):
    r"""
    Class-aware wrapper for `::fz_xml_next()`.
    	Return next sibling of XML node.
    """
    return _mupdf.fz_xml_next(item)

def fz_xml_prev(item):
    r"""
    Class-aware wrapper for `::fz_xml_prev()`.
    	Return previous sibling of XML node.
    """
    return _mupdf.fz_xml_prev(item)

def fz_xml_root(xml):
    r"""
    Class-aware wrapper for `::fz_xml_root()`.
    	Return the topmost XML node of a document.
    """
    return _mupdf.fz_xml_root(xml)

def fz_xml_tag(item):
    r"""
    Class-aware wrapper for `::fz_xml_tag()`.
    	Return tag of XML node. Return NULL for text nodes.
    """
    return _mupdf.fz_xml_tag(item)

def fz_xml_text(item):
    r"""
    Class-aware wrapper for `::fz_xml_text()`.
    	Return the text content of an XML node.
    	Return NULL if the node is a tag.
    """
    return _mupdf.fz_xml_text(item)

def fz_xml_up(item):
    r"""
    Class-aware wrapper for `::fz_xml_up()`.
    	Return parent of XML node.
    """
    return _mupdf.fz_xml_up(item)

def pdf_abandon_operation(doc):
    r"""Class-aware wrapper for `::pdf_abandon_operation()`."""
    return _mupdf.pdf_abandon_operation(doc)

def pdf_access_exec_menu_item_event(evt):
    r"""Class-aware wrapper for `::pdf_access_exec_menu_item_event()`."""
    return _mupdf.pdf_access_exec_menu_item_event(evt)

def pdf_add_annot_border_dash_item(annot, length):
    r"""Class-aware wrapper for `::pdf_add_annot_border_dash_item()`."""
    return _mupdf.pdf_add_annot_border_dash_item(annot, length)

def pdf_add_annot_ink_list(annot, n, stroke):
    r"""Class-aware wrapper for `::pdf_add_annot_ink_list()`."""
    return _mupdf.pdf_add_annot_ink_list(annot, n, stroke)

def pdf_add_annot_ink_list_stroke(annot):
    r"""Class-aware wrapper for `::pdf_add_annot_ink_list_stroke()`."""
    return _mupdf.pdf_add_annot_ink_list_stroke(annot)

def pdf_add_annot_ink_list_stroke_vertex(annot, p):
    r"""Class-aware wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`."""
    return _mupdf.pdf_add_annot_ink_list_stroke_vertex(annot, p)

def pdf_add_annot_quad_point(annot, quad):
    r"""Class-aware wrapper for `::pdf_add_annot_quad_point()`."""
    return _mupdf.pdf_add_annot_quad_point(annot, quad)

def pdf_add_annot_vertex(annot, p):
    r"""Class-aware wrapper for `::pdf_add_annot_vertex()`."""
    return _mupdf.pdf_add_annot_vertex(annot, p)

def pdf_add_cid_font(doc, font):
    r"""Class-aware wrapper for `::pdf_add_cid_font()`."""
    return _mupdf.pdf_add_cid_font(doc, font)

def pdf_add_cjk_font(doc, font, script, wmode, serif):
    r"""Class-aware wrapper for `::pdf_add_cjk_font()`."""
    return _mupdf.pdf_add_cjk_font(doc, font, script, wmode, serif)

def pdf_add_codespace(cmap, low, high, n):
    r"""Class-aware wrapper for `::pdf_add_codespace()`."""
    return _mupdf.pdf_add_codespace(cmap, low, high, n)

def pdf_add_embedded_file(doc, filename, mimetype, contents, created, modifed, add_checksum):
    r"""Class-aware wrapper for `::pdf_add_embedded_file()`."""
    return _mupdf.pdf_add_embedded_file(doc, filename, mimetype, contents, created, modifed, add_checksum)

def pdf_add_hmtx(font, lo, hi, w):
    r"""Class-aware wrapper for `::pdf_add_hmtx()`."""
    return _mupdf.pdf_add_hmtx(font, lo, hi, w)

def pdf_add_image(doc, image):
    r"""Class-aware wrapper for `::pdf_add_image()`."""
    return _mupdf.pdf_add_image(doc, image)

def pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj):
    r"""Class-aware wrapper for `::pdf_add_journal_fragment()`."""
    return _mupdf.pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj)

def pdf_add_new_array(doc, initial):
    r"""Class-aware wrapper for `::pdf_add_new_array()`."""
    return _mupdf.pdf_add_new_array(doc, initial)

def pdf_add_new_dict(doc, initial):
    r"""Class-aware wrapper for `::pdf_add_new_dict()`."""
    return _mupdf.pdf_add_new_dict(doc, initial)

def pdf_add_object(doc, obj):
    r"""Class-aware wrapper for `::pdf_add_object()`."""
    return _mupdf.pdf_add_object(doc, obj)

def pdf_add_page(doc, mediabox, rotate, resources, contents):
    r"""Class-aware wrapper for `::pdf_add_page()`."""
    return _mupdf.pdf_add_page(doc, mediabox, rotate, resources, contents)

def pdf_add_simple_font(doc, font, encoding):
    r"""Class-aware wrapper for `::pdf_add_simple_font()`."""
    return _mupdf.pdf_add_simple_font(doc, font, encoding)

def pdf_add_stream(doc, buf, obj, compressed):
    r"""Class-aware wrapper for `::pdf_add_stream()`."""
    return _mupdf.pdf_add_stream(doc, buf, obj, compressed)

def pdf_add_substitute_font(doc, font):
    r"""Class-aware wrapper for `::pdf_add_substitute_font()`."""
    return _mupdf.pdf_add_substitute_font(doc, font)

def pdf_add_vmtx(font, lo, hi, x, y, w):
    r"""Class-aware wrapper for `::pdf_add_vmtx()`."""
    return _mupdf.pdf_add_vmtx(font, lo, hi, x, y, w)

def pdf_annot_MK_BC(annot, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_MK_BC()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_MK_BC(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.pdf_annot_MK_BC(annot, n, color)

def pdf_annot_MK_BC_rgb(annot, rgb):
    r"""Class-aware wrapper for `::pdf_annot_MK_BC_rgb()`."""
    return _mupdf.pdf_annot_MK_BC_rgb(annot, rgb)

def pdf_annot_MK_BG(annot, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_MK_BG()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_MK_BG(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.pdf_annot_MK_BG(annot, n, color)

def pdf_annot_MK_BG_rgb(annot, rgb):
    r"""Class-aware wrapper for `::pdf_annot_MK_BG_rgb()`."""
    return _mupdf.pdf_annot_MK_BG_rgb(annot, rgb)

def pdf_annot_active(annot):
    r"""Class-aware wrapper for `::pdf_annot_active()`."""
    return _mupdf.pdf_annot_active(annot)

def pdf_annot_ap(annot):
    r"""Class-aware wrapper for `::pdf_annot_ap()`."""
    return _mupdf.pdf_annot_ap(annot)

def pdf_annot_author(annot):
    r"""Class-aware wrapper for `::pdf_annot_author()`."""
    return _mupdf.pdf_annot_author(annot)

def pdf_annot_border(annot):
    r"""Class-aware wrapper for `::pdf_annot_border()`."""
    return _mupdf.pdf_annot_border(annot)

def pdf_annot_border_dash_count(annot):
    r"""Class-aware wrapper for `::pdf_annot_border_dash_count()`."""
    return _mupdf.pdf_annot_border_dash_count(annot)

def pdf_annot_border_dash_item(annot, i):
    r"""Class-aware wrapper for `::pdf_annot_border_dash_item()`."""
    return _mupdf.pdf_annot_border_dash_item(annot, i)

def pdf_annot_border_effect(annot):
    r"""Class-aware wrapper for `::pdf_annot_border_effect()`."""
    return _mupdf.pdf_annot_border_effect(annot)

def pdf_annot_border_effect_intensity(annot):
    r"""Class-aware wrapper for `::pdf_annot_border_effect_intensity()`."""
    return _mupdf.pdf_annot_border_effect_intensity(annot)

def pdf_annot_border_style(annot):
    r"""Class-aware wrapper for `::pdf_annot_border_style()`."""
    return _mupdf.pdf_annot_border_style(annot)

def pdf_annot_border_width(annot):
    r"""Class-aware wrapper for `::pdf_annot_border_width()`."""
    return _mupdf.pdf_annot_border_width(annot)

def pdf_annot_callout_line(annot, callout, n):
    r"""
    Class-aware wrapper for `::pdf_annot_callout_line()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_callout_line(::pdf_annot *annot, ::fz_point callout[3])` => int n
    """
    return _mupdf.pdf_annot_callout_line(annot, callout, n)

def pdf_annot_callout_point(annot):
    r"""Class-aware wrapper for `::pdf_annot_callout_point()`."""
    return _mupdf.pdf_annot_callout_point(annot)

def pdf_annot_callout_style(annot):
    r"""Class-aware wrapper for `::pdf_annot_callout_style()`."""
    return _mupdf.pdf_annot_callout_style(annot)

def pdf_annot_color(annot, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_color(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.pdf_annot_color(annot, n, color)

def pdf_annot_contents(annot):
    r"""Class-aware wrapper for `::pdf_annot_contents()`."""
    return _mupdf.pdf_annot_contents(annot)

def pdf_annot_creation_date(annot):
    r"""Class-aware wrapper for `::pdf_annot_creation_date()`."""
    return _mupdf.pdf_annot_creation_date(annot)

def pdf_annot_default_appearance(annot, font, size, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_default_appearance()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_default_appearance(::pdf_annot *annot, float color[4])` => `(const char *font, float size, int n)`
    """
    return _mupdf.pdf_annot_default_appearance(annot, font, size, n, color)

def pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, size, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_default_appearance_unmapped()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_default_appearance_unmapped(::pdf_annot *annot, char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
    """
    return _mupdf.pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, size, n, color)

def pdf_annot_ensure_local_xref(annot):
    r"""Class-aware wrapper for `::pdf_annot_ensure_local_xref()`."""
    return _mupdf.pdf_annot_ensure_local_xref(annot)

def pdf_annot_event_blur(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_blur()`."""
    return _mupdf.pdf_annot_event_blur(annot)

def pdf_annot_event_down(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_down()`."""
    return _mupdf.pdf_annot_event_down(annot)

def pdf_annot_event_enter(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_enter()`."""
    return _mupdf.pdf_annot_event_enter(annot)

def pdf_annot_event_exit(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_exit()`."""
    return _mupdf.pdf_annot_event_exit(annot)

def pdf_annot_event_focus(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_focus()`."""
    return _mupdf.pdf_annot_event_focus(annot)

def pdf_annot_event_page_close(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_page_close()`."""
    return _mupdf.pdf_annot_event_page_close(annot)

def pdf_annot_event_page_invisible(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_page_invisible()`."""
    return _mupdf.pdf_annot_event_page_invisible(annot)

def pdf_annot_event_page_open(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_page_open()`."""
    return _mupdf.pdf_annot_event_page_open(annot)

def pdf_annot_event_page_visible(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_page_visible()`."""
    return _mupdf.pdf_annot_event_page_visible(annot)

def pdf_annot_event_up(annot):
    r"""Class-aware wrapper for `::pdf_annot_event_up()`."""
    return _mupdf.pdf_annot_event_up(annot)

def pdf_annot_field_event_keystroke(doc, annot, evt):
    r"""Class-aware wrapper for `::pdf_annot_field_event_keystroke()`."""
    return _mupdf.pdf_annot_field_event_keystroke(doc, annot, evt)

def pdf_annot_field_flags(annot):
    r"""Class-aware wrapper for `::pdf_annot_field_flags()`."""
    return _mupdf.pdf_annot_field_flags(annot)

def pdf_annot_field_label(widget):
    r"""Class-aware wrapper for `::pdf_annot_field_label()`."""
    return _mupdf.pdf_annot_field_label(widget)

def pdf_annot_field_value(annot):
    r"""Class-aware wrapper for `::pdf_annot_field_value()`."""
    return _mupdf.pdf_annot_field_value(annot)

def pdf_annot_filespec(annot):
    r"""Class-aware wrapper for `::pdf_annot_filespec()`."""
    return _mupdf.pdf_annot_filespec(annot)

def pdf_annot_flags(annot):
    r"""Class-aware wrapper for `::pdf_annot_flags()`."""
    return _mupdf.pdf_annot_flags(annot)

def pdf_annot_has_author(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_author()`."""
    return _mupdf.pdf_annot_has_author(annot)

def pdf_annot_has_border(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_border()`."""
    return _mupdf.pdf_annot_has_border(annot)

def pdf_annot_has_border_effect(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_border_effect()`."""
    return _mupdf.pdf_annot_has_border_effect(annot)

def pdf_annot_has_callout(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_callout()`."""
    return _mupdf.pdf_annot_has_callout(annot)

def pdf_annot_has_filespec(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_filespec()`."""
    return _mupdf.pdf_annot_has_filespec(annot)

def pdf_annot_has_icon_name(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_icon_name()`."""
    return _mupdf.pdf_annot_has_icon_name(annot)

def pdf_annot_has_ink_list(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_ink_list()`."""
    return _mupdf.pdf_annot_has_ink_list(annot)

def pdf_annot_has_intent(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_intent()`."""
    return _mupdf.pdf_annot_has_intent(annot)

def pdf_annot_has_interior_color(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_interior_color()`."""
    return _mupdf.pdf_annot_has_interior_color(annot)

def pdf_annot_has_line(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_line()`."""
    return _mupdf.pdf_annot_has_line(annot)

def pdf_annot_has_line_ending_styles(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_line_ending_styles()`."""
    return _mupdf.pdf_annot_has_line_ending_styles(annot)

def pdf_annot_has_open(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_open()`."""
    return _mupdf.pdf_annot_has_open(annot)

def pdf_annot_has_popup(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_popup()`."""
    return _mupdf.pdf_annot_has_popup(annot)

def pdf_annot_has_quad_points(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_quad_points()`."""
    return _mupdf.pdf_annot_has_quad_points(annot)

def pdf_annot_has_quadding(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_quadding()`."""
    return _mupdf.pdf_annot_has_quadding(annot)

def pdf_annot_has_rect(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_rect()`."""
    return _mupdf.pdf_annot_has_rect(annot)

def pdf_annot_has_vertices(annot):
    r"""Class-aware wrapper for `::pdf_annot_has_vertices()`."""
    return _mupdf.pdf_annot_has_vertices(annot)

def pdf_annot_hidden_for_editing(annot):
    r"""Class-aware wrapper for `::pdf_annot_hidden_for_editing()`."""
    return _mupdf.pdf_annot_hidden_for_editing(annot)

def pdf_annot_hot(annot):
    r"""Class-aware wrapper for `::pdf_annot_hot()`."""
    return _mupdf.pdf_annot_hot(annot)

def pdf_annot_icon_name(annot):
    r"""Class-aware wrapper for `::pdf_annot_icon_name()`."""
    return _mupdf.pdf_annot_icon_name(annot)

def pdf_annot_ink_list_count(annot):
    r"""Class-aware wrapper for `::pdf_annot_ink_list_count()`."""
    return _mupdf.pdf_annot_ink_list_count(annot)

def pdf_annot_ink_list_stroke_count(annot, i):
    r"""Class-aware wrapper for `::pdf_annot_ink_list_stroke_count()`."""
    return _mupdf.pdf_annot_ink_list_stroke_count(annot, i)

def pdf_annot_ink_list_stroke_vertex(annot, i, k):
    r"""Class-aware wrapper for `::pdf_annot_ink_list_stroke_vertex()`."""
    return _mupdf.pdf_annot_ink_list_stroke_vertex(annot, i, k)

def pdf_annot_intent(annot):
    r"""Class-aware wrapper for `::pdf_annot_intent()`."""
    return _mupdf.pdf_annot_intent(annot)

def pdf_annot_interior_color(annot, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_interior_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_interior_color(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.pdf_annot_interior_color(annot, n, color)

def pdf_annot_is_open(annot):
    r"""Class-aware wrapper for `::pdf_annot_is_open()`."""
    return _mupdf.pdf_annot_is_open(annot)

def pdf_annot_is_standard_stamp(annot):
    r"""Class-aware wrapper for `::pdf_annot_is_standard_stamp()`."""
    return _mupdf.pdf_annot_is_standard_stamp(annot)

def pdf_annot_language(annot):
    r"""Class-aware wrapper for `::pdf_annot_language()`."""
    return _mupdf.pdf_annot_language(annot)

def pdf_annot_line(annot, a, b):
    r"""Class-aware wrapper for `::pdf_annot_line()`."""
    return _mupdf.pdf_annot_line(annot, a, b)

def pdf_annot_line_caption(annot):
    r"""Class-aware wrapper for `::pdf_annot_line_caption()`."""
    return _mupdf.pdf_annot_line_caption(annot)

def pdf_annot_line_caption_offset(annot):
    r"""Class-aware wrapper for `::pdf_annot_line_caption_offset()`."""
    return _mupdf.pdf_annot_line_caption_offset(annot)

def pdf_annot_line_end_style(annot):
    r"""Class-aware wrapper for `::pdf_annot_line_end_style()`."""
    return _mupdf.pdf_annot_line_end_style(annot)

def pdf_annot_line_ending_styles(annot, start_style, end_style):
    r"""
    Class-aware wrapper for `::pdf_annot_line_ending_styles()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_line_ending_styles(::pdf_annot *annot)` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
    """
    return _mupdf.pdf_annot_line_ending_styles(annot, start_style, end_style)

def pdf_annot_line_leader(annot):
    r"""Class-aware wrapper for `::pdf_annot_line_leader()`."""
    return _mupdf.pdf_annot_line_leader(annot)

def pdf_annot_line_leader_extension(annot):
    r"""Class-aware wrapper for `::pdf_annot_line_leader_extension()`."""
    return _mupdf.pdf_annot_line_leader_extension(annot)

def pdf_annot_line_leader_offset(annot):
    r"""Class-aware wrapper for `::pdf_annot_line_leader_offset()`."""
    return _mupdf.pdf_annot_line_leader_offset(annot)

def pdf_annot_line_start_style(annot):
    r"""Class-aware wrapper for `::pdf_annot_line_start_style()`."""
    return _mupdf.pdf_annot_line_start_style(annot)

def pdf_annot_modification_date(annot):
    r"""Class-aware wrapper for `::pdf_annot_modification_date()`."""
    return _mupdf.pdf_annot_modification_date(annot)

def pdf_annot_needs_resynthesis(annot):
    r"""Class-aware wrapper for `::pdf_annot_needs_resynthesis()`."""
    return _mupdf.pdf_annot_needs_resynthesis(annot)

def pdf_annot_obj(annot):
    r"""Class-aware wrapper for `::pdf_annot_obj()`."""
    return _mupdf.pdf_annot_obj(annot)

def pdf_annot_opacity(annot):
    r"""Class-aware wrapper for `::pdf_annot_opacity()`."""
    return _mupdf.pdf_annot_opacity(annot)

def pdf_annot_page(annot):
    r"""Class-aware wrapper for `::pdf_annot_page()`."""
    return _mupdf.pdf_annot_page(annot)

def pdf_annot_pop_and_discard_local_xref(annot):
    r"""Class-aware wrapper for `::pdf_annot_pop_and_discard_local_xref()`."""
    return _mupdf.pdf_annot_pop_and_discard_local_xref(annot)

def pdf_annot_pop_local_xref(annot):
    r"""Class-aware wrapper for `::pdf_annot_pop_local_xref()`."""
    return _mupdf.pdf_annot_pop_local_xref(annot)

def pdf_annot_popup(annot):
    r"""Class-aware wrapper for `::pdf_annot_popup()`."""
    return _mupdf.pdf_annot_popup(annot)

def pdf_annot_push_local_xref(annot):
    r"""Class-aware wrapper for `::pdf_annot_push_local_xref()`."""
    return _mupdf.pdf_annot_push_local_xref(annot)

def pdf_annot_quad_point(annot, i):
    r"""Class-aware wrapper for `::pdf_annot_quad_point()`."""
    return _mupdf.pdf_annot_quad_point(annot, i)

def pdf_annot_quad_point_count(annot):
    r"""Class-aware wrapper for `::pdf_annot_quad_point_count()`."""
    return _mupdf.pdf_annot_quad_point_count(annot)

def pdf_annot_quadding(annot):
    r"""Class-aware wrapper for `::pdf_annot_quadding()`."""
    return _mupdf.pdf_annot_quadding(annot)

def pdf_annot_rect(annot):
    r"""Class-aware wrapper for `::pdf_annot_rect()`."""
    return _mupdf.pdf_annot_rect(annot)

def pdf_annot_request_resynthesis(annot):
    r"""Class-aware wrapper for `::pdf_annot_request_resynthesis()`."""
    return _mupdf.pdf_annot_request_resynthesis(annot)

def pdf_annot_request_synthesis(annot):
    r"""Class-aware wrapper for `::pdf_annot_request_synthesis()`."""
    return _mupdf.pdf_annot_request_synthesis(annot)

def pdf_annot_transform(annot):
    r"""Class-aware wrapper for `::pdf_annot_transform()`."""
    return _mupdf.pdf_annot_transform(annot)

def pdf_annot_type(annot):
    r"""Class-aware wrapper for `::pdf_annot_type()`."""
    return _mupdf.pdf_annot_type(annot)

def pdf_annot_type_from_string(subtype):
    r"""Class-aware wrapper for `::pdf_annot_type_from_string()`."""
    return _mupdf.pdf_annot_type_from_string(subtype)

def pdf_annot_vertex(annot, i):
    r"""Class-aware wrapper for `::pdf_annot_vertex()`."""
    return _mupdf.pdf_annot_vertex(annot, i)

def pdf_annot_vertex_count(annot):
    r"""Class-aware wrapper for `::pdf_annot_vertex_count()`."""
    return _mupdf.pdf_annot_vertex_count(annot)

def pdf_append_explicit_dest_to_uri(url, dest):
    r"""Class-aware wrapper for `::pdf_append_explicit_dest_to_uri()`."""
    return _mupdf.pdf_append_explicit_dest_to_uri(url, dest)

def pdf_append_named_dest_to_uri(url, name):
    r"""Class-aware wrapper for `::pdf_append_named_dest_to_uri()`."""
    return _mupdf.pdf_append_named_dest_to_uri(url, name)

def pdf_append_token(buf, tok, lex):
    r"""Class-aware wrapper for `::pdf_append_token()`."""
    return _mupdf.pdf_append_token(buf, tok, lex)

def pdf_apply_redaction(annot, opts):
    r"""Class-aware wrapper for `::pdf_apply_redaction()`."""
    return _mupdf.pdf_apply_redaction(annot, opts)

def pdf_array_contains(array, obj):
    r"""Class-aware wrapper for `::pdf_array_contains()`."""
    return _mupdf.pdf_array_contains(array, obj)

def pdf_array_delete(array, index):
    r"""Class-aware wrapper for `::pdf_array_delete()`."""
    return _mupdf.pdf_array_delete(array, index)

def pdf_array_find(array, obj):
    r"""Class-aware wrapper for `::pdf_array_find()`."""
    return _mupdf.pdf_array_find(array, obj)

def pdf_array_get(array, i):
    r"""Class-aware wrapper for `::pdf_array_get()`."""
    return _mupdf.pdf_array_get(array, i)

def pdf_array_get_bool(array, index):
    r"""Class-aware wrapper for `::pdf_array_get_bool()`."""
    return _mupdf.pdf_array_get_bool(array, index)

def pdf_array_get_int(array, index):
    r"""Class-aware wrapper for `::pdf_array_get_int()`."""
    return _mupdf.pdf_array_get_int(array, index)

def pdf_array_get_matrix(array, index):
    r"""Class-aware wrapper for `::pdf_array_get_matrix()`."""
    return _mupdf.pdf_array_get_matrix(array, index)

def pdf_array_get_name(array, index):
    r"""Class-aware wrapper for `::pdf_array_get_name()`."""
    return _mupdf.pdf_array_get_name(array, index)

def pdf_array_get_real(array, index):
    r"""Class-aware wrapper for `::pdf_array_get_real()`."""
    return _mupdf.pdf_array_get_real(array, index)

def pdf_array_get_rect(array, index):
    r"""Class-aware wrapper for `::pdf_array_get_rect()`."""
    return _mupdf.pdf_array_get_rect(array, index)

def pdf_array_get_string(array, index, sizep):
    r"""
    Class-aware wrapper for `::pdf_array_get_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_array_get_string(::pdf_obj *array, int index)` => `(const char *, size_t sizep)`
    """
    return _mupdf.pdf_array_get_string(array, index, sizep)

def pdf_array_get_text_string(array, index):
    r"""Class-aware wrapper for `::pdf_array_get_text_string()`."""
    return _mupdf.pdf_array_get_text_string(array, index)

def pdf_array_insert(array, obj, index):
    r"""Class-aware wrapper for `::pdf_array_insert()`."""
    return _mupdf.pdf_array_insert(array, obj, index)

def pdf_array_len(array):
    r"""Class-aware wrapper for `::pdf_array_len()`."""
    return _mupdf.pdf_array_len(array)

def pdf_array_push(array, obj):
    r"""Class-aware wrapper for `::pdf_array_push()`."""
    return _mupdf.pdf_array_push(array, obj)

def pdf_array_push_array(array, initial):
    r"""Class-aware wrapper for `::pdf_array_push_array()`."""
    return _mupdf.pdf_array_push_array(array, initial)

def pdf_array_push_bool(array, x):
    r"""Class-aware wrapper for `::pdf_array_push_bool()`."""
    return _mupdf.pdf_array_push_bool(array, x)

def pdf_array_push_dict(array, initial):
    r"""Class-aware wrapper for `::pdf_array_push_dict()`."""
    return _mupdf.pdf_array_push_dict(array, initial)

def pdf_array_push_int(array, x):
    r"""Class-aware wrapper for `::pdf_array_push_int()`."""
    return _mupdf.pdf_array_push_int(array, x)

def pdf_array_push_name(array, x):
    r"""Class-aware wrapper for `::pdf_array_push_name()`."""
    return _mupdf.pdf_array_push_name(array, x)

def pdf_array_push_real(array, x):
    r"""Class-aware wrapper for `::pdf_array_push_real()`."""
    return _mupdf.pdf_array_push_real(array, x)

def pdf_array_push_string(array, x, n):
    r"""Class-aware wrapper for `::pdf_array_push_string()`."""
    return _mupdf.pdf_array_push_string(array, x, n)

def pdf_array_push_text_string(array, x):
    r"""Class-aware wrapper for `::pdf_array_push_text_string()`."""
    return _mupdf.pdf_array_push_text_string(array, x)

def pdf_array_put(array, i, obj):
    r"""Class-aware wrapper for `::pdf_array_put()`."""
    return _mupdf.pdf_array_put(array, i, obj)

def pdf_array_put_array(array, i, initial):
    r"""Class-aware wrapper for `::pdf_array_put_array()`."""
    return _mupdf.pdf_array_put_array(array, i, initial)

def pdf_array_put_bool(array, i, x):
    r"""Class-aware wrapper for `::pdf_array_put_bool()`."""
    return _mupdf.pdf_array_put_bool(array, i, x)

def pdf_array_put_dict(array, i, initial):
    r"""Class-aware wrapper for `::pdf_array_put_dict()`."""
    return _mupdf.pdf_array_put_dict(array, i, initial)

def pdf_array_put_int(array, i, x):
    r"""Class-aware wrapper for `::pdf_array_put_int()`."""
    return _mupdf.pdf_array_put_int(array, i, x)

def pdf_array_put_name(array, i, x):
    r"""Class-aware wrapper for `::pdf_array_put_name()`."""
    return _mupdf.pdf_array_put_name(array, i, x)

def pdf_array_put_real(array, i, x):
    r"""Class-aware wrapper for `::pdf_array_put_real()`."""
    return _mupdf.pdf_array_put_real(array, i, x)

def pdf_array_put_string(array, i, x, n):
    r"""Class-aware wrapper for `::pdf_array_put_string()`."""
    return _mupdf.pdf_array_put_string(array, i, x, n)

def pdf_array_put_text_string(array, i, x):
    r"""Class-aware wrapper for `::pdf_array_put_text_string()`."""
    return _mupdf.pdf_array_put_text_string(array, i, x)

def pdf_authenticate_password(doc, pw):
    r"""Class-aware wrapper for `::pdf_authenticate_password()`."""
    return _mupdf.pdf_authenticate_password(doc, pw)

def pdf_bake_document(doc, bake_annots, bake_widgets):
    r"""Class-aware wrapper for `::pdf_bake_document()`."""
    return _mupdf.pdf_bake_document(doc, bake_annots, bake_widgets)

def pdf_begin_implicit_operation(doc):
    r"""Class-aware wrapper for `::pdf_begin_implicit_operation()`."""
    return _mupdf.pdf_begin_implicit_operation(doc)

def pdf_begin_operation(doc, operation):
    r"""Class-aware wrapper for `::pdf_begin_operation()`."""
    return _mupdf.pdf_begin_operation(doc, operation)

def pdf_bound_annot(annot):
    r"""Class-aware wrapper for `::pdf_bound_annot()`."""
    return _mupdf.pdf_bound_annot(annot)

def pdf_bound_page(page, box):
    r"""Class-aware wrapper for `::pdf_bound_page()`."""
    return _mupdf.pdf_bound_page(page, box)

def pdf_bound_widget(widget):
    r"""Class-aware wrapper for `::pdf_bound_widget()`."""
    return _mupdf.pdf_bound_widget(widget)

def pdf_button_field_on_state(field):
    r"""Class-aware wrapper for `::pdf_button_field_on_state()`."""
    return _mupdf.pdf_button_field_on_state(field)

def pdf_calculate_form(doc):
    r"""Class-aware wrapper for `::pdf_calculate_form()`."""
    return _mupdf.pdf_calculate_form(doc)

def pdf_can_be_saved_incrementally(doc):
    r"""Class-aware wrapper for `::pdf_can_be_saved_incrementally()`."""
    return _mupdf.pdf_can_be_saved_incrementally(doc)

def pdf_can_redo(doc):
    r"""Class-aware wrapper for `::pdf_can_redo()`."""
    return _mupdf.pdf_can_redo(doc)

def pdf_can_undo(doc):
    r"""Class-aware wrapper for `::pdf_can_undo()`."""
    return _mupdf.pdf_can_undo(doc)

def pdf_check_certificate(verifier, doc, signature):
    r"""Class-aware wrapper for `::pdf_check_certificate()`."""
    return _mupdf.pdf_check_certificate(verifier, doc, signature)

def pdf_check_digest(verifier, doc, signature):
    r"""Class-aware wrapper for `::pdf_check_digest()`."""
    return _mupdf.pdf_check_digest(verifier, doc, signature)

def pdf_check_widget_certificate(verifier, widget):
    r"""Class-aware wrapper for `::pdf_check_widget_certificate()`."""
    return _mupdf.pdf_check_widget_certificate(verifier, widget)

def pdf_check_widget_digest(verifier, widget):
    r"""Class-aware wrapper for `::pdf_check_widget_digest()`."""
    return _mupdf.pdf_check_widget_digest(verifier, widget)

def pdf_choice_field_option(field, exportval, i):
    r"""Class-aware wrapper for `::pdf_choice_field_option()`."""
    return _mupdf.pdf_choice_field_option(field, exportval, i)

def pdf_choice_field_option_count(field):
    r"""Class-aware wrapper for `::pdf_choice_field_option_count()`."""
    return _mupdf.pdf_choice_field_option_count(field)

def pdf_choice_widget_is_multiselect(tw):
    r"""Class-aware wrapper for `::pdf_choice_widget_is_multiselect()`."""
    return _mupdf.pdf_choice_widget_is_multiselect(tw)

def pdf_choice_widget_options(tw, exportval, opts):
    r"""Class-aware wrapper for `::pdf_choice_widget_options()`."""
    return _mupdf.pdf_choice_widget_options(tw, exportval, opts)

def pdf_choice_widget_options2(tw, exportval):
    r"""
    Class-aware wrapper for `::pdf_choice_widget_options2()`.   Swig-friendly wrapper for pdf_choice_widget_options(), returns the
    options directly in a vector.
    """
    return _mupdf.pdf_choice_widget_options2(tw, exportval)

def pdf_choice_widget_set_value(tw, n, opts):
    r"""Class-aware wrapper for `::pdf_choice_widget_set_value()`."""
    return _mupdf.pdf_choice_widget_set_value(tw, n, opts)

def pdf_choice_widget_value(tw, opts):
    r"""Class-aware wrapper for `::pdf_choice_widget_value()`."""
    return _mupdf.pdf_choice_widget_value(tw, opts)

def pdf_clean_file(infile, outfile, password, opts, retainlen):
    r"""Class-aware wrapper for `::pdf_clean_file()`."""
    return _mupdf.pdf_clean_file(infile, outfile, password, opts, retainlen)

def pdf_clean_font_name(fontname):
    r"""Class-aware wrapper for `::pdf_clean_font_name()`."""
    return _mupdf.pdf_clean_font_name(fontname)

def pdf_clean_obj(obj):
    r"""Class-aware wrapper for `::pdf_clean_obj()`."""
    return _mupdf.pdf_clean_obj(obj)

def pdf_clear_annot_border_dash(annot):
    r"""Class-aware wrapper for `::pdf_clear_annot_border_dash()`."""
    return _mupdf.pdf_clear_annot_border_dash(annot)

def pdf_clear_annot_ink_list(annot):
    r"""Class-aware wrapper for `::pdf_clear_annot_ink_list()`."""
    return _mupdf.pdf_clear_annot_ink_list(annot)

def pdf_clear_annot_quad_points(annot):
    r"""Class-aware wrapper for `::pdf_clear_annot_quad_points()`."""
    return _mupdf.pdf_clear_annot_quad_points(annot)

def pdf_clear_annot_vertices(annot):
    r"""Class-aware wrapper for `::pdf_clear_annot_vertices()`."""
    return _mupdf.pdf_clear_annot_vertices(annot)

def pdf_clear_signature(widget):
    r"""Class-aware wrapper for `::pdf_clear_signature()`."""
    return _mupdf.pdf_clear_signature(widget)

def pdf_clear_xref(doc):
    r"""Class-aware wrapper for `::pdf_clear_xref()`."""
    return _mupdf.pdf_clear_xref(doc)

def pdf_clear_xref_to_mark(doc):
    r"""Class-aware wrapper for `::pdf_clear_xref_to_mark()`."""
    return _mupdf.pdf_clear_xref_to_mark(doc)

def pdf_close_processor(proc):
    r"""Class-aware wrapper for `::pdf_close_processor()`."""
    return _mupdf.pdf_close_processor(proc)

def pdf_cmap_size(cmap):
    r"""Class-aware wrapper for `::pdf_cmap_size()`."""
    return _mupdf.pdf_cmap_size(cmap)

def pdf_cmap_wmode(cmap):
    r"""Class-aware wrapper for `::pdf_cmap_wmode()`."""
    return _mupdf.pdf_cmap_wmode(cmap)

def pdf_copy_array(array):
    r"""Class-aware wrapper for `::pdf_copy_array()`."""
    return _mupdf.pdf_copy_array(array)

def pdf_copy_dict(dict):
    r"""Class-aware wrapper for `::pdf_copy_dict()`."""
    return _mupdf.pdf_copy_dict(dict)

def pdf_count_document_associated_files(doc):
    r"""Class-aware wrapper for `::pdf_count_document_associated_files()`."""
    return _mupdf.pdf_count_document_associated_files(doc)

def pdf_count_layer_config_ui(doc):
    r"""Class-aware wrapper for `::pdf_count_layer_config_ui()`."""
    return _mupdf.pdf_count_layer_config_ui(doc)

def pdf_count_layer_configs(doc):
    r"""Class-aware wrapper for `::pdf_count_layer_configs()`."""
    return _mupdf.pdf_count_layer_configs(doc)

def pdf_count_layers(doc):
    r"""Class-aware wrapper for `::pdf_count_layers()`."""
    return _mupdf.pdf_count_layers(doc)

def pdf_count_objects(doc):
    r"""Class-aware wrapper for `::pdf_count_objects()`."""
    return _mupdf.pdf_count_objects(doc)

def pdf_count_page_associated_files(page):
    r"""Class-aware wrapper for `::pdf_count_page_associated_files()`."""
    return _mupdf.pdf_count_page_associated_files(page)

def pdf_count_pages(doc):
    r"""Class-aware wrapper for `::pdf_count_pages()`."""
    return _mupdf.pdf_count_pages(doc)

def pdf_count_pages_imp(doc, chapter):
    r"""Class-aware wrapper for `::pdf_count_pages_imp()`."""
    return _mupdf.pdf_count_pages_imp(doc, chapter)

def pdf_count_q_balance(doc, res, stm, prepend, append):
    r"""
    Class-aware wrapper for `::pdf_count_q_balance()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_count_q_balance(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
    """
    return _mupdf.pdf_count_q_balance(doc, res, stm, prepend, append)

def pdf_count_signatures(doc):
    r"""Class-aware wrapper for `::pdf_count_signatures()`."""
    return _mupdf.pdf_count_signatures(doc)

def pdf_count_unsaved_versions(doc):
    r"""Class-aware wrapper for `::pdf_count_unsaved_versions()`."""
    return _mupdf.pdf_count_unsaved_versions(doc)

def pdf_count_versions(doc):
    r"""Class-aware wrapper for `::pdf_count_versions()`."""
    return _mupdf.pdf_count_versions(doc)

def pdf_create_annot(page, type):
    r"""Class-aware wrapper for `::pdf_create_annot()`."""
    return _mupdf.pdf_create_annot(page, type)

def pdf_create_annot_raw(page, type):
    r"""Class-aware wrapper for `::pdf_create_annot_raw()`."""
    return _mupdf.pdf_create_annot_raw(page, type)

def pdf_create_document():
    r"""Class-aware wrapper for `::pdf_create_document()`."""
    return _mupdf.pdf_create_document()

def pdf_create_field_name(doc, prefix, buf, len):
    r"""Class-aware wrapper for `::pdf_create_field_name()`."""
    return _mupdf.pdf_create_field_name(doc, prefix, buf, len)

def pdf_create_link(page, bbox, uri):
    r"""Class-aware wrapper for `::pdf_create_link()`."""
    return _mupdf.pdf_create_link(page, bbox, uri)

def pdf_create_object(doc):
    r"""Class-aware wrapper for `::pdf_create_object()`."""
    return _mupdf.pdf_create_object(doc)

def pdf_create_signature_widget(page, name):
    r"""Class-aware wrapper for `::pdf_create_signature_widget()`."""
    return _mupdf.pdf_create_signature_widget(page, name)

def pdf_crypt_encrypt_metadata(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_encrypt_metadata()`."""
    return _mupdf.pdf_crypt_encrypt_metadata(crypt)

def pdf_crypt_key(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_key()`."""
    return _mupdf.pdf_crypt_key(crypt)

def pdf_crypt_length(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_length()`."""
    return _mupdf.pdf_crypt_length(crypt)

def pdf_crypt_method(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_method()`."""
    return _mupdf.pdf_crypt_method(crypt)

def pdf_crypt_obj(crypt, obj, num, gen):
    r"""Class-aware wrapper for `::pdf_crypt_obj()`."""
    return _mupdf.pdf_crypt_obj(crypt, obj, num, gen)

def pdf_crypt_owner_encryption(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_owner_encryption()`."""
    return _mupdf.pdf_crypt_owner_encryption(crypt)

def pdf_crypt_owner_password(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_owner_password()`."""
    return _mupdf.pdf_crypt_owner_password(crypt)

def pdf_crypt_permissions(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_permissions()`."""
    return _mupdf.pdf_crypt_permissions(crypt)

def pdf_crypt_permissions_encryption(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_permissions_encryption()`."""
    return _mupdf.pdf_crypt_permissions_encryption(crypt)

def pdf_crypt_revision(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_revision()`."""
    return _mupdf.pdf_crypt_revision(crypt)

def pdf_crypt_stream_method(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_stream_method()`."""
    return _mupdf.pdf_crypt_stream_method(crypt)

def pdf_crypt_string_method(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_string_method()`."""
    return _mupdf.pdf_crypt_string_method(crypt)

def pdf_crypt_user_encryption(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_user_encryption()`."""
    return _mupdf.pdf_crypt_user_encryption(crypt)

def pdf_crypt_user_password(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_user_password()`."""
    return _mupdf.pdf_crypt_user_password(crypt)

def pdf_crypt_version(crypt):
    r"""Class-aware wrapper for `::pdf_crypt_version()`."""
    return _mupdf.pdf_crypt_version(crypt)

def pdf_cycle(here, prev, obj):
    r"""Class-aware wrapper for `::pdf_cycle()`."""
    return _mupdf.pdf_cycle(here, prev, obj)

def pdf_debug_doc_changes(doc):
    r"""Class-aware wrapper for `::pdf_debug_doc_changes()`."""
    return _mupdf.pdf_debug_doc_changes(doc)

def pdf_debug_obj(obj):
    r"""Class-aware wrapper for `::pdf_debug_obj()`."""
    return _mupdf.pdf_debug_obj(obj)

def pdf_debug_ref(obj):
    r"""Class-aware wrapper for `::pdf_debug_ref()`."""
    return _mupdf.pdf_debug_ref(obj)

def pdf_decode_cmap(cmap, s, e, cpt):
    r"""
    Class-aware wrapper for `::pdf_decode_cmap()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_decode_cmap(::pdf_cmap *cmap, unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
    """
    return _mupdf.pdf_decode_cmap(cmap, s, e, cpt)

def pdf_deep_copy_obj(obj):
    r"""Class-aware wrapper for `::pdf_deep_copy_obj()`."""
    return _mupdf.pdf_deep_copy_obj(obj)

def pdf_delete_annot(page, annot):
    r"""Class-aware wrapper for `::pdf_delete_annot()`."""
    return _mupdf.pdf_delete_annot(page, annot)

def pdf_delete_link(page, link):
    r"""Class-aware wrapper for `::pdf_delete_link()`."""
    return _mupdf.pdf_delete_link(page, link)

def pdf_delete_object(doc, num):
    r"""Class-aware wrapper for `::pdf_delete_object()`."""
    return _mupdf.pdf_delete_object(doc, num)

def pdf_delete_page(doc, number):
    r"""Class-aware wrapper for `::pdf_delete_page()`."""
    return _mupdf.pdf_delete_page(doc, number)

def pdf_delete_page_labels(doc, index):
    r"""Class-aware wrapper for `::pdf_delete_page_labels()`."""
    return _mupdf.pdf_delete_page_labels(doc, index)

def pdf_delete_page_range(doc, start, end):
    r"""Class-aware wrapper for `::pdf_delete_page_range()`."""
    return _mupdf.pdf_delete_page_range(doc, start, end)

def pdf_deselect_layer_config_ui(doc, ui):
    r"""Class-aware wrapper for `::pdf_deselect_layer_config_ui()`."""
    return _mupdf.pdf_deselect_layer_config_ui(doc, ui)

def pdf_deserialise_journal(doc, stm):
    r"""Class-aware wrapper for `::pdf_deserialise_journal()`."""
    return _mupdf.pdf_deserialise_journal(doc, stm)

def pdf_dict_del(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_del()`."""
    return _mupdf.pdf_dict_del(dict, key)

def pdf_dict_dels(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_dels()`."""
    return _mupdf.pdf_dict_dels(dict, key)

def pdf_dict_get(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get()`."""
    return _mupdf.pdf_dict_get(dict, key)

def pdf_dict_get_bool(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_bool()`."""
    return _mupdf.pdf_dict_get_bool(dict, key)

def pdf_dict_get_bool_default(dict, key, _def):
    r"""Class-aware wrapper for `::pdf_dict_get_bool_default()`."""
    return _mupdf.pdf_dict_get_bool_default(dict, key, _def)

def pdf_dict_get_date(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_date()`."""
    return _mupdf.pdf_dict_get_date(dict, key)

def pdf_dict_get_inheritable(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable()`."""
    return _mupdf.pdf_dict_get_inheritable(dict, key)

def pdf_dict_get_inheritable_bool(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable_bool()`."""
    return _mupdf.pdf_dict_get_inheritable_bool(dict, key)

def pdf_dict_get_inheritable_date(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable_date()`."""
    return _mupdf.pdf_dict_get_inheritable_date(dict, key)

def pdf_dict_get_inheritable_int(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable_int()`."""
    return _mupdf.pdf_dict_get_inheritable_int(dict, key)

def pdf_dict_get_inheritable_int64(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable_int64()`."""
    return _mupdf.pdf_dict_get_inheritable_int64(dict, key)

def pdf_dict_get_inheritable_matrix(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable_matrix()`."""
    return _mupdf.pdf_dict_get_inheritable_matrix(dict, key)

def pdf_dict_get_inheritable_name(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable_name()`."""
    return _mupdf.pdf_dict_get_inheritable_name(dict, key)

def pdf_dict_get_inheritable_real(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable_real()`."""
    return _mupdf.pdf_dict_get_inheritable_real(dict, key)

def pdf_dict_get_inheritable_rect(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable_rect()`."""
    return _mupdf.pdf_dict_get_inheritable_rect(dict, key)

def pdf_dict_get_inheritable_string(dict, key, sizep):
    r"""
    Class-aware wrapper for `::pdf_dict_get_inheritable_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_dict_get_inheritable_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
    """
    return _mupdf.pdf_dict_get_inheritable_string(dict, key, sizep)

def pdf_dict_get_inheritable_text_string(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_inheritable_text_string()`."""
    return _mupdf.pdf_dict_get_inheritable_text_string(dict, key)

def pdf_dict_get_int(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_int()`."""
    return _mupdf.pdf_dict_get_int(dict, key)

def pdf_dict_get_int64(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_int64()`."""
    return _mupdf.pdf_dict_get_int64(dict, key)

def pdf_dict_get_int_default(dict, key, _def):
    r"""Class-aware wrapper for `::pdf_dict_get_int_default()`."""
    return _mupdf.pdf_dict_get_int_default(dict, key, _def)

def pdf_dict_get_key(dict, idx):
    r"""Class-aware wrapper for `::pdf_dict_get_key()`."""
    return _mupdf.pdf_dict_get_key(dict, idx)

def pdf_dict_get_matrix(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_matrix()`."""
    return _mupdf.pdf_dict_get_matrix(dict, key)

def pdf_dict_get_name(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_name()`."""
    return _mupdf.pdf_dict_get_name(dict, key)

def pdf_dict_get_point(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_point()`."""
    return _mupdf.pdf_dict_get_point(dict, key)

def pdf_dict_get_real(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_real()`."""
    return _mupdf.pdf_dict_get_real(dict, key)

def pdf_dict_get_real_default(dict, key, _def):
    r"""Class-aware wrapper for `::pdf_dict_get_real_default()`."""
    return _mupdf.pdf_dict_get_real_default(dict, key, _def)

def pdf_dict_get_rect(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_rect()`."""
    return _mupdf.pdf_dict_get_rect(dict, key)

def pdf_dict_get_string(dict, key, sizep):
    r"""
    Class-aware wrapper for `::pdf_dict_get_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_dict_get_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
    """
    return _mupdf.pdf_dict_get_string(dict, key, sizep)

def pdf_dict_get_text_string(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_text_string()`."""
    return _mupdf.pdf_dict_get_text_string(dict, key)

def pdf_dict_get_text_string_opt(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_get_text_string_opt()`."""
    return _mupdf.pdf_dict_get_text_string_opt(dict, key)

def pdf_dict_get_val(dict, idx):
    r"""Class-aware wrapper for `::pdf_dict_get_val()`."""
    return _mupdf.pdf_dict_get_val(dict, idx)

def pdf_dict_geta(dict, key, abbrev):
    r"""Class-aware wrapper for `::pdf_dict_geta()`."""
    return _mupdf.pdf_dict_geta(dict, key, abbrev)

def pdf_dict_getp(dict, path):
    r"""Class-aware wrapper for `::pdf_dict_getp()`."""
    return _mupdf.pdf_dict_getp(dict, path)

def pdf_dict_getp_inheritable(dict, path):
    r"""Class-aware wrapper for `::pdf_dict_getp_inheritable()`."""
    return _mupdf.pdf_dict_getp_inheritable(dict, path)

def pdf_dict_gets(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_gets()`."""
    return _mupdf.pdf_dict_gets(dict, key)

def pdf_dict_gets_inheritable(dict, key):
    r"""Class-aware wrapper for `::pdf_dict_gets_inheritable()`."""
    return _mupdf.pdf_dict_gets_inheritable(dict, key)

def pdf_dict_getsa(dict, key, abbrev):
    r"""Class-aware wrapper for `::pdf_dict_getsa()`."""
    return _mupdf.pdf_dict_getsa(dict, key, abbrev)

def pdf_dict_len(dict):
    r"""Class-aware wrapper for `::pdf_dict_len()`."""
    return _mupdf.pdf_dict_len(dict)

def pdf_dict_put(dict, key, val):
    r"""Class-aware wrapper for `::pdf_dict_put()`."""
    return _mupdf.pdf_dict_put(dict, key, val)

def pdf_dict_put_array(dict, key, initial):
    r"""Class-aware wrapper for `::pdf_dict_put_array()`."""
    return _mupdf.pdf_dict_put_array(dict, key, initial)

def pdf_dict_put_bool(dict, key, x):
    r"""Class-aware wrapper for `::pdf_dict_put_bool()`."""
    return _mupdf.pdf_dict_put_bool(dict, key, x)

def pdf_dict_put_date(dict, key, time):
    r"""Class-aware wrapper for `::pdf_dict_put_date()`."""
    return _mupdf.pdf_dict_put_date(dict, key, time)

def pdf_dict_put_dict(dict, key, initial):
    r"""Class-aware wrapper for `::pdf_dict_put_dict()`."""
    return _mupdf.pdf_dict_put_dict(dict, key, initial)

def pdf_dict_put_indirect(dict, key, num):
    r"""Class-aware wrapper for `::pdf_dict_put_indirect()`."""
    return _mupdf.pdf_dict_put_indirect(dict, key, num)

def pdf_dict_put_int(dict, key, x):
    r"""Class-aware wrapper for `::pdf_dict_put_int()`."""
    return _mupdf.pdf_dict_put_int(dict, key, x)

def pdf_dict_put_matrix(dict, key, x):
    r"""Class-aware wrapper for `::pdf_dict_put_matrix()`."""
    return _mupdf.pdf_dict_put_matrix(dict, key, x)

def pdf_dict_put_name(dict, key, x):
    r"""Class-aware wrapper for `::pdf_dict_put_name()`."""
    return _mupdf.pdf_dict_put_name(dict, key, x)

def pdf_dict_put_point(dict, key, x):
    r"""Class-aware wrapper for `::pdf_dict_put_point()`."""
    return _mupdf.pdf_dict_put_point(dict, key, x)

def pdf_dict_put_real(dict, key, x):
    r"""Class-aware wrapper for `::pdf_dict_put_real()`."""
    return _mupdf.pdf_dict_put_real(dict, key, x)

def pdf_dict_put_rect(dict, key, x):
    r"""Class-aware wrapper for `::pdf_dict_put_rect()`."""
    return _mupdf.pdf_dict_put_rect(dict, key, x)

def pdf_dict_put_string(dict, key, x, n):
    r"""Class-aware wrapper for `::pdf_dict_put_string()`."""
    return _mupdf.pdf_dict_put_string(dict, key, x, n)

def pdf_dict_put_text_string(dict, key, x):
    r"""Class-aware wrapper for `::pdf_dict_put_text_string()`."""
    return _mupdf.pdf_dict_put_text_string(dict, key, x)

def pdf_dict_put_val_null(obj, idx):
    r"""Class-aware wrapper for `::pdf_dict_put_val_null()`."""
    return _mupdf.pdf_dict_put_val_null(obj, idx)

def pdf_dict_putp(dict, path, val):
    r"""Class-aware wrapper for `::pdf_dict_putp()`."""
    return _mupdf.pdf_dict_putp(dict, path, val)

def pdf_dict_puts(dict, key, val):
    r"""Class-aware wrapper for `::pdf_dict_puts()`."""
    return _mupdf.pdf_dict_puts(dict, key, val)

def pdf_dict_puts_dict(dict, key, initial):
    r"""Class-aware wrapper for `::pdf_dict_puts_dict()`."""
    return _mupdf.pdf_dict_puts_dict(dict, key, initial)

def pdf_dirty_annot(annot):
    r"""Class-aware wrapper for `::pdf_dirty_annot()`."""
    return _mupdf.pdf_dirty_annot(annot)

def pdf_dirty_obj(obj):
    r"""Class-aware wrapper for `::pdf_dirty_obj()`."""
    return _mupdf.pdf_dirty_obj(obj)

def pdf_disable_js(doc):
    r"""Class-aware wrapper for `::pdf_disable_js()`."""
    return _mupdf.pdf_disable_js(doc)

def pdf_discard_journal(journal):
    r"""Class-aware wrapper for `::pdf_discard_journal()`."""
    return _mupdf.pdf_discard_journal(journal)

def pdf_doc_was_linearized(doc):
    r"""Class-aware wrapper for `::pdf_doc_was_linearized()`."""
    return _mupdf.pdf_doc_was_linearized(doc)

def pdf_document_associated_file(doc, idx):
    r"""Class-aware wrapper for `::pdf_document_associated_file()`."""
    return _mupdf.pdf_document_associated_file(doc, idx)

def pdf_document_event_did_print(doc):
    r"""Class-aware wrapper for `::pdf_document_event_did_print()`."""
    return _mupdf.pdf_document_event_did_print(doc)

def pdf_document_event_did_save(doc):
    r"""Class-aware wrapper for `::pdf_document_event_did_save()`."""
    return _mupdf.pdf_document_event_did_save(doc)

def pdf_document_event_will_close(doc):
    r"""Class-aware wrapper for `::pdf_document_event_will_close()`."""
    return _mupdf.pdf_document_event_will_close(doc)

def pdf_document_event_will_print(doc):
    r"""Class-aware wrapper for `::pdf_document_event_will_print()`."""
    return _mupdf.pdf_document_event_will_print(doc)

def pdf_document_event_will_save(doc):
    r"""Class-aware wrapper for `::pdf_document_event_will_save()`."""
    return _mupdf.pdf_document_event_will_save(doc)

def pdf_document_from_fz_document(ptr):
    r"""Class-aware wrapper for `::pdf_document_from_fz_document()`."""
    return _mupdf.pdf_document_from_fz_document(ptr)

def pdf_document_language(doc):
    r"""Class-aware wrapper for `::pdf_document_language()`."""
    return _mupdf.pdf_document_language(doc)

def pdf_document_output_intent(doc):
    r"""Class-aware wrapper for `::pdf_document_output_intent()`."""
    return _mupdf.pdf_document_output_intent(doc)

def pdf_document_permissions(doc):
    r"""Class-aware wrapper for `::pdf_document_permissions()`."""
    return _mupdf.pdf_document_permissions(doc)

def pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue):
    r"""
    Class-aware wrapper for `::pdf_edit_text_field_value()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_edit_text_field_value(::pdf_annot *widget, const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
    """
    return _mupdf.pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue)

def pdf_empty_store(doc):
    r"""Class-aware wrapper for `::pdf_empty_store()`."""
    return _mupdf.pdf_empty_store(doc)

def pdf_enable_journal(doc):
    r"""Class-aware wrapper for `::pdf_enable_journal()`."""
    return _mupdf.pdf_enable_journal(doc)

def pdf_enable_js(doc):
    r"""Class-aware wrapper for `::pdf_enable_js()`."""
    return _mupdf.pdf_enable_js(doc)

def pdf_enable_layer(doc, layer, enabled):
    r"""Class-aware wrapper for `::pdf_enable_layer()`."""
    return _mupdf.pdf_enable_layer(doc, layer, enabled)

def pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n):
    r"""Class-aware wrapper for `::pdf_encrypt_data()`."""
    return _mupdf.pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n)

def pdf_encrypted_len(crypt, num, gen, len):
    r"""Class-aware wrapper for `::pdf_encrypted_len()`."""
    return _mupdf.pdf_encrypted_len(crypt, num, gen, len)

def pdf_end_hmtx(font):
    r"""Class-aware wrapper for `::pdf_end_hmtx()`."""
    return _mupdf.pdf_end_hmtx(font)

def pdf_end_operation(doc):
    r"""Class-aware wrapper for `::pdf_end_operation()`."""
    return _mupdf.pdf_end_operation(doc)

def pdf_end_vmtx(font):
    r"""Class-aware wrapper for `::pdf_end_vmtx()`."""
    return _mupdf.pdf_end_vmtx(font)

def pdf_ensure_solid_xref(doc, num):
    r"""Class-aware wrapper for `::pdf_ensure_solid_xref()`."""
    return _mupdf.pdf_ensure_solid_xref(doc, num)

def pdf_eval_function(func, _in, inlen, out, outlen):
    r"""
    Class-aware wrapper for `::pdf_eval_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_eval_function(::pdf_function *func, const float *in, int inlen, int outlen)` => float out
    """
    return _mupdf.pdf_eval_function(func, _in, inlen, out, outlen)

def pdf_event_issue_alert(doc, evt):
    r"""Class-aware wrapper for `::pdf_event_issue_alert()`."""
    return _mupdf.pdf_event_issue_alert(doc, evt)

def pdf_event_issue_exec_menu_item(doc, item):
    r"""Class-aware wrapper for `::pdf_event_issue_exec_menu_item()`."""
    return _mupdf.pdf_event_issue_exec_menu_item(doc, item)

def pdf_event_issue_launch_url(doc, url, new_frame):
    r"""Class-aware wrapper for `::pdf_event_issue_launch_url()`."""
    return _mupdf.pdf_event_issue_launch_url(doc, url, new_frame)

def pdf_event_issue_mail_doc(doc, evt):
    r"""Class-aware wrapper for `::pdf_event_issue_mail_doc()`."""
    return _mupdf.pdf_event_issue_mail_doc(doc, evt)

def pdf_event_issue_print(doc):
    r"""Class-aware wrapper for `::pdf_event_issue_print()`."""
    return _mupdf.pdf_event_issue_print(doc)

def pdf_field_border_style(field):
    r"""Class-aware wrapper for `::pdf_field_border_style()`."""
    return _mupdf.pdf_field_border_style(field)

def pdf_field_display(field):
    r"""Class-aware wrapper for `::pdf_field_display()`."""
    return _mupdf.pdf_field_display(field)

def pdf_field_event_calculate(doc, field):
    r"""Class-aware wrapper for `::pdf_field_event_calculate()`."""
    return _mupdf.pdf_field_event_calculate(doc, field)

def pdf_field_event_format(doc, field):
    r"""Class-aware wrapper for `::pdf_field_event_format()`."""
    return _mupdf.pdf_field_event_format(doc, field)

def pdf_field_event_keystroke(doc, field, evt):
    r"""Class-aware wrapper for `::pdf_field_event_keystroke()`."""
    return _mupdf.pdf_field_event_keystroke(doc, field, evt)

def pdf_field_event_validate(doc, field, value, newvalue):
    r"""
    Class-aware wrapper for `::pdf_field_event_validate()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_field_event_validate(::pdf_document *doc, ::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
    """
    return _mupdf.pdf_field_event_validate(doc, field, value, newvalue)

def pdf_field_flags(field):
    r"""Class-aware wrapper for `::pdf_field_flags()`."""
    return _mupdf.pdf_field_flags(field)

def pdf_field_label(field):
    r"""Class-aware wrapper for `::pdf_field_label()`."""
    return _mupdf.pdf_field_label(field)

def pdf_field_reset(doc, field):
    r"""Class-aware wrapper for `::pdf_field_reset()`."""
    return _mupdf.pdf_field_reset(doc, field)

def pdf_field_set_border_style(field, text):
    r"""Class-aware wrapper for `::pdf_field_set_border_style()`."""
    return _mupdf.pdf_field_set_border_style(field, text)

def pdf_field_set_button_caption(field, text):
    r"""Class-aware wrapper for `::pdf_field_set_button_caption()`."""
    return _mupdf.pdf_field_set_button_caption(field, text)

def pdf_field_set_display(field, d):
    r"""Class-aware wrapper for `::pdf_field_set_display()`."""
    return _mupdf.pdf_field_set_display(field, d)

def pdf_field_set_fill_color(field, col):
    r"""Class-aware wrapper for `::pdf_field_set_fill_color()`."""
    return _mupdf.pdf_field_set_fill_color(field, col)

def pdf_field_set_text_color(field, col):
    r"""Class-aware wrapper for `::pdf_field_set_text_color()`."""
    return _mupdf.pdf_field_set_text_color(field, col)

def pdf_field_type(field):
    r"""Class-aware wrapper for `::pdf_field_type()`."""
    return _mupdf.pdf_field_type(field)

def pdf_field_type_string(field):
    r"""Class-aware wrapper for `::pdf_field_type_string()`."""
    return _mupdf.pdf_field_type_string(field)

def pdf_field_value(field):
    r"""Class-aware wrapper for `::pdf_field_value()`."""
    return _mupdf.pdf_field_value(field)

def pdf_filter_annot_contents(doc, annot, options):
    r"""Class-aware wrapper for `::pdf_filter_annot_contents()`."""
    return _mupdf.pdf_filter_annot_contents(doc, annot, options)

def pdf_filter_page_contents(doc, page, options):
    r"""Class-aware wrapper for `::pdf_filter_page_contents()`."""
    return _mupdf.pdf_filter_page_contents(doc, page, options)

def pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up):
    r"""Class-aware wrapper for `::pdf_filter_xobject_instance()`."""
    return _mupdf.pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up)

def pdf_find_font_resource(doc, type, encoding, item, key):
    r"""Class-aware wrapper for `::pdf_find_font_resource()`."""
    return _mupdf.pdf_find_font_resource(doc, type, encoding, item, key)

def pdf_find_item(drop, key):
    r"""Class-aware wrapper for `::pdf_find_item()`."""
    return _mupdf.pdf_find_item(drop, key)

def pdf_find_version_for_obj(doc, obj):
    r"""Class-aware wrapper for `::pdf_find_version_for_obj()`."""
    return _mupdf.pdf_find_version_for_obj(doc, obj)

def pdf_first_annot(page):
    r"""Class-aware wrapper for `::pdf_first_annot()`."""
    return _mupdf.pdf_first_annot(page)

def pdf_first_widget(page):
    r"""Class-aware wrapper for `::pdf_first_widget()`."""
    return _mupdf.pdf_first_widget(page)

def pdf_flatten_inheritable_page_items(page):
    r"""Class-aware wrapper for `::pdf_flatten_inheritable_page_items()`."""
    return _mupdf.pdf_flatten_inheritable_page_items(page)

def pdf_font_cid_to_gid(fontdesc, cid):
    r"""Class-aware wrapper for `::pdf_font_cid_to_gid()`."""
    return _mupdf.pdf_font_cid_to_gid(fontdesc, cid)

def pdf_font_writing_supported(font):
    r"""Class-aware wrapper for `::pdf_font_writing_supported()`."""
    return _mupdf.pdf_font_writing_supported(font)

def pdf_forget_xref(doc):
    r"""Class-aware wrapper for `::pdf_forget_xref()`."""
    return _mupdf.pdf_forget_xref(doc)

def pdf_format_date(time, s, n):
    r"""Class-aware wrapper for `::pdf_format_date()`."""
    return _mupdf.pdf_format_date(time, s, n)

def pdf_format_write_options(buffer, buffer_len, opts):
    r"""Class-aware wrapper for `::pdf_format_write_options()`."""
    return _mupdf.pdf_format_write_options(buffer, buffer_len, opts)

def pdf_function_size(func):
    r"""Class-aware wrapper for `::pdf_function_size()`."""
    return _mupdf.pdf_function_size(func)

def pdf_get_bound_document(obj):
    r"""Class-aware wrapper for `::pdf_get_bound_document()`."""
    return _mupdf.pdf_get_bound_document(obj)

def pdf_get_doc_event_callback_data(doc):
    r"""Class-aware wrapper for `::pdf_get_doc_event_callback_data()`."""
    return _mupdf.pdf_get_doc_event_callback_data(doc)

def pdf_get_embedded_file_params(fs, out):
    r"""Class-aware wrapper for `::pdf_get_embedded_file_params()`."""
    return _mupdf.pdf_get_embedded_file_params(fs, out)

def pdf_get_filespec_params(fs, out):
    r"""Class-aware wrapper for `::pdf_get_filespec_params()`."""
    return _mupdf.pdf_get_filespec_params(fs, out)

def pdf_get_indirect_document(obj):
    r"""Class-aware wrapper for `::pdf_get_indirect_document()`."""
    return _mupdf.pdf_get_indirect_document(obj)

def pdf_get_widget_editing_state(widget):
    r"""Class-aware wrapper for `::pdf_get_widget_editing_state()`."""
    return _mupdf.pdf_get_widget_editing_state(widget)

def pdf_graft_mapped_object(map, obj):
    r"""Class-aware wrapper for `::pdf_graft_mapped_object()`."""
    return _mupdf.pdf_graft_mapped_object(map, obj)

def pdf_graft_mapped_page(map, page_to, src, page_from):
    r"""Class-aware wrapper for `::pdf_graft_mapped_page()`."""
    return _mupdf.pdf_graft_mapped_page(map, page_to, src, page_from)

def pdf_graft_object(dst, obj):
    r"""Class-aware wrapper for `::pdf_graft_object()`."""
    return _mupdf.pdf_graft_object(dst, obj)

def pdf_graft_page(dst, page_to, src, page_from):
    r"""Class-aware wrapper for `::pdf_graft_page()`."""
    return _mupdf.pdf_graft_page(dst, page_to, src, page_from)

def pdf_has_permission(doc, p):
    r"""Class-aware wrapper for `::pdf_has_permission()`."""
    return _mupdf.pdf_has_permission(doc, p)

def pdf_has_unsaved_changes(doc):
    r"""Class-aware wrapper for `::pdf_has_unsaved_changes()`."""
    return _mupdf.pdf_has_unsaved_changes(doc)

def pdf_has_unsaved_sigs(doc):
    r"""Class-aware wrapper for `::pdf_has_unsaved_sigs()`."""
    return _mupdf.pdf_has_unsaved_sigs(doc)

def pdf_incremental_change_since_signing_widget(widget):
    r"""Class-aware wrapper for `::pdf_incremental_change_since_signing_widget()`."""
    return _mupdf.pdf_incremental_change_since_signing_widget(widget)

def pdf_insert_font_resource(doc, key, obj):
    r"""Class-aware wrapper for `::pdf_insert_font_resource()`."""
    return _mupdf.pdf_insert_font_resource(doc, key, obj)

def pdf_insert_page(doc, at, page):
    r"""Class-aware wrapper for `::pdf_insert_page()`."""
    return _mupdf.pdf_insert_page(doc, at, page)

def pdf_intent_from_name(obj):
    r"""Class-aware wrapper for `::pdf_intent_from_name()`."""
    return _mupdf.pdf_intent_from_name(obj)

def pdf_intent_from_string(str):
    r"""Class-aware wrapper for `::pdf_intent_from_string()`."""
    return _mupdf.pdf_intent_from_string(str)

def pdf_invalidate_xfa(doc):
    r"""Class-aware wrapper for `::pdf_invalidate_xfa()`."""
    return _mupdf.pdf_invalidate_xfa(doc)

def pdf_is_array(obj):
    r"""Class-aware wrapper for `::pdf_is_array()`."""
    return _mupdf.pdf_is_array(obj)

def pdf_is_bool(obj):
    r"""Class-aware wrapper for `::pdf_is_bool()`."""
    return _mupdf.pdf_is_bool(obj)

def pdf_is_dict(obj):
    r"""Class-aware wrapper for `::pdf_is_dict()`."""
    return _mupdf.pdf_is_dict(obj)

def pdf_is_embedded_file(fs):
    r"""Class-aware wrapper for `::pdf_is_embedded_file()`."""
    return _mupdf.pdf_is_embedded_file(fs)

def pdf_is_field_locked(locked, name):
    r"""Class-aware wrapper for `::pdf_is_field_locked()`."""
    return _mupdf.pdf_is_field_locked(locked, name)

def pdf_is_filespec(fs):
    r"""Class-aware wrapper for `::pdf_is_filespec()`."""
    return _mupdf.pdf_is_filespec(fs)

def pdf_is_indirect(obj):
    r"""Class-aware wrapper for `::pdf_is_indirect()`."""
    return _mupdf.pdf_is_indirect(obj)

def pdf_is_int(obj):
    r"""Class-aware wrapper for `::pdf_is_int()`."""
    return _mupdf.pdf_is_int(obj)

def pdf_is_jpx_image(dict):
    r"""Class-aware wrapper for `::pdf_is_jpx_image()`."""
    return _mupdf.pdf_is_jpx_image(dict)

def pdf_is_local_object(doc, obj):
    r"""Class-aware wrapper for `::pdf_is_local_object()`."""
    return _mupdf.pdf_is_local_object(doc, obj)

def pdf_is_name(obj):
    r"""Class-aware wrapper for `::pdf_is_name()`."""
    return _mupdf.pdf_is_name(obj)

def pdf_is_null(obj):
    r"""Class-aware wrapper for `::pdf_is_null()`."""
    return _mupdf.pdf_is_null(obj)

def pdf_is_number(obj):
    r"""Class-aware wrapper for `::pdf_is_number()`."""
    return _mupdf.pdf_is_number(obj)

def pdf_is_ocg_hidden(doc, rdb, usage, ocg):
    r"""Class-aware wrapper for `::pdf_is_ocg_hidden()`."""
    return _mupdf.pdf_is_ocg_hidden(doc, rdb, usage, ocg)

def pdf_is_real(obj):
    r"""Class-aware wrapper for `::pdf_is_real()`."""
    return _mupdf.pdf_is_real(obj)

def pdf_is_stream(obj):
    r"""Class-aware wrapper for `::pdf_is_stream()`."""
    return _mupdf.pdf_is_stream(obj)

def pdf_is_string(obj):
    r"""Class-aware wrapper for `::pdf_is_string()`."""
    return _mupdf.pdf_is_string(obj)

def pdf_is_tint_colorspace(cs):
    r"""Class-aware wrapper for `::pdf_is_tint_colorspace()`."""
    return _mupdf.pdf_is_tint_colorspace(cs)

def pdf_js_event_init(js, target, value, willCommit):
    r"""Class-aware wrapper for `::pdf_js_event_init()`."""
    return _mupdf.pdf_js_event_init(js, target, value, willCommit)

def pdf_js_event_init_keystroke(js, target, evt):
    r"""Class-aware wrapper for `::pdf_js_event_init_keystroke()`."""
    return _mupdf.pdf_js_event_init_keystroke(js, target, evt)

def pdf_js_event_result(js):
    r"""Class-aware wrapper for `::pdf_js_event_result()`."""
    return _mupdf.pdf_js_event_result(js)

def pdf_js_event_result_keystroke(js, evt):
    r"""Class-aware wrapper for `::pdf_js_event_result_keystroke()`."""
    return _mupdf.pdf_js_event_result_keystroke(js, evt)

def pdf_js_event_result_validate(js, newvalue):
    r"""
    Class-aware wrapper for `::pdf_js_event_result_validate()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_js_event_result_validate(::pdf_js *js)` => `(int, char *newvalue)`
    """
    return _mupdf.pdf_js_event_result_validate(js, newvalue)

def pdf_js_event_value(js):
    r"""Class-aware wrapper for `::pdf_js_event_value()`."""
    return _mupdf.pdf_js_event_value(js)

def pdf_js_execute(js, name, code, result):
    r"""
    Class-aware wrapper for `::pdf_js_execute()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_js_execute(::pdf_js *js, const char *name, const char *code)` => char *result
    """
    return _mupdf.pdf_js_execute(js, name, code, result)

def pdf_js_set_console(doc, console, user):
    r"""Class-aware wrapper for `::pdf_js_set_console()`."""
    return _mupdf.pdf_js_set_console(doc, console, user)

def pdf_js_supported(doc):
    r"""Class-aware wrapper for `::pdf_js_supported()`."""
    return _mupdf.pdf_js_supported(doc)

def pdf_layer_config_info(doc, config_num, info):
    r"""Class-aware wrapper for `::pdf_layer_config_info()`."""
    return _mupdf.pdf_layer_config_info(doc, config_num, info)

def pdf_layer_config_ui_info(doc, ui, info):
    r"""Class-aware wrapper for `::pdf_layer_config_ui_info()`."""
    return _mupdf.pdf_layer_config_ui_info(doc, ui, info)

def pdf_layer_is_enabled(doc, layer):
    r"""Class-aware wrapper for `::pdf_layer_is_enabled()`."""
    return _mupdf.pdf_layer_is_enabled(doc, layer)

def pdf_layer_name(doc, layer):
    r"""Class-aware wrapper for `::pdf_layer_name()`."""
    return _mupdf.pdf_layer_name(doc, layer)

def pdf_layout_fit_text(font, lang, str, bounds):
    r"""Class-aware wrapper for `::pdf_layout_fit_text()`."""
    return _mupdf.pdf_layout_fit_text(font, lang, str, bounds)

def pdf_lex(f, lexbuf):
    r"""Class-aware wrapper for `::pdf_lex()`."""
    return _mupdf.pdf_lex(f, lexbuf)

def pdf_lex_no_string(f, lexbuf):
    r"""Class-aware wrapper for `::pdf_lex_no_string()`."""
    return _mupdf.pdf_lex_no_string(f, lexbuf)

def pdf_lexbuf_fin(lexbuf):
    r"""Class-aware wrapper for `::pdf_lexbuf_fin()`."""
    return _mupdf.pdf_lexbuf_fin(lexbuf)

def pdf_lexbuf_grow(lexbuf):
    r"""Class-aware wrapper for `::pdf_lexbuf_grow()`."""
    return _mupdf.pdf_lexbuf_grow(lexbuf)

def pdf_lexbuf_init(lexbuf, size):
    r"""Class-aware wrapper for `::pdf_lexbuf_init()`."""
    return _mupdf.pdf_lexbuf_init(lexbuf, size)

def pdf_line_ending_from_name(end):
    r"""Class-aware wrapper for `::pdf_line_ending_from_name()`."""
    return _mupdf.pdf_line_ending_from_name(end)

def pdf_line_ending_from_string(end):
    r"""Class-aware wrapper for `::pdf_line_ending_from_string()`."""
    return _mupdf.pdf_line_ending_from_string(end)

def pdf_load_builtin_cmap(name):
    r"""Class-aware wrapper for `::pdf_load_builtin_cmap()`."""
    return _mupdf.pdf_load_builtin_cmap(name)

def pdf_load_cmap(file):
    r"""Class-aware wrapper for `::pdf_load_cmap()`."""
    return _mupdf.pdf_load_cmap(file)

def pdf_load_colorspace(obj):
    r"""Class-aware wrapper for `::pdf_load_colorspace()`."""
    return _mupdf.pdf_load_colorspace(obj)

def pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image):
    r"""Class-aware wrapper for `::pdf_load_compressed_inline_image()`."""
    return _mupdf.pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image)

def pdf_load_compressed_stream(doc, num, worst_case):
    r"""Class-aware wrapper for `::pdf_load_compressed_stream()`."""
    return _mupdf.pdf_load_compressed_stream(doc, num, worst_case)

def pdf_load_default_colorspaces(doc, page):
    r"""Class-aware wrapper for `::pdf_load_default_colorspaces()`."""
    return _mupdf.pdf_load_default_colorspaces(doc, page)

def pdf_load_embedded_cmap(doc, ref):
    r"""Class-aware wrapper for `::pdf_load_embedded_cmap()`."""
    return _mupdf.pdf_load_embedded_cmap(doc, ref)

def pdf_load_embedded_file_contents(fs):
    r"""Class-aware wrapper for `::pdf_load_embedded_file_contents()`."""
    return _mupdf.pdf_load_embedded_file_contents(fs)

def pdf_load_encoding(estrings, encoding):
    r"""
    Class-aware wrapper for `::pdf_load_encoding()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_load_encoding(const char *encoding)` => const char *estrings
    """
    return _mupdf.pdf_load_encoding(estrings, encoding)

def pdf_load_field_name(field):
    r"""Class-aware wrapper for `::pdf_load_field_name()`."""
    return _mupdf.pdf_load_field_name(field)

def pdf_load_field_name2(field):
    r"""Alternative to `pdf_load_field_name()` that returns a std::string."""
    return _mupdf.pdf_load_field_name2(field)

def pdf_load_function(ref, _in, out):
    r"""Class-aware wrapper for `::pdf_load_function()`."""
    return _mupdf.pdf_load_function(ref, _in, out)

def pdf_load_image(doc, obj):
    r"""Class-aware wrapper for `::pdf_load_image()`."""
    return _mupdf.pdf_load_image(doc, obj)

def pdf_load_inline_image(doc, rdb, dict, file):
    r"""Class-aware wrapper for `::pdf_load_inline_image()`."""
    return _mupdf.pdf_load_inline_image(doc, rdb, dict, file)

def pdf_load_journal(doc, filename):
    r"""Class-aware wrapper for `::pdf_load_journal()`."""
    return _mupdf.pdf_load_journal(doc, filename)

def pdf_load_link_annots(arg_0, arg_1, annots, pagenum, page_ctm):
    r"""Class-aware wrapper for `::pdf_load_link_annots()`."""
    return _mupdf.pdf_load_link_annots(arg_0, arg_1, annots, pagenum, page_ctm)

def pdf_load_links(page):
    r"""Class-aware wrapper for `::pdf_load_links()`."""
    return _mupdf.pdf_load_links(page)

def pdf_load_name_tree(doc, which):
    r"""Class-aware wrapper for `::pdf_load_name_tree()`."""
    return _mupdf.pdf_load_name_tree(doc, which)

def pdf_load_object(doc, num):
    r"""
    Class-aware wrapper for `::pdf_load_object()`.
    	Load a given object.

    	This can cause xref reorganisations (solidifications etc) due to
    	repairs, so all held pdf_xref_entries should be considered
    	invalid after this call (other than the returned one).
    """
    return _mupdf.pdf_load_object(doc, num)

def pdf_load_outline(doc):
    r"""Class-aware wrapper for `::pdf_load_outline()`."""
    return _mupdf.pdf_load_outline(doc)

def pdf_load_page(doc, number):
    r"""Class-aware wrapper for `::pdf_load_page()`."""
    return _mupdf.pdf_load_page(doc, number)

def pdf_load_page_imp(doc, chapter, number):
    r"""Class-aware wrapper for `::pdf_load_page_imp()`."""
    return _mupdf.pdf_load_page_imp(doc, chapter, number)

def pdf_load_page_tree(doc):
    r"""Class-aware wrapper for `::pdf_load_page_tree()`."""
    return _mupdf.pdf_load_page_tree(doc)

def pdf_load_pattern(doc, obj):
    r"""Class-aware wrapper for `::pdf_load_pattern()`."""
    return _mupdf.pdf_load_pattern(doc, obj)

def pdf_load_raw_stream(ref):
    r"""Class-aware wrapper for `::pdf_load_raw_stream()`."""
    return _mupdf.pdf_load_raw_stream(ref)

def pdf_load_raw_stream_number(doc, num):
    r"""Class-aware wrapper for `::pdf_load_raw_stream_number()`."""
    return _mupdf.pdf_load_raw_stream_number(doc, num)

def pdf_load_shading(doc, obj):
    r"""Class-aware wrapper for `::pdf_load_shading()`."""
    return _mupdf.pdf_load_shading(doc, obj)

def pdf_load_stream(ref):
    r"""Class-aware wrapper for `::pdf_load_stream()`."""
    return _mupdf.pdf_load_stream(ref)

def pdf_load_stream_number(doc, num):
    r"""Class-aware wrapper for `::pdf_load_stream_number()`."""
    return _mupdf.pdf_load_stream_number(doc, num)

def pdf_load_stream_or_string_as_utf8(src):
    r"""Class-aware wrapper for `::pdf_load_stream_or_string_as_utf8()`."""
    return _mupdf.pdf_load_stream_or_string_as_utf8(src)

def pdf_load_system_cmap(name):
    r"""Class-aware wrapper for `::pdf_load_system_cmap()`."""
    return _mupdf.pdf_load_system_cmap(name)

def pdf_load_to_unicode(doc, font, strings, collection, cmapstm):
    r"""
    Class-aware wrapper for `::pdf_load_to_unicode()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_load_to_unicode(::pdf_document *doc, ::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
    """
    return _mupdf.pdf_load_to_unicode(doc, font, strings, collection, cmapstm)

def pdf_load_type3_glyphs(doc, fontdesc):
    r"""Class-aware wrapper for `::pdf_load_type3_glyphs()`."""
    return _mupdf.pdf_load_type3_glyphs(doc, fontdesc)

def pdf_load_unencrypted_object(doc, num):
    r"""Class-aware wrapper for `::pdf_load_unencrypted_object()`."""
    return _mupdf.pdf_load_unencrypted_object(doc, num)

def pdf_lookup_cmap(cmap, cpt):
    r"""Class-aware wrapper for `::pdf_lookup_cmap()`."""
    return _mupdf.pdf_lookup_cmap(cmap, cpt)

def pdf_lookup_cmap_full(cmap, cpt, out):
    r"""
    Class-aware wrapper for `::pdf_lookup_cmap_full()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_lookup_cmap_full(::pdf_cmap *cmap, unsigned int cpt)` => `(int, int out)`
    """
    return _mupdf.pdf_lookup_cmap_full(cmap, cpt, out)

def pdf_lookup_dest(doc, needle):
    r"""Class-aware wrapper for `::pdf_lookup_dest()`."""
    return _mupdf.pdf_lookup_dest(doc, needle)

def pdf_lookup_field(form, name):
    r"""Class-aware wrapper for `::pdf_lookup_field()`."""
    return _mupdf.pdf_lookup_field(form, name)

def pdf_lookup_metadata(doc, key, ptr, size):
    r"""Class-aware wrapper for `::pdf_lookup_metadata()`."""
    return _mupdf.pdf_lookup_metadata(doc, key, ptr, size)

def pdf_lookup_metadata2(doc, key):
    r"""
    Class-aware wrapper for `::pdf_lookup_metadata2()`.
    C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
    or calls `fz_throw()` if not found.
    """
    return _mupdf.pdf_lookup_metadata2(doc, key)

def pdf_lookup_name(doc, which, needle):
    r"""Class-aware wrapper for `::pdf_lookup_name()`."""
    return _mupdf.pdf_lookup_name(doc, which, needle)

def pdf_lookup_number(root, needle):
    r"""Class-aware wrapper for `::pdf_lookup_number()`."""
    return _mupdf.pdf_lookup_number(root, needle)

def pdf_lookup_page_loc(doc, needle, parentp, indexp):
    r"""
    Class-aware wrapper for `::pdf_lookup_page_loc()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_lookup_page_loc(::pdf_document *doc, int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
    """
    return _mupdf.pdf_lookup_page_loc(doc, needle, parentp, indexp)

def pdf_lookup_page_number(doc, pageobj):
    r"""Class-aware wrapper for `::pdf_lookup_page_number()`."""
    return _mupdf.pdf_lookup_page_number(doc, pageobj)

def pdf_lookup_page_obj(doc, needle):
    r"""Class-aware wrapper for `::pdf_lookup_page_obj()`."""
    return _mupdf.pdf_lookup_page_obj(doc, needle)

def pdf_lookup_substitute_font(mono, serif, bold, italic, len):
    r"""
    Class-aware wrapper for `::pdf_lookup_substitute_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_lookup_substitute_font(int mono, int serif, int bold, int italic)` => `(const unsigned char *, int len)`
    """
    return _mupdf.pdf_lookup_substitute_font(mono, serif, bold, italic, len)

def pdf_map_one_to_many(cmap, one, many, len):
    r"""
    Class-aware wrapper for `::pdf_map_one_to_many()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_map_one_to_many(::pdf_cmap *cmap, unsigned int one, size_t len)` => int many
    """
    return _mupdf.pdf_map_one_to_many(cmap, one, many, len)

def pdf_map_range_to_range(cmap, srclo, srchi, dstlo):
    r"""Class-aware wrapper for `::pdf_map_range_to_range()`."""
    return _mupdf.pdf_map_range_to_range(cmap, srclo, srchi, dstlo)

def pdf_mark_bits_reset(marks):
    r"""Class-aware wrapper for `::pdf_mark_bits_reset()`."""
    return _mupdf.pdf_mark_bits_reset(marks)

def pdf_mark_bits_set(marks, obj):
    r"""Class-aware wrapper for `::pdf_mark_bits_set()`."""
    return _mupdf.pdf_mark_bits_set(marks, obj)

def pdf_mark_list_check(list, obj):
    r"""Class-aware wrapper for `::pdf_mark_list_check()`."""
    return _mupdf.pdf_mark_list_check(list, obj)

def pdf_mark_list_free(list):
    r"""Class-aware wrapper for `::pdf_mark_list_free()`."""
    return _mupdf.pdf_mark_list_free(list)

def pdf_mark_list_init(list):
    r"""Class-aware wrapper for `::pdf_mark_list_init()`."""
    return _mupdf.pdf_mark_list_init(list)

def pdf_mark_list_pop(list):
    r"""Class-aware wrapper for `::pdf_mark_list_pop()`."""
    return _mupdf.pdf_mark_list_pop(list)

def pdf_mark_list_push(list, obj):
    r"""Class-aware wrapper for `::pdf_mark_list_push()`."""
    return _mupdf.pdf_mark_list_push(list, obj)

def pdf_mark_obj(obj):
    r"""Class-aware wrapper for `::pdf_mark_obj()`."""
    return _mupdf.pdf_mark_obj(obj)

def pdf_mark_xref(doc):
    r"""Class-aware wrapper for `::pdf_mark_xref()`."""
    return _mupdf.pdf_mark_xref(doc)

def pdf_metadata(doc):
    r"""Class-aware wrapper for `::pdf_metadata()`."""
    return _mupdf.pdf_metadata(doc)

def pdf_minimize_document(doc):
    r"""Class-aware wrapper for `::pdf_minimize_document()`."""
    return _mupdf.pdf_minimize_document(doc)

def pdf_name_eq(a, b):
    r"""Class-aware wrapper for `::pdf_name_eq()`."""
    return _mupdf.pdf_name_eq(a, b)

def pdf_name_from_intent(intent):
    r"""Class-aware wrapper for `::pdf_name_from_intent()`."""
    return _mupdf.pdf_name_from_intent(intent)

def pdf_name_from_line_ending(end):
    r"""Class-aware wrapper for `::pdf_name_from_line_ending()`."""
    return _mupdf.pdf_name_from_line_ending(end)

def pdf_needs_password(doc):
    r"""Class-aware wrapper for `::pdf_needs_password()`."""
    return _mupdf.pdf_needs_password(doc)

def pdf_new_action_from_link(doc, uri):
    r"""Class-aware wrapper for `::pdf_new_action_from_link()`."""
    return _mupdf.pdf_new_action_from_link(doc, uri)

def pdf_new_array(doc, initialcap):
    r"""Class-aware wrapper for `::pdf_new_array()`."""
    return _mupdf.pdf_new_array(doc, initialcap)

def pdf_new_buffer_processor(buffer, ahxencode, newlines):
    r"""Class-aware wrapper for `::pdf_new_buffer_processor()`."""
    return _mupdf.pdf_new_buffer_processor(buffer, ahxencode, newlines)

def pdf_new_cmap():
    r"""Class-aware wrapper for `::pdf_new_cmap()`."""
    return _mupdf.pdf_new_cmap()

def pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts):
    r"""Class-aware wrapper for `::pdf_new_color_filter()`."""
    return _mupdf.pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts)

def pdf_new_date(doc, time):
    r"""Class-aware wrapper for `::pdf_new_date()`."""
    return _mupdf.pdf_new_date(doc, time)

def pdf_new_dest_from_link(doc, uri, is_remote):
    r"""Class-aware wrapper for `::pdf_new_dest_from_link()`."""
    return _mupdf.pdf_new_dest_from_link(doc, uri, is_remote)

def pdf_new_dict(doc, initialcap):
    r"""Class-aware wrapper for `::pdf_new_dict()`."""
    return _mupdf.pdf_new_dict(doc, initialcap)

def pdf_new_display_list_from_annot(annot):
    r"""Class-aware wrapper for `::pdf_new_display_list_from_annot()`."""
    return _mupdf.pdf_new_display_list_from_annot(annot)

def pdf_new_graft_map(dst):
    r"""Class-aware wrapper for `::pdf_new_graft_map()`."""
    return _mupdf.pdf_new_graft_map(dst)

def pdf_new_identity_cmap(wmode, bytes):
    r"""Class-aware wrapper for `::pdf_new_identity_cmap()`."""
    return _mupdf.pdf_new_identity_cmap(wmode, bytes)

def pdf_new_indirect(doc, num, gen):
    r"""Class-aware wrapper for `::pdf_new_indirect()`."""
    return _mupdf.pdf_new_indirect(doc, num, gen)

def pdf_new_int(i):
    r"""Class-aware wrapper for `::pdf_new_int()`."""
    return _mupdf.pdf_new_int(i)

def pdf_new_link(page, rect, uri, obj):
    r"""Class-aware wrapper for `::pdf_new_link()`."""
    return _mupdf.pdf_new_link(page, rect, uri, obj)

def pdf_new_matrix(doc, mtx):
    r"""Class-aware wrapper for `::pdf_new_matrix()`."""
    return _mupdf.pdf_new_matrix(doc, mtx)

def pdf_new_name(str):
    r"""Class-aware wrapper for `::pdf_new_name()`."""
    return _mupdf.pdf_new_name(str)

def pdf_new_output_processor(out, ahxencode, newlines):
    r"""Class-aware wrapper for `::pdf_new_output_processor()`."""
    return _mupdf.pdf_new_output_processor(out, ahxencode, newlines)

def pdf_new_pdf_device(doc, topctm, resources, contents):
    r"""Class-aware wrapper for `::pdf_new_pdf_device()`."""
    return _mupdf.pdf_new_pdf_device(doc, topctm, resources, contents)

def pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha):
    r"""Class-aware wrapper for `::pdf_new_pixmap_from_annot()`."""
    return _mupdf.pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha)

def pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
    r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`."""
    return _mupdf.pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

def pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box):
    r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`."""
    return _mupdf.pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box)

def pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
    r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
    return _mupdf.pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

def pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box):
    r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
    return _mupdf.pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box)

def pdf_new_point(doc, point):
    r"""Class-aware wrapper for `::pdf_new_point()`."""
    return _mupdf.pdf_new_point(doc, point)

def pdf_new_processor(size):
    r"""Class-aware wrapper for `::pdf_new_processor()`."""
    return _mupdf.pdf_new_processor(size)

def pdf_new_real(f):
    r"""Class-aware wrapper for `::pdf_new_real()`."""
    return _mupdf.pdf_new_real(f)

def pdf_new_rect(doc, rect):
    r"""Class-aware wrapper for `::pdf_new_rect()`."""
    return _mupdf.pdf_new_rect(doc, rect)

def pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie):
    r"""Class-aware wrapper for `::pdf_new_run_processor()`."""
    return _mupdf.pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie)

def pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts):
    r"""Class-aware wrapper for `::pdf_new_sanitize_filter()`."""
    return _mupdf.pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts)

def pdf_new_string(str, len):
    r"""Class-aware wrapper for `::pdf_new_string()`."""
    return _mupdf.pdf_new_string(str, len)

def pdf_new_text_string(s):
    r"""Class-aware wrapper for `::pdf_new_text_string()`."""
    return _mupdf.pdf_new_text_string(s)

def pdf_new_uri_from_explicit_dest(dest):
    r"""Class-aware wrapper for `::pdf_new_uri_from_explicit_dest()`."""
    return _mupdf.pdf_new_uri_from_explicit_dest(dest)

def pdf_new_uri_from_path_and_explicit_dest(path, dest):
    r"""Class-aware wrapper for `::pdf_new_uri_from_path_and_explicit_dest()`."""
    return _mupdf.pdf_new_uri_from_path_and_explicit_dest(path, dest)

def pdf_new_uri_from_path_and_named_dest(path, name):
    r"""Class-aware wrapper for `::pdf_new_uri_from_path_and_named_dest()`."""
    return _mupdf.pdf_new_uri_from_path_and_named_dest(path, name)

def pdf_new_utf8_from_pdf_stream_obj(src):
    r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`."""
    return _mupdf.pdf_new_utf8_from_pdf_stream_obj(src)

def pdf_new_utf8_from_pdf_string(srcptr, srclen):
    r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_string()`."""
    return _mupdf.pdf_new_utf8_from_pdf_string(srcptr, srclen)

def pdf_new_utf8_from_pdf_string_obj(src):
    r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_string_obj()`."""
    return _mupdf.pdf_new_utf8_from_pdf_string_obj(src)

def pdf_new_xobject(doc, bbox, matrix, res, buffer):
    r"""Class-aware wrapper for `::pdf_new_xobject()`."""
    return _mupdf.pdf_new_xobject(doc, bbox, matrix, res, buffer)

def pdf_next_annot(annot):
    r"""Class-aware wrapper for `::pdf_next_annot()`."""
    return _mupdf.pdf_next_annot(annot)

def pdf_next_widget(previous):
    r"""Class-aware wrapper for `::pdf_next_widget()`."""
    return _mupdf.pdf_next_widget(previous)

def pdf_nuke_annots(page):
    r"""Class-aware wrapper for `::pdf_nuke_annots()`."""
    return _mupdf.pdf_nuke_annots(page)

def pdf_nuke_links(page):
    r"""Class-aware wrapper for `::pdf_nuke_links()`."""
    return _mupdf.pdf_nuke_links(page)

def pdf_nuke_page(page):
    r"""Class-aware wrapper for `::pdf_nuke_page()`."""
    return _mupdf.pdf_nuke_page(page)

def pdf_obj_is_dirty(obj):
    r"""Class-aware wrapper for `::pdf_obj_is_dirty()`."""
    return _mupdf.pdf_obj_is_dirty(obj)

def pdf_obj_is_incremental(obj):
    r"""Class-aware wrapper for `::pdf_obj_is_incremental()`."""
    return _mupdf.pdf_obj_is_incremental(obj)

def pdf_obj_marked(obj):
    r"""Class-aware wrapper for `::pdf_obj_marked()`."""
    return _mupdf.pdf_obj_marked(obj)

def pdf_obj_memo(obj, bit, memo):
    r"""
    Class-aware wrapper for `::pdf_obj_memo()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_obj_memo(::pdf_obj *obj, int bit)` => `(int, int memo)`
    """
    return _mupdf.pdf_obj_memo(obj, bit, memo)

def pdf_obj_num_is_stream(doc, num):
    r"""Class-aware wrapper for `::pdf_obj_num_is_stream()`."""
    return _mupdf.pdf_obj_num_is_stream(doc, num)

def pdf_obj_parent_num(obj):
    r"""Class-aware wrapper for `::pdf_obj_parent_num()`."""
    return _mupdf.pdf_obj_parent_num(obj)

def pdf_obj_refs(ref):
    r"""Class-aware wrapper for `::pdf_obj_refs()`."""
    return _mupdf.pdf_obj_refs(ref)

def pdf_objcmp(a, b):
    r"""Class-aware wrapper for `::pdf_objcmp()`."""
    return _mupdf.pdf_objcmp(a, b)

def pdf_objcmp_deep(a, b):
    r"""Class-aware wrapper for `::pdf_objcmp_deep()`."""
    return _mupdf.pdf_objcmp_deep(a, b)

def pdf_objcmp_resolve(a, b):
    r"""Class-aware wrapper for `::pdf_objcmp_resolve()`."""
    return _mupdf.pdf_objcmp_resolve(a, b)

def pdf_open_contents_stream(doc, obj):
    r"""Class-aware wrapper for `::pdf_open_contents_stream()`."""
    return _mupdf.pdf_open_contents_stream(doc, obj)

def pdf_open_crypt(chain, crypt, num, gen):
    r"""Class-aware wrapper for `::pdf_open_crypt()`."""
    return _mupdf.pdf_open_crypt(chain, crypt, num, gen)

def pdf_open_crypt_with_filter(chain, crypt, name, num, gen):
    r"""Class-aware wrapper for `::pdf_open_crypt_with_filter()`."""
    return _mupdf.pdf_open_crypt_with_filter(chain, crypt, name, num, gen)

def pdf_open_document(filename):
    r"""Class-aware wrapper for `::pdf_open_document()`."""
    return _mupdf.pdf_open_document(filename)

def pdf_open_document_with_stream(file):
    r"""Class-aware wrapper for `::pdf_open_document_with_stream()`."""
    return _mupdf.pdf_open_document_with_stream(file)

def pdf_open_inline_stream(doc, stmobj, length, chain, params):
    r"""Class-aware wrapper for `::pdf_open_inline_stream()`."""
    return _mupdf.pdf_open_inline_stream(doc, stmobj, length, chain, params)

def pdf_open_raw_stream(ref):
    r"""Class-aware wrapper for `::pdf_open_raw_stream()`."""
    return _mupdf.pdf_open_raw_stream(ref)

def pdf_open_raw_stream_number(doc, num):
    r"""Class-aware wrapper for `::pdf_open_raw_stream_number()`."""
    return _mupdf.pdf_open_raw_stream_number(doc, num)

def pdf_open_stream(ref):
    r"""Class-aware wrapper for `::pdf_open_stream()`."""
    return _mupdf.pdf_open_stream(ref)

def pdf_open_stream_number(doc, num):
    r"""Class-aware wrapper for `::pdf_open_stream_number()`."""
    return _mupdf.pdf_open_stream_number(doc, num)

def pdf_open_stream_with_offset(doc, num, dict, stm_ofs):
    r"""Class-aware wrapper for `::pdf_open_stream_with_offset()`."""
    return _mupdf.pdf_open_stream_with_offset(doc, num, dict, stm_ofs)

def pdf_page_associated_file(page, idx):
    r"""Class-aware wrapper for `::pdf_page_associated_file()`."""
    return _mupdf.pdf_page_associated_file(page, idx)

def pdf_page_contents(page):
    r"""Class-aware wrapper for `::pdf_page_contents()`."""
    return _mupdf.pdf_page_contents(page)

def pdf_page_event_close(page):
    r"""Class-aware wrapper for `::pdf_page_event_close()`."""
    return _mupdf.pdf_page_event_close(page)

def pdf_page_event_open(page):
    r"""Class-aware wrapper for `::pdf_page_event_open()`."""
    return _mupdf.pdf_page_event_open(page)

def pdf_page_from_fz_page(ptr):
    r"""Class-aware wrapper for `::pdf_page_from_fz_page()`."""
    return _mupdf.pdf_page_from_fz_page(ptr)

def pdf_page_group(page):
    r"""Class-aware wrapper for `::pdf_page_group()`."""
    return _mupdf.pdf_page_group(page)

def pdf_page_has_transparency(page):
    r"""Class-aware wrapper for `::pdf_page_has_transparency()`."""
    return _mupdf.pdf_page_has_transparency(page)

def pdf_page_label(doc, page, buf, size):
    r"""Class-aware wrapper for `::pdf_page_label()`."""
    return _mupdf.pdf_page_label(doc, page, buf, size)

def pdf_page_label_imp(doc, chapter, page, buf, size):
    r"""Class-aware wrapper for `::pdf_page_label_imp()`."""
    return _mupdf.pdf_page_label_imp(doc, chapter, page, buf, size)

def pdf_page_obj_transform(pageobj, outbox, outctm):
    r"""Class-aware wrapper for `::pdf_page_obj_transform()`."""
    return _mupdf.pdf_page_obj_transform(pageobj, outbox, outctm)

def pdf_page_obj_transform_box(pageobj, outbox, out, box):
    r"""Class-aware wrapper for `::pdf_page_obj_transform_box()`."""
    return _mupdf.pdf_page_obj_transform_box(pageobj, outbox, out, box)

def pdf_page_presentation(page, transition, duration):
    r"""
    Class-aware wrapper for `::pdf_page_presentation()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_page_presentation(::pdf_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
    """
    return _mupdf.pdf_page_presentation(page, transition, duration)

def pdf_page_resources(page):
    r"""Class-aware wrapper for `::pdf_page_resources()`."""
    return _mupdf.pdf_page_resources(page)

def pdf_page_separations(page):
    r"""Class-aware wrapper for `::pdf_page_separations()`."""
    return _mupdf.pdf_page_separations(page)

def pdf_page_transform(page, mediabox, ctm):
    r"""Class-aware wrapper for `::pdf_page_transform()`."""
    return _mupdf.pdf_page_transform(page, mediabox, ctm)

def pdf_page_transform_box(page, mediabox, ctm, box):
    r"""Class-aware wrapper for `::pdf_page_transform_box()`."""
    return _mupdf.pdf_page_transform_box(page, mediabox, ctm, box)

def pdf_page_write(doc, mediabox, presources, pcontents):
    r"""
    Class-aware wrapper for `::pdf_page_write()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_page_write(::pdf_document *doc, ::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
    """
    return _mupdf.pdf_page_write(doc, mediabox, presources, pcontents)

def pdf_parse_array(doc, f, buf):
    r"""Class-aware wrapper for `::pdf_parse_array()`."""
    return _mupdf.pdf_parse_array(doc, f, buf)

def pdf_parse_date(s):
    r"""Class-aware wrapper for `::pdf_parse_date()`."""
    return _mupdf.pdf_parse_date(s)

def pdf_parse_default_appearance(da, font, size, n, color):
    r"""
    Class-aware wrapper for `::pdf_parse_default_appearance()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_parse_default_appearance(const char *da, float color[4])` => `(const char *font, float size, int n)`
    """
    return _mupdf.pdf_parse_default_appearance(da, font, size, n, color)

def pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, size, n, color):
    r"""
    Class-aware wrapper for `::pdf_parse_default_appearance_unmapped()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_parse_default_appearance_unmapped(const char *da, char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
    """
    return _mupdf.pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, size, n, color)

def pdf_parse_dict(doc, f, buf):
    r"""Class-aware wrapper for `::pdf_parse_dict()`."""
    return _mupdf.pdf_parse_dict(doc, f, buf)

def pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair):
    r"""
    Class-aware wrapper for `::pdf_parse_ind_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_parse_ind_obj(::pdf_document *doc, ::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
    """
    return _mupdf.pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair)

def pdf_parse_journal_obj(doc, stm, onum, ostm, newobj):
    r"""
    Class-aware wrapper for `::pdf_parse_journal_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_parse_journal_obj(::pdf_document *doc, ::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
    """
    return _mupdf.pdf_parse_journal_obj(doc, stm, onum, ostm, newobj)

def pdf_parse_stm_obj(doc, f, buf):
    r"""Class-aware wrapper for `::pdf_parse_stm_obj()`."""
    return _mupdf.pdf_parse_stm_obj(doc, f, buf)

def pdf_parse_write_options(opts, args):
    r"""Class-aware wrapper for `::pdf_parse_write_options()`."""
    return _mupdf.pdf_parse_write_options(opts, args)

def pdf_pin_document(obj):
    r"""Class-aware wrapper for `::pdf_pin_document()`."""
    return _mupdf.pdf_pin_document(obj)

def pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location):
    r"""Class-aware wrapper for `::pdf_preview_signature_as_display_list()`."""
    return _mupdf.pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location)

def pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location):
    r"""Class-aware wrapper for `::pdf_preview_signature_as_pixmap()`."""
    return _mupdf.pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location)

def pdf_print_crypt(out, crypt):
    r"""Class-aware wrapper for `::pdf_print_crypt()`."""
    return _mupdf.pdf_print_crypt(out, crypt)

def pdf_print_default_appearance(buf, nbuf, font, size, n, color):
    r"""Class-aware wrapper for `::pdf_print_default_appearance()`."""
    return _mupdf.pdf_print_default_appearance(buf, nbuf, font, size, n, color)

def pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep):
    r"""
    Class-aware wrapper for `::pdf_print_encrypted_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_print_encrypted_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
    """
    return _mupdf.pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep)

def pdf_print_font(out, fontdesc):
    r"""Class-aware wrapper for `::pdf_print_font()`."""
    return _mupdf.pdf_print_font(out, fontdesc)

def pdf_print_obj(out, obj, tight, ascii):
    r"""Class-aware wrapper for `::pdf_print_obj()`."""
    return _mupdf.pdf_print_obj(out, obj, tight, ascii)

def pdf_process_annot(proc, annot, cookie):
    r"""Class-aware wrapper for `::pdf_process_annot()`."""
    return _mupdf.pdf_process_annot(proc, annot, cookie)

def pdf_process_contents(proc, doc, res, stm, cookie, out_res):
    r"""
    Class-aware wrapper for `::pdf_process_contents()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_process_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` =>
    """
    return _mupdf.pdf_process_contents(proc, doc, res, stm, cookie, out_res)

def pdf_process_glyph(proc, doc, resources, contents):
    r"""Class-aware wrapper for `::pdf_process_glyph()`."""
    return _mupdf.pdf_process_glyph(proc, doc, resources, contents)

def pdf_process_raw_contents(proc, doc, rdb, stmobj, cookie):
    r"""Class-aware wrapper for `::pdf_process_raw_contents()`."""
    return _mupdf.pdf_process_raw_contents(proc, doc, rdb, stmobj, cookie)

def pdf_processor_pop_resources(proc):
    r"""Class-aware wrapper for `::pdf_processor_pop_resources()`."""
    return _mupdf.pdf_processor_pop_resources(proc)

def pdf_processor_push_resources(proc, res):
    r"""Class-aware wrapper for `::pdf_processor_push_resources()`."""
    return _mupdf.pdf_processor_push_resources(proc, res)

def pdf_progressive_advance(doc, pagenum):
    r"""Class-aware wrapper for `::pdf_progressive_advance()`."""
    return _mupdf.pdf_progressive_advance(doc, pagenum)

def pdf_purge_local_font_resources(doc):
    r"""Class-aware wrapper for `::pdf_purge_local_font_resources()`."""
    return _mupdf.pdf_purge_local_font_resources(doc)

def pdf_purge_locals_from_store(doc):
    r"""Class-aware wrapper for `::pdf_purge_locals_from_store()`."""
    return _mupdf.pdf_purge_locals_from_store(doc)

def pdf_purge_object_from_store(doc, num):
    r"""Class-aware wrapper for `::pdf_purge_object_from_store()`."""
    return _mupdf.pdf_purge_object_from_store(doc, num)

def pdf_read_journal(doc, stm):
    r"""Class-aware wrapper for `::pdf_read_journal()`."""
    return _mupdf.pdf_read_journal(doc, stm)

def pdf_rearrange_pages(doc, count, pages, structure):
    r"""Class-aware wrapper for `::pdf_rearrange_pages()`."""
    return _mupdf.pdf_rearrange_pages(doc, count, pages, structure)

def pdf_rearrange_pages2(doc, pages, structure):
    r"""Class-aware wrapper for `::pdf_rearrange_pages2()`.   Swig-friendly wrapper for pdf_rearrange_pages()."""
    return _mupdf.pdf_rearrange_pages2(doc, pages, structure)

def pdf_recolor_page(doc, pagenum, opts):
    r"""Class-aware wrapper for `::pdf_recolor_page()`."""
    return _mupdf.pdf_recolor_page(doc, pagenum, opts)

def pdf_recolor_shade(shade, reshade, opaque):
    r"""
    Class-aware wrapper for `::pdf_recolor_shade()`.
    	Recolor a shade.
    """
    return _mupdf.pdf_recolor_shade(shade, reshade, opaque)

def pdf_redact_page(doc, page, opts):
    r"""Class-aware wrapper for `::pdf_redact_page()`."""
    return _mupdf.pdf_redact_page(doc, page, opts)

def pdf_redo(doc):
    r"""Class-aware wrapper for `::pdf_redo()`."""
    return _mupdf.pdf_redo(doc)

def pdf_remove_item(drop, key):
    r"""Class-aware wrapper for `::pdf_remove_item()`."""
    return _mupdf.pdf_remove_item(drop, key)

def pdf_remove_output_intents(doc):
    r"""Class-aware wrapper for `::pdf_remove_output_intents()`."""
    return _mupdf.pdf_remove_output_intents(doc)

def pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root):
    r"""
    Class-aware wrapper for `::pdf_repair_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_repair_obj(::pdf_document *doc, ::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
    """
    return _mupdf.pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root)

def pdf_repair_obj_stms(doc):
    r"""Class-aware wrapper for `::pdf_repair_obj_stms()`."""
    return _mupdf.pdf_repair_obj_stms(doc)

def pdf_repair_trailer(doc):
    r"""Class-aware wrapper for `::pdf_repair_trailer()`."""
    return _mupdf.pdf_repair_trailer(doc)

def pdf_repair_xref(doc):
    r"""Class-aware wrapper for `::pdf_repair_xref()`."""
    return _mupdf.pdf_repair_xref(doc)

def pdf_replace_xref(doc, entries, n):
    r"""Class-aware wrapper for `::pdf_replace_xref()`."""
    return _mupdf.pdf_replace_xref(doc, entries, n)

def pdf_reset_form(doc, fields, exclude):
    r"""Class-aware wrapper for `::pdf_reset_form()`."""
    return _mupdf.pdf_reset_form(doc, fields, exclude)

def pdf_reset_processor(proc):
    r"""Class-aware wrapper for `::pdf_reset_processor()`."""
    return _mupdf.pdf_reset_processor(proc)

def pdf_resolve_indirect(ref):
    r"""
    Class-aware wrapper for `::pdf_resolve_indirect()`.
    	Resolve an indirect object (or chain of objects).

    	This can cause xref reorganisations (solidifications etc) due to
    	repairs, so all held pdf_xref_entries should be considered
    	invalid after this call (other than the returned one).
    """
    return _mupdf.pdf_resolve_indirect(ref)

def pdf_resolve_indirect_chain(ref):
    r"""Class-aware wrapper for `::pdf_resolve_indirect_chain()`."""
    return _mupdf.pdf_resolve_indirect_chain(ref)

def pdf_resolve_link(doc, uri, xp, yp):
    r"""
    Class-aware wrapper for `::pdf_resolve_link()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_resolve_link(::pdf_document *doc, const char *uri)` => `(int, float xp, float yp)`
    """
    return _mupdf.pdf_resolve_link(doc, uri, xp, yp)

def pdf_rewrite_images(doc, opts):
    r"""Class-aware wrapper for `::pdf_rewrite_images()`."""
    return _mupdf.pdf_rewrite_images(doc, opts)

def pdf_run_annot(annot, dev, ctm, cookie):
    r"""Class-aware wrapper for `::pdf_run_annot()`."""
    return _mupdf.pdf_run_annot(annot, dev, ctm, cookie)

def pdf_run_document_structure(doc, dev, cookie):
    r"""Class-aware wrapper for `::pdf_run_document_structure()`."""
    return _mupdf.pdf_run_document_structure(doc, dev, cookie)

def pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs):
    r"""Class-aware wrapper for `::pdf_run_glyph()`."""
    return _mupdf.pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs)

def pdf_run_page(page, dev, ctm, cookie):
    r"""Class-aware wrapper for `::pdf_run_page()`."""
    return _mupdf.pdf_run_page(page, dev, ctm, cookie)

def pdf_run_page_annots(page, dev, ctm, cookie):
    r"""Class-aware wrapper for `::pdf_run_page_annots()`."""
    return _mupdf.pdf_run_page_annots(page, dev, ctm, cookie)

def pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie):
    r"""Class-aware wrapper for `::pdf_run_page_annots_with_usage()`."""
    return _mupdf.pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie)

def pdf_run_page_contents(page, dev, ctm, cookie):
    r"""Class-aware wrapper for `::pdf_run_page_contents()`."""
    return _mupdf.pdf_run_page_contents(page, dev, ctm, cookie)

def pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie):
    r"""Class-aware wrapper for `::pdf_run_page_contents_with_usage()`."""
    return _mupdf.pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie)

def pdf_run_page_widgets(page, dev, ctm, cookie):
    r"""Class-aware wrapper for `::pdf_run_page_widgets()`."""
    return _mupdf.pdf_run_page_widgets(page, dev, ctm, cookie)

def pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie):
    r"""Class-aware wrapper for `::pdf_run_page_widgets_with_usage()`."""
    return _mupdf.pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie)

def pdf_run_page_with_usage(page, dev, ctm, usage, cookie):
    r"""Class-aware wrapper for `::pdf_run_page_with_usage()`."""
    return _mupdf.pdf_run_page_with_usage(page, dev, ctm, usage, cookie)

def pdf_sample_shade_function(samples, n, funcs, func, t0, t1):
    r"""
    Class-aware wrapper for `::pdf_sample_shade_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_sample_shade_function(int n, int funcs, ::pdf_function **func, float t0, float t1)` => `(float samples)`
    """
    return _mupdf.pdf_sample_shade_function(samples, n, funcs, func, t0, t1)

def pdf_save_document(doc, filename, opts):
    r"""Class-aware wrapper for `::pdf_save_document()`."""
    return _mupdf.pdf_save_document(doc, filename, opts)

def pdf_save_journal(doc, filename):
    r"""Class-aware wrapper for `::pdf_save_journal()`."""
    return _mupdf.pdf_save_journal(doc, filename)

def pdf_save_snapshot(doc, filename):
    r"""Class-aware wrapper for `::pdf_save_snapshot()`."""
    return _mupdf.pdf_save_snapshot(doc, filename)

def pdf_select_layer_config(doc, config_num):
    r"""Class-aware wrapper for `::pdf_select_layer_config()`."""
    return _mupdf.pdf_select_layer_config(doc, config_num)

def pdf_select_layer_config_ui(doc, ui):
    r"""Class-aware wrapper for `::pdf_select_layer_config_ui()`."""
    return _mupdf.pdf_select_layer_config_ui(doc, ui)

def pdf_serialise_journal(doc, out):
    r"""Class-aware wrapper for `::pdf_serialise_journal()`."""
    return _mupdf.pdf_serialise_journal(doc, out)

def pdf_set_annot_active(annot, active):
    r"""Class-aware wrapper for `::pdf_set_annot_active()`."""
    return _mupdf.pdf_set_annot_active(annot, active)

def pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents):
    r"""Class-aware wrapper for `::pdf_set_annot_appearance()`."""
    return _mupdf.pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents)

def pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list):
    r"""Class-aware wrapper for `::pdf_set_annot_appearance_from_display_list()`."""
    return _mupdf.pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list)

def pdf_set_annot_author(annot, author):
    r"""Class-aware wrapper for `::pdf_set_annot_author()`."""
    return _mupdf.pdf_set_annot_author(annot, author)

def pdf_set_annot_border(annot, width):
    r"""Class-aware wrapper for `::pdf_set_annot_border()`."""
    return _mupdf.pdf_set_annot_border(annot, width)

def pdf_set_annot_border_effect(annot, effect):
    r"""Class-aware wrapper for `::pdf_set_annot_border_effect()`."""
    return _mupdf.pdf_set_annot_border_effect(annot, effect)

def pdf_set_annot_border_effect_intensity(annot, intensity):
    r"""Class-aware wrapper for `::pdf_set_annot_border_effect_intensity()`."""
    return _mupdf.pdf_set_annot_border_effect_intensity(annot, intensity)

def pdf_set_annot_border_style(annot, style):
    r"""Class-aware wrapper for `::pdf_set_annot_border_style()`."""
    return _mupdf.pdf_set_annot_border_style(annot, style)

def pdf_set_annot_border_width(annot, width):
    r"""Class-aware wrapper for `::pdf_set_annot_border_width()`."""
    return _mupdf.pdf_set_annot_border_width(annot, width)

def pdf_set_annot_callout_line(annot, callout, n):
    r"""Class-aware wrapper for `::pdf_set_annot_callout_line()`."""
    return _mupdf.pdf_set_annot_callout_line(annot, callout, n)

def pdf_set_annot_callout_line2(annot, callout):
    r"""Class-aware wrapper for `::pdf_set_annot_callout_line2()`.   SWIG-friendly wrapper for pdf_set_annot_callout_line()."""
    return _mupdf.pdf_set_annot_callout_line2(annot, callout)

def pdf_set_annot_callout_point(annot, p):
    r"""Class-aware wrapper for `::pdf_set_annot_callout_point()`."""
    return _mupdf.pdf_set_annot_callout_point(annot, p)

def pdf_set_annot_callout_style(annot, style):
    r"""Class-aware wrapper for `::pdf_set_annot_callout_style()`."""
    return _mupdf.pdf_set_annot_callout_style(annot, style)

def pdf_set_annot_color(annot, n, color):
    r"""Class-aware wrapper for `::pdf_set_annot_color()`."""
    return _mupdf.pdf_set_annot_color(annot, n, color)

def pdf_set_annot_contents(annot, text):
    r"""Class-aware wrapper for `::pdf_set_annot_contents()`."""
    return _mupdf.pdf_set_annot_contents(annot, text)

def pdf_set_annot_creation_date(annot, time):
    r"""Class-aware wrapper for `::pdf_set_annot_creation_date()`."""
    return _mupdf.pdf_set_annot_creation_date(annot, time)

def pdf_set_annot_default_appearance(annot, font, size, n, color):
    r"""Class-aware wrapper for `::pdf_set_annot_default_appearance()`."""
    return _mupdf.pdf_set_annot_default_appearance(annot, font, size, n, color)

def pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events):
    r"""Class-aware wrapper for `::pdf_set_annot_field_value()`."""
    return _mupdf.pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events)

def pdf_set_annot_filespec(annot, obj):
    r"""Class-aware wrapper for `::pdf_set_annot_filespec()`."""
    return _mupdf.pdf_set_annot_filespec(annot, obj)

def pdf_set_annot_flags(annot, flags):
    r"""Class-aware wrapper for `::pdf_set_annot_flags()`."""
    return _mupdf.pdf_set_annot_flags(annot, flags)

def pdf_set_annot_hidden_for_editing(annot, hidden):
    r"""Class-aware wrapper for `::pdf_set_annot_hidden_for_editing()`."""
    return _mupdf.pdf_set_annot_hidden_for_editing(annot, hidden)

def pdf_set_annot_hot(annot, hot):
    r"""Class-aware wrapper for `::pdf_set_annot_hot()`."""
    return _mupdf.pdf_set_annot_hot(annot, hot)

def pdf_set_annot_icon_name(annot, name):
    r"""Class-aware wrapper for `::pdf_set_annot_icon_name()`."""
    return _mupdf.pdf_set_annot_icon_name(annot, name)

def pdf_set_annot_ink_list(annot, n, count, v):
    r"""Class-aware wrapper for `::pdf_set_annot_ink_list()`."""
    return _mupdf.pdf_set_annot_ink_list(annot, n, count, v)

def pdf_set_annot_intent(annot, it):
    r"""Class-aware wrapper for `::pdf_set_annot_intent()`."""
    return _mupdf.pdf_set_annot_intent(annot, it)

def pdf_set_annot_interior_color(annot, n, color):
    r"""Class-aware wrapper for `::pdf_set_annot_interior_color()`."""
    return _mupdf.pdf_set_annot_interior_color(annot, n, color)

def pdf_set_annot_is_open(annot, is_open):
    r"""Class-aware wrapper for `::pdf_set_annot_is_open()`."""
    return _mupdf.pdf_set_annot_is_open(annot, is_open)

def pdf_set_annot_language(annot, lang):
    r"""Class-aware wrapper for `::pdf_set_annot_language()`."""
    return _mupdf.pdf_set_annot_language(annot, lang)

def pdf_set_annot_line(annot, a, b):
    r"""Class-aware wrapper for `::pdf_set_annot_line()`."""
    return _mupdf.pdf_set_annot_line(annot, a, b)

def pdf_set_annot_line_caption(annot, cap):
    r"""Class-aware wrapper for `::pdf_set_annot_line_caption()`."""
    return _mupdf.pdf_set_annot_line_caption(annot, cap)

def pdf_set_annot_line_caption_offset(annot, offset):
    r"""Class-aware wrapper for `::pdf_set_annot_line_caption_offset()`."""
    return _mupdf.pdf_set_annot_line_caption_offset(annot, offset)

def pdf_set_annot_line_end_style(annot, e):
    r"""Class-aware wrapper for `::pdf_set_annot_line_end_style()`."""
    return _mupdf.pdf_set_annot_line_end_style(annot, e)

def pdf_set_annot_line_ending_styles(annot, start_style, end_style):
    r"""Class-aware wrapper for `::pdf_set_annot_line_ending_styles()`."""
    return _mupdf.pdf_set_annot_line_ending_styles(annot, start_style, end_style)

def pdf_set_annot_line_leader(annot, ll):
    r"""Class-aware wrapper for `::pdf_set_annot_line_leader()`."""
    return _mupdf.pdf_set_annot_line_leader(annot, ll)

def pdf_set_annot_line_leader_extension(annot, lle):
    r"""Class-aware wrapper for `::pdf_set_annot_line_leader_extension()`."""
    return _mupdf.pdf_set_annot_line_leader_extension(annot, lle)

def pdf_set_annot_line_leader_offset(annot, llo):
    r"""Class-aware wrapper for `::pdf_set_annot_line_leader_offset()`."""
    return _mupdf.pdf_set_annot_line_leader_offset(annot, llo)

def pdf_set_annot_line_start_style(annot, s):
    r"""Class-aware wrapper for `::pdf_set_annot_line_start_style()`."""
    return _mupdf.pdf_set_annot_line_start_style(annot, s)

def pdf_set_annot_modification_date(annot, time):
    r"""Class-aware wrapper for `::pdf_set_annot_modification_date()`."""
    return _mupdf.pdf_set_annot_modification_date(annot, time)

def pdf_set_annot_opacity(annot, opacity):
    r"""Class-aware wrapper for `::pdf_set_annot_opacity()`."""
    return _mupdf.pdf_set_annot_opacity(annot, opacity)

def pdf_set_annot_popup(annot, rect):
    r"""Class-aware wrapper for `::pdf_set_annot_popup()`."""
    return _mupdf.pdf_set_annot_popup(annot, rect)

def pdf_set_annot_quad_points(annot, n, qv):
    r"""Class-aware wrapper for `::pdf_set_annot_quad_points()`."""
    return _mupdf.pdf_set_annot_quad_points(annot, n, qv)

def pdf_set_annot_quadding(annot, q):
    r"""Class-aware wrapper for `::pdf_set_annot_quadding()`."""
    return _mupdf.pdf_set_annot_quadding(annot, q)

def pdf_set_annot_rect(annot, rect):
    r"""Class-aware wrapper for `::pdf_set_annot_rect()`."""
    return _mupdf.pdf_set_annot_rect(annot, rect)

def pdf_set_annot_resynthesised(annot):
    r"""Class-aware wrapper for `::pdf_set_annot_resynthesised()`."""
    return _mupdf.pdf_set_annot_resynthesised(annot)

def pdf_set_annot_stamp_image(annot, image):
    r"""Class-aware wrapper for `::pdf_set_annot_stamp_image()`."""
    return _mupdf.pdf_set_annot_stamp_image(annot, image)

def pdf_set_annot_vertex(annot, i, p):
    r"""Class-aware wrapper for `::pdf_set_annot_vertex()`."""
    return _mupdf.pdf_set_annot_vertex(annot, i, p)

def pdf_set_annot_vertices(annot, n, v):
    r"""Class-aware wrapper for `::pdf_set_annot_vertices()`."""
    return _mupdf.pdf_set_annot_vertices(annot, n, v)

def pdf_set_choice_field_value(widget, value):
    r"""Class-aware wrapper for `::pdf_set_choice_field_value()`."""
    return _mupdf.pdf_set_choice_field_value(widget, value)

def pdf_set_cmap_wmode(cmap, wmode):
    r"""Class-aware wrapper for `::pdf_set_cmap_wmode()`."""
    return _mupdf.pdf_set_cmap_wmode(cmap, wmode)

def pdf_set_default_hmtx(font, w):
    r"""Class-aware wrapper for `::pdf_set_default_hmtx()`."""
    return _mupdf.pdf_set_default_hmtx(font, w)

def pdf_set_default_vmtx(font, y, w):
    r"""Class-aware wrapper for `::pdf_set_default_vmtx()`."""
    return _mupdf.pdf_set_default_vmtx(font, y, w)

def pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data):
    r"""Class-aware wrapper for `::pdf_set_doc_event_callback()`."""
    return _mupdf.pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data)

def pdf_set_document_language(doc, lang):
    r"""Class-aware wrapper for `::pdf_set_document_language()`."""
    return _mupdf.pdf_set_document_language(doc, lang)

def pdf_set_field_value(doc, field, text, ignore_trigger_events):
    r"""Class-aware wrapper for `::pdf_set_field_value()`."""
    return _mupdf.pdf_set_field_value(doc, field, text, ignore_trigger_events)

def pdf_set_font_wmode(font, wmode):
    r"""Class-aware wrapper for `::pdf_set_font_wmode()`."""
    return _mupdf.pdf_set_font_wmode(font, wmode)

def pdf_set_int(obj, i):
    r"""Class-aware wrapper for `::pdf_set_int()`."""
    return _mupdf.pdf_set_int(obj, i)

def pdf_set_layer_config_as_default(doc):
    r"""Class-aware wrapper for `::pdf_set_layer_config_as_default()`."""
    return _mupdf.pdf_set_layer_config_as_default(doc)

def pdf_set_obj_memo(obj, bit, memo):
    r"""Class-aware wrapper for `::pdf_set_obj_memo()`."""
    return _mupdf.pdf_set_obj_memo(obj, bit, memo)

def pdf_set_obj_parent(obj, num):
    r"""Class-aware wrapper for `::pdf_set_obj_parent()`."""
    return _mupdf.pdf_set_obj_parent(obj, num)

def pdf_set_page_box(page, box, rect):
    r"""Class-aware wrapper for `::pdf_set_page_box()`."""
    return _mupdf.pdf_set_page_box(page, box, rect)

def pdf_set_page_labels(doc, index, style, prefix, start):
    r"""Class-aware wrapper for `::pdf_set_page_labels()`."""
    return _mupdf.pdf_set_page_labels(doc, index, style, prefix, start)

def pdf_set_populating_xref_trailer(doc, trailer):
    r"""Class-aware wrapper for `::pdf_set_populating_xref_trailer()`."""
    return _mupdf.pdf_set_populating_xref_trailer(doc, trailer)

def pdf_set_str_len(obj, newlen):
    r"""Class-aware wrapper for `::pdf_set_str_len()`."""
    return _mupdf.pdf_set_str_len(obj, newlen)

def pdf_set_text_field_value(widget, value):
    r"""Class-aware wrapper for `::pdf_set_text_field_value()`."""
    return _mupdf.pdf_set_text_field_value(widget, value)

def pdf_set_usecmap(cmap, usecmap):
    r"""Class-aware wrapper for `::pdf_set_usecmap()`."""
    return _mupdf.pdf_set_usecmap(cmap, usecmap)

def pdf_set_widget_editing_state(widget, editing):
    r"""Class-aware wrapper for `::pdf_set_widget_editing_state()`."""
    return _mupdf.pdf_set_widget_editing_state(widget, editing)

def pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location):
    r"""Class-aware wrapper for `::pdf_sign_signature()`."""
    return _mupdf.pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location)

def pdf_sign_signature_with_appearance(widget, signer, date, disp_list):
    r"""Class-aware wrapper for `::pdf_sign_signature_with_appearance()`."""
    return _mupdf.pdf_sign_signature_with_appearance(widget, signer, date, disp_list)

def pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo):
    r"""Class-aware wrapper for `::pdf_signature_appearance_signed()`."""
    return _mupdf.pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo)

def pdf_signature_appearance_unsigned(rect, lang):
    r"""Class-aware wrapper for `::pdf_signature_appearance_unsigned()`."""
    return _mupdf.pdf_signature_appearance_unsigned(rect, lang)

def pdf_signature_byte_range(doc, signature, byte_range):
    r"""Class-aware wrapper for `::pdf_signature_byte_range()`."""
    return _mupdf.pdf_signature_byte_range(doc, signature, byte_range)

def pdf_signature_contents(doc, signature, contents):
    r"""
    Class-aware wrapper for `::pdf_signature_contents()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_signature_contents(::pdf_document *doc, ::pdf_obj *signature)` => `(size_t, char *contents)`
    """
    return _mupdf.pdf_signature_contents(doc, signature, contents)

def pdf_signature_drop_distinguished_name(name):
    r"""Class-aware wrapper for `::pdf_signature_drop_distinguished_name()`."""
    return _mupdf.pdf_signature_drop_distinguished_name(name)

def pdf_signature_error_description(err):
    r"""Class-aware wrapper for `::pdf_signature_error_description()`."""
    return _mupdf.pdf_signature_error_description(err)

def pdf_signature_format_distinguished_name(name):
    r"""Class-aware wrapper for `::pdf_signature_format_distinguished_name()`."""
    return _mupdf.pdf_signature_format_distinguished_name(name)

def pdf_signature_hash_bytes(doc, signature):
    r"""Class-aware wrapper for `::pdf_signature_hash_bytes()`."""
    return _mupdf.pdf_signature_hash_bytes(doc, signature)

def pdf_signature_incremental_change_since_signing(doc, signature):
    r"""Class-aware wrapper for `::pdf_signature_incremental_change_since_signing()`."""
    return _mupdf.pdf_signature_incremental_change_since_signing(doc, signature)

def pdf_signature_info(name, dn, reason, location, date, include_labels):
    r"""Class-aware wrapper for `::pdf_signature_info()`."""
    return _mupdf.pdf_signature_info(name, dn, reason, location, date, include_labels)

def pdf_signature_is_signed(doc, field):
    r"""Class-aware wrapper for `::pdf_signature_is_signed()`."""
    return _mupdf.pdf_signature_is_signed(doc, field)

def pdf_signature_set_value(doc, field, signer, stime):
    r"""Class-aware wrapper for `::pdf_signature_set_value()`."""
    return _mupdf.pdf_signature_set_value(doc, field, signer, stime)

def pdf_sort_cmap(cmap):
    r"""Class-aware wrapper for `::pdf_sort_cmap()`."""
    return _mupdf.pdf_sort_cmap(cmap)

def pdf_sort_dict(dict):
    r"""Class-aware wrapper for `::pdf_sort_dict()`."""
    return _mupdf.pdf_sort_dict(dict)

def pdf_specifics(doc):
    r"""Class-aware wrapper for `::pdf_specifics()`."""
    return _mupdf.pdf_specifics(doc)

def pdf_sprint_obj(buf, cap, len, obj, tight, ascii):
    r"""
    Class-aware wrapper for `::pdf_sprint_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_sprint_obj(char *buf, size_t cap, ::pdf_obj *obj, int tight, int ascii)` => `(char *, size_t len)`
    """
    return _mupdf.pdf_sprint_obj(buf, cap, len, obj, tight, ascii)

def pdf_store_item(key, val, itemsize):
    r"""Class-aware wrapper for `::pdf_store_item()`."""
    return _mupdf.pdf_store_item(key, val, itemsize)

def pdf_string_from_annot_type(type):
    r"""Class-aware wrapper for `::pdf_string_from_annot_type()`."""
    return _mupdf.pdf_string_from_annot_type(type)

def pdf_string_from_intent(intent):
    r"""Class-aware wrapper for `::pdf_string_from_intent()`."""
    return _mupdf.pdf_string_from_intent(intent)

def pdf_string_from_line_ending(end):
    r"""Class-aware wrapper for `::pdf_string_from_line_ending()`."""
    return _mupdf.pdf_string_from_line_ending(end)

def pdf_structure_type(role_map, tag):
    r"""Class-aware wrapper for `::pdf_structure_type()`."""
    return _mupdf.pdf_structure_type(role_map, tag)

def pdf_subset_fonts(doc, pages_len, pages):
    r"""Class-aware wrapper for `::pdf_subset_fonts()`."""
    return _mupdf.pdf_subset_fonts(doc, pages_len, pages)

def pdf_subset_fonts2(doc, pages):
    r"""Class-aware wrapper for `::pdf_subset_fonts2()`.   Swig-friendly wrapper for pdf_subset_fonts()."""
    return _mupdf.pdf_subset_fonts2(doc, pages)

def pdf_sync_annots(page):
    r"""Class-aware wrapper for `::pdf_sync_annots()`."""
    return _mupdf.pdf_sync_annots(page)

def pdf_sync_links(page):
    r"""Class-aware wrapper for `::pdf_sync_links()`."""
    return _mupdf.pdf_sync_links(page)

def pdf_sync_open_pages(doc):
    r"""Class-aware wrapper for `::pdf_sync_open_pages()`."""
    return _mupdf.pdf_sync_open_pages(doc)

def pdf_sync_page(page):
    r"""Class-aware wrapper for `::pdf_sync_page()`."""
    return _mupdf.pdf_sync_page(page)

def pdf_text_widget_format(tw):
    r"""Class-aware wrapper for `::pdf_text_widget_format()`."""
    return _mupdf.pdf_text_widget_format(tw)

def pdf_text_widget_max_len(tw):
    r"""Class-aware wrapper for `::pdf_text_widget_max_len()`."""
    return _mupdf.pdf_text_widget_max_len(tw)

def pdf_to_bool(obj):
    r"""Class-aware wrapper for `::pdf_to_bool()`."""
    return _mupdf.pdf_to_bool(obj)

def pdf_to_bool_default(obj, _def):
    r"""Class-aware wrapper for `::pdf_to_bool_default()`."""
    return _mupdf.pdf_to_bool_default(obj, _def)

def pdf_to_date(time):
    r"""Class-aware wrapper for `::pdf_to_date()`."""
    return _mupdf.pdf_to_date(time)

def pdf_to_gen(obj):
    r"""Class-aware wrapper for `::pdf_to_gen()`."""
    return _mupdf.pdf_to_gen(obj)

def pdf_to_int(obj):
    r"""Class-aware wrapper for `::pdf_to_int()`."""
    return _mupdf.pdf_to_int(obj)

def pdf_to_int64(obj):
    r"""Class-aware wrapper for `::pdf_to_int64()`."""
    return _mupdf.pdf_to_int64(obj)

def pdf_to_int_default(obj, _def):
    r"""Class-aware wrapper for `::pdf_to_int_default()`."""
    return _mupdf.pdf_to_int_default(obj, _def)

def pdf_to_matrix(array):
    r"""Class-aware wrapper for `::pdf_to_matrix()`."""
    return _mupdf.pdf_to_matrix(array)

def pdf_to_name(obj):
    r"""Class-aware wrapper for `::pdf_to_name()`."""
    return _mupdf.pdf_to_name(obj)

def pdf_to_num(obj):
    r"""Class-aware wrapper for `::pdf_to_num()`."""
    return _mupdf.pdf_to_num(obj)

def pdf_to_point(array, offset):
    r"""Class-aware wrapper for `::pdf_to_point()`."""
    return _mupdf.pdf_to_point(array, offset)

def pdf_to_quad(array, offset):
    r"""Class-aware wrapper for `::pdf_to_quad()`."""
    return _mupdf.pdf_to_quad(array, offset)

def pdf_to_real(obj):
    r"""Class-aware wrapper for `::pdf_to_real()`."""
    return _mupdf.pdf_to_real(obj)

def pdf_to_real_default(obj, _def):
    r"""Class-aware wrapper for `::pdf_to_real_default()`."""
    return _mupdf.pdf_to_real_default(obj, _def)

def pdf_to_rect(array):
    r"""Class-aware wrapper for `::pdf_to_rect()`."""
    return _mupdf.pdf_to_rect(array)

def pdf_to_str_buf(obj):
    r"""Class-aware wrapper for `::pdf_to_str_buf()`."""
    return _mupdf.pdf_to_str_buf(obj)

def pdf_to_str_len(obj):
    r"""Class-aware wrapper for `::pdf_to_str_len()`."""
    return _mupdf.pdf_to_str_len(obj)

def pdf_to_string(obj, sizep):
    r"""
    Class-aware wrapper for `::pdf_to_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_to_string(::pdf_obj *obj)` => `(const char *, size_t sizep)`
    """
    return _mupdf.pdf_to_string(obj, sizep)

def pdf_to_text_string(obj):
    r"""Class-aware wrapper for `::pdf_to_text_string()`."""
    return _mupdf.pdf_to_text_string(obj)

def pdf_toggle_layer_config_ui(doc, ui):
    r"""Class-aware wrapper for `::pdf_toggle_layer_config_ui()`."""
    return _mupdf.pdf_toggle_layer_config_ui(doc, ui)

def pdf_toggle_widget(widget):
    r"""Class-aware wrapper for `::pdf_toggle_widget()`."""
    return _mupdf.pdf_toggle_widget(widget)

def pdf_tos_get_text(tos):
    r"""Class-aware wrapper for `::pdf_tos_get_text()`."""
    return _mupdf.pdf_tos_get_text(tos)

def pdf_tos_make_trm(tos, text, fontdesc, cid, trm, adv):
    r"""
    Class-aware wrapper for `::pdf_tos_make_trm()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_tos_make_trm(::pdf_text_object_state *tos, ::pdf_text_state *text, ::pdf_font_desc *fontdesc, int cid, ::fz_matrix *trm)` => `(int, float adv)`
    """
    return _mupdf.pdf_tos_make_trm(tos, text, fontdesc, cid, trm, adv)

def pdf_tos_move_after_char(tos):
    r"""Class-aware wrapper for `::pdf_tos_move_after_char()`."""
    return _mupdf.pdf_tos_move_after_char(tos)

def pdf_tos_newline(tos, leading):
    r"""Class-aware wrapper for `::pdf_tos_newline()`."""
    return _mupdf.pdf_tos_newline(tos, leading)

def pdf_tos_reset(tos, render):
    r"""Class-aware wrapper for `::pdf_tos_reset()`."""
    return _mupdf.pdf_tos_reset(tos, render)

def pdf_tos_restore(tos, save):
    r"""Class-aware wrapper for `::pdf_tos_restore()`."""
    return _mupdf.pdf_tos_restore(tos, save)

def pdf_tos_save(tos, save):
    r"""Class-aware wrapper for `::pdf_tos_save()`."""
    return _mupdf.pdf_tos_save(tos, save)

def pdf_tos_set_matrix(tos, a, b, c, d, e, f):
    r"""Class-aware wrapper for `::pdf_tos_set_matrix()`."""
    return _mupdf.pdf_tos_set_matrix(tos, a, b, c, d, e, f)

def pdf_tos_translate(tos, tx, ty):
    r"""Class-aware wrapper for `::pdf_tos_translate()`."""
    return _mupdf.pdf_tos_translate(tos, tx, ty)

def pdf_trailer(doc):
    r"""Class-aware wrapper for `::pdf_trailer()`."""
    return _mupdf.pdf_trailer(doc)

def pdf_undo(doc):
    r"""Class-aware wrapper for `::pdf_undo()`."""
    return _mupdf.pdf_undo(doc)

def pdf_undoredo_state(doc, steps):
    r"""
    Class-aware wrapper for `::pdf_undoredo_state()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_undoredo_state(::pdf_document *doc)` => `(int, int steps)`
    """
    return _mupdf.pdf_undoredo_state(doc, steps)

def pdf_undoredo_step(doc, step):
    r"""Class-aware wrapper for `::pdf_undoredo_step()`."""
    return _mupdf.pdf_undoredo_step(doc, step)

def pdf_unmark_obj(obj):
    r"""Class-aware wrapper for `::pdf_unmark_obj()`."""
    return _mupdf.pdf_unmark_obj(obj)

def pdf_update_annot(annot):
    r"""Class-aware wrapper for `::pdf_update_annot()`."""
    return _mupdf.pdf_update_annot(annot)

def pdf_update_default_colorspaces(old_cs, res):
    r"""Class-aware wrapper for `::pdf_update_default_colorspaces()`."""
    return _mupdf.pdf_update_default_colorspaces(old_cs, res)

def pdf_update_object(doc, num, obj):
    r"""Class-aware wrapper for `::pdf_update_object()`."""
    return _mupdf.pdf_update_object(doc, num, obj)

def pdf_update_page(page):
    r"""Class-aware wrapper for `::pdf_update_page()`."""
    return _mupdf.pdf_update_page(page)

def pdf_update_stream(doc, ref, buf, compressed):
    r"""Class-aware wrapper for `::pdf_update_stream()`."""
    return _mupdf.pdf_update_stream(doc, ref, buf, compressed)

def pdf_update_widget(widget):
    r"""Class-aware wrapper for `::pdf_update_widget()`."""
    return _mupdf.pdf_update_widget(widget)

def pdf_update_xobject(doc, xobj, bbox, mat, res, buffer):
    r"""Class-aware wrapper for `::pdf_update_xobject()`."""
    return _mupdf.pdf_update_xobject(doc, xobj, bbox, mat, res, buffer)

def pdf_validate_change_history(doc):
    r"""Class-aware wrapper for `::pdf_validate_change_history()`."""
    return _mupdf.pdf_validate_change_history(doc)

def pdf_validate_changes(doc, version):
    r"""Class-aware wrapper for `::pdf_validate_changes()`."""
    return _mupdf.pdf_validate_changes(doc, version)

def pdf_validate_signature(widget):
    r"""Class-aware wrapper for `::pdf_validate_signature()`."""
    return _mupdf.pdf_validate_signature(widget)

def pdf_verify_embedded_file_checksum(fs):
    r"""Class-aware wrapper for `::pdf_verify_embedded_file_checksum()`."""
    return _mupdf.pdf_verify_embedded_file_checksum(fs)

def pdf_version(doc):
    r"""Class-aware wrapper for `::pdf_version()`."""
    return _mupdf.pdf_version(doc)

def pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values):
    r"""
    Class-aware wrapper for `::pdf_walk_tree()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_walk_tree(::pdf_obj *tree, ::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
    """
    return _mupdf.pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values)

def pdf_was_pure_xfa(doc):
    r"""Class-aware wrapper for `::pdf_was_pure_xfa()`."""
    return _mupdf.pdf_was_pure_xfa(doc)

def pdf_was_repaired(doc):
    r"""Class-aware wrapper for `::pdf_was_repaired()`."""
    return _mupdf.pdf_was_repaired(doc)

def pdf_widget_is_readonly(widget):
    r"""Class-aware wrapper for `::pdf_widget_is_readonly()`."""
    return _mupdf.pdf_widget_is_readonly(widget)

def pdf_widget_is_signed(widget):
    r"""Class-aware wrapper for `::pdf_widget_is_signed()`."""
    return _mupdf.pdf_widget_is_signed(widget)

def pdf_widget_type(widget):
    r"""Class-aware wrapper for `::pdf_widget_type()`."""
    return _mupdf.pdf_widget_type(widget)

def pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer):
    r"""Class-aware wrapper for `::pdf_write_digest()`."""
    return _mupdf.pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer)

def pdf_write_document(doc, out, opts):
    r"""Class-aware wrapper for `::pdf_write_document()`."""
    return _mupdf.pdf_write_document(doc, out, opts)

def pdf_write_journal(doc, out):
    r"""Class-aware wrapper for `::pdf_write_journal()`."""
    return _mupdf.pdf_write_journal(doc, out)

def pdf_write_snapshot(doc, out):
    r"""Class-aware wrapper for `::pdf_write_snapshot()`."""
    return _mupdf.pdf_write_snapshot(doc, out)

def pdf_xobject_bbox(xobj):
    r"""Class-aware wrapper for `::pdf_xobject_bbox()`."""
    return _mupdf.pdf_xobject_bbox(xobj)

def pdf_xobject_colorspace(xobj):
    r"""Class-aware wrapper for `::pdf_xobject_colorspace()`."""
    return _mupdf.pdf_xobject_colorspace(xobj)

def pdf_xobject_isolated(xobj):
    r"""Class-aware wrapper for `::pdf_xobject_isolated()`."""
    return _mupdf.pdf_xobject_isolated(xobj)

def pdf_xobject_knockout(xobj):
    r"""Class-aware wrapper for `::pdf_xobject_knockout()`."""
    return _mupdf.pdf_xobject_knockout(xobj)

def pdf_xobject_matrix(xobj):
    r"""Class-aware wrapper for `::pdf_xobject_matrix()`."""
    return _mupdf.pdf_xobject_matrix(xobj)

def pdf_xobject_resources(xobj):
    r"""Class-aware wrapper for `::pdf_xobject_resources()`."""
    return _mupdf.pdf_xobject_resources(xobj)

def pdf_xobject_transparency(xobj):
    r"""Class-aware wrapper for `::pdf_xobject_transparency()`."""
    return _mupdf.pdf_xobject_transparency(xobj)

def pdf_xref_ensure_incremental_object(doc, num):
    r"""Class-aware wrapper for `::pdf_xref_ensure_incremental_object()`."""
    return _mupdf.pdf_xref_ensure_incremental_object(doc, num)

def pdf_xref_ensure_local_object(doc, num):
    r"""Class-aware wrapper for `::pdf_xref_ensure_local_object()`."""
    return _mupdf.pdf_xref_ensure_local_object(doc, num)

def pdf_xref_entry_map(doc, fn, arg):
    r"""Class-aware wrapper for `::pdf_xref_entry_map()`."""
    return _mupdf.pdf_xref_entry_map(doc, fn, arg)

def pdf_xref_is_incremental(doc, num):
    r"""Class-aware wrapper for `::pdf_xref_is_incremental()`."""
    return _mupdf.pdf_xref_is_incremental(doc, num)

def pdf_xref_len(doc):
    r"""Class-aware wrapper for `::pdf_xref_len()`."""
    return _mupdf.pdf_xref_len(doc)

def pdf_xref_obj_is_unsaved_signature(doc, obj):
    r"""Class-aware wrapper for `::pdf_xref_obj_is_unsaved_signature()`."""
    return _mupdf.pdf_xref_obj_is_unsaved_signature(doc, obj)

def pdf_xref_remove_unsaved_signature(doc, field):
    r"""Class-aware wrapper for `::pdf_xref_remove_unsaved_signature()`."""
    return _mupdf.pdf_xref_remove_unsaved_signature(doc, field)

def pdf_xref_store_unsaved_signature(doc, field, signer):
    r"""Class-aware wrapper for `::pdf_xref_store_unsaved_signature()`."""
    return _mupdf.pdf_xref_store_unsaved_signature(doc, field, signer)

def pdf_zugferd_profile(doc, version):
    r"""
    Class-aware wrapper for `::pdf_zugferd_profile()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_zugferd_profile(::pdf_document *doc)` => `(enum pdf_zugferd_profile, float version)`
    """
    return _mupdf.pdf_zugferd_profile(doc, version)

def pdf_zugferd_profile_to_string(profile):
    r"""Class-aware wrapper for `::pdf_zugferd_profile_to_string()`."""
    return _mupdf.pdf_zugferd_profile_to_string(profile)

def pdf_zugferd_xml(doc):
    r"""Class-aware wrapper for `::pdf_zugferd_xml()`."""
    return _mupdf.pdf_zugferd_xml(doc)

def internal_assert_fail(file, line, fn, expression):
    r"""This file was auto-generated by mupdfwrap.py."""
    return _mupdf.internal_assert_fail(file, line, fn, expression)

def internal_env_flag(name):
    r"""Internal use only. Looks at environmental variable <name>; returns 0 if unset else int value."""
    return _mupdf.internal_env_flag(name)

def internal_env_flag_check_unset(if_, name):
    r"""Internal use only. Looks at environmental variable <name>; returns 0 if unset else int value."""
    return _mupdf.internal_env_flag_check_unset(if_, name)

def internal_context_get():
    r"""Internal use only. Returns `fz_context*` for use by current thread."""
    return _mupdf.internal_context_get()
class FzErrorBase(Exception):
    r"""Base class for exceptions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_code = property(_mupdf.FzErrorBase_m_code_get, _mupdf.FzErrorBase_m_code_set)
    m_text = property(_mupdf.FzErrorBase_m_text_get, _mupdf.FzErrorBase_m_text_set)
    m_what = property(_mupdf.FzErrorBase_m_what_get, _mupdf.FzErrorBase_m_what_set)

    def what(self):
        return _mupdf.FzErrorBase_what(self)

    def __init__(self, code, text):
        _mupdf.FzErrorBase_swiginit(self, _mupdf.new_FzErrorBase(code, text))
    __swig_destroy__ = _mupdf.delete_FzErrorBase

# Register FzErrorBase in _mupdf:
_mupdf.FzErrorBase_swigregister(FzErrorBase)
class FzErrorNone(FzErrorBase):
    r"""For `FZ_ERROR_NONE`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorNone_swiginit(self, _mupdf.new_FzErrorNone(message))
    __swig_destroy__ = _mupdf.delete_FzErrorNone

# Register FzErrorNone in _mupdf:
_mupdf.FzErrorNone_swigregister(FzErrorNone)
class FzErrorGeneric(FzErrorBase):
    r"""For `FZ_ERROR_GENERIC`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorGeneric_swiginit(self, _mupdf.new_FzErrorGeneric(message))
    __swig_destroy__ = _mupdf.delete_FzErrorGeneric

# Register FzErrorGeneric in _mupdf:
_mupdf.FzErrorGeneric_swigregister(FzErrorGeneric)
class FzErrorSystem(FzErrorBase):
    r"""For `FZ_ERROR_SYSTEM`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorSystem_swiginit(self, _mupdf.new_FzErrorSystem(message))
    __swig_destroy__ = _mupdf.delete_FzErrorSystem

# Register FzErrorSystem in _mupdf:
_mupdf.FzErrorSystem_swigregister(FzErrorSystem)
class FzErrorLibrary(FzErrorBase):
    r"""For `FZ_ERROR_LIBRARY`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorLibrary_swiginit(self, _mupdf.new_FzErrorLibrary(message))
    __swig_destroy__ = _mupdf.delete_FzErrorLibrary

# Register FzErrorLibrary in _mupdf:
_mupdf.FzErrorLibrary_swigregister(FzErrorLibrary)
class FzErrorArgument(FzErrorBase):
    r"""For `FZ_ERROR_ARGUMENT`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorArgument_swiginit(self, _mupdf.new_FzErrorArgument(message))
    __swig_destroy__ = _mupdf.delete_FzErrorArgument

# Register FzErrorArgument in _mupdf:
_mupdf.FzErrorArgument_swigregister(FzErrorArgument)
class FzErrorLimit(FzErrorBase):
    r"""For `FZ_ERROR_LIMIT`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorLimit_swiginit(self, _mupdf.new_FzErrorLimit(message))
    __swig_destroy__ = _mupdf.delete_FzErrorLimit

# Register FzErrorLimit in _mupdf:
_mupdf.FzErrorLimit_swigregister(FzErrorLimit)
class FzErrorUnsupported(FzErrorBase):
    r"""For `FZ_ERROR_UNSUPPORTED`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorUnsupported_swiginit(self, _mupdf.new_FzErrorUnsupported(message))
    __swig_destroy__ = _mupdf.delete_FzErrorUnsupported

# Register FzErrorUnsupported in _mupdf:
_mupdf.FzErrorUnsupported_swigregister(FzErrorUnsupported)
class FzErrorFormat(FzErrorBase):
    r"""For `FZ_ERROR_FORMAT`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorFormat_swiginit(self, _mupdf.new_FzErrorFormat(message))
    __swig_destroy__ = _mupdf.delete_FzErrorFormat

# Register FzErrorFormat in _mupdf:
_mupdf.FzErrorFormat_swigregister(FzErrorFormat)
class FzErrorSyntax(FzErrorBase):
    r"""For `FZ_ERROR_SYNTAX`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorSyntax_swiginit(self, _mupdf.new_FzErrorSyntax(message))
    __swig_destroy__ = _mupdf.delete_FzErrorSyntax

# Register FzErrorSyntax in _mupdf:
_mupdf.FzErrorSyntax_swigregister(FzErrorSyntax)
class FzErrorTrylater(FzErrorBase):
    r"""For `FZ_ERROR_TRYLATER`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorTrylater_swiginit(self, _mupdf.new_FzErrorTrylater(message))
    __swig_destroy__ = _mupdf.delete_FzErrorTrylater

# Register FzErrorTrylater in _mupdf:
_mupdf.FzErrorTrylater_swigregister(FzErrorTrylater)
class FzErrorAbort(FzErrorBase):
    r"""For `FZ_ERROR_ABORT`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorAbort_swiginit(self, _mupdf.new_FzErrorAbort(message))
    __swig_destroy__ = _mupdf.delete_FzErrorAbort

# Register FzErrorAbort in _mupdf:
_mupdf.FzErrorAbort_swigregister(FzErrorAbort)
class FzErrorRepaired(FzErrorBase):
    r"""For `FZ_ERROR_REPAIRED`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorRepaired_swiginit(self, _mupdf.new_FzErrorRepaired(message))
    __swig_destroy__ = _mupdf.delete_FzErrorRepaired

# Register FzErrorRepaired in _mupdf:
_mupdf.FzErrorRepaired_swigregister(FzErrorRepaired)

def internal_throw_exception(ctx):
    r"""Throw exception appropriate for error in `ctx`."""
    return _mupdf.internal_throw_exception(ctx)

def to_stdstring(s):
    return _mupdf.to_stdstring(s)

def py_repr(x):
    return _mupdf.py_repr(x)

def py_str(x):
    return _mupdf.py_str(x)

def ll_fz_buffer_to_bytes_internal(buffer, clear):
    return _mupdf.ll_fz_buffer_to_bytes_internal(buffer, clear)

def python_memoryview_from_memory(data, size, writable):
    return _mupdf.python_memoryview_from_memory(data, size, writable)

def ll_fz_buffer_storage_memoryview(buffer, writable):
    return _mupdf.ll_fz_buffer_storage_memoryview(buffer, writable)

def raw_to_python_bytes(*args):
    return _mupdf.raw_to_python_bytes(*args)

def python_buffer_data(PYTHON_BUFFER_DATA):
    return _mupdf.python_buffer_data(PYTHON_BUFFER_DATA)

def python_mutable_buffer_data(PYTHON_BUFFER_MUTABLE_DATA):
    return _mupdf.python_mutable_buffer_data(PYTHON_BUFFER_MUTABLE_DATA)

def obj_enum_to_obj(n):
    return _mupdf.obj_enum_to_obj(n)

def ll_pdf_set_annot_color2(annot, n, color0, color1, color2, color3):
    return _mupdf.ll_pdf_set_annot_color2(annot, n, color0, color1, color2, color3)

def ll_pdf_set_annot_interior_color2(annot, n, color0, color1, color2, color3):
    return _mupdf.ll_pdf_set_annot_interior_color2(annot, n, color0, color1, color2, color3)

def ll_fz_fill_text2(dev, text, ctm, colorspace, color0, color1, color2, color3, alpha, color_params):
    return _mupdf.ll_fz_fill_text2(dev, text, ctm, colorspace, color0, color1, color2, color3, alpha, color_params)

def fz_memrnd2(length):
    return _mupdf.fz_memrnd2(length)

def ll_fz_pixmap_copy_raw(pm, samples):
    return _mupdf.ll_fz_pixmap_copy_raw(pm, samples)

def fz_runetochar2(rune):
    return _mupdf.fz_runetochar2(rune)

def ll_fz_make_bookmark2(doc, loc):
    return _mupdf.ll_fz_make_bookmark2(doc, loc)

def ll_fz_lookup_bookmark2(doc, mark):
    return _mupdf.ll_fz_lookup_bookmark2(doc, mark)

def fz_lookup_bookmark2(doc, mark):
    return _mupdf.fz_lookup_bookmark2(doc, mark)
class fz_convert_color2_v(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    v0 = property(_mupdf.fz_convert_color2_v_v0_get, _mupdf.fz_convert_color2_v_v0_set)
    v1 = property(_mupdf.fz_convert_color2_v_v1_get, _mupdf.fz_convert_color2_v_v1_set)
    v2 = property(_mupdf.fz_convert_color2_v_v2_get, _mupdf.fz_convert_color2_v_v2_set)
    v3 = property(_mupdf.fz_convert_color2_v_v3_get, _mupdf.fz_convert_color2_v_v3_set)

    def __init__(self):
        _mupdf.fz_convert_color2_v_swiginit(self, _mupdf.new_fz_convert_color2_v())
    __swig_destroy__ = _mupdf.delete_fz_convert_color2_v

# Register fz_convert_color2_v in _mupdf:
_mupdf.fz_convert_color2_v_swigregister(fz_convert_color2_v)

def ll_fz_convert_color2(*args):
    return _mupdf.ll_fz_convert_color2(*args)
class DiagnosticCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, description):
        if self.__class__ == DiagnosticCallback:
            _self = None
        else:
            _self = self
        _mupdf.DiagnosticCallback_swiginit(self, _mupdf.new_DiagnosticCallback(_self, description))

    def _print(self, message):
        return _mupdf.DiagnosticCallback__print(self, message)
    __swig_destroy__ = _mupdf.delete_DiagnosticCallback

    @staticmethod
    def s_print(self0, message):
        return _mupdf.DiagnosticCallback_s_print(self0, message)
    m_description = property(_mupdf.DiagnosticCallback_m_description_get, _mupdf.DiagnosticCallback_m_description_set)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_DiagnosticCallback(self)
        return weakref.proxy(self)

# Register DiagnosticCallback in _mupdf:
_mupdf.DiagnosticCallback_swigregister(DiagnosticCallback)
class StoryPositionsCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == StoryPositionsCallback:
            _self = None
        else:
            _self = self
        _mupdf.StoryPositionsCallback_swiginit(self, _mupdf.new_StoryPositionsCallback(_self, ))

    def call(self, position):
        return _mupdf.StoryPositionsCallback_call(self, position)

    @staticmethod
    def s_call(ctx, self0, position):
        return _mupdf.StoryPositionsCallback_s_call(ctx, self0, position)
    __swig_destroy__ = _mupdf.delete_StoryPositionsCallback
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_StoryPositionsCallback(self)
        return weakref.proxy(self)

# Register StoryPositionsCallback in _mupdf:
_mupdf.StoryPositionsCallback_swigregister(StoryPositionsCallback)

def ll_fz_story_positions_director(story, cb):
    return _mupdf.ll_fz_story_positions_director(story, cb)

def Pixmap_set_alpha_helper(balen, n, data_len, zero_out, data, pix, premultiply, bground, colors, bgcolor):
    return _mupdf.Pixmap_set_alpha_helper(balen, n, data_len, zero_out, data, pix, premultiply, bground, colors, bgcolor)

def page_merge_helper(old_annots, graft_map, doc_des, new_annots, n):
    return _mupdf.page_merge_helper(old_annots, graft_map, doc_des, new_annots, n)
class ll_fz_bidi_fragment_text_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    baseDir = property(_mupdf.ll_fz_bidi_fragment_text_outparams_baseDir_get, _mupdf.ll_fz_bidi_fragment_text_outparams_baseDir_set)

    def __init__(self):
        _mupdf.ll_fz_bidi_fragment_text_outparams_swiginit(self, _mupdf.new_ll_fz_bidi_fragment_text_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_bidi_fragment_text_outparams

# Register ll_fz_bidi_fragment_text_outparams in _mupdf:
_mupdf.ll_fz_bidi_fragment_text_outparams_swigregister(ll_fz_bidi_fragment_text_outparams)

def ll_fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags, outparams):
    return _mupdf.ll_fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags, outparams)
class ll_fz_bitmap_details_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    w = property(_mupdf.ll_fz_bitmap_details_outparams_w_get, _mupdf.ll_fz_bitmap_details_outparams_w_set)
    h = property(_mupdf.ll_fz_bitmap_details_outparams_h_get, _mupdf.ll_fz_bitmap_details_outparams_h_set)
    n = property(_mupdf.ll_fz_bitmap_details_outparams_n_get, _mupdf.ll_fz_bitmap_details_outparams_n_set)
    stride = property(_mupdf.ll_fz_bitmap_details_outparams_stride_get, _mupdf.ll_fz_bitmap_details_outparams_stride_set)

    def __init__(self):
        _mupdf.ll_fz_bitmap_details_outparams_swiginit(self, _mupdf.new_ll_fz_bitmap_details_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_bitmap_details_outparams

# Register ll_fz_bitmap_details_outparams in _mupdf:
_mupdf.ll_fz_bitmap_details_outparams_swigregister(ll_fz_bitmap_details_outparams)

def ll_fz_bitmap_details_outparams_fn(bitmap, outparams):
    return _mupdf.ll_fz_bitmap_details_outparams_fn(bitmap, outparams)
class ll_fz_buffer_extract_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_mupdf.ll_fz_buffer_extract_outparams_data_get, _mupdf.ll_fz_buffer_extract_outparams_data_set)

    def __init__(self):
        _mupdf.ll_fz_buffer_extract_outparams_swiginit(self, _mupdf.new_ll_fz_buffer_extract_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_buffer_extract_outparams

# Register ll_fz_buffer_extract_outparams in _mupdf:
_mupdf.ll_fz_buffer_extract_outparams_swigregister(ll_fz_buffer_extract_outparams)

def ll_fz_buffer_extract_outparams_fn(buf, outparams):
    return _mupdf.ll_fz_buffer_extract_outparams_fn(buf, outparams)
class ll_fz_buffer_storage_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    datap = property(_mupdf.ll_fz_buffer_storage_outparams_datap_get, _mupdf.ll_fz_buffer_storage_outparams_datap_set)

    def __init__(self):
        _mupdf.ll_fz_buffer_storage_outparams_swiginit(self, _mupdf.new_ll_fz_buffer_storage_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_buffer_storage_outparams

# Register ll_fz_buffer_storage_outparams in _mupdf:
_mupdf.ll_fz_buffer_storage_outparams_swigregister(ll_fz_buffer_storage_outparams)

def ll_fz_buffer_storage_outparams_fn(buf, outparams):
    return _mupdf.ll_fz_buffer_storage_outparams_fn(buf, outparams)
class ll_fz_chartorune_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rune = property(_mupdf.ll_fz_chartorune_outparams_rune_get, _mupdf.ll_fz_chartorune_outparams_rune_set)

    def __init__(self):
        _mupdf.ll_fz_chartorune_outparams_swiginit(self, _mupdf.new_ll_fz_chartorune_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_chartorune_outparams

# Register ll_fz_chartorune_outparams in _mupdf:
_mupdf.ll_fz_chartorune_outparams_swigregister(ll_fz_chartorune_outparams)

def ll_fz_chartorune_outparams_fn(str, outparams):
    return _mupdf.ll_fz_chartorune_outparams_fn(str, outparams)
class ll_fz_clamp_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out = property(_mupdf.ll_fz_clamp_color_outparams_out_get, _mupdf.ll_fz_clamp_color_outparams_out_set)

    def __init__(self):
        _mupdf.ll_fz_clamp_color_outparams_swiginit(self, _mupdf.new_ll_fz_clamp_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_clamp_color_outparams

# Register ll_fz_clamp_color_outparams in _mupdf:
_mupdf.ll_fz_clamp_color_outparams_swigregister(ll_fz_clamp_color_outparams)

def ll_fz_clamp_color_outparams_fn(cs, _in, outparams):
    return _mupdf.ll_fz_clamp_color_outparams_fn(cs, _in, outparams)
class ll_fz_convert_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dv = property(_mupdf.ll_fz_convert_color_outparams_dv_get, _mupdf.ll_fz_convert_color_outparams_dv_set)

    def __init__(self):
        _mupdf.ll_fz_convert_color_outparams_swiginit(self, _mupdf.new_ll_fz_convert_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_convert_color_outparams

# Register ll_fz_convert_color_outparams in _mupdf:
_mupdf.ll_fz_convert_color_outparams_swigregister(ll_fz_convert_color_outparams)

def ll_fz_convert_color_outparams_fn(ss, sv, ds, _is, params, outparams):
    return _mupdf.ll_fz_convert_color_outparams_fn(ss, sv, ds, _is, params, outparams)
class ll_fz_convert_error_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_mupdf.ll_fz_convert_error_outparams_code_get, _mupdf.ll_fz_convert_error_outparams_code_set)

    def __init__(self):
        _mupdf.ll_fz_convert_error_outparams_swiginit(self, _mupdf.new_ll_fz_convert_error_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_convert_error_outparams

# Register ll_fz_convert_error_outparams in _mupdf:
_mupdf.ll_fz_convert_error_outparams_swigregister(ll_fz_convert_error_outparams)

def ll_fz_convert_error_outparams_fn(outparams):
    return _mupdf.ll_fz_convert_error_outparams_fn(outparams)
class ll_fz_convert_separation_colors_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dst_color = property(_mupdf.ll_fz_convert_separation_colors_outparams_dst_color_get, _mupdf.ll_fz_convert_separation_colors_outparams_dst_color_set)

    def __init__(self):
        _mupdf.ll_fz_convert_separation_colors_outparams_swiginit(self, _mupdf.new_ll_fz_convert_separation_colors_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_convert_separation_colors_outparams

# Register ll_fz_convert_separation_colors_outparams in _mupdf:
_mupdf.ll_fz_convert_separation_colors_outparams_swigregister(ll_fz_convert_separation_colors_outparams)

def ll_fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params, outparams):
    return _mupdf.ll_fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params, outparams)
class ll_fz_decomp_image_from_stream_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    l2extra = property(_mupdf.ll_fz_decomp_image_from_stream_outparams_l2extra_get, _mupdf.ll_fz_decomp_image_from_stream_outparams_l2extra_set)

    def __init__(self):
        _mupdf.ll_fz_decomp_image_from_stream_outparams_swiginit(self, _mupdf.new_ll_fz_decomp_image_from_stream_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_decomp_image_from_stream_outparams

# Register ll_fz_decomp_image_from_stream_outparams in _mupdf:
_mupdf.ll_fz_decomp_image_from_stream_outparams_swigregister(ll_fz_decomp_image_from_stream_outparams)

def ll_fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor, outparams):
    return _mupdf.ll_fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor, outparams)
class ll_fz_deflate_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compressed_length = property(_mupdf.ll_fz_deflate_outparams_compressed_length_get, _mupdf.ll_fz_deflate_outparams_compressed_length_set)

    def __init__(self):
        _mupdf.ll_fz_deflate_outparams_swiginit(self, _mupdf.new_ll_fz_deflate_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_deflate_outparams

# Register ll_fz_deflate_outparams in _mupdf:
_mupdf.ll_fz_deflate_outparams_swigregister(ll_fz_deflate_outparams)

def ll_fz_deflate_outparams_fn(dest, source, source_length, level, outparams):
    return _mupdf.ll_fz_deflate_outparams_fn(dest, source, source_length, level, outparams)
class ll_fz_dom_get_attribute_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    att = property(_mupdf.ll_fz_dom_get_attribute_outparams_att_get, _mupdf.ll_fz_dom_get_attribute_outparams_att_set)

    def __init__(self):
        _mupdf.ll_fz_dom_get_attribute_outparams_swiginit(self, _mupdf.new_ll_fz_dom_get_attribute_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_dom_get_attribute_outparams

# Register ll_fz_dom_get_attribute_outparams in _mupdf:
_mupdf.ll_fz_dom_get_attribute_outparams_swigregister(ll_fz_dom_get_attribute_outparams)

def ll_fz_dom_get_attribute_outparams_fn(elt, i, outparams):
    return _mupdf.ll_fz_dom_get_attribute_outparams_fn(elt, i, outparams)
class ll_fz_drop_imp_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_drop_imp_outparams_refs_get, _mupdf.ll_fz_drop_imp_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_drop_imp_outparams_swiginit(self, _mupdf.new_ll_fz_drop_imp_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_drop_imp_outparams

# Register ll_fz_drop_imp_outparams in _mupdf:
_mupdf.ll_fz_drop_imp_outparams_swigregister(ll_fz_drop_imp_outparams)

def ll_fz_drop_imp_outparams_fn(p, outparams):
    return _mupdf.ll_fz_drop_imp_outparams_fn(p, outparams)
class ll_fz_drop_imp16_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_drop_imp16_outparams_refs_get, _mupdf.ll_fz_drop_imp16_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_drop_imp16_outparams_swiginit(self, _mupdf.new_ll_fz_drop_imp16_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_drop_imp16_outparams

# Register ll_fz_drop_imp16_outparams in _mupdf:
_mupdf.ll_fz_drop_imp16_outparams_swigregister(ll_fz_drop_imp16_outparams)

def ll_fz_drop_imp16_outparams_fn(p, outparams):
    return _mupdf.ll_fz_drop_imp16_outparams_fn(p, outparams)
class ll_fz_encode_character_with_fallback_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out_font = property(_mupdf.ll_fz_encode_character_with_fallback_outparams_out_font_get, _mupdf.ll_fz_encode_character_with_fallback_outparams_out_font_set)

    def __init__(self):
        _mupdf.ll_fz_encode_character_with_fallback_outparams_swiginit(self, _mupdf.new_ll_fz_encode_character_with_fallback_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_encode_character_with_fallback_outparams

# Register ll_fz_encode_character_with_fallback_outparams in _mupdf:
_mupdf.ll_fz_encode_character_with_fallback_outparams_swigregister(ll_fz_encode_character_with_fallback_outparams)

def ll_fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language, outparams):
    return _mupdf.ll_fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language, outparams)
class ll_fz_error_callback_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.ll_fz_error_callback_outparams_user_get, _mupdf.ll_fz_error_callback_outparams_user_set)

    def __init__(self):
        _mupdf.ll_fz_error_callback_outparams_swiginit(self, _mupdf.new_ll_fz_error_callback_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_error_callback_outparams

# Register ll_fz_error_callback_outparams in _mupdf:
_mupdf.ll_fz_error_callback_outparams_swigregister(ll_fz_error_callback_outparams)

def ll_fz_error_callback_outparams_fn(outparams):
    return _mupdf.ll_fz_error_callback_outparams_fn(outparams)
class ll_fz_eval_function_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out = property(_mupdf.ll_fz_eval_function_outparams_out_get, _mupdf.ll_fz_eval_function_outparams_out_set)

    def __init__(self):
        _mupdf.ll_fz_eval_function_outparams_swiginit(self, _mupdf.new_ll_fz_eval_function_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_eval_function_outparams

# Register ll_fz_eval_function_outparams in _mupdf:
_mupdf.ll_fz_eval_function_outparams_swigregister(ll_fz_eval_function_outparams)

def ll_fz_eval_function_outparams_fn(func, _in, inlen, outlen, outparams):
    return _mupdf.ll_fz_eval_function_outparams_fn(func, _in, inlen, outlen, outparams)
class ll_fz_fill_pixmap_with_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    color = property(_mupdf.ll_fz_fill_pixmap_with_color_outparams_color_get, _mupdf.ll_fz_fill_pixmap_with_color_outparams_color_set)

    def __init__(self):
        _mupdf.ll_fz_fill_pixmap_with_color_outparams_swiginit(self, _mupdf.new_ll_fz_fill_pixmap_with_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_fill_pixmap_with_color_outparams

# Register ll_fz_fill_pixmap_with_color_outparams in _mupdf:
_mupdf.ll_fz_fill_pixmap_with_color_outparams_swigregister(ll_fz_fill_pixmap_with_color_outparams)

def ll_fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params, outparams):
    return _mupdf.ll_fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params, outparams)
class ll_fz_get_pixmap_from_image_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    w = property(_mupdf.ll_fz_get_pixmap_from_image_outparams_w_get, _mupdf.ll_fz_get_pixmap_from_image_outparams_w_set)
    h = property(_mupdf.ll_fz_get_pixmap_from_image_outparams_h_get, _mupdf.ll_fz_get_pixmap_from_image_outparams_h_set)

    def __init__(self):
        _mupdf.ll_fz_get_pixmap_from_image_outparams_swiginit(self, _mupdf.new_ll_fz_get_pixmap_from_image_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_get_pixmap_from_image_outparams

# Register ll_fz_get_pixmap_from_image_outparams in _mupdf:
_mupdf.ll_fz_get_pixmap_from_image_outparams_swigregister(ll_fz_get_pixmap_from_image_outparams)

def ll_fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm, outparams):
    return _mupdf.ll_fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm, outparams)
class ll_fz_getopt_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nargv = property(_mupdf.ll_fz_getopt_outparams_nargv_get, _mupdf.ll_fz_getopt_outparams_nargv_set)

    def __init__(self):
        _mupdf.ll_fz_getopt_outparams_swiginit(self, _mupdf.new_ll_fz_getopt_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_getopt_outparams

# Register ll_fz_getopt_outparams in _mupdf:
_mupdf.ll_fz_getopt_outparams_swigregister(ll_fz_getopt_outparams)

def ll_fz_getopt_outparams_fn(nargc, ostr, outparams):
    return _mupdf.ll_fz_getopt_outparams_fn(nargc, ostr, outparams)
class ll_fz_getopt_long_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nargv = property(_mupdf.ll_fz_getopt_long_outparams_nargv_get, _mupdf.ll_fz_getopt_long_outparams_nargv_set)

    def __init__(self):
        _mupdf.ll_fz_getopt_long_outparams_swiginit(self, _mupdf.new_ll_fz_getopt_long_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_getopt_long_outparams

# Register ll_fz_getopt_long_outparams in _mupdf:
_mupdf.ll_fz_getopt_long_outparams_swigregister(ll_fz_getopt_long_outparams)

def ll_fz_getopt_long_outparams_fn(nargc, ostr, longopts, outparams):
    return _mupdf.ll_fz_getopt_long_outparams_fn(nargc, ostr, longopts, outparams)
class ll_fz_grisu_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    exp = property(_mupdf.ll_fz_grisu_outparams_exp_get, _mupdf.ll_fz_grisu_outparams_exp_set)

    def __init__(self):
        _mupdf.ll_fz_grisu_outparams_swiginit(self, _mupdf.new_ll_fz_grisu_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_grisu_outparams

# Register ll_fz_grisu_outparams in _mupdf:
_mupdf.ll_fz_grisu_outparams_swigregister(ll_fz_grisu_outparams)

def ll_fz_grisu_outparams_fn(f, s, outparams):
    return _mupdf.ll_fz_grisu_outparams_fn(f, s, outparams)
class ll_fz_has_option_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    val = property(_mupdf.ll_fz_has_option_outparams_val_get, _mupdf.ll_fz_has_option_outparams_val_set)

    def __init__(self):
        _mupdf.ll_fz_has_option_outparams_swiginit(self, _mupdf.new_ll_fz_has_option_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_has_option_outparams

# Register ll_fz_has_option_outparams in _mupdf:
_mupdf.ll_fz_has_option_outparams_swigregister(ll_fz_has_option_outparams)

def ll_fz_has_option_outparams_fn(opts, key, outparams):
    return _mupdf.ll_fz_has_option_outparams_fn(opts, key, outparams)
class ll_fz_image_resolution_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    xres = property(_mupdf.ll_fz_image_resolution_outparams_xres_get, _mupdf.ll_fz_image_resolution_outparams_xres_set)
    yres = property(_mupdf.ll_fz_image_resolution_outparams_yres_get, _mupdf.ll_fz_image_resolution_outparams_yres_set)

    def __init__(self):
        _mupdf.ll_fz_image_resolution_outparams_swiginit(self, _mupdf.new_ll_fz_image_resolution_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_image_resolution_outparams

# Register ll_fz_image_resolution_outparams in _mupdf:
_mupdf.ll_fz_image_resolution_outparams_swigregister(ll_fz_image_resolution_outparams)

def ll_fz_image_resolution_outparams_fn(image, outparams):
    return _mupdf.ll_fz_image_resolution_outparams_fn(image, outparams)
class ll_fz_keep_imp_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_keep_imp_outparams_refs_get, _mupdf.ll_fz_keep_imp_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_keep_imp_outparams_swiginit(self, _mupdf.new_ll_fz_keep_imp_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_keep_imp_outparams

# Register ll_fz_keep_imp_outparams in _mupdf:
_mupdf.ll_fz_keep_imp_outparams_swigregister(ll_fz_keep_imp_outparams)

def ll_fz_keep_imp_outparams_fn(p, outparams):
    return _mupdf.ll_fz_keep_imp_outparams_fn(p, outparams)
class ll_fz_keep_imp16_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_keep_imp16_outparams_refs_get, _mupdf.ll_fz_keep_imp16_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_keep_imp16_outparams_swiginit(self, _mupdf.new_ll_fz_keep_imp16_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_keep_imp16_outparams

# Register ll_fz_keep_imp16_outparams in _mupdf:
_mupdf.ll_fz_keep_imp16_outparams_swigregister(ll_fz_keep_imp16_outparams)

def ll_fz_keep_imp16_outparams_fn(p, outparams):
    return _mupdf.ll_fz_keep_imp16_outparams_fn(p, outparams)
class ll_fz_keep_imp_locked_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_keep_imp_locked_outparams_refs_get, _mupdf.ll_fz_keep_imp_locked_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_keep_imp_locked_outparams_swiginit(self, _mupdf.new_ll_fz_keep_imp_locked_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_keep_imp_locked_outparams

# Register ll_fz_keep_imp_locked_outparams in _mupdf:
_mupdf.ll_fz_keep_imp_locked_outparams_swigregister(ll_fz_keep_imp_locked_outparams)

def ll_fz_keep_imp_locked_outparams_fn(p, outparams):
    return _mupdf.ll_fz_keep_imp_locked_outparams_fn(p, outparams)
class ll_fz_lookup_base14_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_base14_font_outparams_len_get, _mupdf.ll_fz_lookup_base14_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_base14_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_base14_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_base14_font_outparams

# Register ll_fz_lookup_base14_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_base14_font_outparams_swigregister(ll_fz_lookup_base14_font_outparams)

def ll_fz_lookup_base14_font_outparams_fn(name, outparams):
    return _mupdf.ll_fz_lookup_base14_font_outparams_fn(name, outparams)
class ll_fz_lookup_builtin_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_builtin_font_outparams_len_get, _mupdf.ll_fz_lookup_builtin_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_builtin_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_builtin_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_builtin_font_outparams

# Register ll_fz_lookup_builtin_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_builtin_font_outparams_swigregister(ll_fz_lookup_builtin_font_outparams)

def ll_fz_lookup_builtin_font_outparams_fn(name, bold, italic, outparams):
    return _mupdf.ll_fz_lookup_builtin_font_outparams_fn(name, bold, italic, outparams)
class ll_fz_lookup_cjk_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_cjk_font_outparams_len_get, _mupdf.ll_fz_lookup_cjk_font_outparams_len_set)
    index = property(_mupdf.ll_fz_lookup_cjk_font_outparams_index_get, _mupdf.ll_fz_lookup_cjk_font_outparams_index_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_cjk_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_cjk_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_cjk_font_outparams

# Register ll_fz_lookup_cjk_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_cjk_font_outparams_swigregister(ll_fz_lookup_cjk_font_outparams)

def ll_fz_lookup_cjk_font_outparams_fn(ordering, outparams):
    return _mupdf.ll_fz_lookup_cjk_font_outparams_fn(ordering, outparams)
class ll_fz_lookup_cjk_font_by_language_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_cjk_font_by_language_outparams_len_get, _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_len_set)
    subfont = property(_mupdf.ll_fz_lookup_cjk_font_by_language_outparams_subfont_get, _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_subfont_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_cjk_font_by_language_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_cjk_font_by_language_outparams

# Register ll_fz_lookup_cjk_font_by_language_outparams in _mupdf:
_mupdf.ll_fz_lookup_cjk_font_by_language_outparams_swigregister(ll_fz_lookup_cjk_font_by_language_outparams)

def ll_fz_lookup_cjk_font_by_language_outparams_fn(lang, outparams):
    return _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_fn(lang, outparams)
class ll_fz_lookup_noto_boxes_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_boxes_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_boxes_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_boxes_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_boxes_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_boxes_font_outparams

# Register ll_fz_lookup_noto_boxes_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_boxes_font_outparams_swigregister(ll_fz_lookup_noto_boxes_font_outparams)

def ll_fz_lookup_noto_boxes_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_boxes_font_outparams_fn(outparams)
class ll_fz_lookup_noto_emoji_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_emoji_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_emoji_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_emoji_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_emoji_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_emoji_font_outparams

# Register ll_fz_lookup_noto_emoji_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_emoji_font_outparams_swigregister(ll_fz_lookup_noto_emoji_font_outparams)

def ll_fz_lookup_noto_emoji_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_emoji_font_outparams_fn(outparams)
class ll_fz_lookup_noto_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_font_outparams_len_set)
    subfont = property(_mupdf.ll_fz_lookup_noto_font_outparams_subfont_get, _mupdf.ll_fz_lookup_noto_font_outparams_subfont_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_font_outparams

# Register ll_fz_lookup_noto_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_font_outparams_swigregister(ll_fz_lookup_noto_font_outparams)

def ll_fz_lookup_noto_font_outparams_fn(script, lang, outparams):
    return _mupdf.ll_fz_lookup_noto_font_outparams_fn(script, lang, outparams)
class ll_fz_lookup_noto_math_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_math_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_math_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_math_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_math_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_math_font_outparams

# Register ll_fz_lookup_noto_math_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_math_font_outparams_swigregister(ll_fz_lookup_noto_math_font_outparams)

def ll_fz_lookup_noto_math_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_math_font_outparams_fn(outparams)
class ll_fz_lookup_noto_music_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_music_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_music_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_music_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_music_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_music_font_outparams

# Register ll_fz_lookup_noto_music_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_music_font_outparams_swigregister(ll_fz_lookup_noto_music_font_outparams)

def ll_fz_lookup_noto_music_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_music_font_outparams_fn(outparams)
class ll_fz_lookup_noto_symbol1_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_symbol1_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_symbol1_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_symbol1_font_outparams

# Register ll_fz_lookup_noto_symbol1_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_symbol1_font_outparams_swigregister(ll_fz_lookup_noto_symbol1_font_outparams)

def ll_fz_lookup_noto_symbol1_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_fn(outparams)
class ll_fz_lookup_noto_symbol2_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_symbol2_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_symbol2_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_symbol2_font_outparams

# Register ll_fz_lookup_noto_symbol2_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_symbol2_font_outparams_swigregister(ll_fz_lookup_noto_symbol2_font_outparams)

def ll_fz_lookup_noto_symbol2_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_fn(outparams)
class ll_fz_new_deflated_data_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compressed_length = property(_mupdf.ll_fz_new_deflated_data_outparams_compressed_length_get, _mupdf.ll_fz_new_deflated_data_outparams_compressed_length_set)

    def __init__(self):
        _mupdf.ll_fz_new_deflated_data_outparams_swiginit(self, _mupdf.new_ll_fz_new_deflated_data_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_deflated_data_outparams

# Register ll_fz_new_deflated_data_outparams in _mupdf:
_mupdf.ll_fz_new_deflated_data_outparams_swigregister(ll_fz_new_deflated_data_outparams)

def ll_fz_new_deflated_data_outparams_fn(source, source_length, level, outparams):
    return _mupdf.ll_fz_new_deflated_data_outparams_fn(source, source_length, level, outparams)
class ll_fz_new_deflated_data_from_buffer_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compressed_length = property(_mupdf.ll_fz_new_deflated_data_from_buffer_outparams_compressed_length_get, _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_compressed_length_set)

    def __init__(self):
        _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_swiginit(self, _mupdf.new_ll_fz_new_deflated_data_from_buffer_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_deflated_data_from_buffer_outparams

# Register ll_fz_new_deflated_data_from_buffer_outparams in _mupdf:
_mupdf.ll_fz_new_deflated_data_from_buffer_outparams_swigregister(ll_fz_new_deflated_data_from_buffer_outparams)

def ll_fz_new_deflated_data_from_buffer_outparams_fn(buffer, level, outparams):
    return _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_fn(buffer, level, outparams)
class ll_fz_new_display_list_from_svg_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    w = property(_mupdf.ll_fz_new_display_list_from_svg_outparams_w_get, _mupdf.ll_fz_new_display_list_from_svg_outparams_w_set)
    h = property(_mupdf.ll_fz_new_display_list_from_svg_outparams_h_get, _mupdf.ll_fz_new_display_list_from_svg_outparams_h_set)

    def __init__(self):
        _mupdf.ll_fz_new_display_list_from_svg_outparams_swiginit(self, _mupdf.new_ll_fz_new_display_list_from_svg_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_display_list_from_svg_outparams

# Register ll_fz_new_display_list_from_svg_outparams in _mupdf:
_mupdf.ll_fz_new_display_list_from_svg_outparams_swigregister(ll_fz_new_display_list_from_svg_outparams)

def ll_fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir, outparams):
    return _mupdf.ll_fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir, outparams)
class ll_fz_new_display_list_from_svg_xml_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    w = property(_mupdf.ll_fz_new_display_list_from_svg_xml_outparams_w_get, _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_w_set)
    h = property(_mupdf.ll_fz_new_display_list_from_svg_xml_outparams_h_get, _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_h_set)

    def __init__(self):
        _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_swiginit(self, _mupdf.new_ll_fz_new_display_list_from_svg_xml_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_display_list_from_svg_xml_outparams

# Register ll_fz_new_display_list_from_svg_xml_outparams in _mupdf:
_mupdf.ll_fz_new_display_list_from_svg_xml_outparams_swigregister(ll_fz_new_display_list_from_svg_xml_outparams)

def ll_fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir, outparams):
    return _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir, outparams)
class ll_fz_new_draw_device_with_options_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pixmap = property(_mupdf.ll_fz_new_draw_device_with_options_outparams_pixmap_get, _mupdf.ll_fz_new_draw_device_with_options_outparams_pixmap_set)

    def __init__(self):
        _mupdf.ll_fz_new_draw_device_with_options_outparams_swiginit(self, _mupdf.new_ll_fz_new_draw_device_with_options_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_draw_device_with_options_outparams

# Register ll_fz_new_draw_device_with_options_outparams in _mupdf:
_mupdf.ll_fz_new_draw_device_with_options_outparams_swigregister(ll_fz_new_draw_device_with_options_outparams)

def ll_fz_new_draw_device_with_options_outparams_fn(options, mediabox, outparams):
    return _mupdf.ll_fz_new_draw_device_with_options_outparams_fn(options, mediabox, outparams)
class ll_fz_new_svg_device_with_id_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id = property(_mupdf.ll_fz_new_svg_device_with_id_outparams_id_get, _mupdf.ll_fz_new_svg_device_with_id_outparams_id_set)

    def __init__(self):
        _mupdf.ll_fz_new_svg_device_with_id_outparams_swiginit(self, _mupdf.new_ll_fz_new_svg_device_with_id_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_svg_device_with_id_outparams

# Register ll_fz_new_svg_device_with_id_outparams in _mupdf:
_mupdf.ll_fz_new_svg_device_with_id_outparams_swigregister(ll_fz_new_svg_device_with_id_outparams)

def ll_fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images, outparams):
    return _mupdf.ll_fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images, outparams)
class ll_fz_new_test_device_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_color = property(_mupdf.ll_fz_new_test_device_outparams_is_color_get, _mupdf.ll_fz_new_test_device_outparams_is_color_set)

    def __init__(self):
        _mupdf.ll_fz_new_test_device_outparams_swiginit(self, _mupdf.new_ll_fz_new_test_device_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_test_device_outparams

# Register ll_fz_new_test_device_outparams in _mupdf:
_mupdf.ll_fz_new_test_device_outparams_swigregister(ll_fz_new_test_device_outparams)

def ll_fz_new_test_device_outparams_fn(threshold, options, passthrough, outparams):
    return _mupdf.ll_fz_new_test_device_outparams_fn(threshold, options, passthrough, outparams)
class ll_fz_open_image_decomp_stream_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    l2factor = property(_mupdf.ll_fz_open_image_decomp_stream_outparams_l2factor_get, _mupdf.ll_fz_open_image_decomp_stream_outparams_l2factor_set)

    def __init__(self):
        _mupdf.ll_fz_open_image_decomp_stream_outparams_swiginit(self, _mupdf.new_ll_fz_open_image_decomp_stream_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_open_image_decomp_stream_outparams

# Register ll_fz_open_image_decomp_stream_outparams in _mupdf:
_mupdf.ll_fz_open_image_decomp_stream_outparams_swigregister(ll_fz_open_image_decomp_stream_outparams)

def ll_fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1, outparams):
    return _mupdf.ll_fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1, outparams)
class ll_fz_open_image_decomp_stream_from_buffer_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    l2factor = property(_mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_l2factor_get, _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_l2factor_set)

    def __init__(self):
        _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_swiginit(self, _mupdf.new_ll_fz_open_image_decomp_stream_from_buffer_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_open_image_decomp_stream_from_buffer_outparams

# Register ll_fz_open_image_decomp_stream_from_buffer_outparams in _mupdf:
_mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_swigregister(ll_fz_open_image_decomp_stream_from_buffer_outparams)

def ll_fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0, outparams):
    return _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0, outparams)
class ll_fz_page_presentation_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    duration = property(_mupdf.ll_fz_page_presentation_outparams_duration_get, _mupdf.ll_fz_page_presentation_outparams_duration_set)

    def __init__(self):
        _mupdf.ll_fz_page_presentation_outparams_swiginit(self, _mupdf.new_ll_fz_page_presentation_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_page_presentation_outparams

# Register ll_fz_page_presentation_outparams in _mupdf:
_mupdf.ll_fz_page_presentation_outparams_swigregister(ll_fz_page_presentation_outparams)

def ll_fz_page_presentation_outparams_fn(page, transition, outparams):
    return _mupdf.ll_fz_page_presentation_outparams_fn(page, transition, outparams)
class ll_fz_paint_shade_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cache = property(_mupdf.ll_fz_paint_shade_outparams_cache_get, _mupdf.ll_fz_paint_shade_outparams_cache_set)

    def __init__(self):
        _mupdf.ll_fz_paint_shade_outparams_swiginit(self, _mupdf.new_ll_fz_paint_shade_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_paint_shade_outparams

# Register ll_fz_paint_shade_outparams in _mupdf:
_mupdf.ll_fz_paint_shade_outparams_swigregister(ll_fz_paint_shade_outparams)

def ll_fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop, outparams):
    return _mupdf.ll_fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop, outparams)
class ll_fz_parse_page_range_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    a = property(_mupdf.ll_fz_parse_page_range_outparams_a_get, _mupdf.ll_fz_parse_page_range_outparams_a_set)
    b = property(_mupdf.ll_fz_parse_page_range_outparams_b_get, _mupdf.ll_fz_parse_page_range_outparams_b_set)

    def __init__(self):
        _mupdf.ll_fz_parse_page_range_outparams_swiginit(self, _mupdf.new_ll_fz_parse_page_range_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_parse_page_range_outparams

# Register ll_fz_parse_page_range_outparams in _mupdf:
_mupdf.ll_fz_parse_page_range_outparams_swigregister(ll_fz_parse_page_range_outparams)

def ll_fz_parse_page_range_outparams_fn(s, n, outparams):
    return _mupdf.ll_fz_parse_page_range_outparams_fn(s, n, outparams)
class ll_fz_read_best_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    truncated = property(_mupdf.ll_fz_read_best_outparams_truncated_get, _mupdf.ll_fz_read_best_outparams_truncated_set)

    def __init__(self):
        _mupdf.ll_fz_read_best_outparams_swiginit(self, _mupdf.new_ll_fz_read_best_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_read_best_outparams

# Register ll_fz_read_best_outparams in _mupdf:
_mupdf.ll_fz_read_best_outparams_swigregister(ll_fz_read_best_outparams)

def ll_fz_read_best_outparams_fn(stm, initial, worst_case, outparams):
    return _mupdf.ll_fz_read_best_outparams_fn(stm, initial, worst_case, outparams)
class ll_fz_resolve_link_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    xp = property(_mupdf.ll_fz_resolve_link_outparams_xp_get, _mupdf.ll_fz_resolve_link_outparams_xp_set)
    yp = property(_mupdf.ll_fz_resolve_link_outparams_yp_get, _mupdf.ll_fz_resolve_link_outparams_yp_set)

    def __init__(self):
        _mupdf.ll_fz_resolve_link_outparams_swiginit(self, _mupdf.new_ll_fz_resolve_link_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_resolve_link_outparams

# Register ll_fz_resolve_link_outparams in _mupdf:
_mupdf.ll_fz_resolve_link_outparams_swigregister(ll_fz_resolve_link_outparams)

def ll_fz_resolve_link_outparams_fn(doc, uri, outparams):
    return _mupdf.ll_fz_resolve_link_outparams_fn(doc, uri, outparams)
class ll_fz_search_chapter_page_number_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_chapter_page_number_outparams_hit_mark_get, _mupdf.ll_fz_search_chapter_page_number_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_chapter_page_number_outparams_swiginit(self, _mupdf.new_ll_fz_search_chapter_page_number_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_chapter_page_number_outparams

# Register ll_fz_search_chapter_page_number_outparams in _mupdf:
_mupdf.ll_fz_search_chapter_page_number_outparams_swigregister(ll_fz_search_chapter_page_number_outparams)

def ll_fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max, outparams)
class ll_fz_search_display_list_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_display_list_outparams_hit_mark_get, _mupdf.ll_fz_search_display_list_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_display_list_outparams_swiginit(self, _mupdf.new_ll_fz_search_display_list_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_display_list_outparams

# Register ll_fz_search_display_list_outparams in _mupdf:
_mupdf.ll_fz_search_display_list_outparams_swigregister(ll_fz_search_display_list_outparams)

def ll_fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max, outparams)
class ll_fz_search_page_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_page_outparams_hit_mark_get, _mupdf.ll_fz_search_page_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_page_outparams_swiginit(self, _mupdf.new_ll_fz_search_page_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_page_outparams

# Register ll_fz_search_page_outparams in _mupdf:
_mupdf.ll_fz_search_page_outparams_swigregister(ll_fz_search_page_outparams)

def ll_fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max, outparams)
class ll_fz_search_page_number_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_page_number_outparams_hit_mark_get, _mupdf.ll_fz_search_page_number_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_page_number_outparams_swiginit(self, _mupdf.new_ll_fz_search_page_number_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_page_number_outparams

# Register ll_fz_search_page_number_outparams in _mupdf:
_mupdf.ll_fz_search_page_number_outparams_swigregister(ll_fz_search_page_number_outparams)

def ll_fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max, outparams)
class ll_fz_search_stext_page_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_stext_page_outparams_hit_mark_get, _mupdf.ll_fz_search_stext_page_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_stext_page_outparams_swiginit(self, _mupdf.new_ll_fz_search_stext_page_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_stext_page_outparams

# Register ll_fz_search_stext_page_outparams in _mupdf:
_mupdf.ll_fz_search_stext_page_outparams_swigregister(ll_fz_search_stext_page_outparams)

def ll_fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max, outparams)
class ll_fz_separation_equivalent_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dst_color = property(_mupdf.ll_fz_separation_equivalent_outparams_dst_color_get, _mupdf.ll_fz_separation_equivalent_outparams_dst_color_set)

    def __init__(self):
        _mupdf.ll_fz_separation_equivalent_outparams_swiginit(self, _mupdf.new_ll_fz_separation_equivalent_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_separation_equivalent_outparams

# Register ll_fz_separation_equivalent_outparams in _mupdf:
_mupdf.ll_fz_separation_equivalent_outparams_swigregister(ll_fz_separation_equivalent_outparams)

def ll_fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params, outparams):
    return _mupdf.ll_fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params, outparams)
class ll_fz_store_scavenge_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    phase = property(_mupdf.ll_fz_store_scavenge_outparams_phase_get, _mupdf.ll_fz_store_scavenge_outparams_phase_set)

    def __init__(self):
        _mupdf.ll_fz_store_scavenge_outparams_swiginit(self, _mupdf.new_ll_fz_store_scavenge_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_store_scavenge_outparams

# Register ll_fz_store_scavenge_outparams in _mupdf:
_mupdf.ll_fz_store_scavenge_outparams_swigregister(ll_fz_store_scavenge_outparams)

def ll_fz_store_scavenge_outparams_fn(size, outparams):
    return _mupdf.ll_fz_store_scavenge_outparams_fn(size, outparams)
class ll_fz_store_scavenge_external_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    phase = property(_mupdf.ll_fz_store_scavenge_external_outparams_phase_get, _mupdf.ll_fz_store_scavenge_external_outparams_phase_set)

    def __init__(self):
        _mupdf.ll_fz_store_scavenge_external_outparams_swiginit(self, _mupdf.new_ll_fz_store_scavenge_external_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_store_scavenge_external_outparams

# Register ll_fz_store_scavenge_external_outparams in _mupdf:
_mupdf.ll_fz_store_scavenge_external_outparams_swigregister(ll_fz_store_scavenge_external_outparams)

def ll_fz_store_scavenge_external_outparams_fn(size, outparams):
    return _mupdf.ll_fz_store_scavenge_external_outparams_fn(size, outparams)
class ll_fz_strsep_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    stringp = property(_mupdf.ll_fz_strsep_outparams_stringp_get, _mupdf.ll_fz_strsep_outparams_stringp_set)

    def __init__(self):
        _mupdf.ll_fz_strsep_outparams_swiginit(self, _mupdf.new_ll_fz_strsep_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_strsep_outparams

# Register ll_fz_strsep_outparams in _mupdf:
_mupdf.ll_fz_strsep_outparams_swigregister(ll_fz_strsep_outparams)

def ll_fz_strsep_outparams_fn(delim, outparams):
    return _mupdf.ll_fz_strsep_outparams_fn(delim, outparams)
class ll_fz_strtof_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    es = property(_mupdf.ll_fz_strtof_outparams_es_get, _mupdf.ll_fz_strtof_outparams_es_set)

    def __init__(self):
        _mupdf.ll_fz_strtof_outparams_swiginit(self, _mupdf.new_ll_fz_strtof_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_strtof_outparams

# Register ll_fz_strtof_outparams in _mupdf:
_mupdf.ll_fz_strtof_outparams_swigregister(ll_fz_strtof_outparams)

def ll_fz_strtof_outparams_fn(s, outparams):
    return _mupdf.ll_fz_strtof_outparams_fn(s, outparams)
class ll_fz_subset_cff_for_gids_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    gids = property(_mupdf.ll_fz_subset_cff_for_gids_outparams_gids_get, _mupdf.ll_fz_subset_cff_for_gids_outparams_gids_set)

    def __init__(self):
        _mupdf.ll_fz_subset_cff_for_gids_outparams_swiginit(self, _mupdf.new_ll_fz_subset_cff_for_gids_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_subset_cff_for_gids_outparams

# Register ll_fz_subset_cff_for_gids_outparams in _mupdf:
_mupdf.ll_fz_subset_cff_for_gids_outparams_swigregister(ll_fz_subset_cff_for_gids_outparams)

def ll_fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams):
    return _mupdf.ll_fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
class ll_fz_subset_ttf_for_gids_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    gids = property(_mupdf.ll_fz_subset_ttf_for_gids_outparams_gids_get, _mupdf.ll_fz_subset_ttf_for_gids_outparams_gids_set)

    def __init__(self):
        _mupdf.ll_fz_subset_ttf_for_gids_outparams_swiginit(self, _mupdf.new_ll_fz_subset_ttf_for_gids_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_subset_ttf_for_gids_outparams

# Register ll_fz_subset_ttf_for_gids_outparams in _mupdf:
_mupdf.ll_fz_subset_ttf_for_gids_outparams_swigregister(ll_fz_subset_ttf_for_gids_outparams)

def ll_fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams):
    return _mupdf.ll_fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
class ll_fz_warning_callback_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.ll_fz_warning_callback_outparams_user_get, _mupdf.ll_fz_warning_callback_outparams_user_set)

    def __init__(self):
        _mupdf.ll_fz_warning_callback_outparams_swiginit(self, _mupdf.new_ll_fz_warning_callback_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_warning_callback_outparams

# Register ll_fz_warning_callback_outparams in _mupdf:
_mupdf.ll_fz_warning_callback_outparams_swigregister(ll_fz_warning_callback_outparams)

def ll_fz_warning_callback_outparams_fn(outparams):
    return _mupdf.ll_fz_warning_callback_outparams_fn(outparams)
class ll_pdf_annot_MK_BC_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_mupdf.ll_pdf_annot_MK_BC_outparams_n_get, _mupdf.ll_pdf_annot_MK_BC_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_MK_BC_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_MK_BC_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_MK_BC_outparams

# Register ll_pdf_annot_MK_BC_outparams in _mupdf:
_mupdf.ll_pdf_annot_MK_BC_outparams_swigregister(ll_pdf_annot_MK_BC_outparams)

def ll_pdf_annot_MK_BC_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_MK_BC_outparams_fn(annot, color, outparams)
class ll_pdf_annot_MK_BG_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_mupdf.ll_pdf_annot_MK_BG_outparams_n_get, _mupdf.ll_pdf_annot_MK_BG_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_MK_BG_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_MK_BG_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_MK_BG_outparams

# Register ll_pdf_annot_MK_BG_outparams in _mupdf:
_mupdf.ll_pdf_annot_MK_BG_outparams_swigregister(ll_pdf_annot_MK_BG_outparams)

def ll_pdf_annot_MK_BG_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_MK_BG_outparams_fn(annot, color, outparams)
class ll_pdf_annot_callout_line_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_mupdf.ll_pdf_annot_callout_line_outparams_n_get, _mupdf.ll_pdf_annot_callout_line_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_callout_line_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_callout_line_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_callout_line_outparams

# Register ll_pdf_annot_callout_line_outparams in _mupdf:
_mupdf.ll_pdf_annot_callout_line_outparams_swigregister(ll_pdf_annot_callout_line_outparams)

def ll_pdf_annot_callout_line_outparams_fn(annot, callout, outparams):
    return _mupdf.ll_pdf_annot_callout_line_outparams_fn(annot, callout, outparams)
class ll_pdf_annot_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_mupdf.ll_pdf_annot_color_outparams_n_get, _mupdf.ll_pdf_annot_color_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_color_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_color_outparams

# Register ll_pdf_annot_color_outparams in _mupdf:
_mupdf.ll_pdf_annot_color_outparams_swigregister(ll_pdf_annot_color_outparams)

def ll_pdf_annot_color_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_color_outparams_fn(annot, color, outparams)
class ll_pdf_annot_default_appearance_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    font = property(_mupdf.ll_pdf_annot_default_appearance_outparams_font_get, _mupdf.ll_pdf_annot_default_appearance_outparams_font_set)
    size = property(_mupdf.ll_pdf_annot_default_appearance_outparams_size_get, _mupdf.ll_pdf_annot_default_appearance_outparams_size_set)
    n = property(_mupdf.ll_pdf_annot_default_appearance_outparams_n_get, _mupdf.ll_pdf_annot_default_appearance_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_default_appearance_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_default_appearance_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_default_appearance_outparams

# Register ll_pdf_annot_default_appearance_outparams in _mupdf:
_mupdf.ll_pdf_annot_default_appearance_outparams_swigregister(ll_pdf_annot_default_appearance_outparams)

def ll_pdf_annot_default_appearance_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_default_appearance_outparams_fn(annot, color, outparams)
class ll_pdf_annot_default_appearance_unmapped_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    size = property(_mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_size_get, _mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_size_set)
    n = property(_mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_n_get, _mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_default_appearance_unmapped_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_default_appearance_unmapped_outparams

# Register ll_pdf_annot_default_appearance_unmapped_outparams in _mupdf:
_mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_swigregister(ll_pdf_annot_default_appearance_unmapped_outparams)

def ll_pdf_annot_default_appearance_unmapped_outparams_fn(annot, font_name, font_name_len, color, outparams):
    return _mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_fn(annot, font_name, font_name_len, color, outparams)
class ll_pdf_annot_interior_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_mupdf.ll_pdf_annot_interior_color_outparams_n_get, _mupdf.ll_pdf_annot_interior_color_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_interior_color_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_interior_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_interior_color_outparams

# Register ll_pdf_annot_interior_color_outparams in _mupdf:
_mupdf.ll_pdf_annot_interior_color_outparams_swigregister(ll_pdf_annot_interior_color_outparams)

def ll_pdf_annot_interior_color_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_interior_color_outparams_fn(annot, color, outparams)
class ll_pdf_annot_line_ending_styles_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    start_style = property(_mupdf.ll_pdf_annot_line_ending_styles_outparams_start_style_get, _mupdf.ll_pdf_annot_line_ending_styles_outparams_start_style_set)
    end_style = property(_mupdf.ll_pdf_annot_line_ending_styles_outparams_end_style_get, _mupdf.ll_pdf_annot_line_ending_styles_outparams_end_style_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_line_ending_styles_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_line_ending_styles_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_line_ending_styles_outparams

# Register ll_pdf_annot_line_ending_styles_outparams in _mupdf:
_mupdf.ll_pdf_annot_line_ending_styles_outparams_swigregister(ll_pdf_annot_line_ending_styles_outparams)

def ll_pdf_annot_line_ending_styles_outparams_fn(annot, outparams):
    return _mupdf.ll_pdf_annot_line_ending_styles_outparams_fn(annot, outparams)
class ll_pdf_array_get_string_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sizep = property(_mupdf.ll_pdf_array_get_string_outparams_sizep_get, _mupdf.ll_pdf_array_get_string_outparams_sizep_set)

    def __init__(self):
        _mupdf.ll_pdf_array_get_string_outparams_swiginit(self, _mupdf.new_ll_pdf_array_get_string_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_array_get_string_outparams

# Register ll_pdf_array_get_string_outparams in _mupdf:
_mupdf.ll_pdf_array_get_string_outparams_swigregister(ll_pdf_array_get_string_outparams)

def ll_pdf_array_get_string_outparams_fn(array, index, outparams):
    return _mupdf.ll_pdf_array_get_string_outparams_fn(array, index, outparams)
class ll_pdf_count_q_balance_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    prepend = property(_mupdf.ll_pdf_count_q_balance_outparams_prepend_get, _mupdf.ll_pdf_count_q_balance_outparams_prepend_set)
    append = property(_mupdf.ll_pdf_count_q_balance_outparams_append_get, _mupdf.ll_pdf_count_q_balance_outparams_append_set)

    def __init__(self):
        _mupdf.ll_pdf_count_q_balance_outparams_swiginit(self, _mupdf.new_ll_pdf_count_q_balance_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_count_q_balance_outparams

# Register ll_pdf_count_q_balance_outparams in _mupdf:
_mupdf.ll_pdf_count_q_balance_outparams_swigregister(ll_pdf_count_q_balance_outparams)

def ll_pdf_count_q_balance_outparams_fn(doc, res, stm, outparams):
    return _mupdf.ll_pdf_count_q_balance_outparams_fn(doc, res, stm, outparams)
class ll_pdf_decode_cmap_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cpt = property(_mupdf.ll_pdf_decode_cmap_outparams_cpt_get, _mupdf.ll_pdf_decode_cmap_outparams_cpt_set)

    def __init__(self):
        _mupdf.ll_pdf_decode_cmap_outparams_swiginit(self, _mupdf.new_ll_pdf_decode_cmap_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_decode_cmap_outparams

# Register ll_pdf_decode_cmap_outparams in _mupdf:
_mupdf.ll_pdf_decode_cmap_outparams_swigregister(ll_pdf_decode_cmap_outparams)

def ll_pdf_decode_cmap_outparams_fn(cmap, s, e, outparams):
    return _mupdf.ll_pdf_decode_cmap_outparams_fn(cmap, s, e, outparams)
class ll_pdf_dict_get_inheritable_string_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sizep = property(_mupdf.ll_pdf_dict_get_inheritable_string_outparams_sizep_get, _mupdf.ll_pdf_dict_get_inheritable_string_outparams_sizep_set)

    def __init__(self):
        _mupdf.ll_pdf_dict_get_inheritable_string_outparams_swiginit(self, _mupdf.new_ll_pdf_dict_get_inheritable_string_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_dict_get_inheritable_string_outparams

# Register ll_pdf_dict_get_inheritable_string_outparams in _mupdf:
_mupdf.ll_pdf_dict_get_inheritable_string_outparams_swigregister(ll_pdf_dict_get_inheritable_string_outparams)

def ll_pdf_dict_get_inheritable_string_outparams_fn(dict, key, outparams):
    return _mupdf.ll_pdf_dict_get_inheritable_string_outparams_fn(dict, key, outparams)
class ll_pdf_dict_get_put_drop_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    old_val = property(_mupdf.ll_pdf_dict_get_put_drop_outparams_old_val_get, _mupdf.ll_pdf_dict_get_put_drop_outparams_old_val_set)

    def __init__(self):
        _mupdf.ll_pdf_dict_get_put_drop_outparams_swiginit(self, _mupdf.new_ll_pdf_dict_get_put_drop_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_dict_get_put_drop_outparams

# Register ll_pdf_dict_get_put_drop_outparams in _mupdf:
_mupdf.ll_pdf_dict_get_put_drop_outparams_swigregister(ll_pdf_dict_get_put_drop_outparams)

def ll_pdf_dict_get_put_drop_outparams_fn(dict, key, val, outparams):
    return _mupdf.ll_pdf_dict_get_put_drop_outparams_fn(dict, key, val, outparams)
class ll_pdf_dict_get_string_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sizep = property(_mupdf.ll_pdf_dict_get_string_outparams_sizep_get, _mupdf.ll_pdf_dict_get_string_outparams_sizep_set)

    def __init__(self):
        _mupdf.ll_pdf_dict_get_string_outparams_swiginit(self, _mupdf.new_ll_pdf_dict_get_string_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_dict_get_string_outparams

# Register ll_pdf_dict_get_string_outparams in _mupdf:
_mupdf.ll_pdf_dict_get_string_outparams_swigregister(ll_pdf_dict_get_string_outparams)

def ll_pdf_dict_get_string_outparams_fn(dict, key, outparams):
    return _mupdf.ll_pdf_dict_get_string_outparams_fn(dict, key, outparams)
class ll_pdf_edit_text_field_value_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    selStart = property(_mupdf.ll_pdf_edit_text_field_value_outparams_selStart_get, _mupdf.ll_pdf_edit_text_field_value_outparams_selStart_set)
    selEnd = property(_mupdf.ll_pdf_edit_text_field_value_outparams_selEnd_get, _mupdf.ll_pdf_edit_text_field_value_outparams_selEnd_set)
    newvalue = property(_mupdf.ll_pdf_edit_text_field_value_outparams_newvalue_get, _mupdf.ll_pdf_edit_text_field_value_outparams_newvalue_set)

    def __init__(self):
        _mupdf.ll_pdf_edit_text_field_value_outparams_swiginit(self, _mupdf.new_ll_pdf_edit_text_field_value_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_edit_text_field_value_outparams

# Register ll_pdf_edit_text_field_value_outparams in _mupdf:
_mupdf.ll_pdf_edit_text_field_value_outparams_swigregister(ll_pdf_edit_text_field_value_outparams)

def ll_pdf_edit_text_field_value_outparams_fn(widget, value, change, outparams):
    return _mupdf.ll_pdf_edit_text_field_value_outparams_fn(widget, value, change, outparams)
class ll_pdf_eval_function_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out = property(_mupdf.ll_pdf_eval_function_outparams_out_get, _mupdf.ll_pdf_eval_function_outparams_out_set)

    def __init__(self):
        _mupdf.ll_pdf_eval_function_outparams_swiginit(self, _mupdf.new_ll_pdf_eval_function_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_eval_function_outparams

# Register ll_pdf_eval_function_outparams in _mupdf:
_mupdf.ll_pdf_eval_function_outparams_swigregister(ll_pdf_eval_function_outparams)

def ll_pdf_eval_function_outparams_fn(func, _in, inlen, outlen, outparams):
    return _mupdf.ll_pdf_eval_function_outparams_fn(func, _in, inlen, outlen, outparams)
class ll_pdf_field_event_validate_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    newvalue = property(_mupdf.ll_pdf_field_event_validate_outparams_newvalue_get, _mupdf.ll_pdf_field_event_validate_outparams_newvalue_set)

    def __init__(self):
        _mupdf.ll_pdf_field_event_validate_outparams_swiginit(self, _mupdf.new_ll_pdf_field_event_validate_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_field_event_validate_outparams

# Register ll_pdf_field_event_validate_outparams in _mupdf:
_mupdf.ll_pdf_field_event_validate_outparams_swigregister(ll_pdf_field_event_validate_outparams)

def ll_pdf_field_event_validate_outparams_fn(doc, field, value, outparams):
    return _mupdf.ll_pdf_field_event_validate_outparams_fn(doc, field, value, outparams)
class ll_pdf_js_event_result_validate_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    newvalue = property(_mupdf.ll_pdf_js_event_result_validate_outparams_newvalue_get, _mupdf.ll_pdf_js_event_result_validate_outparams_newvalue_set)

    def __init__(self):
        _mupdf.ll_pdf_js_event_result_validate_outparams_swiginit(self, _mupdf.new_ll_pdf_js_event_result_validate_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_js_event_result_validate_outparams

# Register ll_pdf_js_event_result_validate_outparams in _mupdf:
_mupdf.ll_pdf_js_event_result_validate_outparams_swigregister(ll_pdf_js_event_result_validate_outparams)

def ll_pdf_js_event_result_validate_outparams_fn(js, outparams):
    return _mupdf.ll_pdf_js_event_result_validate_outparams_fn(js, outparams)
class ll_pdf_js_execute_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    result = property(_mupdf.ll_pdf_js_execute_outparams_result_get, _mupdf.ll_pdf_js_execute_outparams_result_set)

    def __init__(self):
        _mupdf.ll_pdf_js_execute_outparams_swiginit(self, _mupdf.new_ll_pdf_js_execute_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_js_execute_outparams

# Register ll_pdf_js_execute_outparams in _mupdf:
_mupdf.ll_pdf_js_execute_outparams_swigregister(ll_pdf_js_execute_outparams)

def ll_pdf_js_execute_outparams_fn(js, name, code, outparams):
    return _mupdf.ll_pdf_js_execute_outparams_fn(js, name, code, outparams)
class ll_pdf_load_encoding_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    estrings = property(_mupdf.ll_pdf_load_encoding_outparams_estrings_get, _mupdf.ll_pdf_load_encoding_outparams_estrings_set)

    def __init__(self):
        _mupdf.ll_pdf_load_encoding_outparams_swiginit(self, _mupdf.new_ll_pdf_load_encoding_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_load_encoding_outparams

# Register ll_pdf_load_encoding_outparams in _mupdf:
_mupdf.ll_pdf_load_encoding_outparams_swigregister(ll_pdf_load_encoding_outparams)

def ll_pdf_load_encoding_outparams_fn(encoding, outparams):
    return _mupdf.ll_pdf_load_encoding_outparams_fn(encoding, outparams)
class ll_pdf_load_to_unicode_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    strings = property(_mupdf.ll_pdf_load_to_unicode_outparams_strings_get, _mupdf.ll_pdf_load_to_unicode_outparams_strings_set)

    def __init__(self):
        _mupdf.ll_pdf_load_to_unicode_outparams_swiginit(self, _mupdf.new_ll_pdf_load_to_unicode_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_load_to_unicode_outparams

# Register ll_pdf_load_to_unicode_outparams in _mupdf:
_mupdf.ll_pdf_load_to_unicode_outparams_swigregister(ll_pdf_load_to_unicode_outparams)

def ll_pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm, outparams):
    return _mupdf.ll_pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm, outparams)
class ll_pdf_lookup_cmap_full_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out = property(_mupdf.ll_pdf_lookup_cmap_full_outparams_out_get, _mupdf.ll_pdf_lookup_cmap_full_outparams_out_set)

    def __init__(self):
        _mupdf.ll_pdf_lookup_cmap_full_outparams_swiginit(self, _mupdf.new_ll_pdf_lookup_cmap_full_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_lookup_cmap_full_outparams

# Register ll_pdf_lookup_cmap_full_outparams in _mupdf:
_mupdf.ll_pdf_lookup_cmap_full_outparams_swigregister(ll_pdf_lookup_cmap_full_outparams)

def ll_pdf_lookup_cmap_full_outparams_fn(cmap, cpt, outparams):
    return _mupdf.ll_pdf_lookup_cmap_full_outparams_fn(cmap, cpt, outparams)
class ll_pdf_lookup_page_loc_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    parentp = property(_mupdf.ll_pdf_lookup_page_loc_outparams_parentp_get, _mupdf.ll_pdf_lookup_page_loc_outparams_parentp_set)
    indexp = property(_mupdf.ll_pdf_lookup_page_loc_outparams_indexp_get, _mupdf.ll_pdf_lookup_page_loc_outparams_indexp_set)

    def __init__(self):
        _mupdf.ll_pdf_lookup_page_loc_outparams_swiginit(self, _mupdf.new_ll_pdf_lookup_page_loc_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_lookup_page_loc_outparams

# Register ll_pdf_lookup_page_loc_outparams in _mupdf:
_mupdf.ll_pdf_lookup_page_loc_outparams_swigregister(ll_pdf_lookup_page_loc_outparams)

def ll_pdf_lookup_page_loc_outparams_fn(doc, needle, outparams):
    return _mupdf.ll_pdf_lookup_page_loc_outparams_fn(doc, needle, outparams)
class ll_pdf_lookup_substitute_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_pdf_lookup_substitute_font_outparams_len_get, _mupdf.ll_pdf_lookup_substitute_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_pdf_lookup_substitute_font_outparams_swiginit(self, _mupdf.new_ll_pdf_lookup_substitute_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_lookup_substitute_font_outparams

# Register ll_pdf_lookup_substitute_font_outparams in _mupdf:
_mupdf.ll_pdf_lookup_substitute_font_outparams_swigregister(ll_pdf_lookup_substitute_font_outparams)

def ll_pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic, outparams):
    return _mupdf.ll_pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic, outparams)
class ll_pdf_map_one_to_many_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    many = property(_mupdf.ll_pdf_map_one_to_many_outparams_many_get, _mupdf.ll_pdf_map_one_to_many_outparams_many_set)

    def __init__(self):
        _mupdf.ll_pdf_map_one_to_many_outparams_swiginit(self, _mupdf.new_ll_pdf_map_one_to_many_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_map_one_to_many_outparams

# Register ll_pdf_map_one_to_many_outparams in _mupdf:
_mupdf.ll_pdf_map_one_to_many_outparams_swigregister(ll_pdf_map_one_to_many_outparams)

def ll_pdf_map_one_to_many_outparams_fn(cmap, one, len, outparams):
    return _mupdf.ll_pdf_map_one_to_many_outparams_fn(cmap, one, len, outparams)
class ll_pdf_obj_memo_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    memo = property(_mupdf.ll_pdf_obj_memo_outparams_memo_get, _mupdf.ll_pdf_obj_memo_outparams_memo_set)

    def __init__(self):
        _mupdf.ll_pdf_obj_memo_outparams_swiginit(self, _mupdf.new_ll_pdf_obj_memo_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_obj_memo_outparams

# Register ll_pdf_obj_memo_outparams in _mupdf:
_mupdf.ll_pdf_obj_memo_outparams_swigregister(ll_pdf_obj_memo_outparams)

def ll_pdf_obj_memo_outparams_fn(obj, bit, outparams):
    return _mupdf.ll_pdf_obj_memo_outparams_fn(obj, bit, outparams)
class ll_pdf_page_presentation_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    duration = property(_mupdf.ll_pdf_page_presentation_outparams_duration_get, _mupdf.ll_pdf_page_presentation_outparams_duration_set)

    def __init__(self):
        _mupdf.ll_pdf_page_presentation_outparams_swiginit(self, _mupdf.new_ll_pdf_page_presentation_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_page_presentation_outparams

# Register ll_pdf_page_presentation_outparams in _mupdf:
_mupdf.ll_pdf_page_presentation_outparams_swigregister(ll_pdf_page_presentation_outparams)

def ll_pdf_page_presentation_outparams_fn(page, transition, outparams):
    return _mupdf.ll_pdf_page_presentation_outparams_fn(page, transition, outparams)
class ll_pdf_page_write_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    presources = property(_mupdf.ll_pdf_page_write_outparams_presources_get, _mupdf.ll_pdf_page_write_outparams_presources_set)
    pcontents = property(_mupdf.ll_pdf_page_write_outparams_pcontents_get, _mupdf.ll_pdf_page_write_outparams_pcontents_set)

    def __init__(self):
        _mupdf.ll_pdf_page_write_outparams_swiginit(self, _mupdf.new_ll_pdf_page_write_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_page_write_outparams

# Register ll_pdf_page_write_outparams in _mupdf:
_mupdf.ll_pdf_page_write_outparams_swigregister(ll_pdf_page_write_outparams)

def ll_pdf_page_write_outparams_fn(doc, mediabox, outparams):
    return _mupdf.ll_pdf_page_write_outparams_fn(doc, mediabox, outparams)
class ll_pdf_parse_default_appearance_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    font = property(_mupdf.ll_pdf_parse_default_appearance_outparams_font_get, _mupdf.ll_pdf_parse_default_appearance_outparams_font_set)
    size = property(_mupdf.ll_pdf_parse_default_appearance_outparams_size_get, _mupdf.ll_pdf_parse_default_appearance_outparams_size_set)
    n = property(_mupdf.ll_pdf_parse_default_appearance_outparams_n_get, _mupdf.ll_pdf_parse_default_appearance_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_parse_default_appearance_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_default_appearance_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_parse_default_appearance_outparams

# Register ll_pdf_parse_default_appearance_outparams in _mupdf:
_mupdf.ll_pdf_parse_default_appearance_outparams_swigregister(ll_pdf_parse_default_appearance_outparams)

def ll_pdf_parse_default_appearance_outparams_fn(da, color, outparams):
    return _mupdf.ll_pdf_parse_default_appearance_outparams_fn(da, color, outparams)
class ll_pdf_parse_default_appearance_unmapped_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    size = property(_mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_size_get, _mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_size_set)
    n = property(_mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_n_get, _mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_default_appearance_unmapped_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_parse_default_appearance_unmapped_outparams

# Register ll_pdf_parse_default_appearance_unmapped_outparams in _mupdf:
_mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_swigregister(ll_pdf_parse_default_appearance_unmapped_outparams)

def ll_pdf_parse_default_appearance_unmapped_outparams_fn(da, font_name, font_name_len, color, outparams):
    return _mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_fn(da, font_name, font_name_len, color, outparams)
class ll_pdf_parse_ind_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num = property(_mupdf.ll_pdf_parse_ind_obj_outparams_num_get, _mupdf.ll_pdf_parse_ind_obj_outparams_num_set)
    gen = property(_mupdf.ll_pdf_parse_ind_obj_outparams_gen_get, _mupdf.ll_pdf_parse_ind_obj_outparams_gen_set)
    stm_ofs = property(_mupdf.ll_pdf_parse_ind_obj_outparams_stm_ofs_get, _mupdf.ll_pdf_parse_ind_obj_outparams_stm_ofs_set)
    try_repair = property(_mupdf.ll_pdf_parse_ind_obj_outparams_try_repair_get, _mupdf.ll_pdf_parse_ind_obj_outparams_try_repair_set)

    def __init__(self):
        _mupdf.ll_pdf_parse_ind_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_ind_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_parse_ind_obj_outparams

# Register ll_pdf_parse_ind_obj_outparams in _mupdf:
_mupdf.ll_pdf_parse_ind_obj_outparams_swigregister(ll_pdf_parse_ind_obj_outparams)

def ll_pdf_parse_ind_obj_outparams_fn(doc, f, outparams):
    return _mupdf.ll_pdf_parse_ind_obj_outparams_fn(doc, f, outparams)
class ll_pdf_parse_journal_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    onum = property(_mupdf.ll_pdf_parse_journal_obj_outparams_onum_get, _mupdf.ll_pdf_parse_journal_obj_outparams_onum_set)
    ostm = property(_mupdf.ll_pdf_parse_journal_obj_outparams_ostm_get, _mupdf.ll_pdf_parse_journal_obj_outparams_ostm_set)
    newobj = property(_mupdf.ll_pdf_parse_journal_obj_outparams_newobj_get, _mupdf.ll_pdf_parse_journal_obj_outparams_newobj_set)

    def __init__(self):
        _mupdf.ll_pdf_parse_journal_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_journal_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_parse_journal_obj_outparams

# Register ll_pdf_parse_journal_obj_outparams in _mupdf:
_mupdf.ll_pdf_parse_journal_obj_outparams_swigregister(ll_pdf_parse_journal_obj_outparams)

def ll_pdf_parse_journal_obj_outparams_fn(doc, stm, outparams):
    return _mupdf.ll_pdf_parse_journal_obj_outparams_fn(doc, stm, outparams)
class ll_pdf_print_encrypted_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sep = property(_mupdf.ll_pdf_print_encrypted_obj_outparams_sep_get, _mupdf.ll_pdf_print_encrypted_obj_outparams_sep_set)

    def __init__(self):
        _mupdf.ll_pdf_print_encrypted_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_print_encrypted_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_print_encrypted_obj_outparams

# Register ll_pdf_print_encrypted_obj_outparams in _mupdf:
_mupdf.ll_pdf_print_encrypted_obj_outparams_swigregister(ll_pdf_print_encrypted_obj_outparams)

def ll_pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen, outparams):
    return _mupdf.ll_pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen, outparams)
class ll_pdf_process_contents_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out_res = property(_mupdf.ll_pdf_process_contents_outparams_out_res_get, _mupdf.ll_pdf_process_contents_outparams_out_res_set)

    def __init__(self):
        _mupdf.ll_pdf_process_contents_outparams_swiginit(self, _mupdf.new_ll_pdf_process_contents_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_process_contents_outparams

# Register ll_pdf_process_contents_outparams in _mupdf:
_mupdf.ll_pdf_process_contents_outparams_swigregister(ll_pdf_process_contents_outparams)

def ll_pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie, outparams):
    return _mupdf.ll_pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie, outparams)
class ll_pdf_repair_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    stmofsp = property(_mupdf.ll_pdf_repair_obj_outparams_stmofsp_get, _mupdf.ll_pdf_repair_obj_outparams_stmofsp_set)
    stmlenp = property(_mupdf.ll_pdf_repair_obj_outparams_stmlenp_get, _mupdf.ll_pdf_repair_obj_outparams_stmlenp_set)
    encrypt = property(_mupdf.ll_pdf_repair_obj_outparams_encrypt_get, _mupdf.ll_pdf_repair_obj_outparams_encrypt_set)
    id = property(_mupdf.ll_pdf_repair_obj_outparams_id_get, _mupdf.ll_pdf_repair_obj_outparams_id_set)
    page = property(_mupdf.ll_pdf_repair_obj_outparams_page_get, _mupdf.ll_pdf_repair_obj_outparams_page_set)
    tmpofs = property(_mupdf.ll_pdf_repair_obj_outparams_tmpofs_get, _mupdf.ll_pdf_repair_obj_outparams_tmpofs_set)
    root = property(_mupdf.ll_pdf_repair_obj_outparams_root_get, _mupdf.ll_pdf_repair_obj_outparams_root_set)

    def __init__(self):
        _mupdf.ll_pdf_repair_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_repair_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_repair_obj_outparams

# Register ll_pdf_repair_obj_outparams in _mupdf:
_mupdf.ll_pdf_repair_obj_outparams_swigregister(ll_pdf_repair_obj_outparams)

def ll_pdf_repair_obj_outparams_fn(doc, buf, outparams):
    return _mupdf.ll_pdf_repair_obj_outparams_fn(doc, buf, outparams)
class ll_pdf_resolve_link_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    xp = property(_mupdf.ll_pdf_resolve_link_outparams_xp_get, _mupdf.ll_pdf_resolve_link_outparams_xp_set)
    yp = property(_mupdf.ll_pdf_resolve_link_outparams_yp_get, _mupdf.ll_pdf_resolve_link_outparams_yp_set)

    def __init__(self):
        _mupdf.ll_pdf_resolve_link_outparams_swiginit(self, _mupdf.new_ll_pdf_resolve_link_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_resolve_link_outparams

# Register ll_pdf_resolve_link_outparams in _mupdf:
_mupdf.ll_pdf_resolve_link_outparams_swigregister(ll_pdf_resolve_link_outparams)

def ll_pdf_resolve_link_outparams_fn(doc, uri, outparams):
    return _mupdf.ll_pdf_resolve_link_outparams_fn(doc, uri, outparams)
class ll_pdf_sample_shade_function_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    samples = property(_mupdf.ll_pdf_sample_shade_function_outparams_samples_get, _mupdf.ll_pdf_sample_shade_function_outparams_samples_set)
    func = property(_mupdf.ll_pdf_sample_shade_function_outparams_func_get, _mupdf.ll_pdf_sample_shade_function_outparams_func_set)

    def __init__(self):
        _mupdf.ll_pdf_sample_shade_function_outparams_swiginit(self, _mupdf.new_ll_pdf_sample_shade_function_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_sample_shade_function_outparams

# Register ll_pdf_sample_shade_function_outparams in _mupdf:
_mupdf.ll_pdf_sample_shade_function_outparams_swigregister(ll_pdf_sample_shade_function_outparams)

def ll_pdf_sample_shade_function_outparams_fn(n, funcs, t0, t1, outparams):
    return _mupdf.ll_pdf_sample_shade_function_outparams_fn(n, funcs, t0, t1, outparams)
class ll_pdf_signature_contents_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    contents = property(_mupdf.ll_pdf_signature_contents_outparams_contents_get, _mupdf.ll_pdf_signature_contents_outparams_contents_set)

    def __init__(self):
        _mupdf.ll_pdf_signature_contents_outparams_swiginit(self, _mupdf.new_ll_pdf_signature_contents_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_signature_contents_outparams

# Register ll_pdf_signature_contents_outparams in _mupdf:
_mupdf.ll_pdf_signature_contents_outparams_swigregister(ll_pdf_signature_contents_outparams)

def ll_pdf_signature_contents_outparams_fn(doc, signature, outparams):
    return _mupdf.ll_pdf_signature_contents_outparams_fn(doc, signature, outparams)
class ll_pdf_sprint_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_pdf_sprint_obj_outparams_len_get, _mupdf.ll_pdf_sprint_obj_outparams_len_set)

    def __init__(self):
        _mupdf.ll_pdf_sprint_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_sprint_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_sprint_obj_outparams

# Register ll_pdf_sprint_obj_outparams in _mupdf:
_mupdf.ll_pdf_sprint_obj_outparams_swigregister(ll_pdf_sprint_obj_outparams)

def ll_pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii, outparams):
    return _mupdf.ll_pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii, outparams)
class ll_pdf_to_string_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sizep = property(_mupdf.ll_pdf_to_string_outparams_sizep_get, _mupdf.ll_pdf_to_string_outparams_sizep_set)

    def __init__(self):
        _mupdf.ll_pdf_to_string_outparams_swiginit(self, _mupdf.new_ll_pdf_to_string_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_to_string_outparams

# Register ll_pdf_to_string_outparams in _mupdf:
_mupdf.ll_pdf_to_string_outparams_swigregister(ll_pdf_to_string_outparams)

def ll_pdf_to_string_outparams_fn(obj, outparams):
    return _mupdf.ll_pdf_to_string_outparams_fn(obj, outparams)
class ll_pdf_tos_make_trm_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    adv = property(_mupdf.ll_pdf_tos_make_trm_outparams_adv_get, _mupdf.ll_pdf_tos_make_trm_outparams_adv_set)

    def __init__(self):
        _mupdf.ll_pdf_tos_make_trm_outparams_swiginit(self, _mupdf.new_ll_pdf_tos_make_trm_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_tos_make_trm_outparams

# Register ll_pdf_tos_make_trm_outparams in _mupdf:
_mupdf.ll_pdf_tos_make_trm_outparams_swigregister(ll_pdf_tos_make_trm_outparams)

def ll_pdf_tos_make_trm_outparams_fn(tos, text, fontdesc, cid, trm, outparams):
    return _mupdf.ll_pdf_tos_make_trm_outparams_fn(tos, text, fontdesc, cid, trm, outparams)
class ll_pdf_undoredo_state_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    steps = property(_mupdf.ll_pdf_undoredo_state_outparams_steps_get, _mupdf.ll_pdf_undoredo_state_outparams_steps_set)

    def __init__(self):
        _mupdf.ll_pdf_undoredo_state_outparams_swiginit(self, _mupdf.new_ll_pdf_undoredo_state_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_undoredo_state_outparams

# Register ll_pdf_undoredo_state_outparams in _mupdf:
_mupdf.ll_pdf_undoredo_state_outparams_swigregister(ll_pdf_undoredo_state_outparams)

def ll_pdf_undoredo_state_outparams_fn(doc, outparams):
    return _mupdf.ll_pdf_undoredo_state_outparams_fn(doc, outparams)
class ll_pdf_walk_tree_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    names = property(_mupdf.ll_pdf_walk_tree_outparams_names_get, _mupdf.ll_pdf_walk_tree_outparams_names_set)
    values = property(_mupdf.ll_pdf_walk_tree_outparams_values_get, _mupdf.ll_pdf_walk_tree_outparams_values_set)

    def __init__(self):
        _mupdf.ll_pdf_walk_tree_outparams_swiginit(self, _mupdf.new_ll_pdf_walk_tree_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_walk_tree_outparams

# Register ll_pdf_walk_tree_outparams in _mupdf:
_mupdf.ll_pdf_walk_tree_outparams_swigregister(ll_pdf_walk_tree_outparams)

def ll_pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg, outparams):
    return _mupdf.ll_pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg, outparams)
class ll_pdf_zugferd_profile_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    version = property(_mupdf.ll_pdf_zugferd_profile_outparams_version_get, _mupdf.ll_pdf_zugferd_profile_outparams_version_set)

    def __init__(self):
        _mupdf.ll_pdf_zugferd_profile_outparams_swiginit(self, _mupdf.new_ll_pdf_zugferd_profile_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_zugferd_profile_outparams

# Register ll_pdf_zugferd_profile_outparams in _mupdf:
_mupdf.ll_pdf_zugferd_profile_outparams_swigregister(ll_pdf_zugferd_profile_outparams)

def ll_pdf_zugferd_profile_outparams_fn(doc, outparams):
    return _mupdf.ll_pdf_zugferd_profile_outparams_fn(doc, outparams)
UCDN_EAST_ASIAN_F = _mupdf.UCDN_EAST_ASIAN_F
UCDN_EAST_ASIAN_H = _mupdf.UCDN_EAST_ASIAN_H
UCDN_EAST_ASIAN_W = _mupdf.UCDN_EAST_ASIAN_W
UCDN_EAST_ASIAN_NA = _mupdf.UCDN_EAST_ASIAN_NA
UCDN_EAST_ASIAN_A = _mupdf.UCDN_EAST_ASIAN_A
UCDN_EAST_ASIAN_N = _mupdf.UCDN_EAST_ASIAN_N
UCDN_SCRIPT_COMMON = _mupdf.UCDN_SCRIPT_COMMON
UCDN_SCRIPT_LATIN = _mupdf.UCDN_SCRIPT_LATIN
UCDN_SCRIPT_GREEK = _mupdf.UCDN_SCRIPT_GREEK
UCDN_SCRIPT_CYRILLIC = _mupdf.UCDN_SCRIPT_CYRILLIC
UCDN_SCRIPT_ARMENIAN = _mupdf.UCDN_SCRIPT_ARMENIAN
UCDN_SCRIPT_HEBREW = _mupdf.UCDN_SCRIPT_HEBREW
UCDN_SCRIPT_ARABIC = _mupdf.UCDN_SCRIPT_ARABIC
UCDN_SCRIPT_SYRIAC = _mupdf.UCDN_SCRIPT_SYRIAC
UCDN_SCRIPT_THAANA = _mupdf.UCDN_SCRIPT_THAANA
UCDN_SCRIPT_DEVANAGARI = _mupdf.UCDN_SCRIPT_DEVANAGARI
UCDN_SCRIPT_BENGALI = _mupdf.UCDN_SCRIPT_BENGALI
UCDN_SCRIPT_GURMUKHI = _mupdf.UCDN_SCRIPT_GURMUKHI
UCDN_SCRIPT_GUJARATI = _mupdf.UCDN_SCRIPT_GUJARATI
UCDN_SCRIPT_ORIYA = _mupdf.UCDN_SCRIPT_ORIYA
UCDN_SCRIPT_TAMIL = _mupdf.UCDN_SCRIPT_TAMIL
UCDN_SCRIPT_TELUGU = _mupdf.UCDN_SCRIPT_TELUGU
UCDN_SCRIPT_KANNADA = _mupdf.UCDN_SCRIPT_KANNADA
UCDN_SCRIPT_MALAYALAM = _mupdf.UCDN_SCRIPT_MALAYALAM
UCDN_SCRIPT_SINHALA = _mupdf.UCDN_SCRIPT_SINHALA
UCDN_SCRIPT_THAI = _mupdf.UCDN_SCRIPT_THAI
UCDN_SCRIPT_LAO = _mupdf.UCDN_SCRIPT_LAO
UCDN_SCRIPT_TIBETAN = _mupdf.UCDN_SCRIPT_TIBETAN
UCDN_SCRIPT_MYANMAR = _mupdf.UCDN_SCRIPT_MYANMAR
UCDN_SCRIPT_GEORGIAN = _mupdf.UCDN_SCRIPT_GEORGIAN
UCDN_SCRIPT_HANGUL = _mupdf.UCDN_SCRIPT_HANGUL
UCDN_SCRIPT_ETHIOPIC = _mupdf.UCDN_SCRIPT_ETHIOPIC
UCDN_SCRIPT_CHEROKEE = _mupdf.UCDN_SCRIPT_CHEROKEE
UCDN_SCRIPT_CANADIAN_ABORIGINAL = _mupdf.UCDN_SCRIPT_CANADIAN_ABORIGINAL
UCDN_SCRIPT_OGHAM = _mupdf.UCDN_SCRIPT_OGHAM
UCDN_SCRIPT_RUNIC = _mupdf.UCDN_SCRIPT_RUNIC
UCDN_SCRIPT_KHMER = _mupdf.UCDN_SCRIPT_KHMER
UCDN_SCRIPT_MONGOLIAN = _mupdf.UCDN_SCRIPT_MONGOLIAN
UCDN_SCRIPT_HIRAGANA = _mupdf.UCDN_SCRIPT_HIRAGANA
UCDN_SCRIPT_KATAKANA = _mupdf.UCDN_SCRIPT_KATAKANA
UCDN_SCRIPT_BOPOMOFO = _mupdf.UCDN_SCRIPT_BOPOMOFO
UCDN_SCRIPT_HAN = _mupdf.UCDN_SCRIPT_HAN
UCDN_SCRIPT_YI = _mupdf.UCDN_SCRIPT_YI
UCDN_SCRIPT_OLD_ITALIC = _mupdf.UCDN_SCRIPT_OLD_ITALIC
UCDN_SCRIPT_GOTHIC = _mupdf.UCDN_SCRIPT_GOTHIC
UCDN_SCRIPT_DESERET = _mupdf.UCDN_SCRIPT_DESERET
UCDN_SCRIPT_INHERITED = _mupdf.UCDN_SCRIPT_INHERITED
UCDN_SCRIPT_TAGALOG = _mupdf.UCDN_SCRIPT_TAGALOG
UCDN_SCRIPT_HANUNOO = _mupdf.UCDN_SCRIPT_HANUNOO
UCDN_SCRIPT_BUHID = _mupdf.UCDN_SCRIPT_BUHID
UCDN_SCRIPT_TAGBANWA = _mupdf.UCDN_SCRIPT_TAGBANWA
UCDN_SCRIPT_LIMBU = _mupdf.UCDN_SCRIPT_LIMBU
UCDN_SCRIPT_TAI_LE = _mupdf.UCDN_SCRIPT_TAI_LE
UCDN_SCRIPT_LINEAR_B = _mupdf.UCDN_SCRIPT_LINEAR_B
UCDN_SCRIPT_UGARITIC = _mupdf.UCDN_SCRIPT_UGARITIC
UCDN_SCRIPT_SHAVIAN = _mupdf.UCDN_SCRIPT_SHAVIAN
UCDN_SCRIPT_OSMANYA = _mupdf.UCDN_SCRIPT_OSMANYA
UCDN_SCRIPT_CYPRIOT = _mupdf.UCDN_SCRIPT_CYPRIOT
UCDN_SCRIPT_BRAILLE = _mupdf.UCDN_SCRIPT_BRAILLE
UCDN_SCRIPT_BUGINESE = _mupdf.UCDN_SCRIPT_BUGINESE
UCDN_SCRIPT_COPTIC = _mupdf.UCDN_SCRIPT_COPTIC
UCDN_SCRIPT_NEW_TAI_LUE = _mupdf.UCDN_SCRIPT_NEW_TAI_LUE
UCDN_SCRIPT_GLAGOLITIC = _mupdf.UCDN_SCRIPT_GLAGOLITIC
UCDN_SCRIPT_TIFINAGH = _mupdf.UCDN_SCRIPT_TIFINAGH
UCDN_SCRIPT_SYLOTI_NAGRI = _mupdf.UCDN_SCRIPT_SYLOTI_NAGRI
UCDN_SCRIPT_OLD_PERSIAN = _mupdf.UCDN_SCRIPT_OLD_PERSIAN
UCDN_SCRIPT_KHAROSHTHI = _mupdf.UCDN_SCRIPT_KHAROSHTHI
UCDN_SCRIPT_BALINESE = _mupdf.UCDN_SCRIPT_BALINESE
UCDN_SCRIPT_CUNEIFORM = _mupdf.UCDN_SCRIPT_CUNEIFORM
UCDN_SCRIPT_PHOENICIAN = _mupdf.UCDN_SCRIPT_PHOENICIAN
UCDN_SCRIPT_PHAGS_PA = _mupdf.UCDN_SCRIPT_PHAGS_PA
UCDN_SCRIPT_NKO = _mupdf.UCDN_SCRIPT_NKO
UCDN_SCRIPT_SUNDANESE = _mupdf.UCDN_SCRIPT_SUNDANESE
UCDN_SCRIPT_LEPCHA = _mupdf.UCDN_SCRIPT_LEPCHA
UCDN_SCRIPT_OL_CHIKI = _mupdf.UCDN_SCRIPT_OL_CHIKI
UCDN_SCRIPT_VAI = _mupdf.UCDN_SCRIPT_VAI
UCDN_SCRIPT_SAURASHTRA = _mupdf.UCDN_SCRIPT_SAURASHTRA
UCDN_SCRIPT_KAYAH_LI = _mupdf.UCDN_SCRIPT_KAYAH_LI
UCDN_SCRIPT_REJANG = _mupdf.UCDN_SCRIPT_REJANG
UCDN_SCRIPT_LYCIAN = _mupdf.UCDN_SCRIPT_LYCIAN
UCDN_SCRIPT_CARIAN = _mupdf.UCDN_SCRIPT_CARIAN
UCDN_SCRIPT_LYDIAN = _mupdf.UCDN_SCRIPT_LYDIAN
UCDN_SCRIPT_CHAM = _mupdf.UCDN_SCRIPT_CHAM
UCDN_SCRIPT_TAI_THAM = _mupdf.UCDN_SCRIPT_TAI_THAM
UCDN_SCRIPT_TAI_VIET = _mupdf.UCDN_SCRIPT_TAI_VIET
UCDN_SCRIPT_AVESTAN = _mupdf.UCDN_SCRIPT_AVESTAN
UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS = _mupdf.UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS
UCDN_SCRIPT_SAMARITAN = _mupdf.UCDN_SCRIPT_SAMARITAN
UCDN_SCRIPT_LISU = _mupdf.UCDN_SCRIPT_LISU
UCDN_SCRIPT_BAMUM = _mupdf.UCDN_SCRIPT_BAMUM
UCDN_SCRIPT_JAVANESE = _mupdf.UCDN_SCRIPT_JAVANESE
UCDN_SCRIPT_MEETEI_MAYEK = _mupdf.UCDN_SCRIPT_MEETEI_MAYEK
UCDN_SCRIPT_IMPERIAL_ARAMAIC = _mupdf.UCDN_SCRIPT_IMPERIAL_ARAMAIC
UCDN_SCRIPT_OLD_SOUTH_ARABIAN = _mupdf.UCDN_SCRIPT_OLD_SOUTH_ARABIAN
UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN = _mupdf.UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN
UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI = _mupdf.UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI
UCDN_SCRIPT_OLD_TURKIC = _mupdf.UCDN_SCRIPT_OLD_TURKIC
UCDN_SCRIPT_KAITHI = _mupdf.UCDN_SCRIPT_KAITHI
UCDN_SCRIPT_BATAK = _mupdf.UCDN_SCRIPT_BATAK
UCDN_SCRIPT_BRAHMI = _mupdf.UCDN_SCRIPT_BRAHMI
UCDN_SCRIPT_MANDAIC = _mupdf.UCDN_SCRIPT_MANDAIC
UCDN_SCRIPT_CHAKMA = _mupdf.UCDN_SCRIPT_CHAKMA
UCDN_SCRIPT_MEROITIC_CURSIVE = _mupdf.UCDN_SCRIPT_MEROITIC_CURSIVE
UCDN_SCRIPT_MEROITIC_HIEROGLYPHS = _mupdf.UCDN_SCRIPT_MEROITIC_HIEROGLYPHS
UCDN_SCRIPT_MIAO = _mupdf.UCDN_SCRIPT_MIAO
UCDN_SCRIPT_SHARADA = _mupdf.UCDN_SCRIPT_SHARADA
UCDN_SCRIPT_SORA_SOMPENG = _mupdf.UCDN_SCRIPT_SORA_SOMPENG
UCDN_SCRIPT_TAKRI = _mupdf.UCDN_SCRIPT_TAKRI
UCDN_SCRIPT_UNKNOWN = _mupdf.UCDN_SCRIPT_UNKNOWN
UCDN_SCRIPT_BASSA_VAH = _mupdf.UCDN_SCRIPT_BASSA_VAH
UCDN_SCRIPT_CAUCASIAN_ALBANIAN = _mupdf.UCDN_SCRIPT_CAUCASIAN_ALBANIAN
UCDN_SCRIPT_DUPLOYAN = _mupdf.UCDN_SCRIPT_DUPLOYAN
UCDN_SCRIPT_ELBASAN = _mupdf.UCDN_SCRIPT_ELBASAN
UCDN_SCRIPT_GRANTHA = _mupdf.UCDN_SCRIPT_GRANTHA
UCDN_SCRIPT_KHOJKI = _mupdf.UCDN_SCRIPT_KHOJKI
UCDN_SCRIPT_KHUDAWADI = _mupdf.UCDN_SCRIPT_KHUDAWADI
UCDN_SCRIPT_LINEAR_A = _mupdf.UCDN_SCRIPT_LINEAR_A
UCDN_SCRIPT_MAHAJANI = _mupdf.UCDN_SCRIPT_MAHAJANI
UCDN_SCRIPT_MANICHAEAN = _mupdf.UCDN_SCRIPT_MANICHAEAN
UCDN_SCRIPT_MENDE_KIKAKUI = _mupdf.UCDN_SCRIPT_MENDE_KIKAKUI
UCDN_SCRIPT_MODI = _mupdf.UCDN_SCRIPT_MODI
UCDN_SCRIPT_MRO = _mupdf.UCDN_SCRIPT_MRO
UCDN_SCRIPT_NABATAEAN = _mupdf.UCDN_SCRIPT_NABATAEAN
UCDN_SCRIPT_OLD_NORTH_ARABIAN = _mupdf.UCDN_SCRIPT_OLD_NORTH_ARABIAN
UCDN_SCRIPT_OLD_PERMIC = _mupdf.UCDN_SCRIPT_OLD_PERMIC
UCDN_SCRIPT_PAHAWH_HMONG = _mupdf.UCDN_SCRIPT_PAHAWH_HMONG
UCDN_SCRIPT_PALMYRENE = _mupdf.UCDN_SCRIPT_PALMYRENE
UCDN_SCRIPT_PAU_CIN_HAU = _mupdf.UCDN_SCRIPT_PAU_CIN_HAU
UCDN_SCRIPT_PSALTER_PAHLAVI = _mupdf.UCDN_SCRIPT_PSALTER_PAHLAVI
UCDN_SCRIPT_SIDDHAM = _mupdf.UCDN_SCRIPT_SIDDHAM
UCDN_SCRIPT_TIRHUTA = _mupdf.UCDN_SCRIPT_TIRHUTA
UCDN_SCRIPT_WARANG_CITI = _mupdf.UCDN_SCRIPT_WARANG_CITI
UCDN_SCRIPT_AHOM = _mupdf.UCDN_SCRIPT_AHOM
UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS = _mupdf.UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS
UCDN_SCRIPT_HATRAN = _mupdf.UCDN_SCRIPT_HATRAN
UCDN_SCRIPT_MULTANI = _mupdf.UCDN_SCRIPT_MULTANI
UCDN_SCRIPT_OLD_HUNGARIAN = _mupdf.UCDN_SCRIPT_OLD_HUNGARIAN
UCDN_SCRIPT_SIGNWRITING = _mupdf.UCDN_SCRIPT_SIGNWRITING
UCDN_SCRIPT_ADLAM = _mupdf.UCDN_SCRIPT_ADLAM
UCDN_SCRIPT_BHAIKSUKI = _mupdf.UCDN_SCRIPT_BHAIKSUKI
UCDN_SCRIPT_MARCHEN = _mupdf.UCDN_SCRIPT_MARCHEN
UCDN_SCRIPT_NEWA = _mupdf.UCDN_SCRIPT_NEWA
UCDN_SCRIPT_OSAGE = _mupdf.UCDN_SCRIPT_OSAGE
UCDN_SCRIPT_TANGUT = _mupdf.UCDN_SCRIPT_TANGUT
UCDN_SCRIPT_MASARAM_GONDI = _mupdf.UCDN_SCRIPT_MASARAM_GONDI
UCDN_SCRIPT_NUSHU = _mupdf.UCDN_SCRIPT_NUSHU
UCDN_SCRIPT_SOYOMBO = _mupdf.UCDN_SCRIPT_SOYOMBO
UCDN_SCRIPT_ZANABAZAR_SQUARE = _mupdf.UCDN_SCRIPT_ZANABAZAR_SQUARE
UCDN_SCRIPT_DOGRA = _mupdf.UCDN_SCRIPT_DOGRA
UCDN_SCRIPT_GUNJALA_GONDI = _mupdf.UCDN_SCRIPT_GUNJALA_GONDI
UCDN_SCRIPT_HANIFI_ROHINGYA = _mupdf.UCDN_SCRIPT_HANIFI_ROHINGYA
UCDN_SCRIPT_MAKASAR = _mupdf.UCDN_SCRIPT_MAKASAR
UCDN_SCRIPT_MEDEFAIDRIN = _mupdf.UCDN_SCRIPT_MEDEFAIDRIN
UCDN_SCRIPT_OLD_SOGDIAN = _mupdf.UCDN_SCRIPT_OLD_SOGDIAN
UCDN_SCRIPT_SOGDIAN = _mupdf.UCDN_SCRIPT_SOGDIAN
UCDN_SCRIPT_ELYMAIC = _mupdf.UCDN_SCRIPT_ELYMAIC
UCDN_SCRIPT_NANDINAGARI = _mupdf.UCDN_SCRIPT_NANDINAGARI
UCDN_SCRIPT_NYIAKENG_PUACHUE_HMONG = _mupdf.UCDN_SCRIPT_NYIAKENG_PUACHUE_HMONG
UCDN_SCRIPT_WANCHO = _mupdf.UCDN_SCRIPT_WANCHO
UCDN_SCRIPT_CHORASMIAN = _mupdf.UCDN_SCRIPT_CHORASMIAN
UCDN_SCRIPT_DIVES_AKURU = _mupdf.UCDN_SCRIPT_DIVES_AKURU
UCDN_SCRIPT_KHITAN_SMALL_SCRIPT = _mupdf.UCDN_SCRIPT_KHITAN_SMALL_SCRIPT
UCDN_SCRIPT_YEZIDI = _mupdf.UCDN_SCRIPT_YEZIDI
UCDN_SCRIPT_VITHKUQI = _mupdf.UCDN_SCRIPT_VITHKUQI
UCDN_SCRIPT_OLD_UYGHUR = _mupdf.UCDN_SCRIPT_OLD_UYGHUR
UCDN_SCRIPT_CYPRO_MINOAN = _mupdf.UCDN_SCRIPT_CYPRO_MINOAN
UCDN_SCRIPT_TANGSA = _mupdf.UCDN_SCRIPT_TANGSA
UCDN_SCRIPT_TOTO = _mupdf.UCDN_SCRIPT_TOTO
UCDN_SCRIPT_KAWI = _mupdf.UCDN_SCRIPT_KAWI
UCDN_SCRIPT_NAG_MUNDARI = _mupdf.UCDN_SCRIPT_NAG_MUNDARI
UCDN_LAST_SCRIPT = _mupdf.UCDN_LAST_SCRIPT
UCDN_LINEBREAK_CLASS_OP = _mupdf.UCDN_LINEBREAK_CLASS_OP
UCDN_LINEBREAK_CLASS_CL = _mupdf.UCDN_LINEBREAK_CLASS_CL
UCDN_LINEBREAK_CLASS_CP = _mupdf.UCDN_LINEBREAK_CLASS_CP
UCDN_LINEBREAK_CLASS_QU = _mupdf.UCDN_LINEBREAK_CLASS_QU
UCDN_LINEBREAK_CLASS_GL = _mupdf.UCDN_LINEBREAK_CLASS_GL
UCDN_LINEBREAK_CLASS_NS = _mupdf.UCDN_LINEBREAK_CLASS_NS
UCDN_LINEBREAK_CLASS_EX = _mupdf.UCDN_LINEBREAK_CLASS_EX
UCDN_LINEBREAK_CLASS_SY = _mupdf.UCDN_LINEBREAK_CLASS_SY
UCDN_LINEBREAK_CLASS_IS = _mupdf.UCDN_LINEBREAK_CLASS_IS
UCDN_LINEBREAK_CLASS_PR = _mupdf.UCDN_LINEBREAK_CLASS_PR
UCDN_LINEBREAK_CLASS_PO = _mupdf.UCDN_LINEBREAK_CLASS_PO
UCDN_LINEBREAK_CLASS_NU = _mupdf.UCDN_LINEBREAK_CLASS_NU
UCDN_LINEBREAK_CLASS_AL = _mupdf.UCDN_LINEBREAK_CLASS_AL
UCDN_LINEBREAK_CLASS_HL = _mupdf.UCDN_LINEBREAK_CLASS_HL
UCDN_LINEBREAK_CLASS_ID = _mupdf.UCDN_LINEBREAK_CLASS_ID
UCDN_LINEBREAK_CLASS_IN = _mupdf.UCDN_LINEBREAK_CLASS_IN
UCDN_LINEBREAK_CLASS_HY = _mupdf.UCDN_LINEBREAK_CLASS_HY
UCDN_LINEBREAK_CLASS_BA = _mupdf.UCDN_LINEBREAK_CLASS_BA
UCDN_LINEBREAK_CLASS_BB = _mupdf.UCDN_LINEBREAK_CLASS_BB
UCDN_LINEBREAK_CLASS_B2 = _mupdf.UCDN_LINEBREAK_CLASS_B2
UCDN_LINEBREAK_CLASS_ZW = _mupdf.UCDN_LINEBREAK_CLASS_ZW
UCDN_LINEBREAK_CLASS_CM = _mupdf.UCDN_LINEBREAK_CLASS_CM
UCDN_LINEBREAK_CLASS_WJ = _mupdf.UCDN_LINEBREAK_CLASS_WJ
UCDN_LINEBREAK_CLASS_H2 = _mupdf.UCDN_LINEBREAK_CLASS_H2
UCDN_LINEBREAK_CLASS_H3 = _mupdf.UCDN_LINEBREAK_CLASS_H3
UCDN_LINEBREAK_CLASS_JL = _mupdf.UCDN_LINEBREAK_CLASS_JL
UCDN_LINEBREAK_CLASS_JV = _mupdf.UCDN_LINEBREAK_CLASS_JV
UCDN_LINEBREAK_CLASS_JT = _mupdf.UCDN_LINEBREAK_CLASS_JT
UCDN_LINEBREAK_CLASS_RI = _mupdf.UCDN_LINEBREAK_CLASS_RI
UCDN_LINEBREAK_CLASS_AI = _mupdf.UCDN_LINEBREAK_CLASS_AI
UCDN_LINEBREAK_CLASS_BK = _mupdf.UCDN_LINEBREAK_CLASS_BK
UCDN_LINEBREAK_CLASS_CB = _mupdf.UCDN_LINEBREAK_CLASS_CB
UCDN_LINEBREAK_CLASS_CJ = _mupdf.UCDN_LINEBREAK_CLASS_CJ
UCDN_LINEBREAK_CLASS_CR = _mupdf.UCDN_LINEBREAK_CLASS_CR
UCDN_LINEBREAK_CLASS_LF = _mupdf.UCDN_LINEBREAK_CLASS_LF
UCDN_LINEBREAK_CLASS_NL = _mupdf.UCDN_LINEBREAK_CLASS_NL
UCDN_LINEBREAK_CLASS_SA = _mupdf.UCDN_LINEBREAK_CLASS_SA
UCDN_LINEBREAK_CLASS_SG = _mupdf.UCDN_LINEBREAK_CLASS_SG
UCDN_LINEBREAK_CLASS_SP = _mupdf.UCDN_LINEBREAK_CLASS_SP
UCDN_LINEBREAK_CLASS_XX = _mupdf.UCDN_LINEBREAK_CLASS_XX
UCDN_LINEBREAK_CLASS_ZWJ = _mupdf.UCDN_LINEBREAK_CLASS_ZWJ
UCDN_LINEBREAK_CLASS_EB = _mupdf.UCDN_LINEBREAK_CLASS_EB
UCDN_LINEBREAK_CLASS_EM = _mupdf.UCDN_LINEBREAK_CLASS_EM
UCDN_GENERAL_CATEGORY_CC = _mupdf.UCDN_GENERAL_CATEGORY_CC
UCDN_GENERAL_CATEGORY_CF = _mupdf.UCDN_GENERAL_CATEGORY_CF
UCDN_GENERAL_CATEGORY_CN = _mupdf.UCDN_GENERAL_CATEGORY_CN
UCDN_GENERAL_CATEGORY_CO = _mupdf.UCDN_GENERAL_CATEGORY_CO
UCDN_GENERAL_CATEGORY_CS = _mupdf.UCDN_GENERAL_CATEGORY_CS
UCDN_GENERAL_CATEGORY_LL = _mupdf.UCDN_GENERAL_CATEGORY_LL
UCDN_GENERAL_CATEGORY_LM = _mupdf.UCDN_GENERAL_CATEGORY_LM
UCDN_GENERAL_CATEGORY_LO = _mupdf.UCDN_GENERAL_CATEGORY_LO
UCDN_GENERAL_CATEGORY_LT = _mupdf.UCDN_GENERAL_CATEGORY_LT
UCDN_GENERAL_CATEGORY_LU = _mupdf.UCDN_GENERAL_CATEGORY_LU
UCDN_GENERAL_CATEGORY_MC = _mupdf.UCDN_GENERAL_CATEGORY_MC
UCDN_GENERAL_CATEGORY_ME = _mupdf.UCDN_GENERAL_CATEGORY_ME
UCDN_GENERAL_CATEGORY_MN = _mupdf.UCDN_GENERAL_CATEGORY_MN
UCDN_GENERAL_CATEGORY_ND = _mupdf.UCDN_GENERAL_CATEGORY_ND
UCDN_GENERAL_CATEGORY_NL = _mupdf.UCDN_GENERAL_CATEGORY_NL
UCDN_GENERAL_CATEGORY_NO = _mupdf.UCDN_GENERAL_CATEGORY_NO
UCDN_GENERAL_CATEGORY_PC = _mupdf.UCDN_GENERAL_CATEGORY_PC
UCDN_GENERAL_CATEGORY_PD = _mupdf.UCDN_GENERAL_CATEGORY_PD
UCDN_GENERAL_CATEGORY_PE = _mupdf.UCDN_GENERAL_CATEGORY_PE
UCDN_GENERAL_CATEGORY_PF = _mupdf.UCDN_GENERAL_CATEGORY_PF
UCDN_GENERAL_CATEGORY_PI = _mupdf.UCDN_GENERAL_CATEGORY_PI
UCDN_GENERAL_CATEGORY_PO = _mupdf.UCDN_GENERAL_CATEGORY_PO
UCDN_GENERAL_CATEGORY_PS = _mupdf.UCDN_GENERAL_CATEGORY_PS
UCDN_GENERAL_CATEGORY_SC = _mupdf.UCDN_GENERAL_CATEGORY_SC
UCDN_GENERAL_CATEGORY_SK = _mupdf.UCDN_GENERAL_CATEGORY_SK
UCDN_GENERAL_CATEGORY_SM = _mupdf.UCDN_GENERAL_CATEGORY_SM
UCDN_GENERAL_CATEGORY_SO = _mupdf.UCDN_GENERAL_CATEGORY_SO
UCDN_GENERAL_CATEGORY_ZL = _mupdf.UCDN_GENERAL_CATEGORY_ZL
UCDN_GENERAL_CATEGORY_ZP = _mupdf.UCDN_GENERAL_CATEGORY_ZP
UCDN_GENERAL_CATEGORY_ZS = _mupdf.UCDN_GENERAL_CATEGORY_ZS
UCDN_BIDI_CLASS_L = _mupdf.UCDN_BIDI_CLASS_L
UCDN_BIDI_CLASS_LRE = _mupdf.UCDN_BIDI_CLASS_LRE
UCDN_BIDI_CLASS_LRO = _mupdf.UCDN_BIDI_CLASS_LRO
UCDN_BIDI_CLASS_R = _mupdf.UCDN_BIDI_CLASS_R
UCDN_BIDI_CLASS_AL = _mupdf.UCDN_BIDI_CLASS_AL
UCDN_BIDI_CLASS_RLE = _mupdf.UCDN_BIDI_CLASS_RLE
UCDN_BIDI_CLASS_RLO = _mupdf.UCDN_BIDI_CLASS_RLO
UCDN_BIDI_CLASS_PDF = _mupdf.UCDN_BIDI_CLASS_PDF
UCDN_BIDI_CLASS_EN = _mupdf.UCDN_BIDI_CLASS_EN
UCDN_BIDI_CLASS_ES = _mupdf.UCDN_BIDI_CLASS_ES
UCDN_BIDI_CLASS_ET = _mupdf.UCDN_BIDI_CLASS_ET
UCDN_BIDI_CLASS_AN = _mupdf.UCDN_BIDI_CLASS_AN
UCDN_BIDI_CLASS_CS = _mupdf.UCDN_BIDI_CLASS_CS
UCDN_BIDI_CLASS_NSM = _mupdf.UCDN_BIDI_CLASS_NSM
UCDN_BIDI_CLASS_BN = _mupdf.UCDN_BIDI_CLASS_BN
UCDN_BIDI_CLASS_B = _mupdf.UCDN_BIDI_CLASS_B
UCDN_BIDI_CLASS_S = _mupdf.UCDN_BIDI_CLASS_S
UCDN_BIDI_CLASS_WS = _mupdf.UCDN_BIDI_CLASS_WS
UCDN_BIDI_CLASS_ON = _mupdf.UCDN_BIDI_CLASS_ON
UCDN_BIDI_CLASS_LRI = _mupdf.UCDN_BIDI_CLASS_LRI
UCDN_BIDI_CLASS_RLI = _mupdf.UCDN_BIDI_CLASS_RLI
UCDN_BIDI_CLASS_FSI = _mupdf.UCDN_BIDI_CLASS_FSI
UCDN_BIDI_CLASS_PDI = _mupdf.UCDN_BIDI_CLASS_PDI
UCDN_BIDI_PAIRED_BRACKET_TYPE_OPEN = _mupdf.UCDN_BIDI_PAIRED_BRACKET_TYPE_OPEN
UCDN_BIDI_PAIRED_BRACKET_TYPE_CLOSE = _mupdf.UCDN_BIDI_PAIRED_BRACKET_TYPE_CLOSE
UCDN_BIDI_PAIRED_BRACKET_TYPE_NONE = _mupdf.UCDN_BIDI_PAIRED_BRACKET_TYPE_NONE

def new_pint():
    return _mupdf.new_pint()

def copy_pint(value):
    return _mupdf.copy_pint(value)

def delete_pint(obj):
    return _mupdf.delete_pint(obj)

def pint_assign(obj, value):
    return _mupdf.pint_assign(obj, value)

def pint_value(obj):
    return _mupdf.pint_value(obj)


import inspect
import os
import re
import sys
import traceback

def log( text):
    print( text, file=sys.stderr)

g_mupdf_trace_director = (os.environ.get('MUPDF_trace_director') == '1')

def fz_lookup_metadata(document, key):
    """
    Like fz_lookup_metadata2() but returns None on error
    instead of raising exception.
    """
    try:
        return fz_lookup_metadata2(document, key)
    except Exception:
        return
FzDocument.fz_lookup_metadata                         = fz_lookup_metadata

def pdf_lookup_metadata(document, key):
    """
    Likepsd_lookup_metadata2() but returns None on error
    instead of raising exception.
    """
    try:
        return pdf_lookup_metadata2(document, key)
    except Exception:
        return
PdfDocument.pdf_lookup_metadata                         = pdf_lookup_metadata

import inspect
import io
import os
import sys
import traceback
import types
def exception_info(
        exception_or_traceback=None,
        limit=None,
        file=None,
        chain=True,
        outer=True,
        show_exception_type=True,
        _filelinefn=True,
        ):
    '''
    Shows an exception and/or backtrace.

    Alternative to `traceback.*` functions that print/return information about
    exceptions and backtraces, such as:

        * `traceback.format_exc()`
        * `traceback.format_exception()`
        * `traceback.print_exc()`
        * `traceback.print_exception()`

    Install as system default with:

        `sys.excepthook = lambda type_, exception, traceback: jlib.exception_info( exception)`

    Returns `None`, or the generated text if `file` is 'return'.

    Args:
        exception_or_traceback:
            `None`, a `BaseException`, a `types.TracebackType` (typically from
            an exception's `.__traceback__` member) or an `inspect.FrameInfo`.

            If `None` we use current exception from `sys.exc_info()` if set,
            otherwise the current backtrace from `inspect.stack()`.
        limit:
            As in `traceback.*` functions: `None` to show all frames, positive
            to show last `limit` frames, negative to exclude outermost `-limit`
            frames. Zero to not show any backtraces.
        file:
            As in `traceback.*` functions: file-like object to which we write
            output, or `sys.stderr` if `None`. Special value 'return' makes us
            return our output as a string.
        chain:
            As in `traceback.*` functions: if true (the default) we show
            chained exceptions as described in PEP-3134. Special value
            'because' reverses the usual ordering, showing higher-level
            exceptions first and joining with 'Because:' text.
        outer:
            If true (the default) we also show an exception's outer frames
            above the `catch` block (see next section for details). We
            use `outer=false` internally for chained exceptions to avoid
            duplication.
        show_exception_type:
            Controls whether exception text is prefixed by
            `f'{type(exception)}: '`. If callable we only include this prefix
            if `show_exception_type(exception)` is true. Otherwise if true (the
            default) we include the prefix for all exceptions (this mimcs the
            behaviour of `traceback.*` functions). Otherwise we exclude the
            prefix for all exceptions.
        _filelinefn:
            Internal only; makes us omit file:line: information to allow simple
            doctest comparison with expected output.

    Differences from `traceback.*` functions:

        Frames are displayed as one line in the form::

            <file>:<line>:<function>: <text>

        Filenames are displayed as relative to the current directory if
        applicable.

        Inclusion of outer frames:
            Unlike `traceback.*` functions, stack traces for exceptions include
            outer stack frames above the point at which an exception was caught
            - i.e. frames from the top-level <module> or thread creation to the
            catch block. [Search for 'sys.exc_info backtrace incomplete' for
            more details.]

            We separate the two parts of the backtrace using a marker line
            '^except raise:' where '^except' points upwards to the frame that
            caught the exception and 'raise:' refers downwards to the frame
            that raised the exception.

            So the backtrace for an exception looks like this::

                <file>:<line>:<fn>: <text>  [in root module.]
                ...                         [... other frames]
                <file>:<line>:<fn>: <text>  [in except: block where exception was caught.]
                ^except raise:              [marker line]
                <file>:<line>:<fn>: <text>  [in try: block.]
                ...                         [... other frames]
                <file>:<line>:<fn>: <text>  [where the exception was raised.]

    Examples:

        In these examples we use `file=sys.stdout` so we can check the output
        with `doctest`, and set `_filelinefn=0` so that the output can be
        matched easily. We also use `+ELLIPSIS` and `...` to match arbitrary
        outer frames from the doctest code itself.

        Basic handling of an exception:

            >>> def c():
            ...     raise Exception( 'c() failed')
            >>> def b():
            ...     try:
            ...         c()
            ...     except Exception as e:
            ...         exception_info( e, file=sys.stdout, _filelinefn=0)
            >>> def a():
            ...     b()

            >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
            Traceback (most recent call last):
                ...
                a(): b()
                b(): exception_info( e, file=sys.stdout, _filelinefn=0)
                ^except raise:
                b(): c()
                c(): raise Exception( 'c() failed')
            Exception: c() failed

        Handling of chained exceptions:

            >>> def e():
            ...     raise Exception( 'e(): deliberate error')
            >>> def d():
            ...     e()
            >>> def c():
            ...     try:
            ...         d()
            ...     except Exception as e:
            ...         raise Exception( 'c: d() failed') from e
            >>> def b():
            ...     try:
            ...         c()
            ...     except Exception as e:
            ...         exception_info( file=sys.stdout, chain=g_chain, _filelinefn=0)
            >>> def a():
            ...     b()

            With `chain=True` (the default), we output low-level exceptions
            first, matching the behaviour of `traceback.*` functions:

                >>> g_chain = True
                >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
                Traceback (most recent call last):
                    c(): d()
                    d(): e()
                    e(): raise Exception( 'e(): deliberate error')
                Exception: e(): deliberate error
                <BLANKLINE>
                The above exception was the direct cause of the following exception:
                Traceback (most recent call last):
                    ...
                    <module>(): a() # doctest: +REPORT_UDIFF +ELLIPSIS
                    a(): b()
                    b(): exception_info( file=sys.stdout, chain=g_chain, _filelinefn=0)
                    ^except raise:
                    b(): c()
                    c(): raise Exception( 'c: d() failed') from e
                Exception: c: d() failed

            With `chain='because'`, we output high-level exceptions first:
                >>> g_chain = 'because'
                >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
                Traceback (most recent call last):
                    ...
                    <module>(): a() # doctest: +REPORT_UDIFF +ELLIPSIS
                    a(): b()
                    b(): exception_info( file=sys.stdout, chain=g_chain, _filelinefn=0)
                    ^except raise:
                    b(): c()
                    c(): raise Exception( 'c: d() failed') from e
                Exception: c: d() failed
                <BLANKLINE>
                Because:
                Traceback (most recent call last):
                    c(): d()
                    d(): e()
                    e(): raise Exception( 'e(): deliberate error')
                Exception: e(): deliberate error

        Show current backtrace by passing `exception_or_traceback=None`:
            >>> def c():
            ...     exception_info( None, file=sys.stdout, _filelinefn=0)
            >>> def b():
            ...     return c()
            >>> def a():
            ...     return b()

            >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
            Traceback (most recent call last):
                ...
                <module>(): a() # doctest: +REPORT_UDIFF +ELLIPSIS
                a(): return b()
                b(): return c()
                c(): exception_info( None, file=sys.stdout, _filelinefn=0)

        Show an exception's `.__traceback__` backtrace:
            >>> def c():
            ...     raise Exception( 'foo') # raise
            >>> def b():
            ...     return c()  # call c
            >>> def a():
            ...     try:
            ...         b() # call b
            ...     except Exception as e:
            ...         exception_info( e.__traceback__, file=sys.stdout, _filelinefn=0)

            >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
            Traceback (most recent call last):
                ...
                a(): b() # call b
                b(): return c()  # call c
                c(): raise Exception( 'foo') # raise
    '''
# Set exactly one of <exception> and <tb>.
#
    if isinstance( exception_or_traceback, (types.TracebackType, inspect.FrameInfo)):
# Simple backtrace, no Exception information.
        exception = None
        tb = exception_or_traceback
    elif isinstance( exception_or_traceback, BaseException):
        exception = exception_or_traceback
        tb = None
    elif exception_or_traceback is None:
# Show exception if available, else backtrace.
        _, exception, tb = sys.exc_info()
        tb = None if exception else inspect.stack()[1:]
    else:
        assert 0, f'Unrecognised exception_or_traceback type: {type(exception_or_traceback)}'

    if file == 'return':
        out = io.StringIO()
    else:
        out = file if file else sys.stderr

    def do_chain( exception):
        exception_info(
                exception,
                limit,
                out,
                chain,
                outer=False,
                show_exception_type=show_exception_type,
                _filelinefn=_filelinefn,
                )

    if exception and chain and chain != 'because' and chain != 'because-compact':
# Output current exception first.
        if exception.__cause__:
            do_chain( exception.__cause__)
            out.write( '\nThe above exception was the direct cause of the following exception:\n')
        elif exception.__context__:
            do_chain( exception.__context__)
            out.write( '\nDuring handling of the above exception, another exception occurred:\n')

    cwd = os.getcwd() + os.sep

    def output_frames( frames, reverse, limit):
        if limit == 0:
            return
        if reverse:
            assert isinstance( frames, list)
            frames = reversed( frames)
        if limit is not None:
            frames = list( frames)
            frames = frames[ -limit:]
        for frame in frames:
            f, filename, line, fnname, text, index = frame
            text = text[0].strip() if text else ''
            if filename.startswith( cwd):
                filename = filename[ len(cwd):]
            if filename.startswith( f'.{os.sep}'):
                filename = filename[ 2:]
            if _filelinefn:
                out.write( f'    {filename}:{line}:{fnname}(): {text}\n')
            else:
                out.write( f'    {fnname}(): {text}\n')

    if limit != 0:
        out.write( 'Traceback (most recent call last):\n')
        if exception:
            tb = exception.__traceback__
            assert tb
            if outer:
                output_frames( inspect.getouterframes( tb.tb_frame), reverse=True, limit=limit)
                out.write( '    ^except raise:\n')
            limit2 = 0 if limit == 0 else None
            output_frames( inspect.getinnerframes( tb), reverse=False, limit=limit2)
        else:
            if not isinstance( tb, list):
                inner = inspect.getinnerframes(tb)
                outer = inspect.getouterframes(tb.tb_frame)
                tb = outer + inner
                tb.reverse()
            output_frames( tb, reverse=True, limit=limit)

    if exception:
        if callable(show_exception_type):
            show_exception_type2 = show_exception_type( exception)
        else:
            show_exception_type2 = show_exception_type
        if show_exception_type2:
            lines = traceback.format_exception_only( type(exception), exception)
            for line in lines:
                out.write( line)
        else:
            out.write( str( exception) + '\n')

    if exception and (chain == 'because' or chain == 'because-compact'):
# Output current exception afterwards.
        pre, post = ('\n', '\n') if chain == 'because' else ('', ' ')
        if exception.__cause__:
            out.write( f'{pre}Because:{post}')
            do_chain( exception.__cause__)
        elif exception.__context__:
            out.write( f'{pre}Because: error occurred handling this exception:{post}')
            do_chain( exception.__context__)

    if file == 'return':
        return out.getvalue()
def ll_fz_bidi_fragment_text(text, textlen, callback, arg, flags):
    """
    Wrapper for out-params of fz_bidi_fragment_text().
    Returns: ::fz_bidi_direction baseDir
    """
    outparams = ll_fz_bidi_fragment_text_outparams()
    ret = ll_fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags, outparams)
    return outparams.baseDir

def fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags):
    """
    Class-aware helper for out-params of fz_bidi_fragment_text() [fz_bidi_fragment_text()].
    """
    baseDir = ll_fz_bidi_fragment_text(text, textlen, callback, arg, flags)
    return baseDir

fz_bidi_fragment_text = fz_bidi_fragment_text_outparams_fn


def ll_fz_bitmap_details(bitmap):
    """
    Wrapper for out-params of fz_bitmap_details().
    Returns: int w, int h, int n, int stride
    """
    outparams = ll_fz_bitmap_details_outparams()
    ret = ll_fz_bitmap_details_outparams_fn(bitmap, outparams)
    return outparams.w, outparams.h, outparams.n, outparams.stride

def fz_bitmap_details_outparams_fn(bitmap):
    """
    Class-aware helper for out-params of fz_bitmap_details() [fz_bitmap_details()].
    """
    w, h, n, stride = ll_fz_bitmap_details(bitmap.m_internal)
    return w, h, n, stride

fz_bitmap_details = fz_bitmap_details_outparams_fn


def ll_fz_buffer_extract(buf):
    """
    Wrapper for out-params of fz_buffer_extract().
    Returns: size_t, unsigned char *data
    """
    outparams = ll_fz_buffer_extract_outparams()
    ret = ll_fz_buffer_extract_outparams_fn(buf, outparams)
    return ret, outparams.data

def fz_buffer_extract_outparams_fn(buf):
    """
    Class-aware helper for out-params of fz_buffer_extract() [fz_buffer_extract()].
    """
    ret, data = ll_fz_buffer_extract(buf.m_internal)
    return ret, data

fz_buffer_extract = fz_buffer_extract_outparams_fn


def ll_fz_buffer_storage(buf):
    """
    Wrapper for out-params of fz_buffer_storage().
    Returns: size_t, unsigned char *datap
    """
    outparams = ll_fz_buffer_storage_outparams()
    ret = ll_fz_buffer_storage_outparams_fn(buf, outparams)
    return ret, outparams.datap

def fz_buffer_storage_outparams_fn(buf):
    """
    Class-aware helper for out-params of fz_buffer_storage() [fz_buffer_storage()].
    """
    ret, datap = ll_fz_buffer_storage(buf.m_internal)
    return ret, datap

fz_buffer_storage = fz_buffer_storage_outparams_fn


def ll_fz_chartorune(str):
    """
    Wrapper for out-params of fz_chartorune().
    Returns: int, int rune
    """
    outparams = ll_fz_chartorune_outparams()
    ret = ll_fz_chartorune_outparams_fn(str, outparams)
    return ret, outparams.rune

def fz_chartorune_outparams_fn(str):
    """
    Class-aware helper for out-params of fz_chartorune() [fz_chartorune()].
    """
    ret, rune = ll_fz_chartorune(str)
    return ret, rune

fz_chartorune = fz_chartorune_outparams_fn


def ll_fz_clamp_color(cs, in_):
    """
    Wrapper for out-params of fz_clamp_color().
    Returns: float out
    """
    outparams = ll_fz_clamp_color_outparams()
    ret = ll_fz_clamp_color_outparams_fn(cs, in_, outparams)
    return outparams.out

def fz_clamp_color_outparams_fn(cs, in_):
    """
    Class-aware helper for out-params of fz_clamp_color() [fz_clamp_color()].
    """
    out = ll_fz_clamp_color(cs.m_internal, in_)
    return out

fz_clamp_color = fz_clamp_color_outparams_fn


def ll_fz_convert_color(ss, sv, ds, is_, params):
    """
    Wrapper for out-params of fz_convert_color().
    Returns: float dv
    """
    outparams = ll_fz_convert_color_outparams()
    ret = ll_fz_convert_color_outparams_fn(ss, sv, ds, is_, params, outparams)
    return outparams.dv

def fz_convert_color_outparams_fn(ss, sv, ds, is_, params):
    """
    Class-aware helper for out-params of fz_convert_color() [fz_convert_color()].
    """
    dv = ll_fz_convert_color(ss.m_internal, sv, ds.m_internal, is_.m_internal, params.internal())
    return dv

fz_convert_color = fz_convert_color_outparams_fn


def ll_fz_convert_error():
    """
    Wrapper for out-params of fz_convert_error().
    Returns: const char *, int code
    """
    outparams = ll_fz_convert_error_outparams()
    ret = ll_fz_convert_error_outparams_fn(outparams)
    return ret, outparams.code

def fz_convert_error_outparams_fn():
    """
    Class-aware helper for out-params of fz_convert_error() [fz_convert_error()].
    """
    ret, code = ll_fz_convert_error()
    return ret, code

fz_convert_error = fz_convert_error_outparams_fn


def ll_fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, color_params):
    """
    Wrapper for out-params of fz_convert_separation_colors().
    Returns: float dst_color
    """
    outparams = ll_fz_convert_separation_colors_outparams()
    ret = ll_fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params, outparams)
    return outparams.dst_color

def fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params):
    """
    Class-aware helper for out-params of fz_convert_separation_colors() [fz_convert_separation_colors()].
    """
    dst_color = ll_fz_convert_separation_colors(src_cs.m_internal, src_color, dst_seps.m_internal, dst_cs.m_internal, color_params.internal())
    return dst_color

fz_convert_separation_colors = fz_convert_separation_colors_outparams_fn


def ll_fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor):
    """
    Wrapper for out-params of fz_decomp_image_from_stream().
    Returns: fz_pixmap *, int l2extra
    """
    outparams = ll_fz_decomp_image_from_stream_outparams()
    ret = ll_fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor, outparams)
    return ret, outparams.l2extra

def fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor):
    """
    Class-aware helper for out-params of fz_decomp_image_from_stream() [fz_decomp_image_from_stream()].
    """
    ret, l2extra = ll_fz_decomp_image_from_stream(stm.m_internal, image.m_internal, subarea.internal(), indexed, l2factor)
    return FzPixmap(ret), l2extra

fz_decomp_image_from_stream = fz_decomp_image_from_stream_outparams_fn


def ll_fz_deflate(dest, source, source_length, level):
    """
    Wrapper for out-params of fz_deflate().
    Returns: size_t compressed_length
    """
    outparams = ll_fz_deflate_outparams()
    ret = ll_fz_deflate_outparams_fn(dest, source, source_length, level, outparams)
    return outparams.compressed_length

def fz_deflate_outparams_fn(dest, source, source_length, level):
    """
    Class-aware helper for out-params of fz_deflate() [fz_deflate()].
    """
    compressed_length = ll_fz_deflate(dest, source, source_length, level)
    return compressed_length

fz_deflate = fz_deflate_outparams_fn


def ll_fz_dom_get_attribute(elt, i):
    """
    Wrapper for out-params of fz_dom_get_attribute().
    Returns: const char *, const char *att
    """
    outparams = ll_fz_dom_get_attribute_outparams()
    ret = ll_fz_dom_get_attribute_outparams_fn(elt, i, outparams)
    return ret, outparams.att

def fz_dom_get_attribute_outparams_fn(elt, i):
    """
    Class-aware helper for out-params of fz_dom_get_attribute() [fz_dom_get_attribute()].
    """
    ret, att = ll_fz_dom_get_attribute(elt.m_internal, i)
    return ret, att

fz_dom_get_attribute = fz_dom_get_attribute_outparams_fn


def ll_fz_drop_imp(p):
    """
    Wrapper for out-params of fz_drop_imp().
    Returns: int, int refs
    """
    outparams = ll_fz_drop_imp_outparams()
    ret = ll_fz_drop_imp_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_drop_imp16(p):
    """
    Wrapper for out-params of fz_drop_imp16().
    Returns: int, int16_t refs
    """
    outparams = ll_fz_drop_imp16_outparams()
    ret = ll_fz_drop_imp16_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_encode_character_with_fallback(font, unicode, script, language):
    """
    Wrapper for out-params of fz_encode_character_with_fallback().
    Returns: int, ::fz_font *out_font
    """
    outparams = ll_fz_encode_character_with_fallback_outparams()
    ret = ll_fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language, outparams)
    return ret, outparams.out_font

def fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language):
    """
    Class-aware helper for out-params of fz_encode_character_with_fallback() [fz_encode_character_with_fallback()].
    """
    ret, out_font = ll_fz_encode_character_with_fallback(font.m_internal, unicode, script, language)
    return ret, FzFont(ll_fz_keep_font( out_font))

fz_encode_character_with_fallback = fz_encode_character_with_fallback_outparams_fn


def ll_fz_error_callback():
    """
    Wrapper for out-params of fz_error_callback().
    Returns: fz_error_cb *, void *user
    """
    outparams = ll_fz_error_callback_outparams()
    ret = ll_fz_error_callback_outparams_fn(outparams)
    return ret, outparams.user

def fz_error_callback_outparams_fn():
    """
    Class-aware helper for out-params of fz_error_callback() [fz_error_callback()].
    """
    ret, user = ll_fz_error_callback()
    return ret, user

fz_error_callback = fz_error_callback_outparams_fn


def ll_fz_eval_function(func, in_, inlen, outlen):
    """
    Wrapper for out-params of fz_eval_function().
    Returns: float out
    """
    outparams = ll_fz_eval_function_outparams()
    ret = ll_fz_eval_function_outparams_fn(func, in_, inlen, outlen, outparams)
    return outparams.out

def fz_eval_function_outparams_fn(func, in_, inlen, outlen):
    """
    Class-aware helper for out-params of fz_eval_function() [fz_eval_function()].
    """
    out = ll_fz_eval_function(func.m_internal, in_, inlen, outlen)
    return out

fz_eval_function = fz_eval_function_outparams_fn


def ll_fz_fill_pixmap_with_color(pix, colorspace, color_params):
    """
    Wrapper for out-params of fz_fill_pixmap_with_color().
    Returns: float color
    """
    outparams = ll_fz_fill_pixmap_with_color_outparams()
    ret = ll_fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params, outparams)
    return outparams.color

def fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params):
    """
    Class-aware helper for out-params of fz_fill_pixmap_with_color() [fz_fill_pixmap_with_color()].
    """
    color = ll_fz_fill_pixmap_with_color(pix.m_internal, colorspace.m_internal, color_params.internal())
    return color

fz_fill_pixmap_with_color = fz_fill_pixmap_with_color_outparams_fn


def ll_fz_get_pixmap_from_image(image, subarea, ctm):
    """
    Wrapper for out-params of fz_get_pixmap_from_image().
    Returns: fz_pixmap *, int w, int h
    """
    outparams = ll_fz_get_pixmap_from_image_outparams()
    ret = ll_fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm, outparams)
    return ret, outparams.w, outparams.h

def fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm):
    """
    Class-aware helper for out-params of fz_get_pixmap_from_image() [fz_get_pixmap_from_image()].
    """
    ret, w, h = ll_fz_get_pixmap_from_image(image.m_internal, subarea.internal(), ctm.internal())
    return FzPixmap(ret), w, h

fz_get_pixmap_from_image = fz_get_pixmap_from_image_outparams_fn


def ll_fz_getopt(nargc, ostr):
    """
    Wrapper for out-params of fz_getopt().
    Returns: int, char *nargv
    """
    outparams = ll_fz_getopt_outparams()
    ret = ll_fz_getopt_outparams_fn(nargc, ostr, outparams)
    return ret, outparams.nargv

def fz_getopt_outparams_fn(nargc, ostr):
    """
    Class-aware helper for out-params of fz_getopt() [fz_getopt()].
    """
    ret, nargv = ll_fz_getopt(nargc, ostr)
    return ret, nargv

fz_getopt = fz_getopt_outparams_fn


def ll_fz_getopt_long(nargc, ostr, longopts):
    """
    Wrapper for out-params of fz_getopt_long().
    Returns: int, char *nargv
    """
    outparams = ll_fz_getopt_long_outparams()
    ret = ll_fz_getopt_long_outparams_fn(nargc, ostr, longopts, outparams)
    return ret, outparams.nargv

def fz_getopt_long_outparams_fn(nargc, ostr, longopts):
    """
    Class-aware helper for out-params of fz_getopt_long() [fz_getopt_long()].
    """
    ret, nargv = ll_fz_getopt_long(nargc, ostr, longopts.m_internal)
    return ret, nargv

fz_getopt_long = fz_getopt_long_outparams_fn


def ll_fz_grisu(f, s):
    """
    Wrapper for out-params of fz_grisu().
    Returns: int, int exp
    """
    outparams = ll_fz_grisu_outparams()
    ret = ll_fz_grisu_outparams_fn(f, s, outparams)
    return ret, outparams.exp

def fz_grisu_outparams_fn(f, s):
    """
    Class-aware helper for out-params of fz_grisu() [fz_grisu()].
    """
    ret, exp = ll_fz_grisu(f, s)
    return ret, exp

fz_grisu = fz_grisu_outparams_fn


def ll_fz_has_option(opts, key):
    """
    Wrapper for out-params of fz_has_option().
    Returns: int, const char *val
    """
    outparams = ll_fz_has_option_outparams()
    ret = ll_fz_has_option_outparams_fn(opts, key, outparams)
    return ret, outparams.val

def fz_has_option_outparams_fn(opts, key):
    """
    Class-aware helper for out-params of fz_has_option() [fz_has_option()].
    """
    ret, val = ll_fz_has_option(opts, key)
    return ret, val

fz_has_option = fz_has_option_outparams_fn


def ll_fz_image_resolution(image):
    """
    Wrapper for out-params of fz_image_resolution().
    Returns: int xres, int yres
    """
    outparams = ll_fz_image_resolution_outparams()
    ret = ll_fz_image_resolution_outparams_fn(image, outparams)
    return outparams.xres, outparams.yres

def fz_image_resolution_outparams_fn(image):
    """
    Class-aware helper for out-params of fz_image_resolution() [fz_image_resolution()].
    """
    xres, yres = ll_fz_image_resolution(image.m_internal)
    return xres, yres

fz_image_resolution = fz_image_resolution_outparams_fn


def ll_fz_keep_imp(p):
    """
    Wrapper for out-params of fz_keep_imp().
    Returns: void *, int refs
    """
    outparams = ll_fz_keep_imp_outparams()
    ret = ll_fz_keep_imp_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_keep_imp16(p):
    """
    Wrapper for out-params of fz_keep_imp16().
    Returns: void *, int16_t refs
    """
    outparams = ll_fz_keep_imp16_outparams()
    ret = ll_fz_keep_imp16_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_keep_imp_locked(p):
    """
    Wrapper for out-params of fz_keep_imp_locked().
    Returns: void *, int refs
    """
    outparams = ll_fz_keep_imp_locked_outparams()
    ret = ll_fz_keep_imp_locked_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_lookup_base14_font(name):
    """
    Wrapper for out-params of fz_lookup_base14_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_base14_font_outparams()
    ret = ll_fz_lookup_base14_font_outparams_fn(name, outparams)
    return ret, outparams.len

def fz_lookup_base14_font_outparams_fn(name):
    """
    Class-aware helper for out-params of fz_lookup_base14_font() [fz_lookup_base14_font()].
    """
    ret, len = ll_fz_lookup_base14_font(name)
    return ret, len

fz_lookup_base14_font = fz_lookup_base14_font_outparams_fn


def ll_fz_lookup_builtin_font(name, bold, italic):
    """
    Wrapper for out-params of fz_lookup_builtin_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_builtin_font_outparams()
    ret = ll_fz_lookup_builtin_font_outparams_fn(name, bold, italic, outparams)
    return ret, outparams.len

def fz_lookup_builtin_font_outparams_fn(name, bold, italic):
    """
    Class-aware helper for out-params of fz_lookup_builtin_font() [fz_lookup_builtin_font()].
    """
    ret, len = ll_fz_lookup_builtin_font(name, bold, italic)
    return ret, len

fz_lookup_builtin_font = fz_lookup_builtin_font_outparams_fn


def ll_fz_lookup_cjk_font(ordering):
    """
    Wrapper for out-params of fz_lookup_cjk_font().
    Returns: const unsigned char *, int len, int index
    """
    outparams = ll_fz_lookup_cjk_font_outparams()
    ret = ll_fz_lookup_cjk_font_outparams_fn(ordering, outparams)
    return ret, outparams.len, outparams.index

def fz_lookup_cjk_font_outparams_fn(ordering):
    """
    Class-aware helper for out-params of fz_lookup_cjk_font() [fz_lookup_cjk_font()].
    """
    ret, len, index = ll_fz_lookup_cjk_font(ordering)
    return ret, len, index

fz_lookup_cjk_font = fz_lookup_cjk_font_outparams_fn


def ll_fz_lookup_cjk_font_by_language(lang):
    """
    Wrapper for out-params of fz_lookup_cjk_font_by_language().
    Returns: const unsigned char *, int len, int subfont
    """
    outparams = ll_fz_lookup_cjk_font_by_language_outparams()
    ret = ll_fz_lookup_cjk_font_by_language_outparams_fn(lang, outparams)
    return ret, outparams.len, outparams.subfont

def fz_lookup_cjk_font_by_language_outparams_fn(lang):
    """
    Class-aware helper for out-params of fz_lookup_cjk_font_by_language() [fz_lookup_cjk_font_by_language()].
    """
    ret, len, subfont = ll_fz_lookup_cjk_font_by_language(lang)
    return ret, len, subfont

fz_lookup_cjk_font_by_language = fz_lookup_cjk_font_by_language_outparams_fn


def ll_fz_lookup_noto_boxes_font():
    """
    Wrapper for out-params of fz_lookup_noto_boxes_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_boxes_font_outparams()
    ret = ll_fz_lookup_noto_boxes_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_boxes_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_boxes_font() [fz_lookup_noto_boxes_font()].
    """
    ret, len = ll_fz_lookup_noto_boxes_font()
    return ret, len

fz_lookup_noto_boxes_font = fz_lookup_noto_boxes_font_outparams_fn


def ll_fz_lookup_noto_emoji_font():
    """
    Wrapper for out-params of fz_lookup_noto_emoji_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_emoji_font_outparams()
    ret = ll_fz_lookup_noto_emoji_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_emoji_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_emoji_font() [fz_lookup_noto_emoji_font()].
    """
    ret, len = ll_fz_lookup_noto_emoji_font()
    return ret, len

fz_lookup_noto_emoji_font = fz_lookup_noto_emoji_font_outparams_fn


def ll_fz_lookup_noto_font(script, lang):
    """
    Wrapper for out-params of fz_lookup_noto_font().
    Returns: const unsigned char *, int len, int subfont
    """
    outparams = ll_fz_lookup_noto_font_outparams()
    ret = ll_fz_lookup_noto_font_outparams_fn(script, lang, outparams)
    return ret, outparams.len, outparams.subfont

def fz_lookup_noto_font_outparams_fn(script, lang):
    """
    Class-aware helper for out-params of fz_lookup_noto_font() [fz_lookup_noto_font()].
    """
    ret, len, subfont = ll_fz_lookup_noto_font(script, lang)
    return ret, len, subfont

fz_lookup_noto_font = fz_lookup_noto_font_outparams_fn


def ll_fz_lookup_noto_math_font():
    """
    Wrapper for out-params of fz_lookup_noto_math_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_math_font_outparams()
    ret = ll_fz_lookup_noto_math_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_math_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_math_font() [fz_lookup_noto_math_font()].
    """
    ret, len = ll_fz_lookup_noto_math_font()
    return ret, len

fz_lookup_noto_math_font = fz_lookup_noto_math_font_outparams_fn


def ll_fz_lookup_noto_music_font():
    """
    Wrapper for out-params of fz_lookup_noto_music_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_music_font_outparams()
    ret = ll_fz_lookup_noto_music_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_music_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_music_font() [fz_lookup_noto_music_font()].
    """
    ret, len = ll_fz_lookup_noto_music_font()
    return ret, len

fz_lookup_noto_music_font = fz_lookup_noto_music_font_outparams_fn


def ll_fz_lookup_noto_symbol1_font():
    """
    Wrapper for out-params of fz_lookup_noto_symbol1_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_symbol1_font_outparams()
    ret = ll_fz_lookup_noto_symbol1_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_symbol1_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_symbol1_font() [fz_lookup_noto_symbol1_font()].
    """
    ret, len = ll_fz_lookup_noto_symbol1_font()
    return ret, len

fz_lookup_noto_symbol1_font = fz_lookup_noto_symbol1_font_outparams_fn


def ll_fz_lookup_noto_symbol2_font():
    """
    Wrapper for out-params of fz_lookup_noto_symbol2_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_symbol2_font_outparams()
    ret = ll_fz_lookup_noto_symbol2_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_symbol2_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_symbol2_font() [fz_lookup_noto_symbol2_font()].
    """
    ret, len = ll_fz_lookup_noto_symbol2_font()
    return ret, len

fz_lookup_noto_symbol2_font = fz_lookup_noto_symbol2_font_outparams_fn


def ll_fz_new_deflated_data(source, source_length, level):
    """
    Wrapper for out-params of fz_new_deflated_data().
    Returns: unsigned char *, size_t compressed_length
    """
    outparams = ll_fz_new_deflated_data_outparams()
    ret = ll_fz_new_deflated_data_outparams_fn(source, source_length, level, outparams)
    return ret, outparams.compressed_length

def fz_new_deflated_data_outparams_fn(source, source_length, level):
    """
    Class-aware helper for out-params of fz_new_deflated_data() [fz_new_deflated_data()].
    """
    ret, compressed_length = ll_fz_new_deflated_data(source, source_length, level)
    return ret, compressed_length

fz_new_deflated_data = fz_new_deflated_data_outparams_fn


def ll_fz_new_deflated_data_from_buffer(buffer, level):
    """
    Wrapper for out-params of fz_new_deflated_data_from_buffer().
    Returns: unsigned char *, size_t compressed_length
    """
    outparams = ll_fz_new_deflated_data_from_buffer_outparams()
    ret = ll_fz_new_deflated_data_from_buffer_outparams_fn(buffer, level, outparams)
    return ret, outparams.compressed_length

def fz_new_deflated_data_from_buffer_outparams_fn(buffer, level):
    """
    Class-aware helper for out-params of fz_new_deflated_data_from_buffer() [fz_new_deflated_data_from_buffer()].
    """
    ret, compressed_length = ll_fz_new_deflated_data_from_buffer(buffer.m_internal, level)
    return ret, compressed_length

fz_new_deflated_data_from_buffer = fz_new_deflated_data_from_buffer_outparams_fn


def ll_fz_new_display_list_from_svg(buf, base_uri, dir):
    """
    Wrapper for out-params of fz_new_display_list_from_svg().
    Returns: fz_display_list *, float w, float h
    """
    outparams = ll_fz_new_display_list_from_svg_outparams()
    ret = ll_fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir, outparams)
    return ret, outparams.w, outparams.h

def fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir):
    """
    Class-aware helper for out-params of fz_new_display_list_from_svg() [fz_new_display_list_from_svg()].
    """
    ret, w, h = ll_fz_new_display_list_from_svg(buf.m_internal, base_uri, dir.m_internal)
    return FzDisplayList(ret), w, h

fz_new_display_list_from_svg = fz_new_display_list_from_svg_outparams_fn


def ll_fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir):
    """
    Wrapper for out-params of fz_new_display_list_from_svg_xml().
    Returns: fz_display_list *, float w, float h
    """
    outparams = ll_fz_new_display_list_from_svg_xml_outparams()
    ret = ll_fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir, outparams)
    return ret, outparams.w, outparams.h

def fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir):
    """
    Class-aware helper for out-params of fz_new_display_list_from_svg_xml() [fz_new_display_list_from_svg_xml()].
    """
    ret, w, h = ll_fz_new_display_list_from_svg_xml(xmldoc.m_internal, xml.m_internal, base_uri, dir.m_internal)
    return FzDisplayList(ret), w, h

fz_new_display_list_from_svg_xml = fz_new_display_list_from_svg_xml_outparams_fn


def ll_fz_new_draw_device_with_options(options, mediabox):
    """
    Wrapper for out-params of fz_new_draw_device_with_options().
    Returns: fz_device *, ::fz_pixmap *pixmap
    """
    outparams = ll_fz_new_draw_device_with_options_outparams()
    ret = ll_fz_new_draw_device_with_options_outparams_fn(options, mediabox, outparams)
    return ret, outparams.pixmap

def fz_new_draw_device_with_options_outparams_fn(options, mediabox):
    """
    Class-aware helper for out-params of fz_new_draw_device_with_options() [fz_new_draw_device_with_options()].
    """
    ret, pixmap = ll_fz_new_draw_device_with_options(options.internal(), mediabox.internal())
    return FzDevice(ret), FzPixmap( pixmap)

fz_new_draw_device_with_options = fz_new_draw_device_with_options_outparams_fn


def ll_fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images):
    """
    Wrapper for out-params of fz_new_svg_device_with_id().
    Returns: fz_device *, int id
    """
    outparams = ll_fz_new_svg_device_with_id_outparams()
    ret = ll_fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images, outparams)
    return ret, outparams.id

def fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images):
    """
    Class-aware helper for out-params of fz_new_svg_device_with_id() [fz_new_svg_device_with_id()].
    """
    ret, id = ll_fz_new_svg_device_with_id(out.m_internal, page_width, page_height, text_format, reuse_images)
    return FzDevice(ret), id

fz_new_svg_device_with_id = fz_new_svg_device_with_id_outparams_fn


def ll_fz_new_test_device(threshold, options, passthrough):
    """
    Wrapper for out-params of fz_new_test_device().
    Returns: fz_device *, int is_color
    """
    outparams = ll_fz_new_test_device_outparams()
    ret = ll_fz_new_test_device_outparams_fn(threshold, options, passthrough, outparams)
    return ret, outparams.is_color

def fz_new_test_device_outparams_fn(threshold, options, passthrough):
    """
    Class-aware helper for out-params of fz_new_test_device() [fz_new_test_device()].
    """
    ret, is_color = ll_fz_new_test_device(threshold, options, passthrough.m_internal)
    return FzDevice(ret), is_color

fz_new_test_device = fz_new_test_device_outparams_fn


def ll_fz_open_image_decomp_stream(arg_0, arg_1):
    """
    Wrapper for out-params of fz_open_image_decomp_stream().
    Returns: fz_stream *, int l2factor
    """
    outparams = ll_fz_open_image_decomp_stream_outparams()
    ret = ll_fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1, outparams)
    return ret, outparams.l2factor

def fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1):
    """
    Class-aware helper for out-params of fz_open_image_decomp_stream() [fz_open_image_decomp_stream()].
    """
    ret, l2factor = ll_fz_open_image_decomp_stream(arg_0.m_internal, arg_1.m_internal)
    return FzStream(ret), l2factor

fz_open_image_decomp_stream = fz_open_image_decomp_stream_outparams_fn


def ll_fz_open_image_decomp_stream_from_buffer(arg_0):
    """
    Wrapper for out-params of fz_open_image_decomp_stream_from_buffer().
    Returns: fz_stream *, int l2factor
    """
    outparams = ll_fz_open_image_decomp_stream_from_buffer_outparams()
    ret = ll_fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0, outparams)
    return ret, outparams.l2factor

def fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0):
    """
    Class-aware helper for out-params of fz_open_image_decomp_stream_from_buffer() [fz_open_image_decomp_stream_from_buffer()].
    """
    ret, l2factor = ll_fz_open_image_decomp_stream_from_buffer(arg_0.m_internal)
    return FzStream(ret), l2factor

fz_open_image_decomp_stream_from_buffer = fz_open_image_decomp_stream_from_buffer_outparams_fn


def ll_fz_page_presentation(page, transition):
    """
    Wrapper for out-params of fz_page_presentation().
    Returns: fz_transition *, float duration
    """
    outparams = ll_fz_page_presentation_outparams()
    ret = ll_fz_page_presentation_outparams_fn(page, transition, outparams)
    return ret, outparams.duration

def fz_page_presentation_outparams_fn(page, transition):
    """
    Class-aware helper for out-params of fz_page_presentation() [fz_page_presentation()].
    """
    ret, duration = ll_fz_page_presentation(page.m_internal, transition.internal())
    return FzTransition(ret), duration

fz_page_presentation = fz_page_presentation_outparams_fn


def ll_fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop):
    """
    Wrapper for out-params of fz_paint_shade().
    Returns: ::fz_shade_color_cache *cache
    """
    outparams = ll_fz_paint_shade_outparams()
    ret = ll_fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop, outparams)
    return outparams.cache

def fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop):
    """
    Class-aware helper for out-params of fz_paint_shade() [fz_paint_shade()].
    """
    cache = ll_fz_paint_shade(shade.m_internal, override_cs.m_internal, ctm.internal(), dest.m_internal, color_params.internal(), bbox.internal(), eop.m_internal)
    return FzShadeColorCache(ll_fz_keep_shade_color_cache( cache))

fz_paint_shade = fz_paint_shade_outparams_fn


def ll_fz_parse_page_range(s, n):
    """
    Wrapper for out-params of fz_parse_page_range().
    Returns: const char *, int a, int b
    """
    outparams = ll_fz_parse_page_range_outparams()
    ret = ll_fz_parse_page_range_outparams_fn(s, n, outparams)
    return ret, outparams.a, outparams.b

def fz_parse_page_range_outparams_fn(s, n):
    """
    Class-aware helper for out-params of fz_parse_page_range() [fz_parse_page_range()].
    """
    ret, a, b = ll_fz_parse_page_range(s, n)
    return ret, a, b

fz_parse_page_range = fz_parse_page_range_outparams_fn


def ll_fz_read_best(stm, initial, worst_case):
    """
    Wrapper for out-params of fz_read_best().
    Returns: fz_buffer *, int truncated
    """
    outparams = ll_fz_read_best_outparams()
    ret = ll_fz_read_best_outparams_fn(stm, initial, worst_case, outparams)
    return ret, outparams.truncated

def fz_read_best_outparams_fn(stm, initial, worst_case):
    """
    Class-aware helper for out-params of fz_read_best() [fz_read_best()].
    """
    ret, truncated = ll_fz_read_best(stm.m_internal, initial, worst_case)
    return FzBuffer(ret), truncated

fz_read_best = fz_read_best_outparams_fn


def ll_fz_resolve_link(doc, uri):
    """
    Wrapper for out-params of fz_resolve_link().
    Returns: fz_location, float xp, float yp
    """
    outparams = ll_fz_resolve_link_outparams()
    ret = ll_fz_resolve_link_outparams_fn(doc, uri, outparams)
    return ret, outparams.xp, outparams.yp

def fz_resolve_link_outparams_fn(doc, uri):
    """
    Class-aware helper for out-params of fz_resolve_link() [fz_resolve_link()].
    """
    ret, xp, yp = ll_fz_resolve_link(doc.m_internal, uri)
    return FzLocation(ret), xp, yp

fz_resolve_link = fz_resolve_link_outparams_fn


def ll_fz_search_chapter_page_number(doc, chapter, page, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_chapter_page_number().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_chapter_page_number_outparams()
    ret = ll_fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_chapter_page_number() [fz_search_chapter_page_number()].
    """
    ret, hit_mark = ll_fz_search_chapter_page_number(doc.m_internal, chapter, page, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_chapter_page_number = fz_search_chapter_page_number_outparams_fn


def ll_fz_search_display_list(list, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_display_list().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_display_list_outparams()
    ret = ll_fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_display_list() [fz_search_display_list()].
    """
    ret, hit_mark = ll_fz_search_display_list(list.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_display_list = fz_search_display_list_outparams_fn


def ll_fz_search_page(page, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_page().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_page_outparams()
    ret = ll_fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_page() [fz_search_page()].
    """
    ret, hit_mark = ll_fz_search_page(page.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_page = fz_search_page_outparams_fn


def ll_fz_search_page_number(doc, number, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_page_number().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_page_number_outparams()
    ret = ll_fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_page_number() [fz_search_page_number()].
    """
    ret, hit_mark = ll_fz_search_page_number(doc.m_internal, number, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_page_number = fz_search_page_number_outparams_fn


def ll_fz_search_stext_page(text, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_stext_page().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_stext_page_outparams()
    ret = ll_fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_stext_page() [fz_search_stext_page()].
    """
    ret, hit_mark = ll_fz_search_stext_page(text.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_stext_page = fz_search_stext_page_outparams_fn


def ll_fz_separation_equivalent(seps, idx, dst_cs, prf, color_params):
    """
    Wrapper for out-params of fz_separation_equivalent().
    Returns: float dst_color
    """
    outparams = ll_fz_separation_equivalent_outparams()
    ret = ll_fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params, outparams)
    return outparams.dst_color

def fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params):
    """
    Class-aware helper for out-params of fz_separation_equivalent() [fz_separation_equivalent()].
    """
    dst_color = ll_fz_separation_equivalent(seps.m_internal, idx, dst_cs.m_internal, prf.m_internal, color_params.internal())
    return dst_color

fz_separation_equivalent = fz_separation_equivalent_outparams_fn


def ll_fz_store_scavenge(size):
    """
    Wrapper for out-params of fz_store_scavenge().
    Returns: int, int phase
    """
    outparams = ll_fz_store_scavenge_outparams()
    ret = ll_fz_store_scavenge_outparams_fn(size, outparams)
    return ret, outparams.phase

def fz_store_scavenge_outparams_fn(size):
    """
    Class-aware helper for out-params of fz_store_scavenge() [fz_store_scavenge()].
    """
    ret, phase = ll_fz_store_scavenge(size)
    return ret, phase

fz_store_scavenge = fz_store_scavenge_outparams_fn


def ll_fz_store_scavenge_external(size):
    """
    Wrapper for out-params of fz_store_scavenge_external().
    Returns: int, int phase
    """
    outparams = ll_fz_store_scavenge_external_outparams()
    ret = ll_fz_store_scavenge_external_outparams_fn(size, outparams)
    return ret, outparams.phase

def fz_store_scavenge_external_outparams_fn(size):
    """
    Class-aware helper for out-params of fz_store_scavenge_external() [fz_store_scavenge_external()].
    """
    ret, phase = ll_fz_store_scavenge_external(size)
    return ret, phase

fz_store_scavenge_external = fz_store_scavenge_external_outparams_fn


def ll_fz_strsep(delim):
    """
    Wrapper for out-params of fz_strsep().
    Returns: char *, char *stringp
    """
    outparams = ll_fz_strsep_outparams()
    ret = ll_fz_strsep_outparams_fn(delim, outparams)
    return ret, outparams.stringp

def fz_strsep_outparams_fn(delim):
    """
    Class-aware helper for out-params of fz_strsep() [fz_strsep()].
    """
    ret, stringp = ll_fz_strsep(delim)
    return ret, stringp

fz_strsep = fz_strsep_outparams_fn


def ll_fz_strtof(s):
    """
    Wrapper for out-params of fz_strtof().
    Returns: float, char *es
    """
    outparams = ll_fz_strtof_outparams()
    ret = ll_fz_strtof_outparams_fn(s, outparams)
    return ret, outparams.es

def fz_strtof_outparams_fn(s):
    """
    Class-aware helper for out-params of fz_strtof() [fz_strtof()].
    """
    ret, es = ll_fz_strtof(s)
    return ret, es

fz_strtof = fz_strtof_outparams_fn


def ll_fz_subset_cff_for_gids(orig, num_gids, symbolic, cidfont):
    """
    Wrapper for out-params of fz_subset_cff_for_gids().
    Returns: fz_buffer *, int gids
    """
    outparams = ll_fz_subset_cff_for_gids_outparams()
    ret = ll_fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
    return ret, outparams.gids

def fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont):
    """
    Class-aware helper for out-params of fz_subset_cff_for_gids() [fz_subset_cff_for_gids()].
    """
    ret, gids = ll_fz_subset_cff_for_gids(orig.m_internal, num_gids, symbolic, cidfont)
    return FzBuffer( ll_fz_keep_buffer( ret)), gids

fz_subset_cff_for_gids = fz_subset_cff_for_gids_outparams_fn


def ll_fz_subset_ttf_for_gids(orig, num_gids, symbolic, cidfont):
    """
    Wrapper for out-params of fz_subset_ttf_for_gids().
    Returns: fz_buffer *, int gids
    """
    outparams = ll_fz_subset_ttf_for_gids_outparams()
    ret = ll_fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
    return ret, outparams.gids

def fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont):
    """
    Class-aware helper for out-params of fz_subset_ttf_for_gids() [fz_subset_ttf_for_gids()].
    """
    ret, gids = ll_fz_subset_ttf_for_gids(orig.m_internal, num_gids, symbolic, cidfont)
    return FzBuffer( ll_fz_keep_buffer( ret)), gids

fz_subset_ttf_for_gids = fz_subset_ttf_for_gids_outparams_fn


def ll_fz_warning_callback():
    """
    Wrapper for out-params of fz_warning_callback().
    Returns: fz_warning_cb *, void *user
    """
    outparams = ll_fz_warning_callback_outparams()
    ret = ll_fz_warning_callback_outparams_fn(outparams)
    return ret, outparams.user

def fz_warning_callback_outparams_fn():
    """
    Class-aware helper for out-params of fz_warning_callback() [fz_warning_callback()].
    """
    ret, user = ll_fz_warning_callback()
    return ret, user

fz_warning_callback = fz_warning_callback_outparams_fn


def ll_pdf_annot_MK_BC(annot, color):
    """
    Wrapper for out-params of pdf_annot_MK_BC().
    Returns: int n
    """
    outparams = ll_pdf_annot_MK_BC_outparams()
    ret = ll_pdf_annot_MK_BC_outparams_fn(annot, color, outparams)
    return outparams.n

def pdf_annot_MK_BC_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_MK_BC() [pdf_annot_MK_BC()].
    """
    n = ll_pdf_annot_MK_BC(annot.m_internal, color)
    return n

pdf_annot_MK_BC = pdf_annot_MK_BC_outparams_fn


def ll_pdf_annot_MK_BG(annot, color):
    """
    Wrapper for out-params of pdf_annot_MK_BG().
    Returns: int n
    """
    outparams = ll_pdf_annot_MK_BG_outparams()
    ret = ll_pdf_annot_MK_BG_outparams_fn(annot, color, outparams)
    return outparams.n

def pdf_annot_MK_BG_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_MK_BG() [pdf_annot_MK_BG()].
    """
    n = ll_pdf_annot_MK_BG(annot.m_internal, color)
    return n

pdf_annot_MK_BG = pdf_annot_MK_BG_outparams_fn


def ll_pdf_annot_callout_line(annot, callout):
    """
    Wrapper for out-params of pdf_annot_callout_line().
    Returns: int n
    """
    outparams = ll_pdf_annot_callout_line_outparams()
    ret = ll_pdf_annot_callout_line_outparams_fn(annot, callout, outparams)
    return outparams.n

def pdf_annot_callout_line_outparams_fn(annot, callout):
    """
    Class-aware helper for out-params of pdf_annot_callout_line() [pdf_annot_callout_line()].
    """
    n = ll_pdf_annot_callout_line(annot.m_internal, callout)
    return n

pdf_annot_callout_line = pdf_annot_callout_line_outparams_fn


def ll_pdf_annot_color(annot, color):
    """
    Wrapper for out-params of pdf_annot_color().
    Returns: int n
    """
    outparams = ll_pdf_annot_color_outparams()
    ret = ll_pdf_annot_color_outparams_fn(annot, color, outparams)
    return outparams.n

def pdf_annot_color_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_color() [pdf_annot_color()].
    """
    n = ll_pdf_annot_color(annot.m_internal, color)
    return n

pdf_annot_color = pdf_annot_color_outparams_fn


def ll_pdf_annot_default_appearance(annot, color):
    """
    Wrapper for out-params of pdf_annot_default_appearance().
    Returns: const char *font, float size, int n
    """
    outparams = ll_pdf_annot_default_appearance_outparams()
    ret = ll_pdf_annot_default_appearance_outparams_fn(annot, color, outparams)
    return outparams.font, outparams.size, outparams.n

def pdf_annot_default_appearance_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_default_appearance() [pdf_annot_default_appearance()].
    """
    font, size, n = ll_pdf_annot_default_appearance(annot.m_internal, color)
    return font, size, n

pdf_annot_default_appearance = pdf_annot_default_appearance_outparams_fn


def ll_pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, color):
    """
    Wrapper for out-params of pdf_annot_default_appearance_unmapped().
    Returns: float size, int n
    """
    outparams = ll_pdf_annot_default_appearance_unmapped_outparams()
    ret = ll_pdf_annot_default_appearance_unmapped_outparams_fn(annot, font_name, font_name_len, color, outparams)
    return outparams.size, outparams.n

def pdf_annot_default_appearance_unmapped_outparams_fn(annot, font_name, font_name_len, color):
    """
    Class-aware helper for out-params of pdf_annot_default_appearance_unmapped() [pdf_annot_default_appearance_unmapped()].
    """
    size, n = ll_pdf_annot_default_appearance_unmapped(annot.m_internal, font_name, font_name_len, color)
    return size, n

pdf_annot_default_appearance_unmapped = pdf_annot_default_appearance_unmapped_outparams_fn


def ll_pdf_annot_interior_color(annot, color):
    """
    Wrapper for out-params of pdf_annot_interior_color().
    Returns: int n
    """
    outparams = ll_pdf_annot_interior_color_outparams()
    ret = ll_pdf_annot_interior_color_outparams_fn(annot, color, outparams)
    return outparams.n

def pdf_annot_interior_color_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_interior_color() [pdf_annot_interior_color()].
    """
    n = ll_pdf_annot_interior_color(annot.m_internal, color)
    return n

pdf_annot_interior_color = pdf_annot_interior_color_outparams_fn


def ll_pdf_annot_line_ending_styles(annot):
    """
    Wrapper for out-params of pdf_annot_line_ending_styles().
    Returns: enum pdf_line_ending start_style, enum pdf_line_ending end_style
    """
    outparams = ll_pdf_annot_line_ending_styles_outparams()
    ret = ll_pdf_annot_line_ending_styles_outparams_fn(annot, outparams)
    return outparams.start_style, outparams.end_style

def pdf_annot_line_ending_styles_outparams_fn(annot):
    """
    Class-aware helper for out-params of pdf_annot_line_ending_styles() [pdf_annot_line_ending_styles()].
    """
    start_style, end_style = ll_pdf_annot_line_ending_styles(annot.m_internal)
    return start_style, end_style

pdf_annot_line_ending_styles = pdf_annot_line_ending_styles_outparams_fn


def ll_pdf_array_get_string(array, index):
    """
    Wrapper for out-params of pdf_array_get_string().
    Returns: const char *, size_t sizep
    """
    outparams = ll_pdf_array_get_string_outparams()
    ret = ll_pdf_array_get_string_outparams_fn(array, index, outparams)
    return ret, outparams.sizep

def pdf_array_get_string_outparams_fn(array, index):
    """
    Class-aware helper for out-params of pdf_array_get_string() [pdf_array_get_string()].
    """
    ret, sizep = ll_pdf_array_get_string(array.m_internal, index)
    return ret, sizep

pdf_array_get_string = pdf_array_get_string_outparams_fn


def ll_pdf_count_q_balance(doc, res, stm):
    """
    Wrapper for out-params of pdf_count_q_balance().
    Returns: int prepend, int append
    """
    outparams = ll_pdf_count_q_balance_outparams()
    ret = ll_pdf_count_q_balance_outparams_fn(doc, res, stm, outparams)
    return outparams.prepend, outparams.append

def pdf_count_q_balance_outparams_fn(doc, res, stm):
    """
    Class-aware helper for out-params of pdf_count_q_balance() [pdf_count_q_balance()].
    """
    prepend, append = ll_pdf_count_q_balance(doc.m_internal, res.m_internal, stm.m_internal)
    return prepend, append

pdf_count_q_balance = pdf_count_q_balance_outparams_fn


def ll_pdf_decode_cmap(cmap, s, e):
    """
    Wrapper for out-params of pdf_decode_cmap().
    Returns: int, unsigned int cpt
    """
    outparams = ll_pdf_decode_cmap_outparams()
    ret = ll_pdf_decode_cmap_outparams_fn(cmap, s, e, outparams)
    return ret, outparams.cpt

def pdf_decode_cmap_outparams_fn(cmap, s, e):
    """
    Class-aware helper for out-params of pdf_decode_cmap() [pdf_decode_cmap()].
    """
    ret, cpt = ll_pdf_decode_cmap(cmap.m_internal, s, e)
    return ret, cpt

pdf_decode_cmap = pdf_decode_cmap_outparams_fn


def ll_pdf_dict_get_inheritable_string(dict, key):
    """
    Wrapper for out-params of pdf_dict_get_inheritable_string().
    Returns: const char *, size_t sizep
    """
    outparams = ll_pdf_dict_get_inheritable_string_outparams()
    ret = ll_pdf_dict_get_inheritable_string_outparams_fn(dict, key, outparams)
    return ret, outparams.sizep

def pdf_dict_get_inheritable_string_outparams_fn(dict, key):
    """
    Class-aware helper for out-params of pdf_dict_get_inheritable_string() [pdf_dict_get_inheritable_string()].
    """
    ret, sizep = ll_pdf_dict_get_inheritable_string(dict.m_internal, key.m_internal)
    return ret, sizep

pdf_dict_get_inheritable_string = pdf_dict_get_inheritable_string_outparams_fn


def ll_pdf_dict_get_put_drop(dict, key, val):
    """
    Wrapper for out-params of pdf_dict_get_put_drop().
    Returns: ::pdf_obj *old_val
    """
    outparams = ll_pdf_dict_get_put_drop_outparams()
    ret = ll_pdf_dict_get_put_drop_outparams_fn(dict, key, val, outparams)
    return outparams.old_val

def ll_pdf_dict_get_string(dict, key):
    """
    Wrapper for out-params of pdf_dict_get_string().
    Returns: const char *, size_t sizep
    """
    outparams = ll_pdf_dict_get_string_outparams()
    ret = ll_pdf_dict_get_string_outparams_fn(dict, key, outparams)
    return ret, outparams.sizep

def pdf_dict_get_string_outparams_fn(dict, key):
    """
    Class-aware helper for out-params of pdf_dict_get_string() [pdf_dict_get_string()].
    """
    ret, sizep = ll_pdf_dict_get_string(dict.m_internal, key.m_internal)
    return ret, sizep

pdf_dict_get_string = pdf_dict_get_string_outparams_fn


def ll_pdf_edit_text_field_value(widget, value, change):
    """
    Wrapper for out-params of pdf_edit_text_field_value().
    Returns: int, int selStart, int selEnd, char *newvalue
    """
    outparams = ll_pdf_edit_text_field_value_outparams()
    ret = ll_pdf_edit_text_field_value_outparams_fn(widget, value, change, outparams)
    return ret, outparams.selStart, outparams.selEnd, outparams.newvalue

def pdf_edit_text_field_value_outparams_fn(widget, value, change):
    """
    Class-aware helper for out-params of pdf_edit_text_field_value() [pdf_edit_text_field_value()].
    """
    ret, selStart, selEnd, newvalue = ll_pdf_edit_text_field_value(widget.m_internal, value, change)
    return ret, selStart, selEnd, newvalue

pdf_edit_text_field_value = pdf_edit_text_field_value_outparams_fn


def ll_pdf_eval_function(func, in_, inlen, outlen):
    """
    Wrapper for out-params of pdf_eval_function().
    Returns: float out
    """
    outparams = ll_pdf_eval_function_outparams()
    ret = ll_pdf_eval_function_outparams_fn(func, in_, inlen, outlen, outparams)
    return outparams.out

def pdf_eval_function_outparams_fn(func, in_, inlen, outlen):
    """
    Class-aware helper for out-params of pdf_eval_function() [pdf_eval_function()].
    """
    out = ll_pdf_eval_function(func.m_internal, in_, inlen, outlen)
    return out

pdf_eval_function = pdf_eval_function_outparams_fn


def ll_pdf_field_event_validate(doc, field, value):
    """
    Wrapper for out-params of pdf_field_event_validate().
    Returns: int, char *newvalue
    """
    outparams = ll_pdf_field_event_validate_outparams()
    ret = ll_pdf_field_event_validate_outparams_fn(doc, field, value, outparams)
    return ret, outparams.newvalue

def pdf_field_event_validate_outparams_fn(doc, field, value):
    """
    Class-aware helper for out-params of pdf_field_event_validate() [pdf_field_event_validate()].
    """
    ret, newvalue = ll_pdf_field_event_validate(doc.m_internal, field.m_internal, value)
    return ret, newvalue

pdf_field_event_validate = pdf_field_event_validate_outparams_fn


def ll_pdf_js_event_result_validate(js):
    """
    Wrapper for out-params of pdf_js_event_result_validate().
    Returns: int, char *newvalue
    """
    outparams = ll_pdf_js_event_result_validate_outparams()
    ret = ll_pdf_js_event_result_validate_outparams_fn(js, outparams)
    return ret, outparams.newvalue

def pdf_js_event_result_validate_outparams_fn(js):
    """
    Class-aware helper for out-params of pdf_js_event_result_validate() [pdf_js_event_result_validate()].
    """
    ret, newvalue = ll_pdf_js_event_result_validate(js.m_internal)
    return ret, newvalue

pdf_js_event_result_validate = pdf_js_event_result_validate_outparams_fn


def ll_pdf_js_execute(js, name, code):
    """
    Wrapper for out-params of pdf_js_execute().
    Returns: char *result
    """
    outparams = ll_pdf_js_execute_outparams()
    ret = ll_pdf_js_execute_outparams_fn(js, name, code, outparams)
    return outparams.result

def pdf_js_execute_outparams_fn(js, name, code):
    """
    Class-aware helper for out-params of pdf_js_execute() [pdf_js_execute()].
    """
    result = ll_pdf_js_execute(js.m_internal, name, code)
    return result

pdf_js_execute = pdf_js_execute_outparams_fn


def ll_pdf_load_encoding(encoding):
    """
    Wrapper for out-params of pdf_load_encoding().
    Returns: const char *estrings
    """
    outparams = ll_pdf_load_encoding_outparams()
    ret = ll_pdf_load_encoding_outparams_fn(encoding, outparams)
    return outparams.estrings

def pdf_load_encoding_outparams_fn(encoding):
    """
    Class-aware helper for out-params of pdf_load_encoding() [pdf_load_encoding()].
    """
    estrings = ll_pdf_load_encoding(encoding)
    return estrings

pdf_load_encoding = pdf_load_encoding_outparams_fn


def ll_pdf_load_to_unicode(doc, font, collection, cmapstm):
    """
    Wrapper for out-params of pdf_load_to_unicode().
    Returns: const char *strings
    """
    outparams = ll_pdf_load_to_unicode_outparams()
    ret = ll_pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm, outparams)
    return outparams.strings

def pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm):
    """
    Class-aware helper for out-params of pdf_load_to_unicode() [pdf_load_to_unicode()].
    """
    strings = ll_pdf_load_to_unicode(doc.m_internal, font.m_internal, collection, cmapstm.m_internal)
    return strings

pdf_load_to_unicode = pdf_load_to_unicode_outparams_fn


def ll_pdf_lookup_cmap_full(cmap, cpt):
    """
    Wrapper for out-params of pdf_lookup_cmap_full().
    Returns: int, int out
    """
    outparams = ll_pdf_lookup_cmap_full_outparams()
    ret = ll_pdf_lookup_cmap_full_outparams_fn(cmap, cpt, outparams)
    return ret, outparams.out

def pdf_lookup_cmap_full_outparams_fn(cmap, cpt):
    """
    Class-aware helper for out-params of pdf_lookup_cmap_full() [pdf_lookup_cmap_full()].
    """
    ret, out = ll_pdf_lookup_cmap_full(cmap.m_internal, cpt)
    return ret, out

pdf_lookup_cmap_full = pdf_lookup_cmap_full_outparams_fn


def ll_pdf_lookup_page_loc(doc, needle):
    """
    Wrapper for out-params of pdf_lookup_page_loc().
    Returns: pdf_obj *, ::pdf_obj *parentp, int indexp
    """
    outparams = ll_pdf_lookup_page_loc_outparams()
    ret = ll_pdf_lookup_page_loc_outparams_fn(doc, needle, outparams)
    return ret, outparams.parentp, outparams.indexp

def pdf_lookup_page_loc_outparams_fn(doc, needle):
    """
    Class-aware helper for out-params of pdf_lookup_page_loc() [pdf_lookup_page_loc()].
    """
    ret, parentp, indexp = ll_pdf_lookup_page_loc(doc.m_internal, needle)
    return PdfObj( ll_pdf_keep_obj( ret)), PdfObj(ll_pdf_keep_obj( parentp)), indexp

pdf_lookup_page_loc = pdf_lookup_page_loc_outparams_fn


def ll_pdf_lookup_substitute_font(mono, serif, bold, italic):
    """
    Wrapper for out-params of pdf_lookup_substitute_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_pdf_lookup_substitute_font_outparams()
    ret = ll_pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic, outparams)
    return ret, outparams.len

def pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic):
    """
    Class-aware helper for out-params of pdf_lookup_substitute_font() [pdf_lookup_substitute_font()].
    """
    ret, len = ll_pdf_lookup_substitute_font(mono, serif, bold, italic)
    return ret, len

pdf_lookup_substitute_font = pdf_lookup_substitute_font_outparams_fn


def ll_pdf_map_one_to_many(cmap, one, len):
    """
    Wrapper for out-params of pdf_map_one_to_many().
    Returns: int many
    """
    outparams = ll_pdf_map_one_to_many_outparams()
    ret = ll_pdf_map_one_to_many_outparams_fn(cmap, one, len, outparams)
    return outparams.many

def pdf_map_one_to_many_outparams_fn(cmap, one, len):
    """
    Class-aware helper for out-params of pdf_map_one_to_many() [pdf_map_one_to_many()].
    """
    many = ll_pdf_map_one_to_many(cmap.m_internal, one, len)
    return many

pdf_map_one_to_many = pdf_map_one_to_many_outparams_fn


def ll_pdf_obj_memo(obj, bit):
    """
    Wrapper for out-params of pdf_obj_memo().
    Returns: int, int memo
    """
    outparams = ll_pdf_obj_memo_outparams()
    ret = ll_pdf_obj_memo_outparams_fn(obj, bit, outparams)
    return ret, outparams.memo

def pdf_obj_memo_outparams_fn(obj, bit):
    """
    Class-aware helper for out-params of pdf_obj_memo() [pdf_obj_memo()].
    """
    ret, memo = ll_pdf_obj_memo(obj.m_internal, bit)
    return ret, memo

pdf_obj_memo = pdf_obj_memo_outparams_fn


def ll_pdf_page_presentation(page, transition):
    """
    Wrapper for out-params of pdf_page_presentation().
    Returns: fz_transition *, float duration
    """
    outparams = ll_pdf_page_presentation_outparams()
    ret = ll_pdf_page_presentation_outparams_fn(page, transition, outparams)
    return ret, outparams.duration

def pdf_page_presentation_outparams_fn(page, transition):
    """
    Class-aware helper for out-params of pdf_page_presentation() [pdf_page_presentation()].
    """
    ret, duration = ll_pdf_page_presentation(page.m_internal, transition.internal())
    return FzTransition(ret), duration

pdf_page_presentation = pdf_page_presentation_outparams_fn


def ll_pdf_page_write(doc, mediabox):
    """
    Wrapper for out-params of pdf_page_write().
    Returns: fz_device *, ::pdf_obj *presources, ::fz_buffer *pcontents
    """
    outparams = ll_pdf_page_write_outparams()
    ret = ll_pdf_page_write_outparams_fn(doc, mediabox, outparams)
    return ret, outparams.presources, outparams.pcontents

def pdf_page_write_outparams_fn(doc, mediabox):
    """
    Class-aware helper for out-params of pdf_page_write() [pdf_page_write()].
    """
    ret, presources, pcontents = ll_pdf_page_write(doc.m_internal, mediabox.internal())
    return FzDevice(ret), PdfObj( presources), FzBuffer( pcontents)

pdf_page_write = pdf_page_write_outparams_fn


def ll_pdf_parse_default_appearance(da, color):
    """
    Wrapper for out-params of pdf_parse_default_appearance().
    Returns: const char *font, float size, int n
    """
    outparams = ll_pdf_parse_default_appearance_outparams()
    ret = ll_pdf_parse_default_appearance_outparams_fn(da, color, outparams)
    return outparams.font, outparams.size, outparams.n

def pdf_parse_default_appearance_outparams_fn(da, color):
    """
    Class-aware helper for out-params of pdf_parse_default_appearance() [pdf_parse_default_appearance()].
    """
    font, size, n = ll_pdf_parse_default_appearance(da, color)
    return font, size, n

pdf_parse_default_appearance = pdf_parse_default_appearance_outparams_fn


def ll_pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, color):
    """
    Wrapper for out-params of pdf_parse_default_appearance_unmapped().
    Returns: float size, int n
    """
    outparams = ll_pdf_parse_default_appearance_unmapped_outparams()
    ret = ll_pdf_parse_default_appearance_unmapped_outparams_fn(da, font_name, font_name_len, color, outparams)
    return outparams.size, outparams.n

def pdf_parse_default_appearance_unmapped_outparams_fn(da, font_name, font_name_len, color):
    """
    Class-aware helper for out-params of pdf_parse_default_appearance_unmapped() [pdf_parse_default_appearance_unmapped()].
    """
    size, n = ll_pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, color)
    return size, n

pdf_parse_default_appearance_unmapped = pdf_parse_default_appearance_unmapped_outparams_fn


def ll_pdf_parse_ind_obj(doc, f):
    """
    Wrapper for out-params of pdf_parse_ind_obj().
    Returns: pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair
    """
    outparams = ll_pdf_parse_ind_obj_outparams()
    ret = ll_pdf_parse_ind_obj_outparams_fn(doc, f, outparams)
    return ret, outparams.num, outparams.gen, outparams.stm_ofs, outparams.try_repair

def pdf_parse_ind_obj_outparams_fn(doc, f):
    """
    Class-aware helper for out-params of pdf_parse_ind_obj() [pdf_parse_ind_obj()].
    """
    ret, num, gen, stm_ofs, try_repair = ll_pdf_parse_ind_obj(doc.m_internal, f.m_internal)
    return PdfObj(ret), num, gen, stm_ofs, try_repair

pdf_parse_ind_obj = pdf_parse_ind_obj_outparams_fn


def ll_pdf_parse_journal_obj(doc, stm):
    """
    Wrapper for out-params of pdf_parse_journal_obj().
    Returns: pdf_obj *, int onum, ::fz_buffer *ostm, int newobj
    """
    outparams = ll_pdf_parse_journal_obj_outparams()
    ret = ll_pdf_parse_journal_obj_outparams_fn(doc, stm, outparams)
    return ret, outparams.onum, outparams.ostm, outparams.newobj

def pdf_parse_journal_obj_outparams_fn(doc, stm):
    """
    Class-aware helper for out-params of pdf_parse_journal_obj() [pdf_parse_journal_obj()].
    """
    ret, onum, ostm, newobj = ll_pdf_parse_journal_obj(doc.m_internal, stm.m_internal)
    return PdfObj(ret), onum, FzBuffer( ostm), newobj

pdf_parse_journal_obj = pdf_parse_journal_obj_outparams_fn


def ll_pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen):
    """
    Wrapper for out-params of pdf_print_encrypted_obj().
    Returns: int sep
    """
    outparams = ll_pdf_print_encrypted_obj_outparams()
    ret = ll_pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen, outparams)
    return outparams.sep

def pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen):
    """
    Class-aware helper for out-params of pdf_print_encrypted_obj() [pdf_print_encrypted_obj()].
    """
    sep = ll_pdf_print_encrypted_obj(out.m_internal, obj.m_internal, tight, ascii, crypt.m_internal, num, gen)
    return sep

pdf_print_encrypted_obj = pdf_print_encrypted_obj_outparams_fn


def ll_pdf_process_contents(proc, doc, res, stm, cookie):
    """
    Wrapper for out-params of pdf_process_contents().
    Returns: ::pdf_obj *out_res
    """
    outparams = ll_pdf_process_contents_outparams()
    ret = ll_pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie, outparams)
    return outparams.out_res

def pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie):
    """
    Class-aware helper for out-params of pdf_process_contents() [pdf_process_contents()].
    """
    out_res = ll_pdf_process_contents(proc.m_internal, doc.m_internal, res.m_internal, stm.m_internal, cookie.m_internal)
    return PdfObj(ll_pdf_keep_obj( out_res))

pdf_process_contents = pdf_process_contents_outparams_fn


def ll_pdf_repair_obj(doc, buf):
    """
    Wrapper for out-params of pdf_repair_obj().
    Returns: int, int64_t stmofsp, int64_t stmlenp, ::pdf_obj *encrypt, ::pdf_obj *id, ::pdf_obj *page, int64_t tmpofs, ::pdf_obj *root
    """
    outparams = ll_pdf_repair_obj_outparams()
    ret = ll_pdf_repair_obj_outparams_fn(doc, buf, outparams)
    return ret, outparams.stmofsp, outparams.stmlenp, outparams.encrypt, outparams.id, outparams.page, outparams.tmpofs, outparams.root

def pdf_repair_obj_outparams_fn(doc, buf):
    """
    Class-aware helper for out-params of pdf_repair_obj() [pdf_repair_obj()].
    """
    ret, stmofsp, stmlenp, encrypt, id, page, tmpofs, root = ll_pdf_repair_obj(doc.m_internal, buf.m_internal)
    return ret, stmofsp, stmlenp, PdfObj(ll_pdf_keep_obj( encrypt)), PdfObj(ll_pdf_keep_obj( id)), PdfObj(ll_pdf_keep_obj( page)), tmpofs, PdfObj(ll_pdf_keep_obj( root))

pdf_repair_obj = pdf_repair_obj_outparams_fn


def ll_pdf_resolve_link(doc, uri):
    """
    Wrapper for out-params of pdf_resolve_link().
    Returns: int, float xp, float yp
    """
    outparams = ll_pdf_resolve_link_outparams()
    ret = ll_pdf_resolve_link_outparams_fn(doc, uri, outparams)
    return ret, outparams.xp, outparams.yp

def pdf_resolve_link_outparams_fn(doc, uri):
    """
    Class-aware helper for out-params of pdf_resolve_link() [pdf_resolve_link()].
    """
    ret, xp, yp = ll_pdf_resolve_link(doc.m_internal, uri)
    return ret, xp, yp

pdf_resolve_link = pdf_resolve_link_outparams_fn


def ll_pdf_sample_shade_function(n, funcs, t0, t1):
    """
    Wrapper for out-params of pdf_sample_shade_function().
    Returns: float samples, ::pdf_function *func
    """
    outparams = ll_pdf_sample_shade_function_outparams()
    ret = ll_pdf_sample_shade_function_outparams_fn(n, funcs, t0, t1, outparams)
    return outparams.samples, outparams.func

def pdf_sample_shade_function_outparams_fn(n, funcs, t0, t1):
    """
    Class-aware helper for out-params of pdf_sample_shade_function() [pdf_sample_shade_function()].
    """
    samples, func = ll_pdf_sample_shade_function(n, funcs, t0, t1)
    return samples, PdfFunction(ll_pdf_keep_function( func))

pdf_sample_shade_function = pdf_sample_shade_function_outparams_fn


def ll_pdf_signature_contents(doc, signature):
    """
    Wrapper for out-params of pdf_signature_contents().
    Returns: size_t, char *contents
    """
    outparams = ll_pdf_signature_contents_outparams()
    ret = ll_pdf_signature_contents_outparams_fn(doc, signature, outparams)
    return ret, outparams.contents

def pdf_signature_contents_outparams_fn(doc, signature):
    """
    Class-aware helper for out-params of pdf_signature_contents() [pdf_signature_contents()].
    """
    ret, contents = ll_pdf_signature_contents(doc.m_internal, signature.m_internal)
    return ret, contents

pdf_signature_contents = pdf_signature_contents_outparams_fn


def ll_pdf_sprint_obj(buf, cap, obj, tight, ascii):
    """
    Wrapper for out-params of pdf_sprint_obj().
    Returns: char *, size_t len
    """
    outparams = ll_pdf_sprint_obj_outparams()
    ret = ll_pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii, outparams)
    return ret, outparams.len

def pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii):
    """
    Class-aware helper for out-params of pdf_sprint_obj() [pdf_sprint_obj()].
    """
    ret, len = ll_pdf_sprint_obj(buf, cap, obj.m_internal, tight, ascii)
    return ret, len

pdf_sprint_obj = pdf_sprint_obj_outparams_fn


def ll_pdf_to_string(obj):
    """
    Wrapper for out-params of pdf_to_string().
    Returns: const char *, size_t sizep
    """
    outparams = ll_pdf_to_string_outparams()
    ret = ll_pdf_to_string_outparams_fn(obj, outparams)
    return ret, outparams.sizep

def pdf_to_string_outparams_fn(obj):
    """
    Class-aware helper for out-params of pdf_to_string() [pdf_to_string()].
    """
    ret, sizep = ll_pdf_to_string(obj.m_internal)
    return ret, sizep

pdf_to_string = pdf_to_string_outparams_fn


def ll_pdf_tos_make_trm(tos, text, fontdesc, cid, trm):
    """
    Wrapper for out-params of pdf_tos_make_trm().
    Returns: int, float adv
    """
    outparams = ll_pdf_tos_make_trm_outparams()
    ret = ll_pdf_tos_make_trm_outparams_fn(tos, text, fontdesc, cid, trm, outparams)
    return ret, outparams.adv

def pdf_tos_make_trm_outparams_fn(tos, text, fontdesc, cid, trm):
    """
    Class-aware helper for out-params of pdf_tos_make_trm() [pdf_tos_make_trm()].
    """
    ret, adv = ll_pdf_tos_make_trm(tos.m_internal, text.m_internal, fontdesc.m_internal, cid, trm.internal())
    return ret, adv

pdf_tos_make_trm = pdf_tos_make_trm_outparams_fn


def ll_pdf_undoredo_state(doc):
    """
    Wrapper for out-params of pdf_undoredo_state().
    Returns: int, int steps
    """
    outparams = ll_pdf_undoredo_state_outparams()
    ret = ll_pdf_undoredo_state_outparams_fn(doc, outparams)
    return ret, outparams.steps

def pdf_undoredo_state_outparams_fn(doc):
    """
    Class-aware helper for out-params of pdf_undoredo_state() [pdf_undoredo_state()].
    """
    ret, steps = ll_pdf_undoredo_state(doc.m_internal)
    return ret, steps

pdf_undoredo_state = pdf_undoredo_state_outparams_fn


def ll_pdf_walk_tree(tree, kid_name, arrive, leave, arg):
    """
    Wrapper for out-params of pdf_walk_tree().
    Returns: ::pdf_obj *names, ::pdf_obj *values
    """
    outparams = ll_pdf_walk_tree_outparams()
    ret = ll_pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg, outparams)
    return outparams.names, outparams.values

def pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg):
    """
    Class-aware helper for out-params of pdf_walk_tree() [pdf_walk_tree()].
    """
    names, values = ll_pdf_walk_tree(tree.m_internal, kid_name.m_internal, arrive, leave, arg)
    return PdfObj(ll_pdf_keep_obj( names)), PdfObj(ll_pdf_keep_obj( values))

pdf_walk_tree = pdf_walk_tree_outparams_fn


def ll_pdf_zugferd_profile(doc):
    """
    Wrapper for out-params of pdf_zugferd_profile().
    Returns: enum pdf_zugferd_profile, float version
    """
    outparams = ll_pdf_zugferd_profile_outparams()
    ret = ll_pdf_zugferd_profile_outparams_fn(doc, outparams)
    return ret, outparams.version

def pdf_zugferd_profile_outparams_fn(doc):
    """
    Class-aware helper for out-params of pdf_zugferd_profile() [pdf_zugferd_profile()].
    """
    ret, version = ll_pdf_zugferd_profile(doc.m_internal)
    return ret, version

pdf_zugferd_profile = pdf_zugferd_profile_outparams_fn


def FzBitmap_fz_bitmap_details_outparams_fn( self):
    """
    Helper for out-params of class method fz_bitmap::ll_fz_bitmap_details() [fz_bitmap_details()].
    """
    w, h, n, stride = ll_fz_bitmap_details( self.m_internal)
    return w, h, n, stride

FzBitmap.fz_bitmap_details = FzBitmap_fz_bitmap_details_outparams_fn


def FzBuffer_fz_buffer_extract_outparams_fn( self):
    """
    Helper for out-params of class method fz_buffer::ll_fz_buffer_extract() [fz_buffer_extract()].
    """
    ret, data = ll_fz_buffer_extract( self.m_internal)
    return ret, data

FzBuffer.fz_buffer_extract = FzBuffer_fz_buffer_extract_outparams_fn


def FzBuffer_fz_buffer_storage_outparams_fn( self):
    """
    Helper for out-params of class method fz_buffer::ll_fz_buffer_storage() [fz_buffer_storage()].
    """
    ret, datap = ll_fz_buffer_storage( self.m_internal)
    return ret, datap

FzBuffer.fz_buffer_storage = FzBuffer_fz_buffer_storage_outparams_fn


def FzBuffer_fz_new_display_list_from_svg_outparams_fn( self, base_uri, dir):
    """
    Helper for out-params of class method fz_buffer::ll_fz_new_display_list_from_svg() [fz_new_display_list_from_svg()].
    """
    ret, w, h = ll_fz_new_display_list_from_svg( self.m_internal, base_uri, dir.m_internal)
    return FzDisplayList(ret), w, h

FzBuffer.fz_new_display_list_from_svg = FzBuffer_fz_new_display_list_from_svg_outparams_fn


def FzBuffer_fz_subset_cff_for_gids_outparams_fn( self, num_gids, symbolic, cidfont):
    """
    Helper for out-params of class method fz_buffer::ll_fz_subset_cff_for_gids() [fz_subset_cff_for_gids()].
    """
    ret, gids = ll_fz_subset_cff_for_gids( self.m_internal, num_gids, symbolic, cidfont)
    return FzBuffer( ll_fz_keep_buffer( ret)), gids

FzBuffer.fz_subset_cff_for_gids = FzBuffer_fz_subset_cff_for_gids_outparams_fn


def FzBuffer_fz_subset_ttf_for_gids_outparams_fn( self, num_gids, symbolic, cidfont):
    """
    Helper for out-params of class method fz_buffer::ll_fz_subset_ttf_for_gids() [fz_subset_ttf_for_gids()].
    """
    ret, gids = ll_fz_subset_ttf_for_gids( self.m_internal, num_gids, symbolic, cidfont)
    return FzBuffer( ll_fz_keep_buffer( ret)), gids

FzBuffer.fz_subset_ttf_for_gids = FzBuffer_fz_subset_ttf_for_gids_outparams_fn


def FzColorspace_fz_clamp_color_outparams_fn( self, in_):
    """
    Helper for out-params of class method fz_colorspace::ll_fz_clamp_color() [fz_clamp_color()].
    """
    out = ll_fz_clamp_color( self.m_internal, in_)
    return out

FzColorspace.fz_clamp_color = FzColorspace_fz_clamp_color_outparams_fn


def FzColorspace_fz_convert_color_outparams_fn( self, sv, params):
    """
    Helper for out-params of class method fz_colorspace::ll_fz_convert_color() [fz_convert_color()].
    """
    dv = ll_fz_convert_color( self.m_internal, sv, params.internal())
    return dv

FzColorspace.fz_convert_color = FzColorspace_fz_convert_color_outparams_fn


def FzColorspace_fz_convert_separation_colors_outparams_fn( self, src_color, dst_seps, color_params):
    """
    Helper for out-params of class method fz_colorspace::ll_fz_convert_separation_colors() [fz_convert_separation_colors()].
    """
    dst_color = ll_fz_convert_separation_colors( self.m_internal, src_color, dst_seps.m_internal, color_params.internal())
    return dst_color

FzColorspace.fz_convert_separation_colors = FzColorspace_fz_convert_separation_colors_outparams_fn


def FzCompressedBuffer_fz_open_image_decomp_stream_from_buffer_outparams_fn( self):
    """
    Helper for out-params of class method fz_compressed_buffer::ll_fz_open_image_decomp_stream_from_buffer() [fz_open_image_decomp_stream_from_buffer()].
    """
    ret, l2factor = ll_fz_open_image_decomp_stream_from_buffer( self.m_internal)
    return FzStream(ret), l2factor

FzCompressedBuffer.fz_open_image_decomp_stream_from_buffer = FzCompressedBuffer_fz_open_image_decomp_stream_from_buffer_outparams_fn


def FzDisplayList_fz_search_display_list_outparams_fn( self, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_display_list::ll_fz_search_display_list() [fz_search_display_list()].
    """
    ret, hit_mark = ll_fz_search_display_list( self.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzDisplayList.fz_search_display_list = FzDisplayList_fz_search_display_list_outparams_fn


def FzDocument_fz_resolve_link_outparams_fn( self, uri):
    """
    Helper for out-params of class method fz_document::ll_fz_resolve_link() [fz_resolve_link()].
    """
    ret, xp, yp = ll_fz_resolve_link( self.m_internal, uri)
    return FzLocation(ret), xp, yp

FzDocument.fz_resolve_link = FzDocument_fz_resolve_link_outparams_fn


def FzDocument_fz_search_chapter_page_number_outparams_fn( self, chapter, page, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_document::ll_fz_search_chapter_page_number() [fz_search_chapter_page_number()].
    """
    ret, hit_mark = ll_fz_search_chapter_page_number( self.m_internal, chapter, page, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzDocument.fz_search_chapter_page_number = FzDocument_fz_search_chapter_page_number_outparams_fn


def FzDocument_fz_search_page_number_outparams_fn( self, number, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_document::ll_fz_search_page_number() [fz_search_page_number()].
    """
    ret, hit_mark = ll_fz_search_page_number( self.m_internal, number, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzDocument.fz_search_page_number = FzDocument_fz_search_page_number_outparams_fn


def FzFont_fz_encode_character_with_fallback_outparams_fn( self, unicode, script, language):
    """
    Helper for out-params of class method fz_font::ll_fz_encode_character_with_fallback() [fz_encode_character_with_fallback()].
    """
    ret, out_font = ll_fz_encode_character_with_fallback( self.m_internal, unicode, script, language)
    return ret, FzFont(ll_fz_keep_font( out_font))

FzFont.fz_encode_character_with_fallback = FzFont_fz_encode_character_with_fallback_outparams_fn


def FzFunction_fz_eval_function_outparams_fn( self, in_, inlen, outlen):
    """
    Helper for out-params of class method fz_function::ll_fz_eval_function() [fz_eval_function()].
    """
    out = ll_fz_eval_function( self.m_internal, in_, inlen, outlen)
    return out

FzFunction.fz_eval_function = FzFunction_fz_eval_function_outparams_fn


def FzImage_fz_get_pixmap_from_image_outparams_fn( self, subarea, ctm):
    """
    Helper for out-params of class method fz_image::ll_fz_get_pixmap_from_image() [fz_get_pixmap_from_image()].
    """
    ret, w, h = ll_fz_get_pixmap_from_image( self.m_internal, subarea.internal(), ctm.internal())
    return FzPixmap(ret), w, h

FzImage.fz_get_pixmap_from_image = FzImage_fz_get_pixmap_from_image_outparams_fn


def FzImage_fz_image_resolution_outparams_fn( self):
    """
    Helper for out-params of class method fz_image::ll_fz_image_resolution() [fz_image_resolution()].
    """
    xres, yres = ll_fz_image_resolution( self.m_internal)
    return xres, yres

FzImage.fz_image_resolution = FzImage_fz_image_resolution_outparams_fn


def FzOutput_fz_new_svg_device_with_id_outparams_fn( self, page_width, page_height, text_format, reuse_images):
    """
    Helper for out-params of class method fz_output::ll_fz_new_svg_device_with_id() [fz_new_svg_device_with_id()].
    """
    ret, id = ll_fz_new_svg_device_with_id( self.m_internal, page_width, page_height, text_format, reuse_images)
    return FzDevice(ret), id

FzOutput.fz_new_svg_device_with_id = FzOutput_fz_new_svg_device_with_id_outparams_fn


def FzOutput_pdf_print_encrypted_obj_outparams_fn( self, obj, tight, ascii, crypt, num, gen):
    """
    Helper for out-params of class method fz_output::ll_pdf_print_encrypted_obj() [pdf_print_encrypted_obj()].
    """
    sep = ll_pdf_print_encrypted_obj( self.m_internal, obj.m_internal, tight, ascii, crypt.m_internal, num, gen)
    return sep

FzOutput.pdf_print_encrypted_obj = FzOutput_pdf_print_encrypted_obj_outparams_fn


def FzPage_fz_page_presentation_outparams_fn( self, transition):
    """
    Helper for out-params of class method fz_page::ll_fz_page_presentation() [fz_page_presentation()].
    """
    ret, duration = ll_fz_page_presentation( self.m_internal, transition.internal())
    return FzTransition(ret), duration

FzPage.fz_page_presentation = FzPage_fz_page_presentation_outparams_fn


def FzPage_fz_search_page_outparams_fn( self, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_page::ll_fz_search_page() [fz_search_page()].
    """
    ret, hit_mark = ll_fz_search_page( self.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzPage.fz_search_page = FzPage_fz_search_page_outparams_fn


def FzPixmap_fz_fill_pixmap_with_color_outparams_fn( self, colorspace, color_params):
    """
    Helper for out-params of class method fz_pixmap::ll_fz_fill_pixmap_with_color() [fz_fill_pixmap_with_color()].
    """
    color = ll_fz_fill_pixmap_with_color( self.m_internal, colorspace.m_internal, color_params.internal())
    return color

FzPixmap.fz_fill_pixmap_with_color = FzPixmap_fz_fill_pixmap_with_color_outparams_fn


def FzSeparations_fz_separation_equivalent_outparams_fn( self, idx, dst_cs, prf, color_params):
    """
    Helper for out-params of class method fz_separations::ll_fz_separation_equivalent() [fz_separation_equivalent()].
    """
    dst_color = ll_fz_separation_equivalent( self.m_internal, idx, dst_cs.m_internal, prf.m_internal, color_params.internal())
    return dst_color

FzSeparations.fz_separation_equivalent = FzSeparations_fz_separation_equivalent_outparams_fn


def FzShade_fz_paint_shade_outparams_fn( self, override_cs, ctm, dest, color_params, bbox, eop):
    """
    Helper for out-params of class method fz_shade::ll_fz_paint_shade() [fz_paint_shade()].
    """
    cache = ll_fz_paint_shade( self.m_internal, override_cs.m_internal, ctm.internal(), dest.m_internal, color_params.internal(), bbox.internal(), eop.m_internal)
    return FzShadeColorCache(ll_fz_keep_shade_color_cache( cache))

FzShade.fz_paint_shade = FzShade_fz_paint_shade_outparams_fn


def FzStextPage_fz_search_stext_page_outparams_fn( self, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_stext_page::ll_fz_search_stext_page() [fz_search_stext_page()].
    """
    ret, hit_mark = ll_fz_search_stext_page( self.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzStextPage.fz_search_stext_page = FzStextPage_fz_search_stext_page_outparams_fn


def FzStream_fz_decomp_image_from_stream_outparams_fn( self, image, subarea, indexed, l2factor):
    """
    Helper for out-params of class method fz_stream::ll_fz_decomp_image_from_stream() [fz_decomp_image_from_stream()].
    """
    ret, l2extra = ll_fz_decomp_image_from_stream( self.m_internal, image.m_internal, subarea.internal(), indexed, l2factor)
    return FzPixmap(ret), l2extra

FzStream.fz_decomp_image_from_stream = FzStream_fz_decomp_image_from_stream_outparams_fn


def FzStream_fz_open_image_decomp_stream_outparams_fn( self, arg_1):
    """
    Helper for out-params of class method fz_stream::ll_fz_open_image_decomp_stream() [fz_open_image_decomp_stream()].
    """
    ret, l2factor = ll_fz_open_image_decomp_stream( self.m_internal, arg_1.m_internal)
    return FzStream(ret), l2factor

FzStream.fz_open_image_decomp_stream = FzStream_fz_open_image_decomp_stream_outparams_fn


def FzStream_fz_read_best_outparams_fn( self, initial, worst_case):
    """
    Helper for out-params of class method fz_stream::ll_fz_read_best() [fz_read_best()].
    """
    ret, truncated = ll_fz_read_best( self.m_internal, initial, worst_case)
    return FzBuffer(ret), truncated

FzStream.fz_read_best = FzStream_fz_read_best_outparams_fn


def FzXml_fz_dom_get_attribute_outparams_fn( self, i):
    """
    Helper for out-params of class method fz_xml::ll_fz_dom_get_attribute() [fz_dom_get_attribute()].
    """
    ret, att = ll_fz_dom_get_attribute( self.m_internal, i)
    return ret, att

FzXml.fz_dom_get_attribute = FzXml_fz_dom_get_attribute_outparams_fn


def FzXml_fz_new_display_list_from_svg_xml_outparams_fn( self, xmldoc, base_uri, dir):
    """
    Helper for out-params of class method fz_xml::ll_fz_new_display_list_from_svg_xml() [fz_new_display_list_from_svg_xml()].
    """
    ret, w, h = ll_fz_new_display_list_from_svg_xml( self.m_internal, xmldoc.m_internal, base_uri, dir.m_internal)
    return FzDisplayList(ret), w, h

FzXml.fz_new_display_list_from_svg_xml = FzXml_fz_new_display_list_from_svg_xml_outparams_fn


def PdfAnnot_pdf_annot_MK_BC_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_MK_BC() [pdf_annot_MK_BC()].
    """
    n = ll_pdf_annot_MK_BC( self.m_internal, color)
    return n

PdfAnnot.pdf_annot_MK_BC = PdfAnnot_pdf_annot_MK_BC_outparams_fn


def PdfAnnot_pdf_annot_MK_BG_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_MK_BG() [pdf_annot_MK_BG()].
    """
    n = ll_pdf_annot_MK_BG( self.m_internal, color)
    return n

PdfAnnot.pdf_annot_MK_BG = PdfAnnot_pdf_annot_MK_BG_outparams_fn


def PdfAnnot_pdf_annot_color_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_color() [pdf_annot_color()].
    """
    n = ll_pdf_annot_color( self.m_internal, color)
    return n

PdfAnnot.pdf_annot_color = PdfAnnot_pdf_annot_color_outparams_fn


def PdfAnnot_pdf_annot_default_appearance_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_default_appearance() [pdf_annot_default_appearance()].
    """
    font, size, n = ll_pdf_annot_default_appearance( self.m_internal, color)
    return font, size, n

PdfAnnot.pdf_annot_default_appearance = PdfAnnot_pdf_annot_default_appearance_outparams_fn


def PdfAnnot_pdf_annot_default_appearance_unmapped_outparams_fn( self, font_name, font_name_len, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_default_appearance_unmapped() [pdf_annot_default_appearance_unmapped()].
    """
    size, n = ll_pdf_annot_default_appearance_unmapped( self.m_internal, font_name, font_name_len, color)
    return size, n

PdfAnnot.pdf_annot_default_appearance_unmapped = PdfAnnot_pdf_annot_default_appearance_unmapped_outparams_fn


def PdfAnnot_pdf_annot_interior_color_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_interior_color() [pdf_annot_interior_color()].
    """
    n = ll_pdf_annot_interior_color( self.m_internal, color)
    return n

PdfAnnot.pdf_annot_interior_color = PdfAnnot_pdf_annot_interior_color_outparams_fn


def PdfAnnot_pdf_annot_line_ending_styles_outparams_fn( self):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_line_ending_styles() [pdf_annot_line_ending_styles()].
    """
    start_style, end_style = ll_pdf_annot_line_ending_styles( self.m_internal)
    return start_style, end_style

PdfAnnot.pdf_annot_line_ending_styles = PdfAnnot_pdf_annot_line_ending_styles_outparams_fn


def PdfAnnot_pdf_edit_text_field_value_outparams_fn( self, value, change):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_edit_text_field_value() [pdf_edit_text_field_value()].
    """
    ret, selStart, selEnd, newvalue = ll_pdf_edit_text_field_value( self.m_internal, value, change)
    return ret, selStart, selEnd, newvalue

PdfAnnot.pdf_edit_text_field_value = PdfAnnot_pdf_edit_text_field_value_outparams_fn


def PdfCmap_pdf_decode_cmap_outparams_fn( self, s, e):
    """
    Helper for out-params of class method pdf_cmap::ll_pdf_decode_cmap() [pdf_decode_cmap()].
    """
    ret, cpt = ll_pdf_decode_cmap( self.m_internal, s, e)
    return ret, cpt

PdfCmap.pdf_decode_cmap = PdfCmap_pdf_decode_cmap_outparams_fn


def PdfCmap_pdf_lookup_cmap_full_outparams_fn( self, cpt):
    """
    Helper for out-params of class method pdf_cmap::ll_pdf_lookup_cmap_full() [pdf_lookup_cmap_full()].
    """
    ret, out = ll_pdf_lookup_cmap_full( self.m_internal, cpt)
    return ret, out

PdfCmap.pdf_lookup_cmap_full = PdfCmap_pdf_lookup_cmap_full_outparams_fn


def PdfCmap_pdf_map_one_to_many_outparams_fn( self, one, len):
    """
    Helper for out-params of class method pdf_cmap::ll_pdf_map_one_to_many() [pdf_map_one_to_many()].
    """
    many = ll_pdf_map_one_to_many( self.m_internal, one, len)
    return many

PdfCmap.pdf_map_one_to_many = PdfCmap_pdf_map_one_to_many_outparams_fn


def PdfDocument_pdf_count_q_balance_outparams_fn( self, res, stm):
    """
    Helper for out-params of class method pdf_document::ll_pdf_count_q_balance() [pdf_count_q_balance()].
    """
    prepend, append = ll_pdf_count_q_balance( self.m_internal, res.m_internal, stm.m_internal)
    return prepend, append

PdfDocument.pdf_count_q_balance = PdfDocument_pdf_count_q_balance_outparams_fn


def PdfDocument_pdf_field_event_validate_outparams_fn( self, field, value):
    """
    Helper for out-params of class method pdf_document::ll_pdf_field_event_validate() [pdf_field_event_validate()].
    """
    ret, newvalue = ll_pdf_field_event_validate( self.m_internal, field.m_internal, value)
    return ret, newvalue

PdfDocument.pdf_field_event_validate = PdfDocument_pdf_field_event_validate_outparams_fn


def PdfDocument_pdf_load_to_unicode_outparams_fn( self, font, collection, cmapstm):
    """
    Helper for out-params of class method pdf_document::ll_pdf_load_to_unicode() [pdf_load_to_unicode()].
    """
    strings = ll_pdf_load_to_unicode( self.m_internal, font.m_internal, collection, cmapstm.m_internal)
    return strings

PdfDocument.pdf_load_to_unicode = PdfDocument_pdf_load_to_unicode_outparams_fn


def PdfDocument_pdf_lookup_page_loc_outparams_fn( self, needle):
    """
    Helper for out-params of class method pdf_document::ll_pdf_lookup_page_loc() [pdf_lookup_page_loc()].
    """
    ret, parentp, indexp = ll_pdf_lookup_page_loc( self.m_internal, needle)
    return PdfObj( ll_pdf_keep_obj( ret)), PdfObj(ll_pdf_keep_obj( parentp)), indexp

PdfDocument.pdf_lookup_page_loc = PdfDocument_pdf_lookup_page_loc_outparams_fn


def PdfDocument_pdf_page_write_outparams_fn( self, mediabox):
    """
    Helper for out-params of class method pdf_document::ll_pdf_page_write() [pdf_page_write()].
    """
    ret, presources, pcontents = ll_pdf_page_write( self.m_internal, mediabox.internal())
    return FzDevice(ret), PdfObj( presources), FzBuffer( pcontents)

PdfDocument.pdf_page_write = PdfDocument_pdf_page_write_outparams_fn


def PdfDocument_pdf_parse_ind_obj_outparams_fn( self, f):
    """
    Helper for out-params of class method pdf_document::ll_pdf_parse_ind_obj() [pdf_parse_ind_obj()].
    """
    ret, num, gen, stm_ofs, try_repair = ll_pdf_parse_ind_obj( self.m_internal, f.m_internal)
    return PdfObj(ret), num, gen, stm_ofs, try_repair

PdfDocument.pdf_parse_ind_obj = PdfDocument_pdf_parse_ind_obj_outparams_fn


def PdfDocument_pdf_parse_journal_obj_outparams_fn( self, stm):
    """
    Helper for out-params of class method pdf_document::ll_pdf_parse_journal_obj() [pdf_parse_journal_obj()].
    """
    ret, onum, ostm, newobj = ll_pdf_parse_journal_obj( self.m_internal, stm.m_internal)
    return PdfObj(ret), onum, FzBuffer( ostm), newobj

PdfDocument.pdf_parse_journal_obj = PdfDocument_pdf_parse_journal_obj_outparams_fn


def PdfDocument_pdf_repair_obj_outparams_fn( self, buf):
    """
    Helper for out-params of class method pdf_document::ll_pdf_repair_obj() [pdf_repair_obj()].
    """
    ret, stmofsp, stmlenp, encrypt, id, page, tmpofs, root = ll_pdf_repair_obj( self.m_internal, buf.m_internal)
    return ret, stmofsp, stmlenp, PdfObj(ll_pdf_keep_obj( encrypt)), PdfObj(ll_pdf_keep_obj( id)), PdfObj(ll_pdf_keep_obj( page)), tmpofs, PdfObj(ll_pdf_keep_obj( root))

PdfDocument.pdf_repair_obj = PdfDocument_pdf_repair_obj_outparams_fn


def PdfDocument_pdf_resolve_link_outparams_fn( self, uri):
    """
    Helper for out-params of class method pdf_document::ll_pdf_resolve_link() [pdf_resolve_link()].
    """
    ret, xp, yp = ll_pdf_resolve_link( self.m_internal, uri)
    return ret, xp, yp

PdfDocument.pdf_resolve_link = PdfDocument_pdf_resolve_link_outparams_fn


def PdfDocument_pdf_signature_contents_outparams_fn( self, signature):
    """
    Helper for out-params of class method pdf_document::ll_pdf_signature_contents() [pdf_signature_contents()].
    """
    ret, contents = ll_pdf_signature_contents( self.m_internal, signature.m_internal)
    return ret, contents

PdfDocument.pdf_signature_contents = PdfDocument_pdf_signature_contents_outparams_fn


def PdfDocument_pdf_undoredo_state_outparams_fn( self):
    """
    Helper for out-params of class method pdf_document::ll_pdf_undoredo_state() [pdf_undoredo_state()].
    """
    ret, steps = ll_pdf_undoredo_state( self.m_internal)
    return ret, steps

PdfDocument.pdf_undoredo_state = PdfDocument_pdf_undoredo_state_outparams_fn


def PdfDocument_pdf_zugferd_profile_outparams_fn( self):
    """
    Helper for out-params of class method pdf_document::ll_pdf_zugferd_profile() [pdf_zugferd_profile()].
    """
    ret, version = ll_pdf_zugferd_profile( self.m_internal)
    return ret, version

PdfDocument.pdf_zugferd_profile = PdfDocument_pdf_zugferd_profile_outparams_fn


def PdfFunction_pdf_eval_function_outparams_fn( self, in_, inlen, outlen):
    """
    Helper for out-params of class method pdf_function::ll_pdf_eval_function() [pdf_eval_function()].
    """
    out = ll_pdf_eval_function( self.m_internal, in_, inlen, outlen)
    return out

PdfFunction.pdf_eval_function = PdfFunction_pdf_eval_function_outparams_fn


def PdfJs_pdf_js_event_result_validate_outparams_fn( self):
    """
    Helper for out-params of class method pdf_js::ll_pdf_js_event_result_validate() [pdf_js_event_result_validate()].
    """
    ret, newvalue = ll_pdf_js_event_result_validate( self.m_internal)
    return ret, newvalue

PdfJs.pdf_js_event_result_validate = PdfJs_pdf_js_event_result_validate_outparams_fn


def PdfJs_pdf_js_execute_outparams_fn( self, name, code):
    """
    Helper for out-params of class method pdf_js::ll_pdf_js_execute() [pdf_js_execute()].
    """
    result = ll_pdf_js_execute( self.m_internal, name, code)
    return result

PdfJs.pdf_js_execute = PdfJs_pdf_js_execute_outparams_fn


def PdfObj_pdf_array_get_string_outparams_fn( self, index):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_array_get_string() [pdf_array_get_string()].
    """
    ret, sizep = ll_pdf_array_get_string( self.m_internal, index)
    return ret, sizep

PdfObj.pdf_array_get_string = PdfObj_pdf_array_get_string_outparams_fn


def PdfObj_pdf_dict_get_inheritable_string_outparams_fn( self):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_dict_get_inheritable_string() [pdf_dict_get_inheritable_string()].
    """
    ret, sizep = ll_pdf_dict_get_inheritable_string( self.m_internal)
    return ret, sizep

PdfObj.pdf_dict_get_inheritable_string = PdfObj_pdf_dict_get_inheritable_string_outparams_fn


def PdfObj_pdf_dict_get_string_outparams_fn( self):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_dict_get_string() [pdf_dict_get_string()].
    """
    ret, sizep = ll_pdf_dict_get_string( self.m_internal)
    return ret, sizep

PdfObj.pdf_dict_get_string = PdfObj_pdf_dict_get_string_outparams_fn


def PdfObj_pdf_obj_memo_outparams_fn( self, bit):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_obj_memo() [pdf_obj_memo()].
    """
    ret, memo = ll_pdf_obj_memo( self.m_internal, bit)
    return ret, memo

PdfObj.pdf_obj_memo = PdfObj_pdf_obj_memo_outparams_fn


def PdfObj_pdf_to_string_outparams_fn( self):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_to_string() [pdf_to_string()].
    """
    ret, sizep = ll_pdf_to_string( self.m_internal)
    return ret, sizep

PdfObj.pdf_to_string = PdfObj_pdf_to_string_outparams_fn


def PdfObj_pdf_walk_tree_outparams_fn( self, arrive, leave, arg):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_walk_tree() [pdf_walk_tree()].
    """
    names, values = ll_pdf_walk_tree( self.m_internal, arrive, leave, arg)
    return PdfObj(ll_pdf_keep_obj( names)), PdfObj(ll_pdf_keep_obj( values))

PdfObj.pdf_walk_tree = PdfObj_pdf_walk_tree_outparams_fn


def PdfPage_pdf_page_presentation_outparams_fn( self, transition):
    """
    Helper for out-params of class method pdf_page::ll_pdf_page_presentation() [pdf_page_presentation()].
    """
    ret, duration = ll_pdf_page_presentation( self.m_internal, transition.internal())
    return FzTransition(ret), duration

PdfPage.pdf_page_presentation = PdfPage_pdf_page_presentation_outparams_fn


def PdfProcessor_pdf_process_contents_outparams_fn( self, doc, res, stm, cookie):
    """
    Helper for out-params of class method pdf_processor::ll_pdf_process_contents() [pdf_process_contents()].
    """
    out_res = ll_pdf_process_contents( self.m_internal, doc.m_internal, res.m_internal, stm.m_internal, cookie.m_internal)
    return PdfObj(ll_pdf_keep_obj( out_res))

PdfProcessor.pdf_process_contents = PdfProcessor_pdf_process_contents_outparams_fn


def PdfTextObjectState_pdf_tos_make_trm_outparams_fn( self, text, fontdesc, cid, trm):
    """
    Helper for out-params of class method pdf_text_object_state::ll_pdf_tos_make_trm() [pdf_tos_make_trm()].
    """
    ret, adv = ll_pdf_tos_make_trm( self.m_internal, text.m_internal, fontdesc.m_internal, cid, trm.internal())
    return ret, adv

PdfTextObjectState.pdf_tos_make_trm = PdfTextObjectState_pdf_tos_make_trm_outparams_fn


# Define __str()__ for each error/exception class, to use self.what().
FzErrorBase.__str__ = lambda self: self.what()
FzErrorNone.__str__ = lambda self: self.what()
FzErrorGeneric.__str__ = lambda self: self.what()
FzErrorSystem.__str__ = lambda self: self.what()
FzErrorLibrary.__str__ = lambda self: self.what()
FzErrorArgument.__str__ = lambda self: self.what()
FzErrorLimit.__str__ = lambda self: self.what()
FzErrorUnsupported.__str__ = lambda self: self.what()
FzErrorFormat.__str__ = lambda self: self.what()
FzErrorSyntax.__str__ = lambda self: self.what()
FzErrorTrylater.__str__ = lambda self: self.what()
FzErrorAbort.__str__ = lambda self: self.what()
FzErrorRepaired.__str__ = lambda self: self.what()

# This must be after the declaration of mupdf::FzError*
# classes in mupdf/exceptions.h and declaration of
# `internal_set_error_classes()`, otherwise generated code is
# before the declaration of the Python class or similar. */
internal_set_error_classes([
        FzErrorNone,
        FzErrorGeneric,
        FzErrorSystem,
        FzErrorLibrary,
        FzErrorArgument,
        FzErrorLimit,
        FzErrorUnsupported,
        FzErrorFormat,
        FzErrorSyntax,
        FzErrorTrylater,
        FzErrorAbort,
        FzErrorRepaired,

FzErrorBase,
])


# Wrap fz_parse_page_range() to fix SWIG bug where a NULL return
# value seems to mess up the returned list - we end up with ret
# containing two elements rather than three, e.g. [0, 2]. This
# occurs with SWIG-3.0; maybe fixed in SWIG-4?
#
ll_fz_parse_page_range_orig = ll_fz_parse_page_range
def ll_fz_parse_page_range(s, n):
    ret = ll_fz_parse_page_range_orig(s, n)
    if len(ret) == 2:
        return None, 0, 0
    else:
        return ret[0], ret[1], ret[2]
fz_parse_page_range = ll_fz_parse_page_range

# Provide native python implementation of format_output_path() (->
# fz_format_output_path).
#
def ll_fz_format_output_path( format, page):
    m = re.search( '(%[0-9]*d)', format)
    if m:
        ret = format[ :m.start(1)] + str(page) + format[ m.end(1):]
    else:
        dot = format.rfind( '.')
        if dot < 0:
            dot = len( format)
        ret = format[:dot] + str(page) + format[dot:]
    return ret
fz_format_output_path = ll_fz_format_output_path

class IteratorWrap:
    """
    This is a Python iterator for containers that have C++-style
    begin() and end() methods that return iterators.

    Iterators must have the following methods:

        __increment__(): move to next item in the container.
        __ref__(): return reference to item in the container.

    Must also be able to compare two iterators for equality.

    """
    def __init__( self, container):
        self.container = container
        self.pos = None
        self.end = container.end()
    def __iter__( self):
        return self
    def __next__( self):    # for python2.
        if self.pos is None:
            self.pos = self.container.begin()
        else:
            self.pos.__increment__()
        if self.pos == self.end:
            raise StopIteration()
        return self.pos.__ref__()
    def next( self):    # for python3.
        return self.__next__()

# The auto-generated Python class method
# FzBuffer.fz_buffer_extract() returns (size, data).
#
# But these raw values aren't particularly useful to
# Python code so we change the method to return a Python
# bytes instance instead, using the special C function
# buffer_extract_bytes() defined above.
#
# The raw values for a buffer are available via
# fz_buffer_storage().

def ll_fz_buffer_extract(buffer):
    """
    Returns buffer data as a Python bytes instance, leaving the
    buffer empty.
    """
    assert isinstance( buffer, fz_buffer)
    return ll_fz_buffer_to_bytes_internal(buffer, clear=1)
def fz_buffer_extract(buffer):
    """
    Returns buffer data as a Python bytes instance, leaving the
    buffer empty.
    """
    assert isinstance( buffer, FzBuffer)
    return ll_fz_buffer_extract(buffer.m_internal)
FzBuffer.fz_buffer_extract = fz_buffer_extract

def ll_fz_buffer_extract_copy( buffer):
    """
    Returns buffer data as a Python bytes instance, leaving the
    buffer unchanged.
    """
    assert isinstance( buffer, fz_buffer)
    return ll_fz_buffer_to_bytes_internal(buffer, clear=0)
def fz_buffer_extract_copy( buffer):
    """
    Returns buffer data as a Python bytes instance, leaving the
    buffer unchanged.
    """
    assert isinstance( buffer, FzBuffer)
    return ll_fz_buffer_extract_copy(buffer.m_internal)
FzBuffer.fz_buffer_extract_copy = fz_buffer_extract_copy

# [ll_fz_buffer_storage_memoryview() is implemented in C.]
def fz_buffer_storage_memoryview( buffer, writable=False):
    """
    Returns a read-only or writable Python `memoryview` onto
    `fz_buffer` data. This relies on `buffer` existing and
    not changing size while the `memoryview` is used.
    """
    assert isinstance( buffer, FzBuffer)
    return ll_fz_buffer_storage_memoryview( buffer.m_internal, writable)
FzBuffer.fz_buffer_storage_memoryview = fz_buffer_storage_memoryview

# Overwrite wrappers for fz_new_buffer_from_copied_data() to
# take Python buffer.
#
ll_fz_new_buffer_from_copied_data_orig = ll_fz_new_buffer_from_copied_data
def ll_fz_new_buffer_from_copied_data(data):
    """
    Returns fz_buffer containing copy of `data`, which should
    be a `bytes` or similar Python buffer instance.
    """
    buffer_ = ll_fz_new_buffer_from_copied_data_orig(python_buffer_data(data), len(data))
    return buffer_
def fz_new_buffer_from_copied_data(data):
    """
    Returns FzBuffer containing copy of `data`, which should be
    a `bytes` or similar Python buffer instance.
    """
    return FzBuffer( ll_fz_new_buffer_from_copied_data( data))
FzBuffer.fz_new_buffer_from_copied_data = fz_new_buffer_from_copied_data

def ll_pdf_dict_getl(obj, *tail):
    """
    Python implementation of ll_pdf_dict_getl(), because SWIG
    doesn't handle variadic args. Each item in `tail` should be
    `mupdf.pdf_obj`.
    """
    for key in tail:
        if not obj:
            break
        obj = ll_pdf_dict_get(obj, key)
    assert isinstance(obj, pdf_obj)
    return obj
def pdf_dict_getl(obj, *tail):
    """
    Python implementation of pdf_dict_getl(), because SWIG
    doesn't handle variadic args. Each item in `tail` should be
    a `mupdf.PdfObj`.
    """
    for key in tail:
        if not obj.m_internal:
            break
        obj = pdf_dict_get(obj, key)
    assert isinstance(obj, PdfObj)
    return obj
PdfObj.pdf_dict_getl = pdf_dict_getl

def ll_pdf_dict_putl(obj, val, *tail):
    """
    Python implementation of ll_pdf_dict_putl() because SWIG
    doesn't handle variadic args. Each item in `tail` should
    be a SWIG wrapper for a `pdf_obj`.
    """
    if ll_pdf_is_indirect( obj):
        obj = ll_pdf_resolve_indirect_chain( obj)
    if not pdf_is_dict( obj):
        raise Exception(f'not a dict: {obj}')
    if not tail:
        return
    doc = ll_pdf_get_bound_document( obj)
    for i, key in enumerate( tail[:-1]):
        assert isinstance( key, PdfObj), f'Item {i} in `tail` should be a pdf_obj but is a {type(key)}.'
        next_obj = ll_pdf_dict_get( obj, key)
        if not next_obj:
# We have to create entries
            next_obj = ll_pdf_new_dict( doc, 1)
            ll_pdf_dict_put( obj, key, next_obj)
        obj = next_obj
    key = tail[-1]
    ll_pdf_dict_put( obj, key, val)
def pdf_dict_putl(obj, val, *tail):
    """
    Python implementation of pdf_dict_putl(fz_context *ctx,
    pdf_obj *obj, pdf_obj *val, ...) because SWIG doesn't
    handle variadic args. Each item in `tail` should
    be a SWIG wrapper for a `PdfObj`.
    """
    if pdf_is_indirect( obj):
        obj = pdf_resolve_indirect_chain( obj)
    if not pdf_is_dict( obj):
        raise Exception(f'not a dict: {obj}')
    if not tail:
        return
    doc = pdf_get_bound_document( obj)
    for i, key in enumerate( tail[:-1]):
        assert isinstance( key, PdfObj), f'item {i} in `tail` should be a PdfObj but is a {type(key)}.'
        next_obj = pdf_dict_get( obj, key)
        if not next_obj.m_internal:
# We have to create entries
            next_obj = pdf_new_dict( doc, 1)
            pdf_dict_put( obj, key, next_obj)
        obj = next_obj
    key = tail[-1]
    pdf_dict_put( obj, key, val)
PdfObj.pdf_dict_putl = pdf_dict_putl

def pdf_dict_putl_drop(obj, *tail):
    raise Exception('mupdf.pdf_dict_putl_drop() is unsupported and unnecessary in Python because reference counting is automatic. Instead use mupdf.pdf_dict_putl().')
PdfObj.pdf_dict_putl_drop = pdf_dict_putl_drop

def ll_pdf_set_annot_color(annot, color):
    """
    Low-level Python implementation of pdf_set_annot_color()
    using ll_pdf_set_annot_color2().
    """
    if isinstance(color, float):
        ll_pdf_set_annot_color2(annot, 1, color, 0, 0, 0)
    elif len(color) == 1:
        ll_pdf_set_annot_color2(annot, 1, color[0], 0, 0, 0)
    elif len(color) == 2:
        ll_pdf_set_annot_color2(annot, 2, color[0], color[1], 0, 0)
    elif len(color) == 3:
        ll_pdf_set_annot_color2(annot, 3, color[0], color[1], color[2], 0)
    elif len(color) == 4:
        ll_pdf_set_annot_color2(annot, 4, color[0], color[1], color[2], color[3])
    else:
        raise Exception( f'Unexpected color should be float or list of 1-4 floats: {color}')
def pdf_set_annot_color(self, color):
    return ll_pdf_set_annot_color(self.m_internal, color)
PdfAnnot.pdf_set_annot_color = pdf_set_annot_color

def ll_pdf_set_annot_interior_color(annot, color):
    """
    Low-level Python version of pdf_set_annot_color() using
    pdf_set_annot_color2().
    """
    if isinstance(color, float):
        ll_pdf_set_annot_interior_color2(annot, 1, color, 0, 0, 0)
    elif len(color) == 1:
        ll_pdf_set_annot_interior_color2(annot, 1, color[0], 0, 0, 0)
    elif len(color) == 2:
        ll_pdf_set_annot_interior_color2(annot, 2, color[0], color[1], 0, 0)
    elif len(color) == 3:
        ll_pdf_set_annot_interior_color2(annot, 3, color[0], color[1], color[2], 0)
    elif len(color) == 4:
        ll_pdf_set_annot_interior_color2(annot, 4, color[0], color[1], color[2], color[3])
    else:
        raise Exception( f'Unexpected color should be float or list of 1-4 floats: {color}')
def pdf_set_annot_interior_color(self, color):
    """
    Python version of pdf_set_annot_color() using
    pdf_set_annot_color2().
    """
    return ll_pdf_set_annot_interior_color(self.m_internal, color)
PdfAnnot.pdf_set_annot_interior_color = pdf_set_annot_interior_color

def ll_fz_fill_text( dev, text, ctm, colorspace, color, alpha, color_params):
    """
    Low-level Python version of fz_fill_text() taking list/tuple for `color`.
    """
    color = tuple(color) + (0,) * (4-len(color))
    assert len(color) == 4, f'color not len 4: len={len(color)}: {color}'
    return ll_fz_fill_text2(dev, text, ctm, colorspace, *color, alpha, color_params)
def fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params):
    """
    Python version of fz_fill_text() taking list/tuple for `color`.
    """
    return ll_fz_fill_text(
            dev.m_internal,
            text.m_internal,
            ctm.internal(),
            colorspace.m_internal,
            color,
            alpha,
            color_params.internal(),
            )
FzDevice.fz_fill_text = fz_fill_text

# Override mupdf_convert_color() to return (rgb0, rgb1, rgb2, rgb3).
def ll_fz_convert_color( ss, sv, ds, is_, params):
    """
    Low-level Python version of fz_convert_color().

    `sv` should be a float or list of 1-4 floats or a SWIG
    representation of a float*.

    Returns (dv0, dv1, dv2, dv3).
    """
    dv = fz_convert_color2_v()
    if isinstance( sv, float):
       ll_fz_convert_color2( ss, sv, 0.0, 0.0, 0.0, ds, dv, is_, params)
    elif isinstance( sv, (tuple, list)):
        sv2 = tuple(sv) + (0,) * (4-len(sv))
        ll_fz_convert_color2( ss, *sv2, ds, dv, is_, params)
    else:
# Assume `sv` is SWIG representation of a `float*`.
        ll_fz_convert_color2( ss, sv, ds, dv, is_, params)
    return dv.v0, dv.v1, dv.v2, dv.v3
def fz_convert_color( ss, sv, ds, is_, params):
    """
    Python version of fz_convert_color().

    `sv` should be a float or list of 1-4 floats or a SWIG
    representation of a float*.

    Returns (dv0, dv1, dv2, dv3).
    """
    return ll_fz_convert_color( ss.m_internal, sv, ds.m_internal, is_.m_internal, params.internal())
FzColorspace.fz_convert_color = fz_convert_color

# Override fz_set_warning_callback() and
# fz_set_error_callback() to use Python classes derived from
# our SWIG Director class DiagnosticCallback (defined in C), so
# that fnptrs can call Python code.
#

# We store DiagnosticCallbackPython instances in these
# globals to ensure they continue to exist after
# set_diagnostic_callback() returns.
#
set_warning_callback_s = None
set_error_callback_s = None

# Override set_error_callback().
class DiagnosticCallbackPython( DiagnosticCallback):
    """
    Overrides Director class DiagnosticCallback's virtual
    `_print()` method in Python.
    """
    def __init__( self, description, printfn):
        super().__init__( description)
        self.printfn = printfn
        if g_mupdf_trace_director:
            log( f'DiagnosticCallbackPython[{self.m_description}].__init__() self={self!r} printfn={printfn!r}')
    def __del__( self):
        if g_mupdf_trace_director:
            log( f'DiagnosticCallbackPython[{self.m_description}].__del__() destructor called.')
    def _print( self, message):
        if g_mupdf_trace_director:
            log( f'DiagnosticCallbackPython[{self.m_description}]._print(): Calling self.printfn={self.printfn!r} with message={message!r}')
        try:
            self.printfn( message)
        except Exception as e:
# This shouldn't happen, so always output a diagnostic.
            log( f'DiagnosticCallbackPython[{self.m_description}]._print(): Warning: exception from self.printfn={self.printfn!r}: e={e!r}')
# Calling `raise` here serves to test
# `DiagnosticCallback()`'s swallowing of what will
# be a C++ exception. But we could swallow the
# exception here instead.
            raise

def set_diagnostic_callback( description, printfn):
    if g_mupdf_trace_director:
        log( f'set_diagnostic_callback() description={description!r} printfn={printfn!r}')
    if printfn:
        ret = DiagnosticCallbackPython( description, printfn)
        return ret
    else:
        if g_mupdf_trace_director:
            log( f'Calling ll_fz_set_{description}_callback() with (None, None)')
        if description == 'error':
            ll_fz_set_error_callback( None, None)
        elif description == 'warning':
            ll_fz_set_warning_callback( None, None)
        else:
            assert 0, f'Unrecognised description={description!r}'
        return None

def fz_set_error_callback( printfn):
    global set_error_callback_s
    set_error_callback_s = set_diagnostic_callback( 'error', printfn)

def fz_set_warning_callback( printfn):
    global set_warning_callback_s
    set_warning_callback_s = set_diagnostic_callback( 'warning', printfn)

# Direct access to fz_pixmap samples.
def ll_fz_pixmap_samples_memoryview( pixmap):
    """
    Returns a writable Python `memoryview` for a `fz_pixmap`.
    """
    assert isinstance( pixmap, fz_pixmap)
    ret = python_memoryview_from_memory(
            ll_fz_pixmap_samples( pixmap),
            ll_fz_pixmap_stride( pixmap) * ll_fz_pixmap_height( pixmap),
            1, # writable
            )
    return ret
def fz_pixmap_samples_memoryview( pixmap):
    """
    Returns a writable Python `memoryview` for a `FzPixmap`.
    """
    return ll_fz_pixmap_samples_memoryview( pixmap.m_internal)
FzPixmap.fz_pixmap_samples_memoryview = fz_pixmap_samples_memoryview

# Avoid potential unsafe use of variadic args by forcing a
# single arg and escaping all '%' characters. (Passing ('%s',
# text) does not work - results in "(null)" being output.)
#
ll_fz_warn_original = ll_fz_warn
def ll_fz_warn( text):
    assert isinstance( text, str), f'text={text!r} str={str!r}'
    text = text.replace( '%', '%%')
    return ll_fz_warn_original( text)
fz_warn = ll_fz_warn

# Force use of pdf_load_field_name2() instead of
# pdf_load_field_name() because the latter returns a char*
# buffer that must be freed by the caller.
ll_pdf_load_field_name = ll_pdf_load_field_name2
pdf_load_field_name = pdf_load_field_name2
PdfObj.pdf_load_field_name = pdf_load_field_name

# It's important that when we create class derived
# from StoryPositionsCallback, we ensure that
# StoryPositionsCallback's constructor is called. Otherwise
# the new instance doesn't seem to be an instance of
# StoryPositionsCallback.
#
class StoryPositionsCallback_python( StoryPositionsCallback):
    def __init__( self, python_callback):
        super().__init__()
        self.python_callback = python_callback
    def call( self, position):
        self.python_callback( position)

ll_fz_story_positions_orig = ll_fz_story_positions
def ll_fz_story_positions( story, python_callback):
    """
    Custom replacement for `ll_fz_story_positions()` that takes
    a Python callable `python_callback`.
    """
#log( f'll_fz_story_positions() type(story)={type(story)!r} type(python_callback)={type(python_callback)!r}')
    python_callback_instance = StoryPositionsCallback_python( python_callback)
    ll_fz_story_positions_director( story, python_callback_instance)
def fz_story_positions( story, python_callback):
#log( f'fz_story_positions() type(story)={type(story)!r} type(python_callback)={type(python_callback)!r}')
    assert isinstance( story, FzStory)
    assert callable( python_callback)
    def python_callback2( position):
        position2 = FzStoryElementPosition( position)
        python_callback( position2)
    ll_fz_story_positions( story.m_internal, python_callback2)
FzStory.fz_story_positions = fz_story_positions

# Monkey-patch `FzDocumentWriter.__init__()` to set `self._out`
# to any `FzOutput2` arg. This ensures that the Python part of
# the derived `FzOutput2` instance is kept alive for use by the
# `FzDocumentWriter`, otherwise Python can delete it, then get
# a SEGV if C++ tries to call the derived Python methods.
#
# [We don't patch equivalent class-aware functions such
# as `fz_new_pdf_writer_with_output()` because they are
# not available to C++/Python, because FzDocumentWriter is
# non-copyable.]
#
FzDocumentWriter__init__0 = FzDocumentWriter.__init__
def FzDocumentWriter__init__1(self, *args):
    out = None
    for arg in args:
        if isinstance( arg, FzOutput2):
            assert not out, "More than one FzOutput2 passed to FzDocumentWriter.__init__()"
            out = arg
    if out is not None:
        self._out = out
    return FzDocumentWriter__init__0(self, *args)
FzDocumentWriter.__init__ = FzDocumentWriter__init__1

# Create class derived from
# fz_install_load_system_font_funcs_args class wrapper with
# overrides of the virtual functions to allow calling of Python
# callbacks.
#
class fz_install_load_system_font_funcs_args3(FzInstallLoadSystemFontFuncsArgs2):
    """
    Class derived from Swig Director class
    fz_install_load_system_font_funcs_args2, to allow
    implementation of fz_install_load_system_font_funcs with
    Python callbacks.
    """
    def __init__(self, f=None, f_cjk=None, f_fallback=None):
        super().__init__()

        self.f3 = f
        self.f_cjk3 = f_cjk
        self.f_fallback3 = f_fallback

        self.use_virtual_f(True if f else False)
        self.use_virtual_f_cjk(True if f_cjk else False)
        self.use_virtual_f_fallback(True if f_fallback else False)

    def ret_font(self, font):
        if font is None:
            return None
        elif isinstance(font, FzFont):
            return ll_fz_keep_font(font.m_internal)
        elif isinstance(font, fz_font):
            return font
        else:
            assert 0, f'Expected FzFont or fz_font, but fz_install_load_system_font_funcs() callback returned {type(font)=}'

    def f(self, ctx, name, bold, italic, needs_exact_metrics):
        font = self.f3(name, bold, italic, needs_exact_metrics)
        return self.ret_font(font)

    def f_cjk(self, ctx, name, ordering, serif):
        font = self.f_cjk3(name, ordering, serif)
        return self.ret_font(font)

    def f_fallback(self, ctx, script, language, serif, bold, italic):
        font = self.f_fallback3(script, language, serif, bold, italic)
        return self.ret_font(font)

# We store the most recently created
# fz_install_load_system_font_funcs_args in this global so that
# it is not cleaned up by Python.
g_fz_install_load_system_font_funcs_args = None

def fz_install_load_system_font_funcs(f=None, f_cjk=None, f_fallback=None):
    """
    Python override for MuPDF
    fz_install_load_system_font_funcs() using Swig Director
    support. Python callbacks are not passed a `ctx` arg, and
    can return None, a mupdf.fz_font or a mupdf.FzFont.
    """
    global g_fz_install_load_system_font_funcs_args
    g_fz_install_load_system_font_funcs_args = fz_install_load_system_font_funcs_args3(
            f,
            f_cjk,
            f_fallback,
            )
    fz_install_load_system_font_funcs2(g_fz_install_load_system_font_funcs_args)

Py_LIMITED_API = '0x03090000'
FzLink.__iter__ = lambda self: IteratorWrap( self)
FzStextBlock.__iter__ = lambda self: IteratorWrap( self)
FzStextLine.__iter__ = lambda self: IteratorWrap( self)
FzStextPage.__iter__ = lambda self: IteratorWrap( self)
fz_aa_context.__str__ = lambda s: to_string_fz_aa_context(s)
fz_aa_context.__repr__ = lambda s: to_string_fz_aa_context(s)
fz_color_params.__str__ = lambda s: to_string_fz_color_params(s)
fz_color_params.__repr__ = lambda s: to_string_fz_color_params(s)
fz_cookie.__str__ = lambda s: to_string_fz_cookie(s)
fz_cookie.__repr__ = lambda s: to_string_fz_cookie(s)
fz_draw_options.__str__ = lambda s: to_string_fz_draw_options(s)
fz_draw_options.__repr__ = lambda s: to_string_fz_draw_options(s)
fz_install_load_system_font_funcs_args.__str__ = lambda s: to_string_fz_install_load_system_font_funcs_args(s)
fz_install_load_system_font_funcs_args.__repr__ = lambda s: to_string_fz_install_load_system_font_funcs_args(s)
fz_irect.__str__ = lambda s: to_string_fz_irect(s)
fz_irect.__repr__ = lambda s: to_string_fz_irect(s)
fz_location.__str__ = lambda s: to_string_fz_location(s)
fz_location.__repr__ = lambda s: to_string_fz_location(s)
fz_matrix.__str__ = lambda s: to_string_fz_matrix(s)
fz_matrix.__repr__ = lambda s: to_string_fz_matrix(s)
fz_md5.__str__ = lambda s: to_string_fz_md5(s)
fz_md5.__repr__ = lambda s: to_string_fz_md5(s)
fz_pdfocr_options.__str__ = lambda s: to_string_fz_pdfocr_options(s)
fz_pdfocr_options.__repr__ = lambda s: to_string_fz_pdfocr_options(s)
fz_point.__str__ = lambda s: to_string_fz_point(s)
fz_point.__repr__ = lambda s: to_string_fz_point(s)
fz_pwg_options.__str__ = lambda s: to_string_fz_pwg_options(s)
fz_pwg_options.__repr__ = lambda s: to_string_fz_pwg_options(s)
fz_quad.__str__ = lambda s: to_string_fz_quad(s)
fz_quad.__repr__ = lambda s: to_string_fz_quad(s)
fz_rect.__str__ = lambda s: to_string_fz_rect(s)
fz_rect.__repr__ = lambda s: to_string_fz_rect(s)
fz_stext_options.__str__ = lambda s: to_string_fz_stext_options(s)
fz_stext_options.__repr__ = lambda s: to_string_fz_stext_options(s)
fz_story_element_position.__str__ = lambda s: to_string_fz_story_element_position(s)
fz_story_element_position.__repr__ = lambda s: to_string_fz_story_element_position(s)
fz_transition.__str__ = lambda s: to_string_fz_transition(s)
fz_transition.__repr__ = lambda s: to_string_fz_transition(s)
pdf_clean_options.__str__ = lambda s: to_string_pdf_clean_options(s)
pdf_clean_options.__repr__ = lambda s: to_string_pdf_clean_options(s)
pdf_filter_factory.__str__ = lambda s: to_string_pdf_filter_factory(s)
pdf_filter_factory.__repr__ = lambda s: to_string_pdf_filter_factory(s)
pdf_filter_options.__str__ = lambda s: to_string_pdf_filter_options(s)
pdf_filter_options.__repr__ = lambda s: to_string_pdf_filter_options(s)
pdf_image_rewriter_options.__str__ = lambda s: to_string_pdf_image_rewriter_options(s)
pdf_image_rewriter_options.__repr__ = lambda s: to_string_pdf_image_rewriter_options(s)
pdf_layer_config.__str__ = lambda s: to_string_pdf_layer_config(s)
pdf_layer_config.__repr__ = lambda s: to_string_pdf_layer_config(s)
pdf_layer_config_ui.__str__ = lambda s: to_string_pdf_layer_config_ui(s)
pdf_layer_config_ui.__repr__ = lambda s: to_string_pdf_layer_config_ui(s)
pdf_recolor_options.__str__ = lambda s: to_string_pdf_recolor_options(s)
pdf_recolor_options.__repr__ = lambda s: to_string_pdf_recolor_options(s)
pdf_redact_options.__str__ = lambda s: to_string_pdf_redact_options(s)
pdf_redact_options.__repr__ = lambda s: to_string_pdf_redact_options(s)
pdf_sanitize_filter_options.__str__ = lambda s: to_string_pdf_sanitize_filter_options(s)
pdf_sanitize_filter_options.__repr__ = lambda s: to_string_pdf_sanitize_filter_options(s)
pdf_write_options.__str__ = lambda s: to_string_pdf_write_options(s)
pdf_write_options.__repr__ = lambda s: to_string_pdf_write_options(s)
FzAaContext.__str__ = lambda self: self.to_string()
FzAaContext.__repr__ = lambda self: self.to_string()
FzColorParams.__str__ = lambda self: self.to_string()
FzColorParams.__repr__ = lambda self: self.to_string()
FzCookie.__str__ = lambda self: self.to_string()
FzCookie.__repr__ = lambda self: self.to_string()
FzDrawOptions.__str__ = lambda self: self.to_string()
FzDrawOptions.__repr__ = lambda self: self.to_string()
FzInstallLoadSystemFontFuncsArgs.__str__ = lambda self: self.to_string()
FzInstallLoadSystemFontFuncsArgs.__repr__ = lambda self: self.to_string()
FzIrect.__str__ = lambda self: self.to_string()
FzIrect.__repr__ = lambda self: self.to_string()
FzLocation.__str__ = lambda self: self.to_string()
FzLocation.__repr__ = lambda self: self.to_string()
FzMatrix.__str__ = lambda self: self.to_string()
FzMatrix.__repr__ = lambda self: self.to_string()
FzMd5.__str__ = lambda self: self.to_string()
FzMd5.__repr__ = lambda self: self.to_string()
FzPdfocrOptions.__str__ = lambda self: self.to_string()
FzPdfocrOptions.__repr__ = lambda self: self.to_string()
FzPoint.__str__ = lambda self: self.to_string()
FzPoint.__repr__ = lambda self: self.to_string()
FzPwgOptions.__str__ = lambda self: self.to_string()
FzPwgOptions.__repr__ = lambda self: self.to_string()
FzQuad.__str__ = lambda self: self.to_string()
FzQuad.__repr__ = lambda self: self.to_string()
FzRect.__str__ = lambda self: self.to_string()
FzRect.__repr__ = lambda self: self.to_string()
FzStextOptions.__str__ = lambda self: self.to_string()
FzStextOptions.__repr__ = lambda self: self.to_string()
FzStoryElementPosition.__str__ = lambda self: self.to_string()
FzStoryElementPosition.__repr__ = lambda self: self.to_string()
FzTransition.__str__ = lambda self: self.to_string()
FzTransition.__repr__ = lambda self: self.to_string()
PdfCleanOptions.__str__ = lambda self: self.to_string()
PdfCleanOptions.__repr__ = lambda self: self.to_string()
PdfFilterFactory.__str__ = lambda self: self.to_string()
PdfFilterFactory.__repr__ = lambda self: self.to_string()
PdfFilterOptions.__str__ = lambda self: self.to_string()
PdfFilterOptions.__repr__ = lambda self: self.to_string()
PdfImageRewriterOptions.__str__ = lambda self: self.to_string()
PdfImageRewriterOptions.__repr__ = lambda self: self.to_string()
PdfLayerConfig.__str__ = lambda self: self.to_string()
PdfLayerConfig.__repr__ = lambda self: self.to_string()
PdfLayerConfigUi.__str__ = lambda self: self.to_string()
PdfLayerConfigUi.__repr__ = lambda self: self.to_string()
PdfRecolorOptions.__str__ = lambda self: self.to_string()
PdfRecolorOptions.__repr__ = lambda self: self.to_string()
PdfRedactOptions.__str__ = lambda self: self.to_string()
PdfRedactOptions.__repr__ = lambda self: self.to_string()
PdfSanitizeFilterOptions.__str__ = lambda self: self.to_string()
PdfSanitizeFilterOptions.__repr__ = lambda self: self.to_string()
PdfWriteOptions.__str__ = lambda self: self.to_string()
PdfWriteOptions.__repr__ = lambda self: self.to_string()


PDF_ENUM_NAME_1_2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_1_2))
PDF_ENUM_NAME_1_5 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_1_5))
PDF_ENUM_NAME_3D = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_3D))
PDF_ENUM_NAME_A = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_A))
PDF_ENUM_NAME_A85 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_A85))
PDF_ENUM_NAME_AA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AA))
PDF_ENUM_NAME_AC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AC))
PDF_ENUM_NAME_AESV2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AESV2))
PDF_ENUM_NAME_AESV3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AESV3))
PDF_ENUM_NAME_AF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AF))
PDF_ENUM_NAME_AFRelationship = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AFRelationship))
PDF_ENUM_NAME_AHx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AHx))
PDF_ENUM_NAME_AP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AP))
PDF_ENUM_NAME_AS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AS))
PDF_ENUM_NAME_ASCII85Decode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ASCII85Decode))
PDF_ENUM_NAME_ASCIIHexDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ASCIIHexDecode))
PDF_ENUM_NAME_AcroForm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AcroForm))
PDF_ENUM_NAME_Action = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Action))
PDF_ENUM_NAME_ActualText = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ActualText))
PDF_ENUM_NAME_Adobe_PPKLite = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Adobe_PPKLite))
PDF_ENUM_NAME_All = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_All))
PDF_ENUM_NAME_AllOff = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AllOff))
PDF_ENUM_NAME_AllOn = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AllOn))
PDF_ENUM_NAME_Alpha = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alpha))
PDF_ENUM_NAME_Alt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alt))
PDF_ENUM_NAME_Alternate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alternate))
PDF_ENUM_NAME_Alternative = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alternative))
PDF_ENUM_NAME_Annot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Annot))
PDF_ENUM_NAME_Annots = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Annots))
PDF_ENUM_NAME_AnyOff = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AnyOff))
PDF_ENUM_NAME_App = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_App))
PDF_ENUM_NAME_Approved = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Approved))
PDF_ENUM_NAME_Art = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Art))
PDF_ENUM_NAME_ArtBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ArtBox))
PDF_ENUM_NAME_Artifact = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Artifact))
PDF_ENUM_NAME_AsIs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AsIs))
PDF_ENUM_NAME_Ascent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ascent))
PDF_ENUM_NAME_Aside = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Aside))
PDF_ENUM_NAME_AuthEvent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AuthEvent))
PDF_ENUM_NAME_Author = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Author))
PDF_ENUM_NAME_B = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_B))
PDF_ENUM_NAME_BBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BBox))
PDF_ENUM_NAME_BC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BC))
PDF_ENUM_NAME_BE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BE))
PDF_ENUM_NAME_BG = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BG))
PDF_ENUM_NAME_BM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BM))
PDF_ENUM_NAME_BPC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BPC))
PDF_ENUM_NAME_BS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BS))
PDF_ENUM_NAME_Background = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Background))
PDF_ENUM_NAME_BaseEncoding = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BaseEncoding))
PDF_ENUM_NAME_BaseFont = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BaseFont))
PDF_ENUM_NAME_BaseState = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BaseState))
PDF_ENUM_NAME_BibEntry = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BibEntry))
PDF_ENUM_NAME_BitsPerComponent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerComponent))
PDF_ENUM_NAME_BitsPerCoordinate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerCoordinate))
PDF_ENUM_NAME_BitsPerFlag = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerFlag))
PDF_ENUM_NAME_BitsPerSample = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerSample))
PDF_ENUM_NAME_BlackIs1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BlackIs1))
PDF_ENUM_NAME_BlackPoint = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BlackPoint))
PDF_ENUM_NAME_BleedBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BleedBox))
PDF_ENUM_NAME_Blinds = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Blinds))
PDF_ENUM_NAME_BlockQuote = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BlockQuote))
PDF_ENUM_NAME_Border = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Border))
PDF_ENUM_NAME_Bounds = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Bounds))
PDF_ENUM_NAME_Box = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Box))
PDF_ENUM_NAME_Bt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Bt))
PDF_ENUM_NAME_Btn = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Btn))
PDF_ENUM_NAME_Butt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Butt))
PDF_ENUM_NAME_ByteRange = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ByteRange))
PDF_ENUM_NAME_C = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_C))
PDF_ENUM_NAME_C0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_C0))
PDF_ENUM_NAME_C1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_C1))
PDF_ENUM_NAME_CA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CA))
PDF_ENUM_NAME_CCF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CCF))
PDF_ENUM_NAME_CCITTFaxDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CCITTFaxDecode))
PDF_ENUM_NAME_CF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CF))
PDF_ENUM_NAME_CFM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CFM))
PDF_ENUM_NAME_CI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CI))
PDF_ENUM_NAME_CIDFontType0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDFontType0))
PDF_ENUM_NAME_CIDFontType0C = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDFontType0C))
PDF_ENUM_NAME_CIDFontType2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDFontType2))
PDF_ENUM_NAME_CIDSystemInfo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDSystemInfo))
PDF_ENUM_NAME_CIDToGIDMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDToGIDMap))
PDF_ENUM_NAME_CL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CL))
PDF_ENUM_NAME_CMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CMYK))
PDF_ENUM_NAME_CO = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CO))
PDF_ENUM_NAME_CP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CP))
PDF_ENUM_NAME_CS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CS))
PDF_ENUM_NAME_CalCMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CalCMYK))
PDF_ENUM_NAME_CalGray = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CalGray))
PDF_ENUM_NAME_CalRGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CalRGB))
PDF_ENUM_NAME_Cap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Cap))
PDF_ENUM_NAME_CapHeight = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CapHeight))
PDF_ENUM_NAME_Caption = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Caption))
PDF_ENUM_NAME_Caret = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Caret))
PDF_ENUM_NAME_Catalog = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Catalog))
PDF_ENUM_NAME_Cert = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Cert))
PDF_ENUM_NAME_Ch = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ch))
PDF_ENUM_NAME_Changes = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Changes))
PDF_ENUM_NAME_CharProcs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CharProcs))
PDF_ENUM_NAME_CheckSum = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CheckSum))
PDF_ENUM_NAME_Circle = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Circle))
PDF_ENUM_NAME_ClosedArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ClosedArrow))
PDF_ENUM_NAME_Code = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Code))
PDF_ENUM_NAME_Collection = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Collection))
PDF_ENUM_NAME_ColorSpace = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ColorSpace))
PDF_ENUM_NAME_ColorTransform = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ColorTransform))
PDF_ENUM_NAME_Colorants = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Colorants))
PDF_ENUM_NAME_Colors = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Colors))
PDF_ENUM_NAME_Columns = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Columns))
PDF_ENUM_NAME_Confidential = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Confidential))
PDF_ENUM_NAME_Configs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Configs))
PDF_ENUM_NAME_ContactInfo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ContactInfo))
PDF_ENUM_NAME_Contents = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Contents))
PDF_ENUM_NAME_Coords = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Coords))
PDF_ENUM_NAME_Count = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Count))
PDF_ENUM_NAME_Cover = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Cover))
PDF_ENUM_NAME_CreationDate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CreationDate))
PDF_ENUM_NAME_Creator = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Creator))
PDF_ENUM_NAME_CropBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CropBox))
PDF_ENUM_NAME_Crypt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Crypt))
PDF_ENUM_NAME_D = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_D))
PDF_ENUM_NAME_DA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DA))
PDF_ENUM_NAME_DC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DC))
PDF_ENUM_NAME_DCT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DCT))
PDF_ENUM_NAME_DCTDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DCTDecode))
PDF_ENUM_NAME_DL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DL))
PDF_ENUM_NAME_DOS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DOS))
PDF_ENUM_NAME_DP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DP))
PDF_ENUM_NAME_DR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DR))
PDF_ENUM_NAME_DS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DS))
PDF_ENUM_NAME_DV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DV))
PDF_ENUM_NAME_DW = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DW))
PDF_ENUM_NAME_DW2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DW2))
PDF_ENUM_NAME_DamagedRowsBeforeError = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DamagedRowsBeforeError))
PDF_ENUM_NAME_Data = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Data))
PDF_ENUM_NAME_Date = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Date))
PDF_ENUM_NAME_Decode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Decode))
PDF_ENUM_NAME_DecodeParms = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DecodeParms))
PDF_ENUM_NAME_Default = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Default))
PDF_ENUM_NAME_DefaultCMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DefaultCMYK))
PDF_ENUM_NAME_DefaultGray = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DefaultGray))
PDF_ENUM_NAME_DefaultRGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DefaultRGB))
PDF_ENUM_NAME_Departmental = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Departmental))
PDF_ENUM_NAME_Desc = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Desc))
PDF_ENUM_NAME_DescendantFonts = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DescendantFonts))
PDF_ENUM_NAME_Descent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Descent))
PDF_ENUM_NAME_Design = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Design))
PDF_ENUM_NAME_Dest = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dest))
PDF_ENUM_NAME_DestOutputProfile = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DestOutputProfile))
PDF_ENUM_NAME_Dests = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dests))
PDF_ENUM_NAME_DeviceCMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceCMYK))
PDF_ENUM_NAME_DeviceGray = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceGray))
PDF_ENUM_NAME_DeviceN = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceN))
PDF_ENUM_NAME_DeviceRGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceRGB))
PDF_ENUM_NAME_Di = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Di))
PDF_ENUM_NAME_Diamond = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Diamond))
PDF_ENUM_NAME_Differences = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Differences))
PDF_ENUM_NAME_DigestLocation = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DigestLocation))
PDF_ENUM_NAME_DigestMethod = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DigestMethod))
PDF_ENUM_NAME_DigestValue = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DigestValue))
PDF_ENUM_NAME_Dissolve = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dissolve))
PDF_ENUM_NAME_Div = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Div))
PDF_ENUM_NAME_Dm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dm))
PDF_ENUM_NAME_DocMDP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DocMDP))
PDF_ENUM_NAME_Document = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Document))
PDF_ENUM_NAME_DocumentFragment = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DocumentFragment))
PDF_ENUM_NAME_Domain = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Domain))
PDF_ENUM_NAME_Draft = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Draft))
PDF_ENUM_NAME_Dur = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dur))
PDF_ENUM_NAME_E = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_E))
PDF_ENUM_NAME_EF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EF))
PDF_ENUM_NAME_EarlyChange = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EarlyChange))
PDF_ENUM_NAME_Em = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Em))
PDF_ENUM_NAME_EmbeddedFile = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EmbeddedFile))
PDF_ENUM_NAME_EmbeddedFiles = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EmbeddedFiles))
PDF_ENUM_NAME_Encode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Encode))
PDF_ENUM_NAME_EncodedByteAlign = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EncodedByteAlign))
PDF_ENUM_NAME_Encoding = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Encoding))
PDF_ENUM_NAME_Encrypt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Encrypt))
PDF_ENUM_NAME_EncryptMetadata = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EncryptMetadata))
PDF_ENUM_NAME_EncryptedPayload = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EncryptedPayload))
PDF_ENUM_NAME_EndOfBlock = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EndOfBlock))
PDF_ENUM_NAME_EndOfLine = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EndOfLine))
PDF_ENUM_NAME_Exclude = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Exclude))
PDF_ENUM_NAME_Experimental = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Experimental))
PDF_ENUM_NAME_Expired = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Expired))
PDF_ENUM_NAME_ExtGState = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ExtGState))
PDF_ENUM_NAME_Extend = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Extend))
PDF_ENUM_NAME_F = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_F))
PDF_ENUM_NAME_FENote = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FENote))
PDF_ENUM_NAME_FL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FL))
PDF_ENUM_NAME_FRM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FRM))
PDF_ENUM_NAME_FS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FS))
PDF_ENUM_NAME_FT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FT))
PDF_ENUM_NAME_Fade = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fade))
PDF_ENUM_NAME_Ff = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ff))
PDF_ENUM_NAME_FieldMDP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FieldMDP))
PDF_ENUM_NAME_Fields = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fields))
PDF_ENUM_NAME_Figure = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Figure))
PDF_ENUM_NAME_FileAttachment = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FileAttachment))
PDF_ENUM_NAME_FileSize = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FileSize))
PDF_ENUM_NAME_Filespec = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Filespec))
PDF_ENUM_NAME_Filter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Filter))
PDF_ENUM_NAME_Final = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Final))
PDF_ENUM_NAME_Fingerprint = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fingerprint))
PDF_ENUM_NAME_First = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_First))
PDF_ENUM_NAME_FirstChar = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FirstChar))
PDF_ENUM_NAME_FirstPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FirstPage))
PDF_ENUM_NAME_Fit = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fit))
PDF_ENUM_NAME_FitB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitB))
PDF_ENUM_NAME_FitBH = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitBH))
PDF_ENUM_NAME_FitBV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitBV))
PDF_ENUM_NAME_FitH = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitH))
PDF_ENUM_NAME_FitR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitR))
PDF_ENUM_NAME_FitV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitV))
PDF_ENUM_NAME_Fl = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fl))
PDF_ENUM_NAME_Flags = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Flags))
PDF_ENUM_NAME_FlateDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FlateDecode))
PDF_ENUM_NAME_Fly = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fly))
PDF_ENUM_NAME_Font = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Font))
PDF_ENUM_NAME_FontBBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontBBox))
PDF_ENUM_NAME_FontDescriptor = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontDescriptor))
PDF_ENUM_NAME_FontFile = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontFile))
PDF_ENUM_NAME_FontFile2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontFile2))
PDF_ENUM_NAME_FontFile3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontFile3))
PDF_ENUM_NAME_FontMatrix = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontMatrix))
PDF_ENUM_NAME_FontName = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontName))
PDF_ENUM_NAME_ForComment = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ForComment))
PDF_ENUM_NAME_ForPublicRelease = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ForPublicRelease))
PDF_ENUM_NAME_Form = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Form))
PDF_ENUM_NAME_FormData = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FormData))
PDF_ENUM_NAME_FormEx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FormEx))
PDF_ENUM_NAME_FormType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FormType))
PDF_ENUM_NAME_Formula = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Formula))
PDF_ENUM_NAME_FreeText = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FreeText))
PDF_ENUM_NAME_FreeTextCallout = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FreeTextCallout))
PDF_ENUM_NAME_FreeTextTypeWriter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FreeTextTypeWriter))
PDF_ENUM_NAME_Function = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Function))
PDF_ENUM_NAME_FunctionType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FunctionType))
PDF_ENUM_NAME_Functions = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Functions))
PDF_ENUM_NAME_G = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_G))
PDF_ENUM_NAME_GTS_PDFX = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_GTS_PDFX))
PDF_ENUM_NAME_Gamma = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Gamma))
PDF_ENUM_NAME_Glitter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Glitter))
PDF_ENUM_NAME_GoTo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_GoTo))
PDF_ENUM_NAME_GoToR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_GoToR))
PDF_ENUM_NAME_Group = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Group))
PDF_ENUM_NAME_H = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H))
PDF_ENUM_NAME_H1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H1))
PDF_ENUM_NAME_H2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H2))
PDF_ENUM_NAME_H3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H3))
PDF_ENUM_NAME_H4 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H4))
PDF_ENUM_NAME_H5 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H5))
PDF_ENUM_NAME_H6 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H6))
PDF_ENUM_NAME_Height = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Height))
PDF_ENUM_NAME_Helv = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Helv))
PDF_ENUM_NAME_Highlight = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Highlight))
PDF_ENUM_NAME_HistoryPos = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_HistoryPos))
PDF_ENUM_NAME_I = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_I))
PDF_ENUM_NAME_IC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IC))
PDF_ENUM_NAME_ICCBased = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ICCBased))
PDF_ENUM_NAME_ID = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ID))
PDF_ENUM_NAME_IM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IM))
PDF_ENUM_NAME_IRT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IRT))
PDF_ENUM_NAME_IT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IT))
PDF_ENUM_NAME_Identity = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Identity))
PDF_ENUM_NAME_Identity_H = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Identity_H))
PDF_ENUM_NAME_Identity_V = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Identity_V))
PDF_ENUM_NAME_Image = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Image))
PDF_ENUM_NAME_ImageB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageB))
PDF_ENUM_NAME_ImageC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageC))
PDF_ENUM_NAME_ImageI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageI))
PDF_ENUM_NAME_ImageMask = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageMask))
PDF_ENUM_NAME_Include = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Include))
PDF_ENUM_NAME_Index = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Index))
PDF_ENUM_NAME_Indexed = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Indexed))
PDF_ENUM_NAME_Info = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Info))
PDF_ENUM_NAME_Ink = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ink))
PDF_ENUM_NAME_InkList = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_InkList))
PDF_ENUM_NAME_Intent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Intent))
PDF_ENUM_NAME_Interpolate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Interpolate))
PDF_ENUM_NAME_IsMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IsMap))
PDF_ENUM_NAME_ItalicAngle = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ItalicAngle))
PDF_ENUM_NAME_JBIG2Decode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JBIG2Decode))
PDF_ENUM_NAME_JBIG2Globals = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JBIG2Globals))
PDF_ENUM_NAME_JPXDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JPXDecode))
PDF_ENUM_NAME_JS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JS))
PDF_ENUM_NAME_JavaScript = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JavaScript))
PDF_ENUM_NAME_K = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_K))
PDF_ENUM_NAME_Keywords = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Keywords))
PDF_ENUM_NAME_Kids = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Kids))
PDF_ENUM_NAME_L = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_L))
PDF_ENUM_NAME_LBody = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LBody))
PDF_ENUM_NAME_LC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LC))
PDF_ENUM_NAME_LE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LE))
PDF_ENUM_NAME_LI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LI))
PDF_ENUM_NAME_LJ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LJ))
PDF_ENUM_NAME_LL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LL))
PDF_ENUM_NAME_LLE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LLE))
PDF_ENUM_NAME_LLO = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LLO))
PDF_ENUM_NAME_LW = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LW))
PDF_ENUM_NAME_LZ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LZ))
PDF_ENUM_NAME_LZW = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LZW))
PDF_ENUM_NAME_LZWDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LZWDecode))
PDF_ENUM_NAME_Lab = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lab))
PDF_ENUM_NAME_Label = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Label))
PDF_ENUM_NAME_Lang = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lang))
PDF_ENUM_NAME_Last = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Last))
PDF_ENUM_NAME_LastChar = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LastChar))
PDF_ENUM_NAME_LastPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LastPage))
PDF_ENUM_NAME_Launch = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Launch))
PDF_ENUM_NAME_Layer = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Layer))
PDF_ENUM_NAME_Lbl = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lbl))
PDF_ENUM_NAME_Length = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length))
PDF_ENUM_NAME_Length1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length1))
PDF_ENUM_NAME_Length2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length2))
PDF_ENUM_NAME_Length3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length3))
PDF_ENUM_NAME_Limits = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Limits))
PDF_ENUM_NAME_Line = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Line))
PDF_ENUM_NAME_LineArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LineArrow))
PDF_ENUM_NAME_LineDimension = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LineDimension))
PDF_ENUM_NAME_Linearized = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Linearized))
PDF_ENUM_NAME_Link = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Link))
PDF_ENUM_NAME_List = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_List))
PDF_ENUM_NAME_Location = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Location))
PDF_ENUM_NAME_Lock = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lock))
PDF_ENUM_NAME_Locked = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Locked))
PDF_ENUM_NAME_Luminosity = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Luminosity))
PDF_ENUM_NAME_M = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_M))
PDF_ENUM_NAME_MCID = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MCID))
PDF_ENUM_NAME_MK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MK))
PDF_ENUM_NAME_ML = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ML))
PDF_ENUM_NAME_MMType1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MMType1))
PDF_ENUM_NAME_Mac = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Mac))
PDF_ENUM_NAME_Mask = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Mask))
PDF_ENUM_NAME_Matrix = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Matrix))
PDF_ENUM_NAME_Matte = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Matte))
PDF_ENUM_NAME_MaxLen = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MaxLen))
PDF_ENUM_NAME_MediaBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MediaBox))
PDF_ENUM_NAME_Metadata = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Metadata))
PDF_ENUM_NAME_MissingWidth = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MissingWidth))
PDF_ENUM_NAME_ModDate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ModDate))
PDF_ENUM_NAME_Movie = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Movie))
PDF_ENUM_NAME_Msg = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Msg))
PDF_ENUM_NAME_Multiply = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Multiply))
PDF_ENUM_NAME_N = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_N))
PDF_ENUM_NAME_Name = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Name))
PDF_ENUM_NAME_Named = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Named))
PDF_ENUM_NAME_Names = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Names))
PDF_ENUM_NAME_NewWindow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NewWindow))
PDF_ENUM_NAME_Next = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Next))
PDF_ENUM_NAME_NextPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NextPage))
PDF_ENUM_NAME_NonEFontNoWarn = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NonEFontNoWarn))
PDF_ENUM_NAME_NonStruct = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NonStruct))
PDF_ENUM_NAME_None = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_None))
PDF_ENUM_NAME_Normal = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Normal))
PDF_ENUM_NAME_NotApproved = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NotApproved))
PDF_ENUM_NAME_NotForPublicRelease = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NotForPublicRelease))
PDF_ENUM_NAME_Note = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Note))
PDF_ENUM_NAME_NumSections = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NumSections))
PDF_ENUM_NAME_Nums = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Nums))
PDF_ENUM_NAME_O = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_O))
PDF_ENUM_NAME_OC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OC))
PDF_ENUM_NAME_OCG = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCG))
PDF_ENUM_NAME_OCGs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCGs))
PDF_ENUM_NAME_OCMD = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCMD))
PDF_ENUM_NAME_OCProperties = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCProperties))
PDF_ENUM_NAME_OE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OE))
PDF_ENUM_NAME_OFF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OFF))
PDF_ENUM_NAME_ON = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ON))
PDF_ENUM_NAME_OP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OP))
PDF_ENUM_NAME_OPM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OPM))
PDF_ENUM_NAME_OS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OS))
PDF_ENUM_NAME_ObjStm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ObjStm))
PDF_ENUM_NAME_Of = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Of))
PDF_ENUM_NAME_Off = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Off))
PDF_ENUM_NAME_Open = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Open))
PDF_ENUM_NAME_OpenArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OpenArrow))
PDF_ENUM_NAME_OpenType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OpenType))
PDF_ENUM_NAME_Opt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Opt))
PDF_ENUM_NAME_Order = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Order))
PDF_ENUM_NAME_Ordering = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ordering))
PDF_ENUM_NAME_Outlines = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Outlines))
PDF_ENUM_NAME_OutputCondition = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputCondition))
PDF_ENUM_NAME_OutputConditionIdentifier = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputConditionIdentifier))
PDF_ENUM_NAME_OutputIntent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputIntent))
PDF_ENUM_NAME_OutputIntents = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputIntents))
PDF_ENUM_NAME_P = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_P))
PDF_ENUM_NAME_PDF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PDF))
PDF_ENUM_NAME_PS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PS))
PDF_ENUM_NAME_Page = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Page))
PDF_ENUM_NAME_PageLabels = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PageLabels))
PDF_ENUM_NAME_PageMode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PageMode))
PDF_ENUM_NAME_Pages = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Pages))
PDF_ENUM_NAME_PaintType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PaintType))
PDF_ENUM_NAME_Params = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Params))
PDF_ENUM_NAME_Parent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Parent))
PDF_ENUM_NAME_ParentTree = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ParentTree))
PDF_ENUM_NAME_Part = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Part))
PDF_ENUM_NAME_Pattern = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Pattern))
PDF_ENUM_NAME_PatternType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PatternType))
PDF_ENUM_NAME_Perms = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Perms))
PDF_ENUM_NAME_PieceInfo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PieceInfo))
PDF_ENUM_NAME_PolyLine = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PolyLine))
PDF_ENUM_NAME_PolyLineDimension = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PolyLineDimension))
PDF_ENUM_NAME_Polygon = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Polygon))
PDF_ENUM_NAME_PolygonCloud = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PolygonCloud))
PDF_ENUM_NAME_PolygonDimension = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PolygonDimension))
PDF_ENUM_NAME_Popup = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Popup))
PDF_ENUM_NAME_PreRelease = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PreRelease))
PDF_ENUM_NAME_Predictor = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Predictor))
PDF_ENUM_NAME_Prev = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prev))
PDF_ENUM_NAME_PrevPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PrevPage))
PDF_ENUM_NAME_Preview = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Preview))
PDF_ENUM_NAME_Print = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Print))
PDF_ENUM_NAME_PrinterMark = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PrinterMark))
PDF_ENUM_NAME_Private = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Private))
PDF_ENUM_NAME_ProcSet = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ProcSet))
PDF_ENUM_NAME_Producer = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Producer))
PDF_ENUM_NAME_Prop_AuthTime = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prop_AuthTime))
PDF_ENUM_NAME_Prop_AuthType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prop_AuthType))
PDF_ENUM_NAME_Prop_Build = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prop_Build))
PDF_ENUM_NAME_Properties = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Properties))
PDF_ENUM_NAME_PubSec = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PubSec))
PDF_ENUM_NAME_Push = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Push))
PDF_ENUM_NAME_Q = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Q))
PDF_ENUM_NAME_QuadPoints = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_QuadPoints))
PDF_ENUM_NAME_Quote = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Quote))
PDF_ENUM_NAME_R = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_R))
PDF_ENUM_NAME_RB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RB))
PDF_ENUM_NAME_RBGroups = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RBGroups))
PDF_ENUM_NAME_RC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RC))
PDF_ENUM_NAME_RClosedArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RClosedArrow))
PDF_ENUM_NAME_RD = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RD))
PDF_ENUM_NAME_REx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_REx))
PDF_ENUM_NAME_RGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RGB))
PDF_ENUM_NAME_RI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RI))
PDF_ENUM_NAME_RL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RL))
PDF_ENUM_NAME_ROpenArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ROpenArrow))
PDF_ENUM_NAME_RP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RP))
PDF_ENUM_NAME_RT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RT))
PDF_ENUM_NAME_Range = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Range))
PDF_ENUM_NAME_Reason = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Reason))
PDF_ENUM_NAME_Rect = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Rect))
PDF_ENUM_NAME_Redact = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Redact))
PDF_ENUM_NAME_Ref = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ref))
PDF_ENUM_NAME_Reference = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Reference))
PDF_ENUM_NAME_Registry = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Registry))
PDF_ENUM_NAME_ResetForm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ResetForm))
PDF_ENUM_NAME_Resources = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Resources))
PDF_ENUM_NAME_RoleMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RoleMap))
PDF_ENUM_NAME_Root = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Root))
PDF_ENUM_NAME_Rotate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Rotate))
PDF_ENUM_NAME_Rows = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Rows))
PDF_ENUM_NAME_Ruby = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ruby))
PDF_ENUM_NAME_RunLengthDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RunLengthDecode))
PDF_ENUM_NAME_S = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_S))
PDF_ENUM_NAME_SMask = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SMask))
PDF_ENUM_NAME_SMaskInData = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SMaskInData))
PDF_ENUM_NAME_Schema = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Schema))
PDF_ENUM_NAME_Screen = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Screen))
PDF_ENUM_NAME_Sect = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sect))
PDF_ENUM_NAME_Separation = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Separation))
PDF_ENUM_NAME_Shading = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Shading))
PDF_ENUM_NAME_ShadingType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ShadingType))
PDF_ENUM_NAME_Si = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Si))
PDF_ENUM_NAME_Sig = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sig))
PDF_ENUM_NAME_SigFlags = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SigFlags))
PDF_ENUM_NAME_SigQ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SigQ))
PDF_ENUM_NAME_SigRef = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SigRef))
PDF_ENUM_NAME_Size = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Size))
PDF_ENUM_NAME_Slash = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Slash))
PDF_ENUM_NAME_Sold = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sold))
PDF_ENUM_NAME_Sound = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sound))
PDF_ENUM_NAME_Source = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Source))
PDF_ENUM_NAME_Span = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Span))
PDF_ENUM_NAME_Split = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Split))
PDF_ENUM_NAME_Square = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Square))
PDF_ENUM_NAME_Squiggly = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Squiggly))
PDF_ENUM_NAME_St = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_St))
PDF_ENUM_NAME_Stamp = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Stamp))
PDF_ENUM_NAME_StampImage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StampImage))
PDF_ENUM_NAME_StampSnapshot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StampSnapshot))
PDF_ENUM_NAME_Standard = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Standard))
PDF_ENUM_NAME_StdCF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StdCF))
PDF_ENUM_NAME_StemV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StemV))
PDF_ENUM_NAME_StmF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StmF))
PDF_ENUM_NAME_StrF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StrF))
PDF_ENUM_NAME_StrikeOut = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StrikeOut))
PDF_ENUM_NAME_Strong = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Strong))
PDF_ENUM_NAME_StructParent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StructParent))
PDF_ENUM_NAME_StructParents = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StructParents))
PDF_ENUM_NAME_StructTreeRoot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StructTreeRoot))
PDF_ENUM_NAME_Sub = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sub))
PDF_ENUM_NAME_SubFilter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SubFilter))
PDF_ENUM_NAME_Subject = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Subject))
PDF_ENUM_NAME_Subtype = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Subtype))
PDF_ENUM_NAME_Subtype2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Subtype2))
PDF_ENUM_NAME_Supplement = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Supplement))
PDF_ENUM_NAME_Symb = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Symb))
PDF_ENUM_NAME_T = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_T))
PDF_ENUM_NAME_TBody = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TBody))
PDF_ENUM_NAME_TD = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TD))
PDF_ENUM_NAME_TFoot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TFoot))
PDF_ENUM_NAME_TH = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TH))
PDF_ENUM_NAME_THead = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_THead))
PDF_ENUM_NAME_TI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TI))
PDF_ENUM_NAME_TOC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TOC))
PDF_ENUM_NAME_TOCI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TOCI))
PDF_ENUM_NAME_TR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TR))
PDF_ENUM_NAME_TR2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TR2))
PDF_ENUM_NAME_TU = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TU))
PDF_ENUM_NAME_Table = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Table))
PDF_ENUM_NAME_Text = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Text))
PDF_ENUM_NAME_Thumb = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Thumb))
PDF_ENUM_NAME_TilingType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TilingType))
PDF_ENUM_NAME_Times = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Times))
PDF_ENUM_NAME_Title = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Title))
PDF_ENUM_NAME_ToUnicode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ToUnicode))
PDF_ENUM_NAME_Top = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Top))
PDF_ENUM_NAME_TopSecret = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TopSecret))
PDF_ENUM_NAME_Trans = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Trans))
PDF_ENUM_NAME_TransformMethod = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TransformMethod))
PDF_ENUM_NAME_TransformParams = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TransformParams))
PDF_ENUM_NAME_Transparency = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Transparency))
PDF_ENUM_NAME_TrapNet = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrapNet))
PDF_ENUM_NAME_TrimBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrimBox))
PDF_ENUM_NAME_TrueType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrueType))
PDF_ENUM_NAME_TrustedMode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrustedMode))
PDF_ENUM_NAME_Tx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Tx))
PDF_ENUM_NAME_Type = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type))
PDF_ENUM_NAME_Type0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type0))
PDF_ENUM_NAME_Type1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type1))
PDF_ENUM_NAME_Type1C = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type1C))
PDF_ENUM_NAME_Type3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type3))
PDF_ENUM_NAME_U = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_U))
PDF_ENUM_NAME_UE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UE))
PDF_ENUM_NAME_UF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UF))
PDF_ENUM_NAME_URI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_URI))
PDF_ENUM_NAME_URL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_URL))
PDF_ENUM_NAME_Unchanged = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Unchanged))
PDF_ENUM_NAME_Uncover = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Uncover))
PDF_ENUM_NAME_Underline = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Underline))
PDF_ENUM_NAME_Unix = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Unix))
PDF_ENUM_NAME_Unspecified = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Unspecified))
PDF_ENUM_NAME_Usage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Usage))
PDF_ENUM_NAME_UseBlackPtComp = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UseBlackPtComp))
PDF_ENUM_NAME_UseCMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UseCMap))
PDF_ENUM_NAME_UseOutlines = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UseOutlines))
PDF_ENUM_NAME_UserUnit = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UserUnit))
PDF_ENUM_NAME_V = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_V))
PDF_ENUM_NAME_V2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_V2))
PDF_ENUM_NAME_VE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_VE))
PDF_ENUM_NAME_Version = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Version))
PDF_ENUM_NAME_Vertices = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Vertices))
PDF_ENUM_NAME_VerticesPerRow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_VerticesPerRow))
PDF_ENUM_NAME_View = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_View))
PDF_ENUM_NAME_W = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_W))
PDF_ENUM_NAME_W2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_W2))
PDF_ENUM_NAME_WMode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WMode))
PDF_ENUM_NAME_WP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WP))
PDF_ENUM_NAME_WT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WT))
PDF_ENUM_NAME_Warichu = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Warichu))
PDF_ENUM_NAME_Watermark = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Watermark))
PDF_ENUM_NAME_WhitePoint = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WhitePoint))
PDF_ENUM_NAME_Widget = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Widget))
PDF_ENUM_NAME_Width = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Width))
PDF_ENUM_NAME_Widths = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Widths))
PDF_ENUM_NAME_WinAnsiEncoding = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WinAnsiEncoding))
PDF_ENUM_NAME_Wipe = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Wipe))
PDF_ENUM_NAME_XFA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XFA))
PDF_ENUM_NAME_XHeight = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XHeight))
PDF_ENUM_NAME_XML = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XML))
PDF_ENUM_NAME_XObject = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XObject))
PDF_ENUM_NAME_XRef = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XRef))
PDF_ENUM_NAME_XRefStm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XRefStm))
PDF_ENUM_NAME_XStep = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XStep))
PDF_ENUM_NAME_XYZ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XYZ))
PDF_ENUM_NAME_YStep = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_YStep))
PDF_ENUM_NAME_Yes = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Yes))
PDF_ENUM_NAME_ZaDb = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ZaDb))
PDF_ENUM_NAME_a = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_a))
PDF_ENUM_NAME_adbe_pkcs7_detached = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_adbe_pkcs7_detached))
PDF_ENUM_NAME_ca = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ca))
PDF_ENUM_NAME_n0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_n0))
PDF_ENUM_NAME_n1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_n1))
PDF_ENUM_NAME_n2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_n2))
PDF_ENUM_NAME_op = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_op))
PDF_ENUM_NAME_r = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_r))
PDF_NULL = PdfObj( obj_enum_to_obj( PDF_ENUM_NULL))
PDF_TRUE = PdfObj( obj_enum_to_obj( PDF_ENUM_TRUE))
PDF_FALSE = PdfObj( obj_enum_to_obj( PDF_ENUM_FALSE))


# ================================================================================
# Datei: venv\Lib\site-packages\pymupdf\pymupdf.py
# ================================================================================

# pylint: disable=wildcard-import,unused-import
from . import *


# ================================================================================
# Datei: venv\Lib\site-packages\pymupdf\table.py
# ================================================================================

"""
Copyright (C) 2023 Artifex Software, Inc.

This file is part of PyMuPDF.

PyMuPDF is free software: you can redistribute it and/or modify it under the
terms of the GNU Affero General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

PyMuPDF is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
details.

You should have received a copy of the GNU Affero General Public License
along with MuPDF. If not, see <https://www.gnu.org/licenses/agpl-3.0.en.html>

Alternative licensing terms are available from the licensor.
For commercial licensing, see <https://www.artifex.com/> or contact
Artifex Software, Inc., 39 Mesa Street, Suite 108A, San Francisco,
CA 94129, USA, for further information.

---------------------------------------------------------------------
Portions of this code have been ported from pdfplumber, see
https://pypi.org/project/pdfplumber/.

The ported code is under the following MIT license:

---------------------------------------------------------------------
The MIT License (MIT)

Copyright (c) 2015, Jeremy Singer-Vine

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
---------------------------------------------------------------------
Also see here: https://github.com/jsvine/pdfplumber/blob/stable/LICENSE.txt
---------------------------------------------------------------------

The porting mainly pertains to files "table.py" and relevant parts of
"utils/text.py" within pdfplumber's repository on Github.
With respect to "text.py", we have removed functions or features that are not
used by table processing. Examples are:

* the text search function
* simple text extraction
* text extraction by lines

Original pdfplumber code does neither detect, nor identify table headers.
This PyMuPDF port adds respective code to the 'Table' class as method '_get_header'.
This is implemented as new class TableHeader with the properties:
* bbox: A tuple for the header's bbox
* cells: A tuple for each bbox of a column header
* names: A list of strings with column header text
* external: A bool indicating whether the header is outside the table cells.

"""

import inspect
import itertools
import string
import html
from collections.abc import Sequence
from dataclasses import dataclass
from operator import itemgetter

# -------------------------------------------------------------------
# Start of PyMuPDF interface code
# -------------------------------------------------------------------
from . import (
    Rect,
    Matrix,
    TEXTFLAGS_TEXT,
    TOOLS,
    EMPTY_RECT,
    sRGB_to_pdf,
    Point,
    message,
)

EDGES = []  # vector graphics from PyMuPDF
CHARS = []  # text characters from PyMuPDF
TEXTPAGE = None
white_spaces = set(string.whitespace)  # for checking white space only cells
# -------------------------------------------------------------------
# End of PyMuPDF interface code
# -------------------------------------------------------------------


class UnsetFloat(float):
    pass


NON_NEGATIVE_SETTINGS = [
    "snap_tolerance",
    "snap_x_tolerance",
    "snap_y_tolerance",
    "join_tolerance",
    "join_x_tolerance",
    "join_y_tolerance",
    "edge_min_length",
    "min_words_vertical",
    "min_words_horizontal",
    "intersection_tolerance",
    "intersection_x_tolerance",
    "intersection_y_tolerance",
]


TABLE_STRATEGIES = ["lines", "lines_strict", "text", "explicit"]
UNSET = UnsetFloat(0)
DEFAULT_SNAP_TOLERANCE = 3
DEFAULT_JOIN_TOLERANCE = 3
DEFAULT_MIN_WORDS_VERTICAL = 3
DEFAULT_MIN_WORDS_HORIZONTAL = 1
DEFAULT_X_TOLERANCE = 3
DEFAULT_Y_TOLERANCE = 3
DEFAULT_X_DENSITY = 7.25
DEFAULT_Y_DENSITY = 13
bbox_getter = itemgetter("x0", "top", "x1", "bottom")


LIGATURES = {
    "ﬀ": "ff",
    "ﬃ": "ffi",
    "ﬄ": "ffl",
    "ﬁ": "fi",
    "ﬂ": "fl",
    "ﬆ": "st",
    "ﬅ": "st",
}


def to_list(collection) -> list:
    if isinstance(collection, list):
        return collection
    elif isinstance(collection, Sequence):
        return list(collection)
    elif hasattr(collection, "to_dict"):
        res = collection.to_dict("records")  # pragma: nocover
        return res
    else:
        return list(collection)


class TextMap:
    """
    A TextMap maps each unicode character in the text to an individual `char`
    object (or, in the case of layout-implied whitespace, `None`).
    """

    def __init__(self, tuples=None) -> None:
        self.tuples = tuples
        self.as_string = "".join(map(itemgetter(0), tuples))

    def match_to_dict(
        self,
        m,
        main_group: int = 0,
        return_groups: bool = True,
        return_chars: bool = True,
    ) -> dict:
        subset = self.tuples[m.start(main_group) : m.end(main_group)]
        chars = [c for (text, c) in subset if c is not None]
        x0, top, x1, bottom = objects_to_bbox(chars)

        result = {
            "text": m.group(main_group),
            "x0": x0,
            "top": top,
            "x1": x1,
            "bottom": bottom,
        }

        if return_groups:
            result["groups"] = m.groups()

        if return_chars:
            result["chars"] = chars

        return result


class WordMap:
    """
    A WordMap maps words->chars.
    """

    def __init__(self, tuples) -> None:
        self.tuples = tuples

    def to_textmap(
        self,
        layout: bool = False,
        layout_width=0,
        layout_height=0,
        layout_width_chars: int = 0,
        layout_height_chars: int = 0,
        x_density=DEFAULT_X_DENSITY,
        y_density=DEFAULT_Y_DENSITY,
        x_shift=0,
        y_shift=0,
        y_tolerance=DEFAULT_Y_TOLERANCE,
        use_text_flow: bool = False,
        presorted: bool = False,
        expand_ligatures: bool = True,
    ) -> TextMap:
        """
        Given a list of (word, chars) tuples (i.e., a WordMap), return a list of
        (char-text, char) tuples (i.e., a TextMap) that can be used to mimic the
        structural layout of the text on the page(s), using the following approach:

        - Sort the words by (doctop, x0) if not already sorted.

        - Calculate the initial doctop for the starting page.

        - Cluster the words by doctop (taking `y_tolerance` into account), and
          iterate through them.

        - For each cluster, calculate the distance between that doctop and the
          initial doctop, in points, minus `y_shift`. Divide that distance by
          `y_density` to calculate the minimum number of newlines that should come
          before this cluster. Append that number of newlines *minus* the number of
          newlines already appended, with a minimum of one.

        - Then for each cluster, iterate through each word in it. Divide each
          word's x0, minus `x_shift`, by `x_density` to calculate the minimum
          number of characters that should come before this cluster.  Append that
          number of spaces *minus* the number of characters and spaces already
          appended, with a minimum of one. Then append the word's text.

        - At the termination of each line, add more spaces if necessary to
          mimic `layout_width`.

        - Finally, add newlines to the end if necessary to mimic to
          `layout_height`.

        Note: This approach currently works best for horizontal, left-to-right
        text, but will display all words regardless of orientation. There is room
        for improvement in better supporting right-to-left text, as well as
        vertical text.
        """
        _textmap = []

        if not len(self.tuples):
            return TextMap(_textmap)

        expansions = LIGATURES if expand_ligatures else {}

        if layout:
            if layout_width_chars:
                if layout_width:
                    raise ValueError(
                        "`layout_width` and `layout_width_chars` cannot both be set."
                    )
            else:
                layout_width_chars = int(round(layout_width / x_density))

            if layout_height_chars:
                if layout_height:
                    raise ValueError(
                        "`layout_height` and `layout_height_chars` cannot both be set."
                    )
            else:
                layout_height_chars = int(round(layout_height / y_density))

            blank_line = [(" ", None)] * layout_width_chars
        else:
            blank_line = []

        num_newlines = 0

        words_sorted_doctop = (
            self.tuples
            if presorted or use_text_flow
            else sorted(self.tuples, key=lambda x: float(x[0]["doctop"]))
        )

        first_word = words_sorted_doctop[0][0]
        doctop_start = first_word["doctop"] - first_word["top"]

        for i, ws in enumerate(
            cluster_objects(
                words_sorted_doctop, lambda x: float(x[0]["doctop"]), y_tolerance
            )
        ):
            y_dist = (
                (ws[0][0]["doctop"] - (doctop_start + y_shift)) / y_density
                if layout
                else 0
            )
            num_newlines_prepend = max(
                # At least one newline, unless this iis the first line
                int(i > 0),
                # ... or as many as needed to get the imputed "distance" from the top
                round(y_dist) - num_newlines,
            )

            for i in range(num_newlines_prepend):
                if not len(_textmap) or _textmap[-1][0] == "\n":
                    _textmap += blank_line
                _textmap.append(("\n", None))

            num_newlines += num_newlines_prepend

            line_len = 0

            line_words_sorted_x0 = (
                ws
                if presorted or use_text_flow
                else sorted(ws, key=lambda x: float(x[0]["x0"]))
            )

            for word, chars in line_words_sorted_x0:
                x_dist = (word["x0"] - x_shift) / x_density if layout else 0
                num_spaces_prepend = max(min(1, line_len), round(x_dist) - line_len)
                _textmap += [(" ", None)] * num_spaces_prepend
                line_len += num_spaces_prepend

                for c in chars:
                    letters = expansions.get(c["text"], c["text"])
                    for letter in letters:
                        _textmap.append((letter, c))
                        line_len += 1

            # Append spaces at end of line
            if layout:
                _textmap += [(" ", None)] * (layout_width_chars - line_len)

        # Append blank lines at end of text
        if layout:
            num_newlines_append = layout_height_chars - (num_newlines + 1)
            for i in range(num_newlines_append):
                if i > 0:
                    _textmap += blank_line
                _textmap.append(("\n", None))

            # Remove terminal newline
            if _textmap[-1] == ("\n", None):
                _textmap = _textmap[:-1]

        return TextMap(_textmap)


class WordExtractor:
    def __init__(
        self,
        x_tolerance=DEFAULT_X_TOLERANCE,
        y_tolerance=DEFAULT_Y_TOLERANCE,
        keep_blank_chars: bool = False,
        use_text_flow=False,
        horizontal_ltr=True,  # Should words be read left-to-right?
        vertical_ttb=False,  # Should vertical words be read top-to-bottom?
        extra_attrs=None,
        split_at_punctuation=False,
        expand_ligatures=True,
    ):
        self.x_tolerance = x_tolerance
        self.y_tolerance = y_tolerance
        self.keep_blank_chars = keep_blank_chars
        self.use_text_flow = use_text_flow
        self.horizontal_ltr = horizontal_ltr
        self.vertical_ttb = vertical_ttb
        self.extra_attrs = [] if extra_attrs is None else extra_attrs

        # Note: string.punctuation = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
        self.split_at_punctuation = (
            string.punctuation
            if split_at_punctuation is True
            else (split_at_punctuation or "")
        )

        self.expansions = LIGATURES if expand_ligatures else {}

    def merge_chars(self, ordered_chars: list):
        x0, top, x1, bottom = objects_to_bbox(ordered_chars)
        doctop_adj = ordered_chars[0]["doctop"] - ordered_chars[0]["top"]
        upright = ordered_chars[0]["upright"]
        direction = 1 if (self.horizontal_ltr if upright else self.vertical_ttb) else -1

        matrix = ordered_chars[0]["matrix"]

        rotation = 0
        if not upright and matrix[1] < 0:
            ordered_chars = reversed(ordered_chars)
            rotation = 270

        if matrix[0] < 0 and matrix[3] < 0:
            rotation = 180
        elif matrix[1] > 0:
            rotation = 90

        word = {
            "text": "".join(
                self.expansions.get(c["text"], c["text"]) for c in ordered_chars
            ),
            "x0": x0,
            "x1": x1,
            "top": top,
            "doctop": top + doctop_adj,
            "bottom": bottom,
            "upright": upright,
            "direction": direction,
            "rotation": rotation,
        }

        for key in self.extra_attrs:
            word[key] = ordered_chars[0][key]

        return word

    def char_begins_new_word(
        self,
        prev_char,
        curr_char,
    ) -> bool:
        """This method takes several factors into account to determine if
        `curr_char` represents the beginning of a new word:

        - Whether the text is "upright" (i.e., non-rotated)
        - Whether the user has specified that horizontal text runs
          left-to-right (default) or right-to-left, as represented by
          self.horizontal_ltr
        - Whether the user has specified that vertical text the text runs
          top-to-bottom (default) or bottom-to-top, as represented by
          self.vertical_ttb
        - The x0, top, x1, and bottom attributes of prev_char and
          curr_char
        - The self.x_tolerance and self.y_tolerance settings. Note: In
          this case, x/y refer to those directions for non-rotated text.
          For vertical text, they are flipped. A more accurate terminology
          might be "*intra*line character distance tolerance" and
          "*inter*line character distance tolerance"

        An important note: The *intra*line distance is measured from the
        *end* of the previous character to the *beginning* of the current
        character, while the *inter*line distance is measured from the
        *top* of the previous character to the *top* of the next
        character. The reasons for this are partly repository-historical,
        and partly logical, as successive text lines' bounding boxes often
        overlap slightly (and we don't want that overlap to be interpreted
        as the two lines being the same line).

        The upright-ness of the character determines the attributes to
        compare, while horizontal_ltr/vertical_ttb determine the direction
        of the comparison.
        """

        # Note: Due to the grouping step earlier in the process,
        # curr_char["upright"] will always equal prev_char["upright"].
        if curr_char["upright"]:
            x = self.x_tolerance
            y = self.y_tolerance
            ay = prev_char["top"]
            cy = curr_char["top"]
            if self.horizontal_ltr:
                ax = prev_char["x0"]
                bx = prev_char["x1"]
                cx = curr_char["x0"]
            else:
                ax = -prev_char["x1"]
                bx = -prev_char["x0"]
                cx = -curr_char["x1"]

        else:
            x = self.y_tolerance
            y = self.x_tolerance
            ay = prev_char["x0"]
            cy = curr_char["x0"]
            if self.vertical_ttb:
                ax = prev_char["top"]
                bx = prev_char["bottom"]
                cx = curr_char["top"]
            else:
                ax = -prev_char["bottom"]
                bx = -prev_char["top"]
                cx = -curr_char["bottom"]

        return bool(
            # Intraline test
            (cx < ax)
            or (cx > bx + x)
            # Interline test
            or (cy > ay + y)
        )

    def iter_chars_to_words(self, ordered_chars):
        current_word: list = []

        def start_next_word(new_char=None):
            nonlocal current_word

            if current_word:
                yield current_word

            current_word = [] if new_char is None else [new_char]

        for char in ordered_chars:
            text = char["text"]

            if not self.keep_blank_chars and text.isspace():
                yield from start_next_word(None)

            elif text in self.split_at_punctuation:
                yield from start_next_word(char)
                yield from start_next_word(None)

            elif current_word and self.char_begins_new_word(current_word[-1], char):
                yield from start_next_word(char)

            else:
                current_word.append(char)

        # Finally, after all chars processed
        if current_word:
            yield current_word

    def iter_sort_chars(self, chars):
        def upright_key(x) -> int:
            return -int(x["upright"])

        for upright_cluster in cluster_objects(list(chars), upright_key, 0):
            upright = upright_cluster[0]["upright"]
            cluster_key = "doctop" if upright else "x0"

            # Cluster by line
            subclusters = cluster_objects(
                upright_cluster, itemgetter(cluster_key), self.y_tolerance
            )

            for sc in subclusters:
                # Sort within line
                sort_key = "x0" if upright else "doctop"
                to_yield = sorted(sc, key=itemgetter(sort_key))

                # Reverse order if necessary
                if not (self.horizontal_ltr if upright else self.vertical_ttb):
                    yield from reversed(to_yield)
                else:
                    yield from to_yield

    def iter_extract_tuples(self, chars):
        ordered_chars = chars if self.use_text_flow else self.iter_sort_chars(chars)

        grouping_key = itemgetter("upright", *self.extra_attrs)
        grouped_chars = itertools.groupby(ordered_chars, grouping_key)

        for keyvals, char_group in grouped_chars:
            for word_chars in self.iter_chars_to_words(char_group):
                yield (self.merge_chars(word_chars), word_chars)

    def extract_wordmap(self, chars) -> WordMap:
        return WordMap(list(self.iter_extract_tuples(chars)))

    def extract_words(self, chars: list) -> list:
        words = list(word for word, word_chars in self.iter_extract_tuples(chars))
        return words


def extract_words(chars: list, **kwargs) -> list:
    return WordExtractor(**kwargs).extract_words(chars)


TEXTMAP_KWARGS = inspect.signature(WordMap.to_textmap).parameters.keys()
WORD_EXTRACTOR_KWARGS = inspect.signature(WordExtractor).parameters.keys()


def chars_to_textmap(chars: list, **kwargs) -> TextMap:
    kwargs.update({"presorted": True})

    extractor = WordExtractor(
        **{k: kwargs[k] for k in WORD_EXTRACTOR_KWARGS if k in kwargs}
    )
    wordmap = extractor.extract_wordmap(chars)
    textmap = wordmap.to_textmap(
        **{k: kwargs[k] for k in TEXTMAP_KWARGS if k in kwargs}
    )

    return textmap


def extract_text(chars: list, **kwargs) -> str:
    chars = to_list(chars)
    if len(chars) == 0:
        return ""

    if kwargs.get("layout"):
        return chars_to_textmap(chars, **kwargs).as_string
    else:
        y_tolerance = kwargs.get("y_tolerance", DEFAULT_Y_TOLERANCE)
        extractor = WordExtractor(
            **{k: kwargs[k] for k in WORD_EXTRACTOR_KWARGS if k in kwargs}
        )
        words = extractor.extract_words(chars)
        if words:
            rotation = words[0]["rotation"]  # rotation cannot change within a cell
        else:
            rotation = 0

        if rotation == 90:
            words.sort(key=lambda w: (w["x1"], -w["top"]))
            lines = " ".join([w["text"] for w in words])
        elif rotation == 270:
            words.sort(key=lambda w: (-w["x1"], w["top"]))
            lines = " ".join([w["text"] for w in words])
        else:
            lines = cluster_objects(words, itemgetter("doctop"), y_tolerance)
            lines = "\n".join(" ".join(word["text"] for word in line) for line in lines)
            if rotation == 180:  # needs extra treatment
                lines = "".join([(c if c != "\n" else " ") for c in reversed(lines)])

        return lines


def collate_line(
    line_chars: list,
    tolerance=DEFAULT_X_TOLERANCE,
) -> str:
    coll = ""
    last_x1 = None
    for char in sorted(line_chars, key=itemgetter("x0")):
        if (last_x1 is not None) and (char["x0"] > (last_x1 + tolerance)):
            coll += " "
        last_x1 = char["x1"]
        coll += char["text"]
    return coll


def dedupe_chars(chars: list, tolerance=1) -> list:
    """
    Removes duplicate chars — those sharing the same text, fontname, size,
    and positioning (within `tolerance`) as other characters in the set.
    """
    key = itemgetter("fontname", "size", "upright", "text")
    pos_key = itemgetter("doctop", "x0")

    def yield_unique_chars(chars: list):
        sorted_chars = sorted(chars, key=key)
        for grp, grp_chars in itertools.groupby(sorted_chars, key=key):
            for y_cluster in cluster_objects(
                list(grp_chars), itemgetter("doctop"), tolerance
            ):
                for x_cluster in cluster_objects(
                    y_cluster, itemgetter("x0"), tolerance
                ):
                    yield sorted(x_cluster, key=pos_key)[0]

    deduped = yield_unique_chars(chars)
    return sorted(deduped, key=chars.index)


def line_to_edge(line):
    edge = dict(line)
    edge["orientation"] = "h" if (line["top"] == line["bottom"]) else "v"
    return edge


def rect_to_edges(rect) -> list:
    top, bottom, left, right = [dict(rect) for x in range(4)]
    top.update(
        {
            "object_type": "rect_edge",
            "height": 0,
            "y0": rect["y1"],
            "bottom": rect["top"],
            "orientation": "h",
        }
    )
    bottom.update(
        {
            "object_type": "rect_edge",
            "height": 0,
            "y1": rect["y0"],
            "top": rect["top"] + rect["height"],
            "doctop": rect["doctop"] + rect["height"],
            "orientation": "h",
        }
    )
    left.update(
        {
            "object_type": "rect_edge",
            "width": 0,
            "x1": rect["x0"],
            "orientation": "v",
        }
    )
    right.update(
        {
            "object_type": "rect_edge",
            "width": 0,
            "x0": rect["x1"],
            "orientation": "v",
        }
    )
    return [top, bottom, left, right]


def curve_to_edges(curve) -> list:
    point_pairs = zip(curve["pts"], curve["pts"][1:])
    return [
        {
            "object_type": "curve_edge",
            "x0": min(p0[0], p1[0]),
            "x1": max(p0[0], p1[0]),
            "top": min(p0[1], p1[1]),
            "doctop": min(p0[1], p1[1]) + (curve["doctop"] - curve["top"]),
            "bottom": max(p0[1], p1[1]),
            "width": abs(p0[0] - p1[0]),
            "height": abs(p0[1] - p1[1]),
            "orientation": "v" if p0[0] == p1[0] else ("h" if p0[1] == p1[1] else None),
        }
        for p0, p1 in point_pairs
    ]


def obj_to_edges(obj) -> list:
    t = obj["object_type"]
    if "_edge" in t:
        return [obj]
    elif t == "line":
        return [line_to_edge(obj)]
    else:
        return {"rect": rect_to_edges, "curve": curve_to_edges}[t](obj)


def filter_edges(
    edges,
    orientation=None,
    edge_type=None,
    min_length=1,
) -> list:
    if orientation not in ("v", "h", None):
        raise ValueError("Orientation must be 'v' or 'h'")

    def test(e) -> bool:
        dim = "height" if e["orientation"] == "v" else "width"
        et_correct = e["object_type"] == edge_type if edge_type is not None else True
        orient_correct = orientation is None or e["orientation"] == orientation
        return bool(et_correct and orient_correct and (e[dim] >= min_length))

    return list(filter(test, edges))


def cluster_list(xs, tolerance=0) -> list:
    if tolerance == 0:
        return [[x] for x in sorted(xs)]
    if len(xs) < 2:
        return [[x] for x in sorted(xs)]
    groups = []
    xs = list(sorted(xs))
    current_group = [xs[0]]
    last = xs[0]
    for x in xs[1:]:
        if x <= (last + tolerance):
            current_group.append(x)
        else:
            groups.append(current_group)
            current_group = [x]
        last = x
    groups.append(current_group)
    return groups


def make_cluster_dict(values, tolerance) -> dict:
    clusters = cluster_list(list(set(values)), tolerance)

    nested_tuples = [
        [(val, i) for val in value_cluster] for i, value_cluster in enumerate(clusters)
    ]

    return dict(itertools.chain(*nested_tuples))


def cluster_objects(xs, key_fn, tolerance) -> list:
    if not callable(key_fn):
        key_fn = itemgetter(key_fn)

    values = map(key_fn, xs)
    cluster_dict = make_cluster_dict(values, tolerance)

    get_0, get_1 = itemgetter(0), itemgetter(1)

    cluster_tuples = sorted(((x, cluster_dict.get(key_fn(x))) for x in xs), key=get_1)

    grouped = itertools.groupby(cluster_tuples, key=get_1)

    return [list(map(get_0, v)) for k, v in grouped]


def move_object(obj, axis: str, value):
    assert axis in ("h", "v")
    if axis == "h":
        new_items = [
            ("x0", obj["x0"] + value),
            ("x1", obj["x1"] + value),
        ]
    if axis == "v":
        new_items = [
            ("top", obj["top"] + value),
            ("bottom", obj["bottom"] + value),
        ]
        if "doctop" in obj:
            new_items += [("doctop", obj["doctop"] + value)]
        if "y0" in obj:
            new_items += [
                ("y0", obj["y0"] - value),
                ("y1", obj["y1"] - value),
            ]
    return obj.__class__(tuple(obj.items()) + tuple(new_items))


def snap_objects(objs, attr: str, tolerance) -> list:
    axis = {"x0": "h", "x1": "h", "top": "v", "bottom": "v"}[attr]
    list_objs = list(objs)
    clusters = cluster_objects(list_objs, itemgetter(attr), tolerance)
    avgs = [sum(map(itemgetter(attr), cluster)) / len(cluster) for cluster in clusters]
    snapped_clusters = [
        [move_object(obj, axis, avg - obj[attr]) for obj in cluster]
        for cluster, avg in zip(clusters, avgs)
    ]
    return list(itertools.chain(*snapped_clusters))


def snap_edges(
    edges,
    x_tolerance=DEFAULT_SNAP_TOLERANCE,
    y_tolerance=DEFAULT_SNAP_TOLERANCE,
):
    """
    Given a list of edges, snap any within `tolerance` pixels of one another
    to their positional average.
    """
    by_orientation = {"v": [], "h": []}
    for e in edges:
        by_orientation[e["orientation"]].append(e)

    snapped_v = snap_objects(by_orientation["v"], "x0", x_tolerance)
    snapped_h = snap_objects(by_orientation["h"], "top", y_tolerance)
    return snapped_v + snapped_h


def resize_object(obj, key: str, value):
    assert key in ("x0", "x1", "top", "bottom")
    old_value = obj[key]
    diff = value - old_value
    new_items = [
        (key, value),
    ]
    if key == "x0":
        assert value <= obj["x1"]
        new_items.append(("width", obj["x1"] - value))
    elif key == "x1":
        assert value >= obj["x0"]
        new_items.append(("width", value - obj["x0"]))
    elif key == "top":
        assert value <= obj["bottom"]
        new_items.append(("doctop", obj["doctop"] + diff))
        new_items.append(("height", obj["height"] - diff))
        if "y1" in obj:
            new_items.append(("y1", obj["y1"] - diff))
    elif key == "bottom":
        assert value >= obj["top"]
        new_items.append(("height", obj["height"] + diff))
        if "y0" in obj:
            new_items.append(("y0", obj["y0"] - diff))
    return obj.__class__(tuple(obj.items()) + tuple(new_items))


def join_edge_group(edges, orientation: str, tolerance=DEFAULT_JOIN_TOLERANCE):
    """
    Given a list of edges along the same infinite line, join those that
    are within `tolerance` pixels of one another.
    """
    if orientation == "h":
        min_prop, max_prop = "x0", "x1"
    elif orientation == "v":
        min_prop, max_prop = "top", "bottom"
    else:
        raise ValueError("Orientation must be 'v' or 'h'")

    sorted_edges = list(sorted(edges, key=itemgetter(min_prop)))
    joined = [sorted_edges[0]]
    for e in sorted_edges[1:]:
        last = joined[-1]
        if e[min_prop] <= (last[max_prop] + tolerance):
            if e[max_prop] > last[max_prop]:
                # Extend current edge to new extremity
                joined[-1] = resize_object(last, max_prop, e[max_prop])
        else:
            # Edge is separate from previous edges
            joined.append(e)

    return joined


def merge_edges(
    edges,
    snap_x_tolerance,
    snap_y_tolerance,
    join_x_tolerance,
    join_y_tolerance,
):
    """
    Using the `snap_edges` and `join_edge_group` methods above,
    merge a list of edges into a more "seamless" list.
    """

    def get_group(edge):
        if edge["orientation"] == "h":
            return ("h", edge["top"])
        else:
            return ("v", edge["x0"])

    if snap_x_tolerance > 0 or snap_y_tolerance > 0:
        edges = snap_edges(edges, snap_x_tolerance, snap_y_tolerance)

    _sorted = sorted(edges, key=get_group)
    edge_groups = itertools.groupby(_sorted, key=get_group)
    edge_gen = (
        join_edge_group(
            items, k[0], (join_x_tolerance if k[0] == "h" else join_y_tolerance)
        )
        for k, items in edge_groups
    )
    edges = list(itertools.chain(*edge_gen))
    return edges


def bbox_to_rect(bbox) -> dict:
    """
    Return the rectangle (i.e a dict with keys "x0", "top", "x1",
    "bottom") for an object.
    """
    return {"x0": bbox[0], "top": bbox[1], "x1": bbox[2], "bottom": bbox[3]}


def objects_to_rect(objects) -> dict:
    """
    Given an iterable of objects, return the smallest rectangle (i.e. a
    dict with "x0", "top", "x1", and "bottom" keys) that contains them
    all.
    """
    return bbox_to_rect(objects_to_bbox(objects))


def merge_bboxes(bboxes):
    """
    Given an iterable of bounding boxes, return the smallest bounding box
    that contains them all.
    """
    x0, top, x1, bottom = zip(*bboxes)
    return (min(x0), min(top), max(x1), max(bottom))


def objects_to_bbox(objects):
    """
    Given an iterable of objects, return the smallest bounding box that
    contains them all.
    """
    return merge_bboxes(map(bbox_getter, objects))


def words_to_edges_h(words, word_threshold: int = DEFAULT_MIN_WORDS_HORIZONTAL):
    """
    Find (imaginary) horizontal lines that connect the tops
    of at least `word_threshold` words.
    """
    by_top = cluster_objects(words, itemgetter("top"), 1)
    large_clusters = filter(lambda x: len(x) >= word_threshold, by_top)
    rects = list(map(objects_to_rect, large_clusters))
    if len(rects) == 0:
        return []
    min_x0 = min(map(itemgetter("x0"), rects))
    max_x1 = max(map(itemgetter("x1"), rects))

    edges = []
    for r in rects:
        edges += [
            # Top of text
            {
                "x0": min_x0,
                "x1": max_x1,
                "top": r["top"],
                "bottom": r["top"],
                "width": max_x1 - min_x0,
                "orientation": "h",
            },
            # For each detected row, we also add the 'bottom' line.  This will
            # generate extra edges, (some will be redundant with the next row
            # 'top' line), but this catches the last row of every table.
            {
                "x0": min_x0,
                "x1": max_x1,
                "top": r["bottom"],
                "bottom": r["bottom"],
                "width": max_x1 - min_x0,
                "orientation": "h",
            },
        ]

    return edges


def get_bbox_overlap(a, b):
    a_left, a_top, a_right, a_bottom = a
    b_left, b_top, b_right, b_bottom = b
    o_left = max(a_left, b_left)
    o_right = min(a_right, b_right)
    o_bottom = min(a_bottom, b_bottom)
    o_top = max(a_top, b_top)
    o_width = o_right - o_left
    o_height = o_bottom - o_top
    if o_height >= 0 and o_width >= 0 and o_height + o_width > 0:
        return (o_left, o_top, o_right, o_bottom)
    else:
        return None


def words_to_edges_v(words, word_threshold: int = DEFAULT_MIN_WORDS_VERTICAL):
    """
    Find (imaginary) vertical lines that connect the left, right, or
    center of at least `word_threshold` words.
    """
    # Find words that share the same left, right, or centerpoints
    by_x0 = cluster_objects(words, itemgetter("x0"), 1)
    by_x1 = cluster_objects(words, itemgetter("x1"), 1)

    def get_center(word):
        return float(word["x0"] + word["x1"]) / 2

    by_center = cluster_objects(words, get_center, 1)
    clusters = by_x0 + by_x1 + by_center

    # Find the points that align with the most words
    sorted_clusters = sorted(clusters, key=lambda x: -len(x))
    large_clusters = filter(lambda x: len(x) >= word_threshold, sorted_clusters)

    # For each of those points, find the bboxes fitting all matching words
    bboxes = list(map(objects_to_bbox, large_clusters))

    # Iterate through those bboxes, condensing overlapping bboxes
    condensed_bboxes = []
    for bbox in bboxes:
        overlap = any(get_bbox_overlap(bbox, c) for c in condensed_bboxes)
        if not overlap:
            condensed_bboxes.append(bbox)

    if len(condensed_bboxes) == 0:
        return []

    condensed_rects = map(bbox_to_rect, condensed_bboxes)
    sorted_rects = list(sorted(condensed_rects, key=itemgetter("x0")))

    max_x1 = max(map(itemgetter("x1"), sorted_rects))
    min_top = min(map(itemgetter("top"), sorted_rects))
    max_bottom = max(map(itemgetter("bottom"), sorted_rects))

    return [
        {
            "x0": b["x0"],
            "x1": b["x0"],
            "top": min_top,
            "bottom": max_bottom,
            "height": max_bottom - min_top,
            "orientation": "v",
        }
        for b in sorted_rects
    ] + [
        {
            "x0": max_x1,
            "x1": max_x1,
            "top": min_top,
            "bottom": max_bottom,
            "height": max_bottom - min_top,
            "orientation": "v",
        }
    ]


def edges_to_intersections(edges, x_tolerance=1, y_tolerance=1) -> dict:
    """
    Given a list of edges, return the points at which they intersect
    within `tolerance` pixels.
    """
    intersections = {}
    v_edges, h_edges = [
        list(filter(lambda x: x["orientation"] == o, edges)) for o in ("v", "h")
    ]
    for v in sorted(v_edges, key=itemgetter("x0", "top")):
        for h in sorted(h_edges, key=itemgetter("top", "x0")):
            if (
                (v["top"] <= (h["top"] + y_tolerance))
                and (v["bottom"] >= (h["top"] - y_tolerance))
                and (v["x0"] >= (h["x0"] - x_tolerance))
                and (v["x0"] <= (h["x1"] + x_tolerance))
            ):
                vertex = (v["x0"], h["top"])
                if vertex not in intersections:
                    intersections[vertex] = {"v": [], "h": []}
                intersections[vertex]["v"].append(v)
                intersections[vertex]["h"].append(h)
    return intersections


def obj_to_bbox(obj):
    """
    Return the bounding box for an object.
    """
    return bbox_getter(obj)


def intersections_to_cells(intersections):
    """
    Given a list of points (`intersections`), return all rectangular "cells"
    that those points describe.

    `intersections` should be a dictionary with (x0, top) tuples as keys,
    and a list of edge objects as values. The edge objects should correspond
    to the edges that touch the intersection.
    """

    def edge_connects(p1, p2) -> bool:
        def edges_to_set(edges):
            return set(map(obj_to_bbox, edges))

        if p1[0] == p2[0]:
            common = edges_to_set(intersections[p1]["v"]).intersection(
                edges_to_set(intersections[p2]["v"])
            )
            if len(common):
                return True

        if p1[1] == p2[1]:
            common = edges_to_set(intersections[p1]["h"]).intersection(
                edges_to_set(intersections[p2]["h"])
            )
            if len(common):
                return True
        return False

    points = list(sorted(intersections.keys()))
    n_points = len(points)

    def find_smallest_cell(points, i: int):
        if i == n_points - 1:
            return None
        pt = points[i]
        rest = points[i + 1 :]
        # Get all the points directly below and directly right
        below = [x for x in rest if x[0] == pt[0]]
        right = [x for x in rest if x[1] == pt[1]]
        for below_pt in below:
            if not edge_connects(pt, below_pt):
                continue

            for right_pt in right:
                if not edge_connects(pt, right_pt):
                    continue

                bottom_right = (right_pt[0], below_pt[1])

                if (
                    (bottom_right in intersections)
                    and edge_connects(bottom_right, right_pt)
                    and edge_connects(bottom_right, below_pt)
                ):
                    return (pt[0], pt[1], bottom_right[0], bottom_right[1])
        return None

    cell_gen = (find_smallest_cell(points, i) for i in range(len(points)))
    return list(filter(None, cell_gen))


def cells_to_tables(page, cells) -> list:
    """
    Given a list of bounding boxes (`cells`), return a list of tables that
    hold those cells most simply (and contiguously).
    """

    def bbox_to_corners(bbox) -> tuple:
        x0, top, x1, bottom = bbox
        return ((x0, top), (x0, bottom), (x1, top), (x1, bottom))

    remaining_cells = list(cells)

    # Iterate through the cells found above, and assign them
    # to contiguous tables

    current_corners = set()
    current_cells = []

    tables = []
    while len(remaining_cells):
        initial_cell_count = len(current_cells)
        for cell in list(remaining_cells):
            cell_corners = bbox_to_corners(cell)
            # If we're just starting a table ...
            if len(current_cells) == 0:
                # ... immediately assign it to the empty group
                current_corners |= set(cell_corners)
                current_cells.append(cell)
                remaining_cells.remove(cell)
            else:
                # How many corners does this table share with the current group?
                corner_count = sum(c in current_corners for c in cell_corners)

                # If touching on at least one corner...
                if corner_count > 0:
                    # ... assign it to the current group
                    current_corners |= set(cell_corners)
                    current_cells.append(cell)
                    remaining_cells.remove(cell)

        # If this iteration did not find any more cells to append...
        if len(current_cells) == initial_cell_count:
            # ... start a new cell group
            tables.append(list(current_cells))
            current_corners.clear()
            current_cells.clear()

    # Once we have exhausting the list of cells ...

    # ... and we have a cell group that has not been stored
    if len(current_cells):
        # ... store it.
        tables.append(list(current_cells))

    # PyMuPDF modification:
    # Remove tables without text or having only 1 column
    for i in range(len(tables) - 1, -1, -1):
        r = EMPTY_RECT()
        x1_vals = set()
        x0_vals = set()
        for c in tables[i]:
            r |= c
            x1_vals.add(c[2])
            x0_vals.add(c[0])
        if (
            len(x1_vals) < 2
            or len(x0_vals) < 2
            or white_spaces.issuperset(
                page.get_textbox(
                    r,
                    textpage=TEXTPAGE,
                )
            )
        ):
            del tables[i]

    # Sort the tables top-to-bottom-left-to-right based on the value of the
    # topmost-and-then-leftmost coordinate of a table.
    _sorted = sorted(tables, key=lambda t: min((c[1], c[0]) for c in t))
    return _sorted


class CellGroup:
    def __init__(self, cells):
        self.cells = cells
        self.bbox = (
            min(map(itemgetter(0), filter(None, cells))),
            min(map(itemgetter(1), filter(None, cells))),
            max(map(itemgetter(2), filter(None, cells))),
            max(map(itemgetter(3), filter(None, cells))),
        )


class TableRow(CellGroup):
    pass


class TableHeader:
    """PyMuPDF extension containing the identified table header."""

    def __init__(self, bbox, cells, names, above):
        self.bbox = bbox
        self.cells = cells
        self.names = names
        self.external = above


class Table:
    def __init__(self, page, cells):
        self.page = page
        self.cells = cells
        self.header = self._get_header()  # PyMuPDF extension

    @property
    def bbox(self):
        c = self.cells
        return (
            min(map(itemgetter(0), c)),
            min(map(itemgetter(1), c)),
            max(map(itemgetter(2), c)),
            max(map(itemgetter(3), c)),
        )

    @property
    def rows(self) -> list:
        _sorted = sorted(self.cells, key=itemgetter(1, 0))
        xs = list(sorted(set(map(itemgetter(0), self.cells))))
        rows = []
        for y, row_cells in itertools.groupby(_sorted, itemgetter(1)):
            xdict = {cell[0]: cell for cell in row_cells}
            row = TableRow([xdict.get(x) for x in xs])
            rows.append(row)
        return rows

    @property
    def row_count(self) -> int:  # PyMuPDF extension
        return len(self.rows)

    @property
    def col_count(self) -> int:  # PyMuPDF extension
        return max([len(r.cells) for r in self.rows])

    def extract(self, **kwargs) -> list:
        chars = CHARS
        table_arr = []

        def char_in_bbox(char, bbox) -> bool:
            v_mid = (char["top"] + char["bottom"]) / 2
            h_mid = (char["x0"] + char["x1"]) / 2
            x0, top, x1, bottom = bbox
            return bool(
                (h_mid >= x0) and (h_mid < x1) and (v_mid >= top) and (v_mid < bottom)
            )

        for row in self.rows:
            arr = []
            row_chars = [char for char in chars if char_in_bbox(char, row.bbox)]

            for cell in row.cells:
                if cell is None:
                    cell_text = None
                else:
                    cell_chars = [
                        char for char in row_chars if char_in_bbox(char, cell)
                    ]

                    if len(cell_chars):
                        kwargs["x_shift"] = cell[0]
                        kwargs["y_shift"] = cell[1]
                        if "layout" in kwargs:
                            kwargs["layout_width"] = cell[2] - cell[0]
                            kwargs["layout_height"] = cell[3] - cell[1]
                        cell_text = extract_text(cell_chars, **kwargs)
                    else:
                        cell_text = ""
                arr.append(cell_text)
            table_arr.append(arr)

        return table_arr

    def to_markdown(self, clean=True):
        """Output table content as a string in Github-markdown format.

        If clean is true, markdown syntax is removed from cell content."""
        output = "|"

        # generate header string and MD underline
        for i, name in enumerate(self.header.names):
            if name is None or name == "":  # generate a name if empty
                name = f"Col{i+1}"
            name = name.replace("\n", " ")  # remove any line breaks
            if clean:  # remove sensitive syntax
                name = html.escape(name.replace("-", "&#45;"))
            output += name + "|"

        output += "\n"
        output += "|" + "|".join("---" for i in range(self.col_count)) + "|\n"

        # skip first row in details if header is part of the table
        j = 0 if self.header.external else 1

        # iterate over detail rows
        for row in self.extract()[j:]:
            line = "|"
            for i, cell in enumerate(row):
                # output None cells with empty string
                cell = "" if cell is None else cell.replace("\n", " ")
                if clean:  # remove sensitive syntax
                    cell = html.escape(cell.replace("-", "&#45;"))
                line += cell + "|"
            line += "\n"
            output += line
        return output + "\n"

    def to_pandas(self, **kwargs):
        """Return a pandas DataFrame version of the table."""
        try:
            import pandas as pd
        except ModuleNotFoundError:
            message("Package 'pandas' is not installed")
            raise

        pd_dict = {}
        extract = self.extract()
        hdr = self.header
        names = self.header.names
        hdr_len = len(names)
        # ensure uniqueness of column names
        for i in range(hdr_len):
            name = names[i]
            if not name:
                names[i] = f"Col{i}"
        if hdr_len != len(set(names)):
            for i in range(hdr_len):
                name = names[i]
                if name != f"Col{i}":
                    names[i] = f"{i}-{name}"

        if not hdr.external:  # header is part of 'extract'
            extract = extract[1:]

        for i in range(hdr_len):
            key = names[i]
            value = []
            for j in range(len(extract)):
                value.append(extract[j][i])
            pd_dict[key] = value

        return pd.DataFrame(pd_dict)

    def _get_header(self, y_tolerance=3):
        """Identify the table header.

        *** PyMuPDF extension. ***

        Starting from the first line above the table upwards, check if it
        qualifies to be part of the table header.

        Criteria include:
        * A one-line table never has an extra header.
        * Column borders must not intersect any word. If this happens, all
          text of this line and above of it is ignored.
        * No excess inter-line distance: If a line further up has a distance
          of more than 1.5 times of its font size, it will be ignored and
          all lines above of it.
        * Must have same text properties.
        * Starting with the top table line, a bold text property cannot change
          back to non-bold.

        If not all criteria are met (or there is no text above the table),
        the first table row is assumed to be the header.
        """
        page = self.page
        y_delta = y_tolerance

        def top_row_is_bold(bbox):
            """Check if row 0 has bold text anywhere.

            If this is true, then any non-bold text in lines above disqualify
            these lines as header.

            bbox is the (potentially repaired) row 0 bbox.

            Returns True or False
            """
            for b in page.get_text("dict", flags=TEXTFLAGS_TEXT, clip=bbox)["blocks"]:
                for l in b["lines"]:
                    for s in l["spans"]:
                        if s["flags"] & 16:
                            return True
            return False

        try:
            row = self.rows[0]
            cells = row.cells
            bbox = Rect(row.bbox)
        except IndexError:  # this table has no rows
            return None

        # return this if we determine that the top row is the header
        header_top_row = TableHeader(bbox, cells, self.extract()[0], False)

        # one-line tables have no extra header
        if len(self.rows) < 2:
            return header_top_row

        # x-ccordinates of columns between x0 and x1 of the table
        if len(cells) < 2:
            return header_top_row

        col_x = [
            c[2] if c is not None else None for c in cells[:-1]
        ]  # column (x) coordinates

        # Special check: is top row bold?
        # If first line above table is not bold, but top-left table cell is bold,
        # we take first table row as header
        top_row_bold = top_row_is_bold(bbox)

        # clip = area above table
        # We will inspect this area for text qualifying as column header.
        clip = +bbox  # take row 0 bbox
        clip.y0 = 0  # start at top of page
        clip.y1 = bbox.y0  # end at top of table

        spans = []  # the text spans inside clip
        for b in page.get_text("dict", clip=clip, flags=TEXTFLAGS_TEXT)["blocks"]:
            for l in b["lines"]:
                for s in l["spans"]:
                    if (
                        not s["flags"] & 1 and s["text"].strip()
                    ):  # ignore superscripts and empty text
                        spans.append(s)

        select = []  # y1 coordinates above, sorted descending
        line_heights = []  # line heights above, sorted descending
        line_bolds = []  # bold indicator per line above, same sorting

        # spans sorted descending
        spans.sort(key=lambda s: s["bbox"][3], reverse=True)
        # walk through the spans and fill above 3 lists
        for i in range(len(spans)):
            s = spans[i]
            y1 = s["bbox"][3]  # span bottom
            h = y1 - s["bbox"][1]  # span bbox height
            bold = s["flags"] & 16

            # use first item to start the lists
            if i == 0:
                select.append(y1)
                line_heights.append(h)
                line_bolds.append(bold)
                continue

            # get last items from the 3 lists
            y0 = select[-1]
            h0 = line_heights[-1]
            bold0 = line_bolds[-1]

            if bold0 and not bold:
                break  # stop if switching from bold to non-bold

            # if fitting in height of previous span, modify bbox
            if y0 - y1 <= y_delta or abs((y0 - h0) - s["bbox"][1]) <= y_delta:
                s["bbox"] = (s["bbox"][0], y0 - h0, s["bbox"][2], y0)
                spans[i] = s
                if bold:
                    line_bolds[-1] = bold
                continue
            elif y0 - y1 > 1.5 * h0:
                break  # stop if distance to previous line too large
            select.append(y1)
            line_heights.append(h)
            line_bolds.append(bold)

        if select == []:  # nothing above the table?
            return header_top_row

        select = select[:5]  # only accept up to 5 lines in any header

        # take top row as header if text above table is too far apart
        if bbox.y0 - select[0] >= line_heights[0]:
            return header_top_row

        # if top table row is bold, but line above is not:
        if top_row_bold and not line_bolds[0]:
            return header_top_row

        if spans == []:  # nothing left above the table, return top row
            return header_top_row

        # re-compute clip above table
        nclip = EMPTY_RECT()
        for s in [s for s in spans if s["bbox"][3] >= select[-1]]:
            nclip |= s["bbox"]
        if not nclip.is_empty:
            clip = nclip

        clip.y1 = bbox.y0  # make sure we still include every word above

        # Confirm that no word in clip is intersecting a column separator
        word_rects = [Rect(w[:4]) for w in page.get_text("words", clip=clip)]
        word_tops = sorted(list(set([r[1] for r in word_rects])), reverse=True)

        select = []

        # exclude lines with words that intersect a column border
        for top in word_tops:
            intersecting = [
                (x, r)
                for x in col_x
                if x is not None
                for r in word_rects
                if r[1] == top and r[0] < x and r[2] > x
            ]
            if intersecting == []:
                select.append(top)
            else:  # detected a word crossing a column border
                break

        if select == []:  # nothing left over: return first row
            return header_top_row

        hdr_bbox = +clip  # compute the header cells
        hdr_bbox.y0 = select[-1]  # hdr_bbox top is smallest top coord of words
        hdr_cells = [
            (c[0], hdr_bbox.y0, c[2], hdr_bbox.y1) if c is not None else None
            for c in cells
        ]

        # adjust left/right of header bbox
        hdr_bbox.x0 = self.bbox[0]
        hdr_bbox.x1 = self.bbox[2]

        # column names: no line breaks, no excess spaces
        hdr_names = [
            (
                page.get_textbox(c).replace("\n", " ").replace("  ", " ").strip()
                if c is not None
                else ""
            )
            for c in hdr_cells
        ]
        return TableHeader(tuple(hdr_bbox), hdr_cells, hdr_names, True)


@dataclass
class TableSettings:
    vertical_strategy: str = "lines"
    horizontal_strategy: str = "lines"
    explicit_vertical_lines: list = None
    explicit_horizontal_lines: list = None
    snap_tolerance: float = DEFAULT_SNAP_TOLERANCE
    snap_x_tolerance: float = UNSET
    snap_y_tolerance: float = UNSET
    join_tolerance: float = DEFAULT_JOIN_TOLERANCE
    join_x_tolerance: float = UNSET
    join_y_tolerance: float = UNSET
    edge_min_length: float = 3
    min_words_vertical: float = DEFAULT_MIN_WORDS_VERTICAL
    min_words_horizontal: float = DEFAULT_MIN_WORDS_HORIZONTAL
    intersection_tolerance: float = 3
    intersection_x_tolerance: float = UNSET
    intersection_y_tolerance: float = UNSET
    text_settings: dict = None

    def __post_init__(self) -> "TableSettings":
        """Clean up user-provided table settings.

        Validates that the table settings provided consists of acceptable values and
        returns a cleaned up version. The cleaned up version fills out the missing
        values with the default values in the provided settings.

        TODO: Can be further used to validate that the values are of the correct
            type. For example, raising a value error when a non-boolean input is
            provided for the key ``keep_blank_chars``.

        :param table_settings: User-provided table settings.
        :returns: A cleaned up version of the user-provided table settings.
        :raises ValueError: When an unrecognised key is provided.
        """

        for setting in NON_NEGATIVE_SETTINGS:
            if (getattr(self, setting) or 0) < 0:
                raise ValueError(f"Table setting '{setting}' cannot be negative")

        for orientation in ["horizontal", "vertical"]:
            strategy = getattr(self, orientation + "_strategy")
            if strategy not in TABLE_STRATEGIES:
                raise ValueError(
                    f"{orientation}_strategy must be one of"
                    f'{{{",".join(TABLE_STRATEGIES)}}}'
                )

        if self.text_settings is None:
            self.text_settings = {}

        # This next section is for backwards compatibility
        for attr in ["x_tolerance", "y_tolerance"]:
            if attr not in self.text_settings:
                self.text_settings[attr] = self.text_settings.get("tolerance", 3)

        if "tolerance" in self.text_settings:
            del self.text_settings["tolerance"]
        # End of that section

        for attr, fallback in [
            ("snap_x_tolerance", "snap_tolerance"),
            ("snap_y_tolerance", "snap_tolerance"),
            ("join_x_tolerance", "join_tolerance"),
            ("join_y_tolerance", "join_tolerance"),
            ("intersection_x_tolerance", "intersection_tolerance"),
            ("intersection_y_tolerance", "intersection_tolerance"),
        ]:
            if getattr(self, attr) is UNSET:
                setattr(self, attr, getattr(self, fallback))

        return self

    @classmethod
    def resolve(cls, settings=None):
        if settings is None:
            return cls()
        elif isinstance(settings, cls):
            return settings
        elif isinstance(settings, dict):
            core_settings = {}
            text_settings = {}
            for k, v in settings.items():
                if k[:5] == "text_":
                    text_settings[k[5:]] = v
                else:
                    core_settings[k] = v
            core_settings["text_settings"] = text_settings
            return cls(**core_settings)
        else:
            raise ValueError(f"Cannot resolve settings: {settings}")


class TableFinder:
    """
    Given a PDF page, find plausible table structures.

    Largely borrowed from Anssi Nurminen's master's thesis:
    http://dspace.cc.tut.fi/dpub/bitstream/handle/123456789/21520/Nurminen.pdf?sequence=3

    ... and inspired by Tabula:
    https://github.com/tabulapdf/tabula-extractor/issues/16
    """

    def __init__(self, page, settings=None):
        self.page = page
        self.settings = TableSettings.resolve(settings)
        self.edges = self.get_edges()
        self.intersections = edges_to_intersections(
            self.edges,
            self.settings.intersection_x_tolerance,
            self.settings.intersection_y_tolerance,
        )
        self.cells = intersections_to_cells(self.intersections)
        self.tables = [
            Table(self.page, cell_group)
            for cell_group in cells_to_tables(self.page, self.cells)
        ]

    def get_edges(self) -> list:
        settings = self.settings

        for orientation in ["vertical", "horizontal"]:
            strategy = getattr(settings, orientation + "_strategy")
            if strategy == "explicit":
                lines = getattr(settings, "explicit_" + orientation + "_lines")
                if len(lines) < 2:
                    raise ValueError(
                        f"If {orientation}_strategy == 'explicit', "
                        f"explicit_{orientation}_lines "
                        f"must be specified as a list/tuple of two or more "
                        f"floats/ints."
                    )

        v_strat = settings.vertical_strategy
        h_strat = settings.horizontal_strategy

        if v_strat == "text" or h_strat == "text":
            words = extract_words(CHARS, **(settings.text_settings or {}))
        else:
            words = []

        v_explicit = []
        for desc in settings.explicit_vertical_lines or []:
            if isinstance(desc, dict):
                for e in obj_to_edges(desc):
                    if e["orientation"] == "v":
                        v_explicit.append(e)
            else:
                v_explicit.append(
                    {
                        "x0": desc,
                        "x1": desc,
                        "top": self.page.rect[1],
                        "bottom": self.page.rect[3],
                        "height": self.page.rect[3] - self.page.rect[1],
                        "orientation": "v",
                    }
                )

        if v_strat == "lines":
            v_base = filter_edges(EDGES, "v")
        elif v_strat == "lines_strict":
            v_base = filter_edges(EDGES, "v", edge_type="line")
        elif v_strat == "text":
            v_base = words_to_edges_v(words, word_threshold=settings.min_words_vertical)
        elif v_strat == "explicit":
            v_base = []
        else:
            v_base = []

        v = v_base + v_explicit

        h_explicit = []
        for desc in settings.explicit_horizontal_lines or []:
            if isinstance(desc, dict):
                for e in obj_to_edges(desc):
                    if e["orientation"] == "h":
                        h_explicit.append(e)
            else:
                h_explicit.append(
                    {
                        "x0": self.page.rect[0],
                        "x1": self.page.rect[2],
                        "width": self.page.rect[2] - self.page.rect[0],
                        "top": desc,
                        "bottom": desc,
                        "orientation": "h",
                    }
                )

        if h_strat == "lines":
            h_base = filter_edges(EDGES, "h")
        elif h_strat == "lines_strict":
            h_base = filter_edges(EDGES, "h", edge_type="line")
        elif h_strat == "text":
            h_base = words_to_edges_h(
                words, word_threshold=settings.min_words_horizontal
            )
        elif h_strat == "explicit":
            h_base = []
        else:
            h_base = []

        h = h_base + h_explicit

        edges = list(v) + list(h)

        edges = merge_edges(
            edges,
            snap_x_tolerance=settings.snap_x_tolerance,
            snap_y_tolerance=settings.snap_y_tolerance,
            join_x_tolerance=settings.join_x_tolerance,
            join_y_tolerance=settings.join_y_tolerance,
        )

        return filter_edges(edges, min_length=settings.edge_min_length)

    def __getitem__(self, i):
        tcount = len(self.tables)
        if i >= tcount:
            raise IndexError("table not on page")
        while i < 0:
            i += tcount
        return self.tables[i]


"""
Start of PyMuPDF interface code.
The following functions are executed when "page.find_tables()" is called.

* make_chars: Fills the CHARS list with text character information extracted
              via "rawdict" text extraction. Items in CHARS are formatted
              as expected by the table code.
* make_edges: Fills the EDGES list with vector graphic information extracted
              via "get_drawings". Items in EDGES are formatted as expected
              by the table code.

The lists CHARS and EDGES are used to replace respective document access
of pdfplumber or, respectively pdfminer.
The table code has been modified to use these lists instead of accessing
page information themselves.
"""


# -----------------------------------------------------------------------------
# Extract all page characters to fill the CHARS list
# -----------------------------------------------------------------------------
def make_chars(page, clip=None):
    """Extract text as "rawdict" to fill CHARS."""
    global TEXTPAGE
    page_number = page.number + 1
    page_height = page.rect.height
    ctm = page.transformation_matrix
    TEXTPAGE = page.get_textpage(clip=clip, flags=TEXTFLAGS_TEXT)
    blocks = page.get_text("rawdict", textpage=TEXTPAGE)["blocks"]
    doctop_base = page_height * page.number
    for block in blocks:
        for line in block["lines"]:
            ldir = line["dir"]  # = (cosine, sine) of angle
            ldir = (round(ldir[0], 4), round(ldir[1], 4))
            matrix = Matrix(ldir[0], -ldir[1], ldir[1], ldir[0], 0, 0)
            if ldir[1] == 0:
                upright = True
            else:
                upright = False
            for span in sorted(line["spans"], key=lambda s: s["bbox"][0]):
                fontname = span["font"]
                fontsize = span["size"]
                color = sRGB_to_pdf(span["color"])
                for char in sorted(span["chars"], key=lambda c: c["bbox"][0]):
                    bbox = Rect(char["bbox"])
                    bbox_ctm = bbox * ctm
                    origin = Point(char["origin"]) * ctm
                    matrix.e = origin.x
                    matrix.f = origin.y
                    text = char["c"]
                    char_dict = {
                        "adv": bbox.x1 - bbox.x0 if upright else bbox.y1 - bbox.y0,
                        "bottom": bbox.y1,
                        "doctop": bbox.y0 + doctop_base,
                        "fontname": fontname,
                        "height": bbox.y1 - bbox.y0,
                        "matrix": tuple(matrix),
                        "ncs": "DeviceRGB",
                        "non_stroking_color": color,
                        "non_stroking_pattern": None,
                        "object_type": "char",
                        "page_number": page_number,
                        "size": fontsize if upright else bbox.y1 - bbox.y0,
                        "stroking_color": color,
                        "stroking_pattern": None,
                        "text": text,
                        "top": bbox.y0,
                        "upright": upright,
                        "width": bbox.x1 - bbox.x0,
                        "x0": bbox.x0,
                        "x1": bbox.x1,
                        "y0": bbox_ctm.y0,
                        "y1": bbox_ctm.y1,
                    }
                    CHARS.append(char_dict)


# ------------------------------------------------------------------------
# Extract all page vector graphics to fill the EDGES list.
# We are ignoring Bézier curves completely and are converting everything
# else to lines.
# ------------------------------------------------------------------------
def make_edges(page, clip=None, tset=None, add_lines=None):
    snap_x = tset.snap_x_tolerance
    snap_y = tset.snap_y_tolerance
    min_length = tset.edge_min_length
    lines_strict = (
        tset.vertical_strategy == "lines_strict"
        or tset.horizontal_strategy == "lines_strict"
    )
    page_height = page.rect.height
    doctop_basis = page.number * page_height
    page_number = page.number + 1
    prect = page.rect
    if page.rotation in (90, 270):
        w, h = prect.br
        prect = Rect(0, 0, h, w)
    if clip is not None:
        clip = Rect(clip)
    else:
        clip = prect

    def are_neighbors(r1, r2):
        """Detect whether r1, r2 are neighbors.

        Defined as:
        The minimum distance between points of r1 and points of r2 is not
        larger than some delta.

        This check supports empty rect-likes and thus also lines.

        Note:
        This type of check is MUCH faster than native Rect containment checks.
        """
        if (  # check if x-coordinates of r1 are within those of r2
            r2.x0 - snap_x <= r1.x0 <= r2.x1 + snap_x
            or r2.x0 - snap_x <= r1.x1 <= r2.x1 + snap_x
        ) and (  # ... same for y-coordinates
            r2.y0 - snap_y <= r1.y0 <= r2.y1 + snap_y
            or r2.y0 - snap_y <= r1.y1 <= r2.y1 + snap_y
        ):
            return True

        # same check with r1 / r2 exchanging their roles (this is necessary!)
        if (
            r1.x0 - snap_x <= r2.x0 <= r1.x1 + snap_x
            or r1.x0 - snap_x <= r2.x1 <= r1.x1 + snap_x
        ) and (
            r1.y0 - snap_y <= r2.y0 <= r1.y1 + snap_y
            or r1.y0 - snap_y <= r2.y1 <= r1.y1 + snap_y
        ):
            return True
        return False

    def clean_graphics():
        """Detect and join rectangles of "connected" vector graphics."""

        paths = []  # paths relevant for table detection
        for p in page.get_drawings():
            # ignore fill-only graphics if they do not simulate lines,
            # which means one of width or height are small.
            if (
                p["type"] == "f"
                and lines_strict
                and p["rect"].width > snap_x
                and p["rect"].height > snap_y
            ):
                continue
            paths.append(p)

        # start with all vector graphics rectangles
        prects = sorted(set([p["rect"] for p in paths]), key=lambda r: (r.y1, r.x0))
        new_rects = []  # the final list of joined rectangles
        # ----------------------------------------------------------------
        # Strategy: Join rectangles that "almost touch" each other.
        # Extend first rectangle with any other that is a "neighbor".
        # Then move it to the final list and continue with the rest.
        # ----------------------------------------------------------------
        while prects:  # the algorithm will empty this list
            prect0 = prects[0]  # copy of first rectangle (performance reasons!)
            repeat = True
            while repeat:  # this loop extends first rect in list
                repeat = False  # set to true again if some other rect touches
                for i in range(len(prects) - 1, 0, -1):  # run backwards
                    if are_neighbors(prect0, prects[i]):  # close enough to rect 0?
                        prect0 |= prects[i].tl  # extend rect 0
                        prect0 |= prects[i].br  # extend rect 0
                        del prects[i]  # delete this rect
                        repeat = True  # keep checking the rest

            # move rect 0 over to result list if there is some text in it
            if not white_spaces.issuperset(page.get_textbox(prect0, textpage=TEXTPAGE)):
                # contains text, so accept it as a table bbox candidate
                new_rects.append(prect0)
            del prects[0]  # remove from rect list

        return new_rects, paths

    bboxes, paths = clean_graphics()

    def is_parallel(p1, p2):
        """Check if line is roughly axis-parallel."""
        if abs(p1.x - p2.x) <= snap_x or abs(p1.y - p2.y) <= snap_y:
            return True
        return False

    def make_line(p, p1, p2, clip):
        """Given 2 points, make a line dictionary for table detection."""
        if not is_parallel(p1, p2):  # only accepting axis-parallel lines
            return {}
        # compute the extremal values
        x0 = min(p1.x, p2.x)
        x1 = max(p1.x, p2.x)
        y0 = min(p1.y, p2.y)
        y1 = max(p1.y, p2.y)

        # check for outside clip
        if x0 > clip.x1 or x1 < clip.x0 or y0 > clip.y1 or y1 < clip.y0:
            return {}

        if x0 < clip.x0:
            x0 = clip.x0  # adjust to clip boundary

        if x1 > clip.x1:
            x1 = clip.x1  # adjust to clip boundary

        if y0 < clip.y0:
            y0 = clip.y0  # adjust to clip boundary

        if y1 > clip.y1:
            y1 = clip.y1  # adjust to clip boundary

        width = x1 - x0  # from adjusted values
        height = y1 - y0  # from adjusted values
        if width == height == 0:
            return {}  # nothing left to deal with
        line_dict = {
            "x0": x0,
            "y0": page_height - y0,
            "x1": x1,
            "y1": page_height - y1,
            "width": width,
            "height": height,
            "pts": [(x0, y0), (x1, y1)],
            "linewidth": p["width"],
            "stroke": True,
            "fill": False,
            "evenodd": False,
            "stroking_color": p["color"] if p["color"] else p["fill"],
            "non_stroking_color": None,
            "object_type": "line",
            "page_number": page_number,
            "stroking_pattern": None,
            "non_stroking_pattern": None,
            "top": y0,
            "bottom": y1,
            "doctop": y0 + doctop_basis,
        }
        return line_dict

    for p in paths:
        items = p["items"]  # items in this path

        # if 'closePath', add a line from last to first point
        if p["closePath"] and items[0][0] == "l" and items[-1][0] == "l":
            items.append(("l", items[-1][2], items[0][1]))

        for i in items:
            if i[0] not in ("l", "re", "qu"):
                continue  # ignore anything else

            if i[0] == "l":  # a line
                p1, p2 = i[1:]
                line_dict = make_line(p, p1, p2, clip)
                if line_dict:
                    EDGES.append(line_to_edge(line_dict))

            elif i[0] == "re":
                # A rectangle: decompose into 4 lines, but filter out
                # the ones that simulate a line
                rect = i[1].normalize()  # normalize the rectangle

                if (
                    rect.width <= min_length and rect.width < rect.height
                ):  # simulates a vertical line
                    x = abs(rect.x1 + rect.x0) / 2  # take middle value for x
                    p1 = Point(x, rect.y0)
                    p2 = Point(x, rect.y1)
                    line_dict = make_line(p, p1, p2, clip)
                    if line_dict:
                        EDGES.append(line_to_edge(line_dict))
                    continue

                if (
                    rect.height <= min_length and rect.height < rect.width
                ):  # simulates a horizontal line
                    y = abs(rect.y1 + rect.y0) / 2  # take middle value for y
                    p1 = Point(rect.x0, y)
                    p2 = Point(rect.x1, y)
                    line_dict = make_line(p, p1, p2, clip)
                    if line_dict:
                        EDGES.append(line_to_edge(line_dict))
                    continue

                line_dict = make_line(p, rect.tl, rect.bl, clip)
                if line_dict:
                    EDGES.append(line_to_edge(line_dict))

                line_dict = make_line(p, rect.bl, rect.br, clip)
                if line_dict:
                    EDGES.append(line_to_edge(line_dict))

                line_dict = make_line(p, rect.br, rect.tr, clip)
                if line_dict:
                    EDGES.append(line_to_edge(line_dict))

                line_dict = make_line(p, rect.tr, rect.tl, clip)
                if line_dict:
                    EDGES.append(line_to_edge(line_dict))

            else:  # must be a quad
                # we convert it into (up to) 4 lines
                ul, ur, ll, lr = i[1]

                line_dict = make_line(p, ul, ll, clip)
                if line_dict:
                    EDGES.append(line_to_edge(line_dict))

                line_dict = make_line(p, ll, lr, clip)
                if line_dict:
                    EDGES.append(line_to_edge(line_dict))

                line_dict = make_line(p, lr, ur, clip)
                if line_dict:
                    EDGES.append(line_to_edge(line_dict))

                line_dict = make_line(p, ur, ul, clip)
                if line_dict:
                    EDGES.append(line_to_edge(line_dict))

    path = {"color": (0, 0, 0), "fill": None, "width": 1}
    for bbox in bboxes:  # add the border lines for all enveloping bboxes
        line_dict = make_line(path, bbox.tl, bbox.tr, clip)
        if line_dict:
            EDGES.append(line_to_edge(line_dict))

        line_dict = make_line(path, bbox.bl, bbox.br, clip)
        if line_dict:
            EDGES.append(line_to_edge(line_dict))

        line_dict = make_line(path, bbox.tl, bbox.bl, clip)
        if line_dict:
            EDGES.append(line_to_edge(line_dict))

        line_dict = make_line(path, bbox.tr, bbox.br, clip)
        if line_dict:
            EDGES.append(line_to_edge(line_dict))

    if add_lines is not None:  # add user-specified lines
        assert isinstance(add_lines, (tuple, list))
    else:
        add_lines = []
    for p1, p2 in add_lines:
        p1 = Point(p1)
        p2 = Point(p2)
        line_dict = make_line(path, p1, p2, clip)
        if line_dict:
            EDGES.append(line_to_edge(line_dict))


def page_rotation_set0(page):
    """Nullify page rotation.

    To correctly detect tables, page rotation must be zero.
    This function performs the necessary adjustments and returns information
    for reverting this changes.
    """
    mediabox = page.mediabox
    rot = page.rotation  # contains normalized rotation value
    # need to derotate the page's content
    mb = page.mediabox  # current mediabox

    if rot == 90:
        # before derotation, shift content horizontally
        mat0 = Matrix(1, 0, 0, 1, mb.y1 - mb.x1 - mb.x0 - mb.y0, 0)
    elif rot == 270:
        # before derotation, shift content vertically
        mat0 = Matrix(1, 0, 0, 1, 0, mb.x1 - mb.y1 - mb.y0 - mb.x0)
    else:
        mat0 = Matrix(1, 0, 0, 1, -2 * mb.x0, -2 * mb.y0)

    # prefix with derotation matrix
    mat = mat0 * page.derotation_matrix
    cmd = b"%g %g %g %g %g %g cm " % tuple(mat)
    xref = TOOLS._insert_contents(page, cmd, 0)

    # swap x- and y-coordinates
    if rot in (90, 270):
        x0, y0, x1, y1 = mb
        mb.x0 = y0
        mb.y0 = x0
        mb.x1 = y1
        mb.y1 = x1
        page.set_mediabox(mb)

    page.set_rotation(0)

    # refresh the page to apply these changes
    doc = page.parent
    pno = page.number
    page = doc[pno]
    return page, xref, rot, mediabox


def page_rotation_reset(page, xref, rot, mediabox):
    """Reset page rotation to original values.

    To be used before we return tables."""
    doc = page.parent  # document of the page
    doc.update_stream(xref, b" ")  # remove de-rotation matrix
    page.set_mediabox(mediabox)  # set mediabox to old value
    page.set_rotation(rot)  # set rotation to old value
    pno = page.number
    page = doc[pno]  # update page info
    return page


def find_tables(
    page,
    clip=None,
    vertical_strategy: str = "lines",
    horizontal_strategy: str = "lines",
    vertical_lines: list = None,
    horizontal_lines: list = None,
    snap_tolerance: float = DEFAULT_SNAP_TOLERANCE,
    snap_x_tolerance: float = None,
    snap_y_tolerance: float = None,
    join_tolerance: float = DEFAULT_JOIN_TOLERANCE,
    join_x_tolerance: float = None,
    join_y_tolerance: float = None,
    edge_min_length: float = 3,
    min_words_vertical: float = DEFAULT_MIN_WORDS_VERTICAL,
    min_words_horizontal: float = DEFAULT_MIN_WORDS_HORIZONTAL,
    intersection_tolerance: float = 3,
    intersection_x_tolerance: float = None,
    intersection_y_tolerance: float = None,
    text_tolerance=3,
    text_x_tolerance=3,
    text_y_tolerance=3,
    strategy=None,  # offer abbreviation
    add_lines=None,  # optional user-specified lines
):
    global CHARS, EDGES
    CHARS = []
    EDGES = []
    old_small = bool(TOOLS.set_small_glyph_heights())  # save old value
    TOOLS.set_small_glyph_heights(True)  # we need minimum bboxes
    if page.rotation != 0:
        page, old_xref, old_rot, old_mediabox = page_rotation_set0(page)
    else:
        old_xref, old_rot, old_mediabox = None, None, None

    if snap_x_tolerance is None:
        snap_x_tolerance = UNSET
    if snap_y_tolerance is None:
        snap_y_tolerance = UNSET
    if join_x_tolerance is None:
        join_x_tolerance = UNSET
    if join_y_tolerance is None:
        join_y_tolerance = UNSET
    if intersection_x_tolerance is None:
        intersection_x_tolerance = UNSET
    if intersection_y_tolerance is None:
        intersection_y_tolerance = UNSET
    if strategy is not None:
        vertical_strategy = strategy
        horizontal_strategy = strategy

    settings = {
        "vertical_strategy": vertical_strategy,
        "horizontal_strategy": horizontal_strategy,
        "explicit_vertical_lines": vertical_lines,
        "explicit_horizontal_lines": horizontal_lines,
        "snap_tolerance": snap_tolerance,
        "snap_x_tolerance": snap_x_tolerance,
        "snap_y_tolerance": snap_y_tolerance,
        "join_tolerance": join_tolerance,
        "join_x_tolerance": join_x_tolerance,
        "join_y_tolerance": join_y_tolerance,
        "edge_min_length": edge_min_length,
        "min_words_vertical": min_words_vertical,
        "min_words_horizontal": min_words_horizontal,
        "intersection_tolerance": intersection_tolerance,
        "intersection_x_tolerance": intersection_x_tolerance,
        "intersection_y_tolerance": intersection_y_tolerance,
        "text_tolerance": text_tolerance,
        "text_x_tolerance": text_x_tolerance,
        "text_y_tolerance": text_y_tolerance,
    }
    tset = TableSettings.resolve(settings=settings)
    page.table_settings = tset

    make_chars(page, clip=clip)  # create character list of page
    make_edges(
        page, clip=clip, tset=tset, add_lines=add_lines
    )  # create lines and curves
    tables = TableFinder(page, settings=tset)

    TOOLS.set_small_glyph_heights(old_small)
    if old_xref is not None:
        page = page_rotation_reset(page, old_xref, old_rot, old_mediabox)
    return tables


# ================================================================================
# Datei: venv\Lib\site-packages\pymupdf\utils.py
# ================================================================================

# ------------------------------------------------------------------------
# Copyright 2020-2022, Harald Lieder, mailto:harald.lieder@outlook.com
# License: GNU AFFERO GPL 3.0, https://www.gnu.org/licenses/agpl-3.0.html
#
# Part of "PyMuPDF", a Python binding for "MuPDF" (http://mupdf.com), a
# lightweight PDF, XPS, and E-book viewer, renderer and toolkit which is
# maintained and developed by Artifex Software, Inc. https://artifex.com.
# ------------------------------------------------------------------------
import io
import math
import os
import typing
import weakref

try:
    from . import pymupdf
except Exception:
    import pymupdf
try:
    from . import mupdf
except Exception:
    import mupdf

_format_g = pymupdf.format_g

g_exceptions_verbose = pymupdf.g_exceptions_verbose

point_like = "point_like"
rect_like = "rect_like"
matrix_like = "matrix_like"
quad_like = "quad_like"

# ByteString is gone from typing in 3.14.
# collections.abc.Buffer available from 3.12 only
try:
    ByteString = typing.ByteString
except AttributeError:
    # pylint: disable=unsupported-binary-operation
    ByteString = bytes | bytearray | memoryview

AnyType = typing.Any
OptInt = typing.Union[int, None]
OptFloat = typing.Optional[float]
OptStr = typing.Optional[str]
OptDict = typing.Optional[dict]
OptBytes = typing.Optional[ByteString]
OptSeq = typing.Optional[typing.Sequence]

"""
This is a collection of functions to extend PyMupdf.
"""


def write_text(
        page: pymupdf.Page,
        rect=None,
        writers=None,
        overlay=True,
        color=None,
        opacity=None,
        keep_proportion=True,
        rotate=0,
        oc=0,
        ) -> None:
    """Write the text of one or more pymupdf.TextWriter objects.

    Args:
        rect: target rectangle. If None, the union of the text writers is used.
        writers: one or more pymupdf.TextWriter objects.
        overlay: put in foreground or background.
        keep_proportion: maintain aspect ratio of rectangle sides.
        rotate: arbitrary rotation angle.
        oc: the xref of an optional content object
    """
    assert isinstance(page, pymupdf.Page)
    if not writers:
        raise ValueError("need at least one pymupdf.TextWriter")
    if type(writers) is pymupdf.TextWriter:
        if rotate == 0 and rect is None:
            writers.write_text(page, opacity=opacity, color=color, overlay=overlay)
            return None
        else:
            writers = (writers,)
    clip = writers[0].text_rect
    textdoc = pymupdf.Document()
    tpage = textdoc.new_page(width=page.rect.width, height=page.rect.height)
    for writer in writers:
        clip |= writer.text_rect
        writer.write_text(tpage, opacity=opacity, color=color)
    if rect is None:
        rect = clip
    page.show_pdf_page(
        rect,
        textdoc,
        0,
        overlay=overlay,
        keep_proportion=keep_proportion,
        rotate=rotate,
        clip=clip,
        oc=oc,
    )
    textdoc = None
    tpage = None


def show_pdf_page(
        page,
        rect,
        src,
        pno=0,
        keep_proportion=True,
        overlay=True,
        oc=0,
        rotate=0,
        clip=None,
        ) -> int:
    """Show page number 'pno' of PDF 'src' in rectangle 'rect'.

    Args:
        rect: (rect-like) where to place the source image
        src: (document) source PDF
        pno: (int) source page number
        keep_proportion: (bool) do not change width-height-ratio
        overlay: (bool) put in foreground
        oc: (xref) make visibility dependent on this OCG / OCMD (which must be defined in the target PDF)
        rotate: (int) degrees (multiple of 90)
        clip: (rect-like) part of source page rectangle
    Returns:
        xref of inserted object (for reuse)
    """
    def calc_matrix(sr, tr, keep=True, rotate=0):
        """Calculate transformation matrix from source to target rect.

        Notes:
            The product of four matrices in this sequence: (1) translate correct
            source corner to origin, (2) rotate, (3) scale, (4) translate to
            target's top-left corner.
        Args:
            sr: source rect in PDF (!) coordinate system
            tr: target rect in PDF coordinate system
            keep: whether to keep source ratio of width to height
            rotate: rotation angle in degrees
        Returns:
            Transformation matrix.
        """
        # calc center point of source rect
        smp = (sr.tl + sr.br) / 2.0
        # calc center point of target rect
        tmp = (tr.tl + tr.br) / 2.0

        # m moves to (0, 0), then rotates
        m = pymupdf.Matrix(1, 0, 0, 1, -smp.x, -smp.y) * pymupdf.Matrix(rotate)

        sr1 = sr * m  # resulting source rect to calculate scale factors

        fw = tr.width / sr1.width  # scale the width
        fh = tr.height / sr1.height  # scale the height
        if keep:
            fw = fh = min(fw, fh)  # take min if keeping aspect ratio

        m *= pymupdf.Matrix(fw, fh)  # concat scale matrix
        m *= pymupdf.Matrix(1, 0, 0, 1, tmp.x, tmp.y)  # concat move to target center
        return pymupdf.JM_TUPLE(m)

    pymupdf.CheckParent(page)
    doc = page.parent

    if not doc.is_pdf or not src.is_pdf:
        raise ValueError("is no PDF")

    if rect.is_empty or rect.is_infinite:
        raise ValueError("rect must be finite and not empty")

    while pno < 0:  # support negative page numbers
        pno += src.page_count
    src_page = src[pno]  # load source page
    if src_page.get_contents() == []:
        raise ValueError("nothing to show - source page empty")

    tar_rect = rect * ~page.transformation_matrix  # target rect in PDF coordinates

    src_rect = src_page.rect if not clip else src_page.rect & clip  # source rect
    if src_rect.is_empty or src_rect.is_infinite:
        raise ValueError("clip must be finite and not empty")
    src_rect = src_rect * ~src_page.transformation_matrix  # ... in PDF coord

    matrix = calc_matrix(src_rect, tar_rect, keep=keep_proportion, rotate=rotate)

    # list of existing /Form /XObjects
    ilst = [i[1] for i in doc.get_page_xobjects(page.number)]
    ilst += [i[7] for i in doc.get_page_images(page.number)]
    ilst += [i[4] for i in doc.get_page_fonts(page.number)]

    # create a name not in that list
    n = "fzFrm"
    i = 0
    _imgname = n + "0"
    while _imgname in ilst:
        i += 1
        _imgname = n + str(i)

    isrc = src._graft_id  # used as key for graftmaps
    if doc._graft_id == isrc:
        raise ValueError("source document must not equal target")

    # retrieve / make pymupdf.Graftmap for source PDF
    gmap = doc.Graftmaps.get(isrc, None)
    if gmap is None:
        gmap = pymupdf.Graftmap(doc)
        doc.Graftmaps[isrc] = gmap

    # take note of generated xref for automatic reuse
    pno_id = (isrc, pno)  # id of src[pno]
    xref = doc.ShownPages.get(pno_id, 0)

    if overlay:
        page.wrap_contents()  # ensure a balanced graphics state
    xref = page._show_pdf_page(
        src_page,
        overlay=overlay,
        matrix=matrix,
        xref=xref,
        oc=oc,
        clip=src_rect,
        graftmap=gmap,
        _imgname=_imgname,
    )
    doc.ShownPages[pno_id] = xref

    return xref


def replace_image(page: pymupdf.Page, xref: int, *, filename=None, pixmap=None, stream=None):
    """Replace the image referred to by xref.

    Replace the image by changing the object definition stored under xref. This
    will leave the pages appearance instructions intact, so the new image is
    being displayed with the same bbox, rotation etc.
    By providing a small fully transparent image, an effect as if the image had
    been deleted can be achieved.
    A typical use may include replacing large images by a smaller version,
    e.g. with a lower resolution or graylevel instead of colored.

    Args:
        xref: the xref of the image to replace.
        filename, pixmap, stream: exactly one of these must be provided. The
            meaning being the same as in Page.insert_image.
    """
    doc = page.parent  # the owning document
    if not doc.xref_is_image(xref):
        raise ValueError("xref not an image")  # insert new image anywhere in page
    if bool(filename) + bool(stream) + bool(pixmap) != 1:
        raise ValueError("Exactly one of filename/stream/pixmap must be given")
    new_xref = page.insert_image(
        page.rect, filename=filename, stream=stream, pixmap=pixmap
    )
    doc.xref_copy(new_xref, xref)  # copy over new to old
    last_contents_xref = page.get_contents()[-1]
    # new image insertion has created a new /Contents source,
    # which we will set to spaces now
    doc.update_stream(last_contents_xref, b" ")
    page._image_info = None  # clear cache of extracted image information


def delete_image(page: pymupdf.Page, xref: int):
    """Delete the image referred to by xef.

    Actually replaces by a small transparent Pixmap using method Page.replace_image.

    Args:
        xref: xref of the image to delete.
    """
    # make a small 100% transparent pixmap (of just any dimension)
    pix = pymupdf.Pixmap(pymupdf.csGRAY, (0, 0, 1, 1), 1)
    pix.clear_with()  # clear all samples bytes to 0x00
    page.replace_image(xref, pixmap=pix)


def insert_image(
        page,
        rect,
        *,
        alpha=-1,
        filename=None,
        height=0,
        keep_proportion=True,
        mask=None,
        oc=0,
        overlay=True,
        pixmap=None,
        rotate=0,
        stream=None,
        width=0,
        xref=0,
        ):
    """Insert an image for display in a rectangle.

    Args:
        rect: (rect_like) position of image on the page.
        alpha: (int, optional) set to 0 if image has no transparency.
        filename: (str, Path, file object) image filename.
        height: (int)
        keep_proportion: (bool) keep width / height ratio (default).
        mask: (bytes, optional) image consisting of alpha values to use.
        oc: (int) xref of OCG or OCMD to declare as Optional Content.
        overlay: (bool) put in foreground (default) or background.
        pixmap: (pymupdf.Pixmap) use this as image.
        rotate: (int) rotate by 0, 90, 180 or 270 degrees.
        stream: (bytes) use this as image.
        width: (int)
        xref: (int) use this as image.

    'page' and 'rect' are positional, all other parameters are keywords.

    If 'xref' is given, that image is used. Other input options are ignored.
    Else, exactly one of pixmap, stream or filename must be given.

    'alpha=0' for non-transparent images improves performance significantly.
    Affects stream and filename only.

    Optimum transparent insertions are possible by using filename / stream in
    conjunction with a 'mask' image of alpha values.

    Returns:
        xref (int) of inserted image. Re-use as argument for multiple insertions.
    """
    pymupdf.CheckParent(page)
    doc = page.parent
    if not doc.is_pdf:
        raise ValueError("is no PDF")

    if xref == 0 and (bool(filename) + bool(stream) + bool(pixmap) != 1):
        raise ValueError("xref=0 needs exactly one of filename, pixmap, stream")

    if filename:
        if type(filename) is str:
            pass
        elif hasattr(filename, "absolute"):
            filename = str(filename)
        elif hasattr(filename, "name"):
            filename = filename.name
        else:
            raise ValueError("bad filename")

    if filename and not os.path.exists(filename):
        raise FileNotFoundError("No such file: '%s'" % filename)
    elif stream and type(stream) not in (bytes, bytearray, io.BytesIO):
        raise ValueError("stream must be bytes-like / BytesIO")
    elif pixmap and type(pixmap) is not pymupdf.Pixmap:
        raise ValueError("pixmap must be a pymupdf.Pixmap")
    if mask and not (stream or filename):
        raise ValueError("mask requires stream or filename")
    if mask and type(mask) not in (bytes, bytearray, io.BytesIO):
        raise ValueError("mask must be bytes-like / BytesIO")
    while rotate < 0:
        rotate += 360
    while rotate >= 360:
        rotate -= 360
    if rotate not in (0, 90, 180, 270):
        raise ValueError("bad rotate value")

    r = pymupdf.Rect(rect)
    if r.is_empty or r.is_infinite:
        raise ValueError("rect must be finite and not empty")
    clip = r * ~page.transformation_matrix

    # Create a unique image reference name.
    ilst = [i[7] for i in doc.get_page_images(page.number)]
    ilst += [i[1] for i in doc.get_page_xobjects(page.number)]
    ilst += [i[4] for i in doc.get_page_fonts(page.number)]
    n = "fzImg"  # 'pymupdf image'
    i = 0
    _imgname = n + "0"  # first name candidate
    while _imgname in ilst:
        i += 1
        _imgname = n + str(i)  # try new name

    if overlay:
        page.wrap_contents()  # ensure a balanced graphics state
    digests = doc.InsertedImages
    xref, digests = page._insert_image(
        filename=filename,
        pixmap=pixmap,
        stream=stream,
        imask=mask,
        clip=clip,
        overlay=overlay,
        oc=oc,
        xref=xref,
        rotate=rotate,
        keep_proportion=keep_proportion,
        width=width,
        height=height,
        alpha=alpha,
        _imgname=_imgname,
        digests=digests,
    )
    if digests is not None:
        doc.InsertedImages = digests

    return xref


def search_for(
        page,
        text,
        *,
        clip=None,
        quads=False,
        flags=pymupdf.TEXT_DEHYPHENATE
            | pymupdf.TEXT_PRESERVE_WHITESPACE
            | pymupdf.TEXT_PRESERVE_LIGATURES
            | pymupdf.TEXT_MEDIABOX_CLIP
            ,
        textpage=None,
        ) -> list:
    """Search for a string on a page.

    Args:
        text: string to be searched for
        clip: restrict search to this rectangle
        quads: (bool) return quads instead of rectangles
        flags: bit switches, default: join hyphened words
        textpage: a pre-created pymupdf.TextPage
    Returns:
        a list of rectangles or quads, each containing one occurrence.
    """
    if clip is not None:
        clip = pymupdf.Rect(clip)

    pymupdf.CheckParent(page)
    tp = textpage
    if tp is None:
        tp = page.get_textpage(clip=clip, flags=flags)  # create pymupdf.TextPage
    elif getattr(tp, "parent") != page:
        raise ValueError("not a textpage of this page")
    rlist = tp.search(text, quads=quads)
    if textpage is None:
        del tp
    return rlist


def search_page_for(
    doc: pymupdf.Document,
    pno: int,
    text: str,
    quads: bool = False,
    clip: rect_like = None,
    flags: int = pymupdf.TEXT_DEHYPHENATE
            | pymupdf.TEXT_PRESERVE_LIGATURES
            | pymupdf.TEXT_PRESERVE_WHITESPACE
            | pymupdf.TEXT_MEDIABOX_CLIP
            ,
    textpage: pymupdf.TextPage = None,
) -> list:
    """Search for a string on a page.

    Args:
        pno: page number
        text: string to be searched for
        clip: restrict search to this rectangle
        quads: (bool) return quads instead of rectangles
        flags: bit switches, default: join hyphened words
        textpage: reuse a prepared textpage
    Returns:
        a list of rectangles or quads, each containing an occurrence.
    """

    return doc[pno].search_for(
        text,
        quads=quads,
        clip=clip,
        flags=flags,
        textpage=textpage,
    )


def get_text_blocks(
    page: pymupdf.Page,
    clip: rect_like = None,
    flags: OptInt = None,
    textpage: pymupdf.TextPage = None,
    sort: bool = False,
) -> list:
    """Return the text blocks on a page.

    Notes:
        Lines in a block are concatenated with line breaks.
    Args:
        flags: (int) control the amount of data parsed into the textpage.
    Returns:
        A list of the blocks. Each item contains the containing rectangle
        coordinates, text lines, running block number and block type.
    """
    pymupdf.CheckParent(page)
    if flags is None:
        flags = pymupdf.TEXTFLAGS_BLOCKS
    tp = textpage
    if tp is None:
        tp = page.get_textpage(clip=clip, flags=flags)
    elif getattr(tp, "parent") != page:
        raise ValueError("not a textpage of this page")

    blocks = tp.extractBLOCKS()
    if textpage is None:
        del tp
    if sort:
        blocks.sort(key=lambda b: (b[3], b[0]))
    return blocks


def get_text_words(
    page: pymupdf.Page,
    clip: rect_like = None,
    flags: OptInt = None,
    textpage: pymupdf.TextPage = None,
    sort: bool = False,
    delimiters=None,
    tolerance=3,
) -> list:
    """Return the text words as a list with the bbox for each word.

    Args:
        page: pymupdf.Page
        clip: (rect-like) area on page to consider
        flags: (int) control the amount of data parsed into the textpage.
        textpage: (pymupdf.TextPage) either passed-in or None.
        sort: (bool) sort the words in reading sequence.
        delimiters: (str,list) characters to use as word delimiters.
        tolerance: (float) consider words to be part of the same line if
            top or bottom coordinate are not larger than this. Relevant
            only if sort=True.

    Returns:
        Word tuples (x0, y0, x1, y1, "word", bno, lno, wno).
    """

    def sort_words(words):
        """Sort words line-wise, forgiving small deviations."""
        words.sort(key=lambda w: (w[3], w[0]))
        nwords = []  # final word list
        line = [words[0]]  # collects words roughly in same line
        lrect = pymupdf.Rect(words[0][:4])  # start the line rectangle
        for w in words[1:]:
            wrect = pymupdf.Rect(w[:4])
            if (
                abs(wrect.y0 - lrect.y0) <= tolerance
                or abs(wrect.y1 - lrect.y1) <= tolerance
            ):
                line.append(w)
                lrect |= wrect
            else:
                line.sort(key=lambda w: w[0])  # sort words in line l-t-r
                nwords.extend(line)  # append to final words list
                line = [w]  # start next line
                lrect = wrect  # start next line rect

        line.sort(key=lambda w: w[0])  # sort words in line l-t-r
        nwords.extend(line)  # append to final words list

        return nwords

    pymupdf.CheckParent(page)
    if flags is None:
        flags = pymupdf.TEXTFLAGS_WORDS
    tp = textpage
    if tp is None:
        tp = page.get_textpage(clip=clip, flags=flags)
    elif getattr(tp, "parent") != page:
        raise ValueError("not a textpage of this page")

    words = tp.extractWORDS(delimiters)

    # if textpage was given, we subselect the words in clip
    if textpage is not None and clip is not None:
        # sub-select words contained in clip
        clip = pymupdf.Rect(clip)
        words = [
            w for w in words if abs(clip & w[:4]) >= 0.5 * abs(pymupdf.Rect(w[:4]))
        ]

    if textpage is None:
        del tp
    if words and sort:
        # advanced sort if any words found
        words = sort_words(words)

    return words


def get_sorted_text(
    page: pymupdf.Page,
    clip: rect_like = None,
    flags: OptInt = None,
    textpage: pymupdf.TextPage = None,
    tolerance=3,
) -> str:
    """Extract plain text avoiding unacceptable line breaks.

    Text contained in clip will be sorted in reading sequence. Some effort
    is also spent to simulate layout vertically and horizontally.

    Args:
        page: pymupdf.Page
        clip: (rect-like) only consider text inside
        flags: (int) text extraction flags
        textpage: pymupdf.TextPage
        tolerance: (float) consider words to be on the same line if their top
            or bottom coordinates do not differ more than this.

    Notes:
        If a TextPage is provided, all text is checked for being inside clip
        with at least 50% of its bbox.
        This allows to use some "global" TextPage in conjunction with sub-
        selecting words in parts of the defined TextPage rectangle.

    Returns:
        A text string in reading sequence. Left indentation of each line,
        inter-line and inter-word distances strive to reflect the layout.
    """

    def line_text(clip, line):
        """Create the string of one text line.

        We are trying to simulate some horizontal layout here, too.

        Args:
            clip: (pymupdf.Rect) the area from which all text is being read.
            line: (list) word tuples (rect, text) contained in the line
        Returns:
            Text in this line. Generated from words in 'line'. Distance from
            predecessor is translated to multiple spaces, thus simulating
            text indentations and large horizontal distances.
        """
        line.sort(key=lambda w: w[0].x0)
        ltext = ""  # text in the line
        x1 = clip.x0  # end coordinate of ltext
        lrect = pymupdf.EMPTY_RECT()  # bbox of this line
        for r, t in line:
            lrect |= r  # update line bbox
            # convert distance to previous word to multiple spaces
            dist = max(
                int(round((r.x0 - x1) / r.width * len(t))),
                0 if (x1 == clip.x0 or r.x0 <= x1) else 1,
            )  # number of space characters

            ltext += " " * dist + t  # append word string
            x1 = r.x1  # update new end position
        return ltext

    # Extract words in correct sequence first.
    words = [
        (pymupdf.Rect(w[:4]), w[4])
        for w in get_text_words(
            page,
            clip=clip,
            flags=flags,
            textpage=textpage,
            sort=True,
            tolerance=tolerance,
        )
    ]

    if not words:  # no text present
        return ""
    totalbox = pymupdf.EMPTY_RECT()  # area covering all text
    for wr, text in words:
        totalbox |= wr

    lines = []  # list of reconstituted lines
    line = [words[0]]  # current line
    lrect = words[0][0]  # the line's rectangle

    # walk through the words
    for wr, text in words[1:]:  # start with second word
        w0r, _ = line[-1]  # read previous word in current line

        # if this word matches top or bottom of the line, append it
        if abs(lrect.y0 - wr.y0) <= tolerance or abs(lrect.y1 - wr.y1) <= tolerance:
            line.append((wr, text))
            lrect |= wr
        else:
            # output current line and re-initialize
            ltext = line_text(totalbox, line)
            lines.append((lrect, ltext))
            line = [(wr, text)]
            lrect = wr

    # also append unfinished last line
    ltext = line_text(totalbox, line)
    lines.append((lrect, ltext))

    # sort all lines vertically
    lines.sort(key=lambda l: (l[0].y1))

    text = lines[0][1]  # text of first line
    y1 = lines[0][0].y1  # its bottom coordinate
    for lrect, ltext in lines[1:]:
        distance = min(int(round((lrect.y0 - y1) / lrect.height)), 5)
        breaks = "\n" * (distance + 1)
        text += breaks + ltext
        y1 = lrect.y1

    # return text in clip
    return text


def get_textbox(
    page: pymupdf.Page,
    rect: rect_like,
    textpage: pymupdf.TextPage = None,
) -> str:
    tp = textpage
    if tp is None:
        tp = page.get_textpage()
    elif getattr(tp, "parent") != page:
        raise ValueError("not a textpage of this page")
    rc = tp.extractTextbox(rect)
    if textpage is None:
        del tp
    return rc


def get_text_selection(
    page: pymupdf.Page,
    p1: point_like,
    p2: point_like,
    clip: rect_like = None,
    textpage: pymupdf.TextPage = None,
):
    pymupdf.CheckParent(page)
    tp = textpage
    if tp is None:
        tp = page.get_textpage(clip=clip, flags=pymupdf.TEXT_DEHYPHENATE)
    elif getattr(tp, "parent") != page:
        raise ValueError("not a textpage of this page")
    rc = tp.extractSelection(p1, p2)
    if textpage is None:
        del tp
    return rc


def get_textpage_ocr(
    page: pymupdf.Page,
    flags: int = 0,
    language: str = "eng",
    dpi: int = 72,
    full: bool = False,
    tessdata: str = None,
) -> pymupdf.TextPage:
    """Create a Textpage from combined results of normal and OCR text parsing.

    Args:
        flags: (int) control content becoming part of the result.
        language: (str) specify expected language(s). Default is "eng" (English).
        dpi: (int) resolution in dpi, default 72.
        full: (bool) whether to OCR the full page image, or only its images (default)
    """
    pymupdf.CheckParent(page)
    tessdata = pymupdf.get_tessdata(tessdata)

    def full_ocr(page, dpi, language, flags):
        zoom = dpi / 72
        mat = pymupdf.Matrix(zoom, zoom)
        pix = page.get_pixmap(matrix=mat)
        ocr_pdf = pymupdf.Document(
                "pdf",
                pix.pdfocr_tobytes(
                    compress=False,
                    language=language,
                    tessdata=tessdata,
                    ),
                )
        ocr_page = ocr_pdf.load_page(0)
        unzoom = page.rect.width / ocr_page.rect.width
        ctm = pymupdf.Matrix(unzoom, unzoom) * page.derotation_matrix
        tpage = ocr_page.get_textpage(flags=flags, matrix=ctm)
        ocr_pdf.close()
        pix = None
        tpage.parent = weakref.proxy(page)
        return tpage

    # if OCR for the full page, OCR its pixmap @ desired dpi
    if full:
        return full_ocr(page, dpi, language, flags)

    # For partial OCR, make a normal textpage, then extend it with text that
    # is OCRed from each image.
    # Because of this, we need the images flag bit set ON.
    tpage = page.get_textpage(flags=flags)
    for block in page.get_text("dict", flags=pymupdf.TEXT_PRESERVE_IMAGES)["blocks"]:
        if block["type"] != 1:  # only look at images
            continue
        bbox = pymupdf.Rect(block["bbox"])
        if bbox.width <= 3 or bbox.height <= 3:  # ignore tiny stuff
            continue
        try:
            pix = pymupdf.Pixmap(block["image"])  # get image pixmap
            if pix.n - pix.alpha != 3:  # we need to convert this to RGB!
                pix = pymupdf.Pixmap(pymupdf.csRGB, pix)
            if pix.alpha:  # must remove alpha channel
                pix = pymupdf.Pixmap(pix, 0)
            imgdoc = pymupdf.Document(
                    "pdf",
                    pix.pdfocr_tobytes(language=language, tessdata=tessdata),
                    )  # pdf with OCRed page
            imgpage = imgdoc.load_page(0)  # read image as a page
            pix = None
            # compute matrix to transform coordinates back to that of 'page'
            imgrect = imgpage.rect  # page size of image PDF
            shrink = pymupdf.Matrix(1 / imgrect.width, 1 / imgrect.height)
            mat = shrink * block["transform"]
            imgpage.extend_textpage(tpage, flags=0, matrix=mat)
            imgdoc.close()
        except (RuntimeError, mupdf.FzErrorBase):
            if 0 and g_exceptions_verbose:
                # Don't show exception info here because it can happen in
                # normal operation (see test_3842b).
                pymupdf.exception_info()
            tpage = None
            pymupdf.message("Falling back to full page OCR")
            return full_ocr(page, dpi, language, flags)

    return tpage


def get_image_info(page: pymupdf.Page, hashes: bool = False, xrefs: bool = False) -> list:
    """Extract image information only from a pymupdf.TextPage.

    Args:
        hashes: (bool) include MD5 hash for each image.
        xrefs: (bool) try to find the xref for each image. Sets hashes to true.
    """
    doc = page.parent
    if xrefs and doc.is_pdf:
        hashes = True
    if not doc.is_pdf:
        xrefs = False
    imginfo = getattr(page, "_image_info", None)
    if imginfo and not xrefs:
        return imginfo
    if not imginfo:
        tp = page.get_textpage(flags=pymupdf.TEXT_PRESERVE_IMAGES)
        imginfo = tp.extractIMGINFO(hashes=hashes)
        del tp
        if hashes:
            page._image_info = imginfo
    if not xrefs or not doc.is_pdf:
        return imginfo
    imglist = page.get_images()
    digests = {}
    for item in imglist:
        xref = item[0]
        pix = pymupdf.Pixmap(doc, xref)
        digests[pix.digest] = xref
        del pix
    for i in range(len(imginfo)):
        item = imginfo[i]
        xref = digests.get(item["digest"], 0)
        item["xref"] = xref
        imginfo[i] = item
    return imginfo


def get_image_rects(page: pymupdf.Page, name, transform=False) -> list:
    """Return list of image positions on a page.

    Args:
        name: (str, list, int) image identification. May be reference name, an
              item of the page's image list or an xref.
        transform: (bool) whether to also return the transformation matrix.
    Returns:
        A list of pymupdf.Rect objects or tuples of (pymupdf.Rect, pymupdf.Matrix)
        for all image locations on the page.
    """
    if type(name) in (list, tuple):
        xref = name[0]
    elif type(name) is int:
        xref = name
    else:
        imglist = [i for i in page.get_images() if i[7] == name]
        if imglist == []:
            raise ValueError("bad image name")
        elif len(imglist) != 1:
            raise ValueError("multiple image names found")
        xref = imglist[0][0]
    pix = pymupdf.Pixmap(page.parent, xref)  # make pixmap of the image to compute MD5
    digest = pix.digest
    del pix
    infos = page.get_image_info(hashes=True)
    if not transform:
        bboxes = [pymupdf.Rect(im["bbox"]) for im in infos if im["digest"] == digest]
    else:
        bboxes = [
            (pymupdf.Rect(im["bbox"]), pymupdf.Matrix(im["transform"]))
            for im in infos
            if im["digest"] == digest
        ]
    return bboxes


def get_text(
    page: pymupdf.Page,
    option: str = "text",
    clip: rect_like = None,
    flags: OptInt = None,
    textpage: pymupdf.TextPage = None,
    sort: bool = False,
    delimiters=None,
    tolerance=3,
):
    """Extract text from a page or an annotation.

    This is a unifying wrapper for various methods of the pymupdf.TextPage class.

    Args:
        option: (str) text, words, blocks, html, dict, json, rawdict, xhtml or xml.
        clip: (rect-like) restrict output to this area.
        flags: bit switches to e.g. exclude images or decompose ligatures.
        textpage: reuse this pymupdf.TextPage and make no new one. If specified,
            'flags' and 'clip' are ignored.

    Returns:
        the output of methods get_text_words / get_text_blocks or pymupdf.TextPage
        methods extractText, extractHTML, extractDICT, extractJSON, extractRAWDICT,
        extractXHTML or etractXML respectively.
        Default and misspelling choice is "text".
    """
    formats = {
        "text": pymupdf.TEXTFLAGS_TEXT,
        "html": pymupdf.TEXTFLAGS_HTML,
        "json": pymupdf.TEXTFLAGS_DICT,
        "rawjson": pymupdf.TEXTFLAGS_RAWDICT,
        "xml": pymupdf.TEXTFLAGS_XML,
        "xhtml": pymupdf.TEXTFLAGS_XHTML,
        "dict": pymupdf.TEXTFLAGS_DICT,
        "rawdict": pymupdf.TEXTFLAGS_RAWDICT,
        "words": pymupdf.TEXTFLAGS_WORDS,
        "blocks": pymupdf.TEXTFLAGS_BLOCKS,
    }
    option = option.lower()
    assert option in formats
    if option not in formats:
        option = "text"
    if flags is None:
        flags = formats[option]

    if option == "words":
        return get_text_words(
            page,
            clip=clip,
            flags=flags,
            textpage=textpage,
            sort=sort,
            delimiters=delimiters,
        )
    if option == "blocks":
        return get_text_blocks(
            page, clip=clip, flags=flags, textpage=textpage, sort=sort
        )

    if option == "text" and sort:
        return get_sorted_text(
            page,
            clip=clip,
            flags=flags,
            textpage=textpage,
            tolerance=tolerance,
        )

    pymupdf.CheckParent(page)
    cb = None
    if option in ("html", "xml", "xhtml"):  # no clipping for MuPDF functions
        clip = page.cropbox
    if clip is not None:
        clip = pymupdf.Rect(clip)
        cb = None
    elif type(page) is pymupdf.Page:
        cb = page.cropbox
    # pymupdf.TextPage with or without images
    tp = textpage
    #pymupdf.exception_info()
    if tp is None:
        tp = page.get_textpage(clip=clip, flags=flags)
    elif getattr(tp, "parent") != page:
        raise ValueError("not a textpage of this page")
    #pymupdf.log( '{option=}')
    if option == "json":
        t = tp.extractJSON(cb=cb, sort=sort)
    elif option == "rawjson":
        t = tp.extractRAWJSON(cb=cb, sort=sort)
    elif option == "dict":
        t = tp.extractDICT(cb=cb, sort=sort)
    elif option == "rawdict":
        t = tp.extractRAWDICT(cb=cb, sort=sort)
    elif option == "html":
        t = tp.extractHTML()
    elif option == "xml":
        t = tp.extractXML()
    elif option == "xhtml":
        t = tp.extractXHTML()
    else:
        t = tp.extractText(sort=sort)

    if textpage is None:
        del tp
    return t


def get_page_text(
    doc: pymupdf.Document,
    pno: int,
    option: str = "text",
    clip: rect_like = None,
    flags: OptInt = None,
    textpage: pymupdf.TextPage = None,
    sort: bool = False,
) -> typing.Any:
    """Extract a document page's text by page number.

    Notes:
        Convenience function calling page.get_text().
    Args:
        pno: page number
        option: (str) text, words, blocks, html, dict, json, rawdict, xhtml or xml.
    Returns:
        output from page.TextPage().
    """
    return doc[pno].get_text(option, clip=clip, flags=flags, sort=sort)

def get_pixmap(
        page: pymupdf.Page,
        *,
        matrix: matrix_like=pymupdf.Identity,
        dpi=None,
        colorspace: pymupdf.Colorspace=pymupdf.csRGB,
        clip: rect_like=None,
        alpha: bool=False,
        annots: bool=True,
        ) -> pymupdf.Pixmap:
    """Create pixmap of page.

    Keyword args:
        matrix: Matrix for transformation (default: Identity).
        dpi: desired dots per inch. If given, matrix is ignored.
        colorspace: (str/Colorspace) cmyk, rgb, gray - case ignored, default csRGB.
        clip: (irect-like) restrict rendering to this area.
        alpha: (bool) whether to include alpha channel
        annots: (bool) whether to also render annotations
    """
    if dpi:
        zoom = dpi / 72
        matrix = pymupdf.Matrix(zoom, zoom)

    if type(colorspace) is str:
        if colorspace.upper() == "GRAY":
            colorspace = pymupdf.csGRAY
        elif colorspace.upper() == "CMYK":
            colorspace = pymupdf.csCMYK
        else:
            colorspace = pymupdf.csRGB
    if colorspace.n not in (1, 3, 4):
        raise ValueError("unsupported colorspace")

    dl = page.get_displaylist(annots=annots)
    pix = dl.get_pixmap(matrix=matrix, colorspace=colorspace, alpha=alpha, clip=clip)
    dl = None
    if dpi:
        pix.set_dpi(dpi, dpi)
    return pix


def get_page_pixmap(
    doc: pymupdf.Document,
    pno: int,
    *,
    matrix: matrix_like = pymupdf.Identity,
    dpi=None,
    colorspace: pymupdf.Colorspace = pymupdf.csRGB,
    clip: rect_like = None,
    alpha: bool = False,
    annots: bool = True,
) -> pymupdf.Pixmap:
    """Create pixmap of document page by page number.

    Notes:
        Convenience function calling page.get_pixmap.
    Args:
        pno: (int) page number
        matrix: pymupdf.Matrix for transformation (default: pymupdf.Identity).
        colorspace: (str,pymupdf.Colorspace) rgb, rgb, gray - case ignored, default csRGB.
        clip: (irect-like) restrict rendering to this area.
        alpha: (bool) include alpha channel
        annots: (bool) also render annotations
    """
    return doc[pno].get_pixmap(
            matrix=matrix,
            dpi=dpi, colorspace=colorspace,
            clip=clip,
            alpha=alpha,
            annots=annots
            )


def getLinkDict(ln, document=None) -> dict:
    if isinstance(ln, pymupdf.Outline):
        dest = ln.destination(document)
    elif isinstance(ln, pymupdf.Link):
        dest = ln.dest
    else:
        assert 0, f'Unexpected {type(ln)=}.'
    nl = {"kind": dest.kind, "xref": 0}
    try:
        if hasattr(ln, 'rect'):
            nl["from"] = ln.rect
    except Exception:
        # This seems to happen quite often in PyMuPDF/tests.
        if g_exceptions_verbose >= 2:   pymupdf.exception_info()
        pass
    pnt = pymupdf.Point(0, 0)
    if dest.flags & pymupdf.LINK_FLAG_L_VALID:
        pnt.x = dest.lt.x
    if dest.flags & pymupdf.LINK_FLAG_T_VALID:
        pnt.y = dest.lt.y

    if dest.kind == pymupdf.LINK_URI:
        nl["uri"] = dest.uri

    elif dest.kind == pymupdf.LINK_GOTO:
        nl["page"] = dest.page
        nl["to"] = pnt
        if dest.flags & pymupdf.LINK_FLAG_R_IS_ZOOM:
            nl["zoom"] = dest.rb.x
        else:
            nl["zoom"] = 0.0

    elif dest.kind == pymupdf.LINK_GOTOR:
        nl["file"] = dest.file_spec.replace("\\", "/")
        nl["page"] = dest.page
        if dest.page < 0:
            nl["to"] = dest.dest
        else:
            nl["to"] = pnt
            if dest.flags & pymupdf.LINK_FLAG_R_IS_ZOOM:
                nl["zoom"] = dest.rb.x
            else:
                nl["zoom"] = 0.0

    elif dest.kind == pymupdf.LINK_LAUNCH:
        nl["file"] = dest.file_spec.replace("\\", "/")

    elif dest.kind == pymupdf.LINK_NAMED:
        # The dicts should not have same key(s).
        assert not (dest.named.keys() & nl.keys())
        nl.update(dest.named)
        if 'to' in nl:
            nl['to'] = pymupdf.Point(nl['to'])

    else:
        nl["page"] = dest.page
    return nl


def get_links(page: pymupdf.Page) -> list:
    """Create a list of all links contained in a PDF page.

    Notes:
        see PyMuPDF ducmentation for details.
    """

    pymupdf.CheckParent(page)
    ln = page.first_link
    links = []
    while ln:
        nl = getLinkDict(ln, page.parent)
        links.append(nl)
        ln = ln.next
    if links != [] and page.parent.is_pdf:
        linkxrefs = [x for x in
                #page.annot_xrefs()
                pymupdf.JM_get_annot_xref_list2(page)
                if x[1] == pymupdf.PDF_ANNOT_LINK  # pylint: disable=no-member
                ]
        if len(linkxrefs) == len(links):
            for i in range(len(linkxrefs)):
                links[i]["xref"] = linkxrefs[i][0]
                links[i]["id"] = linkxrefs[i][2]
    return links


def get_toc(
    doc: pymupdf.Document,
    simple: bool = True,
) -> list:
    """Create a table of contents.

    Args:
        simple: a bool to control output. Returns a list, where each entry consists of outline level, title, page number and link destination (if simple = False). For details see PyMuPDF's documentation.
    """
    def recurse(olItem, liste, lvl):
        """Recursively follow the outline item chain and record item information in a list."""
        while olItem and olItem.this.m_internal:
            if olItem.title:
                title = olItem.title
            else:
                title = " "

            if not olItem.is_external:
                if olItem.uri:
                    if olItem.page == -1:
                        resolve = doc.resolve_link(olItem.uri)
                        page = resolve[0] + 1
                    else:
                        page = olItem.page + 1
                else:
                    page = -1
            else:
                page = -1

            if not simple:
                link = getLinkDict(olItem, doc)
                liste.append([lvl, title, page, link])
            else:
                liste.append([lvl, title, page])

            if olItem.down:
                liste = recurse(olItem.down, liste, lvl + 1)
            olItem = olItem.next
        return liste

    # ensure document is open
    if doc.is_closed:
        raise ValueError("document closed")
    doc.init_doc()
    olItem = doc.outline
    if not olItem:
        return []
    lvl = 1
    liste = []
    toc = recurse(olItem, liste, lvl)
    if doc.is_pdf and not simple:
        doc._extend_toc_items(toc)
    return toc


def del_toc_item(
    doc: pymupdf.Document,
    idx: int,
) -> None:
    """Delete TOC / bookmark item by index."""
    xref = doc.get_outline_xrefs()[idx]
    doc._remove_toc_item(xref)


def set_toc_item(
    doc: pymupdf.Document,
    idx: int,
    dest_dict: OptDict = None,
    kind: OptInt = None,
    pno: OptInt = None,
    uri: OptStr = None,
    title: OptStr = None,
    to: point_like = None,
    filename: OptStr = None,
    zoom: float = 0,
) -> None:
    """Update TOC item by index.

    It allows changing the item's title and link destination.

    Args:
        idx:
            (int) desired index of the TOC list, as created by get_toc.
        dest_dict:
            (dict) destination dictionary as created by get_toc(False).
            Outrules all other parameters. If None, the remaining parameters
            are used to make a dest dictionary.
        kind:
            (int) kind of link (pymupdf.LINK_GOTO, etc.). If None, then only
            the title will be updated. If pymupdf.LINK_NONE, the TOC item will
            be deleted.
        pno:
            (int) page number (1-based like in get_toc). Required if
            pymupdf.LINK_GOTO.
        uri:
            (str) the URL, required if pymupdf.LINK_URI.
        title:
            (str) the new title. No change if None.
        to:
            (point-like) destination on the target page. If omitted, (72, 36)
            will be used as target coordinates.
        filename:
            (str) destination filename, required for pymupdf.LINK_GOTOR and
            pymupdf.LINK_LAUNCH.
        name:
            (str) a destination name for pymupdf.LINK_NAMED.
        zoom:
            (float) a zoom factor for the target location (pymupdf.LINK_GOTO).
    """
    xref = doc.get_outline_xrefs()[idx]
    page_xref = 0
    if type(dest_dict) is dict:
        if dest_dict["kind"] == pymupdf.LINK_GOTO:
            pno = dest_dict["page"]
            page_xref = doc.page_xref(pno)
            page_height = doc.page_cropbox(pno).height
            to = dest_dict.get('to', pymupdf.Point(72, 36))
            to.y = page_height - to.y
            dest_dict["to"] = to
        action = getDestStr(page_xref, dest_dict)
        if not action.startswith("/A"):
            raise ValueError("bad bookmark dest")
        color = dest_dict.get("color")
        if color:
            color = list(map(float, color))
            if len(color) != 3 or min(color) < 0 or max(color) > 1:
                raise ValueError("bad color value")
        bold = dest_dict.get("bold", False)
        italic = dest_dict.get("italic", False)
        flags = italic + 2 * bold
        collapse = dest_dict.get("collapse")
        return doc._update_toc_item(
            xref,
            action=action[2:],
            title=title,
            color=color,
            flags=flags,
            collapse=collapse,
        )

    if kind == pymupdf.LINK_NONE:  # delete bookmark item
        return doc.del_toc_item(idx)
    if kind is None and title is None:  # treat as no-op
        return None
    if kind is None:  # only update title text
        return doc._update_toc_item(xref, action=None, title=title)

    if kind == pymupdf.LINK_GOTO:
        if pno is None or pno not in range(1, doc.page_count + 1):
            raise ValueError("bad page number")
        page_xref = doc.page_xref(pno - 1)
        page_height = doc.page_cropbox(pno - 1).height
        if to is None:
            to = pymupdf.Point(72, page_height - 36)
        else:
            to = pymupdf.Point(to)
            to.y = page_height - to.y

    ddict = {
        "kind": kind,
        "to": to,
        "uri": uri,
        "page": pno,
        "file": filename,
        "zoom": zoom,
    }
    action = getDestStr(page_xref, ddict)
    if action == "" or not action.startswith("/A"):
        raise ValueError("bad bookmark dest")

    return doc._update_toc_item(xref, action=action[2:], title=title)


def get_area(*args) -> float:
    """Calculate area of rectangle.\nparameter is one of 'px' (default), 'in', 'cm', or 'mm'."""
    rect = args[0]
    if len(args) > 1:
        unit = args[1]
    else:
        unit = "px"
    u = {"px": (1, 1), "in": (1.0, 72.0), "cm": (2.54, 72.0), "mm": (25.4, 72.0)}
    f = (u[unit][0] / u[unit][1]) ** 2
    return f * rect.width * rect.height


def set_metadata(doc: pymupdf.Document, m: dict = None) -> None:
    """Update the PDF /Info object.

    Args:
        m: a dictionary like doc.metadata.
    """
    if not doc.is_pdf:
        raise ValueError("is no PDF")
    if doc.is_closed or doc.is_encrypted:
        raise ValueError("document closed or encrypted")
    if m is None:
        m = {}
    elif type(m) is not dict:
        raise ValueError("bad metadata")
    keymap = {
        "author": "Author",
        "producer": "Producer",
        "creator": "Creator",
        "title": "Title",
        "format": None,
        "encryption": None,
        "creationDate": "CreationDate",
        "modDate": "ModDate",
        "subject": "Subject",
        "keywords": "Keywords",
        "trapped": "Trapped",
    }
    valid_keys = set(keymap.keys())
    diff_set = set(m.keys()).difference(valid_keys)
    if diff_set != set():
        msg = "bad dict key(s): %s" % diff_set
        raise ValueError(msg)

    t, temp = doc.xref_get_key(-1, "Info")
    if t != "xref":
        info_xref = 0
    else:
        info_xref = int(temp.replace("0 R", ""))

    if m == {} and info_xref == 0:  # nothing to do
        return

    if info_xref == 0:  # no prev metadata: get new xref
        info_xref = doc.get_new_xref()
        doc.update_object(info_xref, "<<>>")  # fill it with empty object
        doc.xref_set_key(-1, "Info", "%i 0 R" % info_xref)
    elif m == {}:  # remove existing metadata
        doc.xref_set_key(-1, "Info", "null")
        doc.init_doc()
        return

    for key, val in [(k, v) for k, v in m.items() if keymap[k] is not None]:
        pdf_key = keymap[key]
        if not bool(val) or val in ("none", "null"):
            val = "null"
        else:
            val = pymupdf.get_pdf_str(val)
        doc.xref_set_key(info_xref, pdf_key, val)
    doc.init_doc()
    return


def getDestStr(xref: int, ddict: dict) -> str:
    """Calculate the PDF action string.

    Notes:
        Supports Link annotations and outline items (bookmarks).
    """
    if not ddict:
        return ""
    str_goto = lambda a, b, c, d: f"/A<</S/GoTo/D[{a} 0 R/XYZ {_format_g((b, c, d))}]>>"
    str_gotor1 = lambda a, b, c, d, e, f: f"/A<</S/GoToR/D[{a} /XYZ {_format_g((b, c, d))}]/F<</F{e}/UF{f}/Type/Filespec>>>>"
    str_gotor2 = lambda a, b, c: f"/A<</S/GoToR/D{a}/F<</F{b}/UF{c}/Type/Filespec>>>>"
    str_launch = lambda a, b: f"/A<</S/Launch/F<</F{a}/UF{b}/Type/Filespec>>>>"
    str_uri = lambda a: f"/A<</S/URI/URI{a}>>"

    if type(ddict) in (int, float):
        dest = str_goto(xref, 0, ddict, 0)
        return dest
    d_kind = ddict.get("kind", pymupdf.LINK_NONE)

    if d_kind == pymupdf.LINK_NONE:
        return ""

    if ddict["kind"] == pymupdf.LINK_GOTO:
        d_zoom = ddict.get("zoom", 0)
        to = ddict.get("to", pymupdf.Point(0, 0))
        d_left, d_top = to
        dest = str_goto(xref, d_left, d_top, d_zoom)
        return dest

    if ddict["kind"] == pymupdf.LINK_URI:
        dest = str_uri(pymupdf.get_pdf_str(ddict["uri"]),)
        return dest

    if ddict["kind"] == pymupdf.LINK_LAUNCH:
        fspec = pymupdf.get_pdf_str(ddict["file"])
        dest = str_launch(fspec, fspec)
        return dest

    if ddict["kind"] == pymupdf.LINK_GOTOR and ddict["page"] < 0:
        fspec = pymupdf.get_pdf_str(ddict["file"])
        dest = str_gotor2(pymupdf.get_pdf_str(ddict["to"]), fspec, fspec)
        return dest

    if ddict["kind"] == pymupdf.LINK_GOTOR and ddict["page"] >= 0:
        fspec = pymupdf.get_pdf_str(ddict["file"])
        dest = str_gotor1(
            ddict["page"],
            ddict["to"].x,
            ddict["to"].y,
            ddict["zoom"],
            fspec,
            fspec,
        )
        return dest

    return ""


def set_toc(
    doc: pymupdf.Document,
    toc: list,
    collapse: int = 1,
) -> int:
    """Create new outline tree (table of contents, TOC).

    Args:
        toc: (list, tuple) each entry must contain level, title, page and
            optionally top margin on the page. None or '()' remove the TOC.
        collapse: (int) collapses entries beyond this level. Zero or None
            shows all entries unfolded.
    Returns:
        the number of inserted items, or the number of removed items respectively.
    """
    if doc.is_closed or doc.is_encrypted:
        raise ValueError("document closed or encrypted")
    if not doc.is_pdf:
        raise ValueError("is no PDF")
    if not toc:  # remove all entries
        return len(doc._delToC())

    # validity checks --------------------------------------------------------
    if type(toc) not in (list, tuple):
        raise ValueError("'toc' must be list or tuple")
    toclen = len(toc)
    page_count = doc.page_count
    t0 = toc[0]
    if type(t0) not in (list, tuple):
        raise ValueError("items must be sequences of 3 or 4 items")
    if t0[0] != 1:
        raise ValueError("hierarchy level of item 0 must be 1")
    for i in list(range(toclen - 1)):
        t1 = toc[i]
        t2 = toc[i + 1]
        if not -1 <= t1[2] <= page_count:
            raise ValueError("row %i: page number out of range" % i)
        if (type(t2) not in (list, tuple)) or len(t2) not in (3, 4):
            raise ValueError("bad row %i" % (i + 1))
        if (type(t2[0]) is not int) or t2[0] < 1:
            raise ValueError("bad hierarchy level in row %i" % (i + 1))
        if t2[0] > t1[0] + 1:
            raise ValueError("bad hierarchy level in row %i" % (i + 1))
    # no formal errors in toc --------------------------------------------------

    # --------------------------------------------------------------------------
    # make a list of xref numbers, which we can use for our TOC entries
    # --------------------------------------------------------------------------
    old_xrefs = doc._delToC()  # del old outlines, get their xref numbers

    # prepare table of xrefs for new bookmarks
    old_xrefs = []
    xref = [0] + old_xrefs
    xref[0] = doc._getOLRootNumber()  # entry zero is outline root xref number
    if toclen > len(old_xrefs):  # too few old xrefs?
        for i in range((toclen - len(old_xrefs))):
            xref.append(doc.get_new_xref())  # acquire new ones

    lvltab = {0: 0}  # to store last entry per hierarchy level

    # ------------------------------------------------------------------------------
    # contains new outline objects as strings - first one is the outline root
    # ------------------------------------------------------------------------------
    olitems = [{"count": 0, "first": -1, "last": -1, "xref": xref[0]}]
    # ------------------------------------------------------------------------------
    # build olitems as a list of PDF-like connected dictionaries
    # ------------------------------------------------------------------------------
    for i in range(toclen):
        o = toc[i]
        lvl = o[0]  # level
        title = pymupdf.get_pdf_str(o[1])  # title
        pno = min(doc.page_count - 1, max(0, o[2] - 1))  # page number
        page_xref = doc.page_xref(pno)
        page_height = doc.page_cropbox(pno).height
        top = pymupdf.Point(72, page_height - 36)
        dest_dict = {"to": top, "kind": pymupdf.LINK_GOTO}  # fall back target
        if o[2] < 0:
            dest_dict["kind"] = pymupdf.LINK_NONE
        if len(o) > 3:  # some target is specified
            if type(o[3]) in (int, float):  # convert a number to a point
                dest_dict["to"] = pymupdf.Point(72, page_height - o[3])
            else:  # if something else, make sure we have a dict
                # We make a copy of o[3] to avoid modifying our caller's data.
                dest_dict = o[3].copy() if type(o[3]) is dict else dest_dict
                if "to" not in dest_dict:  # target point not in dict?
                    dest_dict["to"] = top  # put default in
                else:  # transform target to PDF coordinates
                    page = doc[pno]
                    point = pymupdf.Point(dest_dict["to"])
                    point.y = page.cropbox.height - point.y
                    point = point * page.rotation_matrix
                    dest_dict["to"] = (point.x, point.y)
        d = {}
        d["first"] = -1
        d["count"] = 0
        d["last"] = -1
        d["prev"] = -1
        d["next"] = -1
        d["dest"] = getDestStr(page_xref, dest_dict)
        d["top"] = dest_dict["to"]
        d["title"] = title
        d["parent"] = lvltab[lvl - 1]
        d["xref"] = xref[i + 1]
        d["color"] = dest_dict.get("color")
        d["flags"] = dest_dict.get("italic", 0) + 2 * dest_dict.get("bold", 0)
        lvltab[lvl] = i + 1
        parent = olitems[lvltab[lvl - 1]]  # the parent entry

        if (
            dest_dict.get("collapse") or collapse and lvl > collapse
        ):  # suppress expansion
            parent["count"] -= 1  # make /Count negative
        else:
            parent["count"] += 1  # positive /Count

        if parent["first"] == -1:
            parent["first"] = i + 1
            parent["last"] = i + 1
        else:
            d["prev"] = parent["last"]
            prev = olitems[parent["last"]]
            prev["next"] = i + 1
            parent["last"] = i + 1
        olitems.append(d)

    # ------------------------------------------------------------------------------
    # now create each outline item as a string and insert it in the PDF
    # ------------------------------------------------------------------------------
    for i, ol in enumerate(olitems):
        txt = "<<"
        if ol["count"] != 0:
            txt += "/Count %i" % ol["count"]
        try:
            txt += ol["dest"]
        except Exception:
            # Verbose in PyMuPDF/tests.
            if g_exceptions_verbose >= 2:   pymupdf.exception_info()
            pass
        try:
            if ol["first"] > -1:
                txt += "/First %i 0 R" % xref[ol["first"]]
        except Exception:
            if g_exceptions_verbose >= 2:   pymupdf.exception_info()
            pass
        try:
            if ol["last"] > -1:
                txt += "/Last %i 0 R" % xref[ol["last"]]
        except Exception:
            if g_exceptions_verbose >= 2:   pymupdf.exception_info()
            pass
        try:
            if ol["next"] > -1:
                txt += "/Next %i 0 R" % xref[ol["next"]]
        except Exception:
            # Verbose in PyMuPDF/tests.
            if g_exceptions_verbose >= 2:   pymupdf.exception_info()
            pass
        try:
            if ol["parent"] > -1:
                txt += "/Parent %i 0 R" % xref[ol["parent"]]
        except Exception:
            # Verbose in PyMuPDF/tests.
            if g_exceptions_verbose >= 2:   pymupdf.exception_info()
            pass
        try:
            if ol["prev"] > -1:
                txt += "/Prev %i 0 R" % xref[ol["prev"]]
        except Exception:
            # Verbose in PyMuPDF/tests.
            if g_exceptions_verbose >= 2:   pymupdf.exception_info()
            pass
        try:
            txt += "/Title" + ol["title"]
        except Exception:
            # Verbose in PyMuPDF/tests.
            if g_exceptions_verbose >= 2:   pymupdf.exception_info()
            pass

        if ol.get("color") and len(ol["color"]) == 3:
            txt += f"/C[ {_format_g(tuple(ol['color']))}]"
        if ol.get("flags", 0) > 0:
            txt += "/F %i" % ol["flags"]

        if i == 0:  # special: this is the outline root
            txt += "/Type/Outlines"  # so add the /Type entry
        txt += ">>"
        doc.update_object(xref[i], txt)  # insert the PDF object

    doc.init_doc()
    return toclen


def do_widgets(
    tar: pymupdf.Document,
    src: pymupdf.Document,
    graftmap,
    from_page: int = -1,
    to_page: int = -1,
    start_at: int = -1,
    join_duplicates=0,
) -> None:
    """Insert widgets of copied page range into target PDF.

    Parameter values **must** equal those of method insert_pdf() which
    must have been previously executed.
    """
    if not src.is_form_pdf:  # nothing to do: source PDF has no fields
        return

    def clean_kid_parents(acro_fields):
        """ Make sure all kids have correct "Parent" pointers."""
        for i in range(acro_fields.pdf_array_len()):
            parent = acro_fields.pdf_array_get(i)
            kids = parent.pdf_dict_get(pymupdf.PDF_NAME("Kids"))
            for j in range(kids.pdf_array_len()):
                kid = kids.pdf_array_get(j)
                kid.pdf_dict_put(pymupdf.PDF_NAME("Parent"), parent)

    def join_widgets(pdf, acro_fields, xref1, xref2, name):
        """Called for each pair of widgets having the same name.

        Args:
            pdf: target MuPDF document
            acro_fields: object Root/AcroForm/Fields
            xref1, xref2: widget xrefs having same names
            name: (str) the name

        Result:
            Defined or updated widget parent that points to both widgets.
        """

        def re_target(pdf, acro_fields, xref1, kids1, xref2, kids2):
            """Merge widget in xref2 into "Kids" list of widget xref1.

            Args:
                xref1, kids1: target widget and its "Kids" array.
                xref2, kids2: source wwidget and its "Kids" array (may be empty).
            """
            # make indirect objects from widgets
            w1_ind = mupdf.pdf_new_indirect(pdf, xref1, 0)
            w2_ind = mupdf.pdf_new_indirect(pdf, xref2, 0)
            # find source widget in "Fields" array
            idx = acro_fields.pdf_array_find(w2_ind)
            acro_fields.pdf_array_delete(idx)

            if not kids2.pdf_is_array():  # source widget has no kids
                widget = mupdf.pdf_load_object(pdf, xref2)

                # delete name from widget and insert target as parent
                widget.pdf_dict_del(pymupdf.PDF_NAME("T"))
                widget.pdf_dict_put(pymupdf.PDF_NAME("Parent"), w1_ind)

                # put in target Kids
                kids1.pdf_array_push(w2_ind)
            else:  # copy source kids to target kids
                for i in range(kids2.pdf_array_len()):
                    kid = kids2.pdf_array_get(i)
                    kid.pdf_dict_put(pymupdf.PDF_NAME("Parent"), w1_ind)
                    kid_ind = mupdf.pdf_new_indirect(pdf, kid.pdf_to_num(), 0)
                    kids1.pdf_array_push(kid_ind)

        def new_target(pdf, acro_fields, xref1, w1, xref2, w2, name):
            """Make new "Parent" for two widgets with same name.

            Args:
                xref1, w1: first widget
                xref2, w2: second widget
                name: field name

            Result:
                Both widgets have no "Kids". We create a new object with the
                name and a "Kids" array containing the widgets.
                Original widgets must be removed from AcroForm/Fields.
            """
            # make new "Parent" object
            new = mupdf.pdf_new_dict(pdf, 5)
            new.pdf_dict_put_text_string(pymupdf.PDF_NAME("T"), name)
            kids = new.pdf_dict_put_array(pymupdf.PDF_NAME("Kids"), 2)
            new_obj = mupdf.pdf_add_object(pdf, new)
            new_obj_xref = new_obj.pdf_to_num()
            new_ind = mupdf.pdf_new_indirect(pdf, new_obj_xref, 0)

            # copy over some required source widget properties
            ft = w1.pdf_dict_get(pymupdf.PDF_NAME("FT"))
            w1.pdf_dict_del(pymupdf.PDF_NAME("FT"))
            new_obj.pdf_dict_put(pymupdf.PDF_NAME("FT"), ft)

            aa = w1.pdf_dict_get(pymupdf.PDF_NAME("AA"))
            w1.pdf_dict_del(pymupdf.PDF_NAME("AA"))
            new_obj.pdf_dict_put(pymupdf.PDF_NAME("AA"), aa)

            # remove name field, insert "Parent" field in source widgets
            w1.pdf_dict_del(pymupdf.PDF_NAME("T"))
            w1.pdf_dict_put(pymupdf.PDF_NAME("Parent"), new_ind)
            w2.pdf_dict_del(pymupdf.PDF_NAME("T"))
            w2.pdf_dict_put(pymupdf.PDF_NAME("Parent"), new_ind)

            # put source widgets in "kids" array
            ind1 = mupdf.pdf_new_indirect(pdf, xref1, 0)
            ind2 = mupdf.pdf_new_indirect(pdf, xref2, 0)
            kids.pdf_array_push(ind1)
            kids.pdf_array_push(ind2)

            # remove source widgets from "AcroForm/Fields"
            idx = acro_fields.pdf_array_find(ind1)
            acro_fields.pdf_array_delete(idx)
            idx = acro_fields.pdf_array_find(ind2)
            acro_fields.pdf_array_delete(idx)

            acro_fields.pdf_array_push(new_ind)

        w1 = mupdf.pdf_load_object(pdf, xref1)
        w2 = mupdf.pdf_load_object(pdf, xref2)
        kids1 = w1.pdf_dict_get(pymupdf.PDF_NAME("Kids"))
        kids2 = w2.pdf_dict_get(pymupdf.PDF_NAME("Kids"))

        # check which widget has a suitable "Kids" array
        if kids1.pdf_is_array():
            re_target(pdf, acro_fields, xref1, kids1, xref2, kids2)  # pylint: disable=arguments-out-of-order
        elif kids2.pdf_is_array():
            re_target(pdf, acro_fields, xref2, kids2, xref1, kids1)  # pylint: disable=arguments-out-of-order
        else:
            new_target(pdf, acro_fields, xref1, w1, xref2, w2, name)  # pylint: disable=arguments-out-of-order

    def get_kids(parent, kids_list):
        """Return xref list of leaf kids for a parent.

        Call with an empty list.
        """
        kids = mupdf.pdf_dict_get(parent, pymupdf.PDF_NAME("Kids"))
        if not kids.pdf_is_array():
            return kids_list
        for i in range(kids.pdf_array_len()):
            kid = kids.pdf_array_get(i)
            if mupdf.pdf_is_dict(mupdf.pdf_dict_get(kid, pymupdf.PDF_NAME("Kids"))):
                kids_list = get_kids(kid, kids_list)
            else:
                kids_list.append(kid.pdf_to_num())
        return kids_list

    def kids_xrefs(widget):
        """Get the xref of top "Parent" and the list of leaf widgets."""
        kids_list = []
        parent = mupdf.pdf_dict_get(widget, pymupdf.PDF_NAME("Parent"))
        parent_xref = parent.pdf_to_num()
        if parent_xref == 0:
            return parent_xref, kids_list
        kids_list = get_kids(parent, kids_list)
        return parent_xref, kids_list

    def deduplicate_names(pdf, acro_fields, join_duplicates=False):
        """Handle any widget name duplicates caused by the merge."""
        names = {}  # key is a widget name, value a list of widgets having it.

        # extract all names and widgets in "AcroForm/Fields"
        for i in range(mupdf.pdf_array_len(acro_fields)):
            wobject = mupdf.pdf_array_get(acro_fields, i)
            xref = wobject.pdf_to_num()

            # extract widget name and collect widget(s) using it
            T = mupdf.pdf_dict_get_text_string(wobject, pymupdf.PDF_NAME("T"))
            xrefs = names.get(T, [])
            xrefs.append(xref)
            names[T] = xrefs

        for name, xrefs in names.items():
            if len(xrefs) < 2:
                continue
            xref0, xref1 = xrefs[:2]  # only exactly 2 should occur!
            if join_duplicates:  # combine fields with equal names
                join_widgets(pdf, acro_fields, xref0, xref1, name)
            else:  # make field names unique
                newname = name + f" [{xref1}]"  # append this to the name
                wobject = mupdf.pdf_load_object(pdf, xref1)
                wobject.pdf_dict_put_text_string(pymupdf.PDF_NAME("T"), newname)

        clean_kid_parents(acro_fields)

    def get_acroform(doc):
        """Retrieve the AcroForm dictionary form a PDF."""
        pdf = mupdf.pdf_document_from_fz_document(doc)
        # AcroForm (= central form field info)
        return mupdf.pdf_dict_getp(mupdf.pdf_trailer(pdf), "Root/AcroForm")

    tarpdf = mupdf.pdf_document_from_fz_document(tar)
    srcpdf = mupdf.pdf_document_from_fz_document(src)

    if tar.is_form_pdf:
        # target is a Form PDF, so use it to include source fields
        acro = get_acroform(tar)
        # Important arrays in AcroForm
        acro_fields = acro.pdf_dict_get(pymupdf.PDF_NAME("Fields"))
        tar_co = acro.pdf_dict_get(pymupdf.PDF_NAME("CO"))
        if not tar_co.pdf_is_array():
            tar_co = acro.pdf_dict_put_array(pymupdf.PDF_NAME("CO"), 5)
    else:
        # target is no Form PDF, so copy over source AcroForm
        acro = mupdf.pdf_deep_copy_obj(get_acroform(src))  # make a copy

        # Clear "Fields" and "CO" arrays: will be populated by page fields.
        # This is required to avoid copying unneeded objects.
        acro.pdf_dict_del(pymupdf.PDF_NAME("Fields"))
        acro.pdf_dict_put_array(pymupdf.PDF_NAME("Fields"), 5)
        acro.pdf_dict_del(pymupdf.PDF_NAME("CO"))
        acro.pdf_dict_put_array(pymupdf.PDF_NAME("CO"), 5)

        # Enrich AcroForm for copying to target
        acro_graft = mupdf.pdf_graft_mapped_object(graftmap, acro)

        # Insert AcroForm into target PDF
        acro_tar = mupdf.pdf_add_object(tarpdf, acro_graft)
        acro_fields = acro_tar.pdf_dict_get(pymupdf.PDF_NAME("Fields"))
        tar_co = acro_tar.pdf_dict_get(pymupdf.PDF_NAME("CO"))

        # get its xref and insert it into target catalog
        tar_xref = acro_tar.pdf_to_num()
        acro_tar_ind = mupdf.pdf_new_indirect(tarpdf, tar_xref, 0)
        root = mupdf.pdf_dict_get(mupdf.pdf_trailer(tarpdf), pymupdf.PDF_NAME("Root"))
        root.pdf_dict_put(pymupdf.PDF_NAME("AcroForm"), acro_tar_ind)

    if from_page <= to_page:
        src_range = range(from_page, to_page + 1)
    else:
        src_range = range(from_page, to_page - 1, -1)

    parents = {}  # information about widget parents

    # remove "P" owning page reference from all widgets of all source pages
    for i in src_range:
        src_page = src[src_range[i]]
        for xref in [
            xref
            for xref, wtype, _ in src_page.annot_xrefs()
            if wtype == pymupdf.PDF_ANNOT_WIDGET  # pylint: disable=no-member
        ]:
            w_obj = mupdf.pdf_load_object(srcpdf, xref)
            w_obj.pdf_dict_del(pymupdf.PDF_NAME("P"))

            # get the widget's parent structure
            parent_xref, old_kids = kids_xrefs(w_obj)
            if parent_xref:
                parents[parent_xref] = {
                    "new_xref": 0,
                    "old_kids": old_kids,
                    "new_kids": [],
                }
    # Copy over Parent widgets first - they are not page-dependent
    for xref in parents.keys():  # pylint: disable=consider-using-dict-items
        parent = mupdf.pdf_load_object(srcpdf, xref)
        parent_graft = mupdf.pdf_graft_mapped_object(graftmap, parent)
        parent_tar = mupdf.pdf_add_object(tarpdf, parent_graft)
        kids_xrefs_new = get_kids(parent_tar, [])
        parent_xref_new = parent_tar.pdf_to_num()
        parent_ind = mupdf.pdf_new_indirect(tarpdf, parent_xref_new, 0)
        acro_fields.pdf_array_push(parent_ind)
        parents[xref]["new_xref"] = parent_xref_new
        parents[xref]["new_kids"] = kids_xrefs_new

    for i in src_range:
        # read first copied over page in target
        tar_page = tar[start_at + i]

        # read the original page in the source PDF
        src_page = src[src_range[i]]

        # now walk through source page widgets and copy over
        w_xrefs = [  # widget xrefs of the source page
            xref
            for xref, wtype, _ in src_page.annot_xrefs()
            if wtype == pymupdf.PDF_ANNOT_WIDGET  # pylint: disable=no-member
        ]
        if not w_xrefs:  # no widgets on this source page
            continue

        # convert to formal PDF page
        tar_page_pdf = mupdf.pdf_page_from_fz_page(tar_page)

        # extract annotations array
        tar_annots = mupdf.pdf_dict_get(tar_page_pdf.obj(), pymupdf.PDF_NAME("Annots"))
        if not mupdf.pdf_is_array(tar_annots):
            tar_annots = mupdf.pdf_dict_put_array(
                tar_page_pdf.obj(), pymupdf.PDF_NAME("Annots"), 5
            )

        for xref in w_xrefs:
            w_obj = mupdf.pdf_load_object(srcpdf, xref)

            # check if field takes part in inter-field validations
            is_aac = mupdf.pdf_is_dict(mupdf.pdf_dict_getp(w_obj, "AA/C"))

            # check if parent of widget already in target
            parent_xref = mupdf.pdf_to_num(
                w_obj.pdf_dict_get(pymupdf.PDF_NAME("Parent"))
            )
            if parent_xref == 0:  # parent not in target yet
                w_obj_graft = mupdf.pdf_graft_mapped_object(graftmap, w_obj)
                w_obj_tar = mupdf.pdf_add_object(tarpdf, w_obj_graft)
                tar_xref = w_obj_tar.pdf_to_num()
                w_obj_tar_ind = mupdf.pdf_new_indirect(tarpdf, tar_xref, 0)
                mupdf.pdf_array_push(tar_annots, w_obj_tar_ind)
                mupdf.pdf_array_push(acro_fields, w_obj_tar_ind)
            else:
                parent = parents[parent_xref]
                idx = parent["old_kids"].index(xref)  # search for xref in parent
                tar_xref = parent["new_kids"][idx]
                w_obj_tar_ind = mupdf.pdf_new_indirect(tarpdf, tar_xref, 0)
                mupdf.pdf_array_push(tar_annots, w_obj_tar_ind)

            # Into "AcroForm/CO" if a computation field.
            if is_aac:
                mupdf.pdf_array_push(tar_co, w_obj_tar_ind)

    deduplicate_names(tarpdf, acro_fields, join_duplicates=join_duplicates)

def do_links(
    doc1: pymupdf.Document,
    doc2: pymupdf.Document,
    from_page: int = -1,
    to_page: int = -1,
    start_at: int = -1,
) -> None:
    """Insert links contained in copied page range into destination PDF.

    Parameter values **must** equal those of method insert_pdf(), which must
    have been previously executed.
    """
    #pymupdf.log( 'utils.do_links()')
    # --------------------------------------------------------------------------
    # internal function to create the actual "/Annots" object string
    # --------------------------------------------------------------------------
    def cre_annot(lnk, xref_dst, pno_src, ctm):
        """Create annotation object string for a passed-in link."""

        r = lnk["from"] * ctm  # rect in PDF coordinates
        rect = _format_g(tuple(r))
        if lnk["kind"] == pymupdf.LINK_GOTO:
            txt = pymupdf.annot_skel["goto1"]  # annot_goto
            idx = pno_src.index(lnk["page"])
            p = lnk["to"] * ctm  # target point in PDF coordinates
            annot = txt(xref_dst[idx], p.x, p.y, lnk["zoom"], rect)

        elif lnk["kind"] == pymupdf.LINK_GOTOR:
            if lnk["page"] >= 0:
                txt = pymupdf.annot_skel["gotor1"]  # annot_gotor
                pnt = lnk.get("to", pymupdf.Point(0, 0))  # destination point
                if type(pnt) is not pymupdf.Point:
                    pnt = pymupdf.Point(0, 0)
                annot = txt(
                    lnk["page"],
                    pnt.x,
                    pnt.y,
                    lnk["zoom"],
                    lnk["file"],
                    lnk["file"],
                    rect,
                )
            else:
                txt = pymupdf.annot_skel["gotor2"]  # annot_gotor_n
                to = pymupdf.get_pdf_str(lnk["to"])
                to = to[1:-1]
                f = lnk["file"]
                annot = txt(to, f, rect)

        elif lnk["kind"] == pymupdf.LINK_LAUNCH:
            txt = pymupdf.annot_skel["launch"]  # annot_launch
            annot = txt(lnk["file"], lnk["file"], rect)

        elif lnk["kind"] == pymupdf.LINK_URI:
            txt = pymupdf.annot_skel["uri"]  # annot_uri
            annot = txt(lnk["uri"], rect)

        else:
            annot = ""

        return annot

    # --------------------------------------------------------------------------

    # validate & normalize parameters
    if from_page < 0:
        fp = 0
    elif from_page >= doc2.page_count:
        fp = doc2.page_count - 1
    else:
        fp = from_page

    if to_page < 0 or to_page >= doc2.page_count:
        tp = doc2.page_count - 1
    else:
        tp = to_page

    if start_at < 0:
        raise ValueError("'start_at' must be >= 0")
    sa = start_at

    incr = 1 if fp <= tp else -1  # page range could be reversed

    # lists of source / destination page numbers
    pno_src = list(range(fp, tp + incr, incr))
    pno_dst = [sa + i for i in range(len(pno_src))]

    # lists of source / destination page xrefs
    xref_src = []
    xref_dst = []
    for i in range(len(pno_src)):
        p_src = pno_src[i]
        p_dst = pno_dst[i]
        old_xref = doc2.page_xref(p_src)
        new_xref = doc1.page_xref(p_dst)
        xref_src.append(old_xref)
        xref_dst.append(new_xref)

    # create the links for each copied page in destination PDF
    for i in range(len(xref_src)):
        page_src = doc2[pno_src[i]]  # load source page
        links = page_src.get_links()  # get all its links
        #pymupdf.log( '{pno_src=}')
        #pymupdf.log( '{type(page_src)=}')
        #pymupdf.log( '{page_src=}')
        #pymupdf.log( '{=i len(links)}')
        if len(links) == 0:  # no links there
            page_src = None
            continue
        ctm = ~page_src.transformation_matrix  # calc page transformation matrix
        page_dst = doc1[pno_dst[i]]  # load destination page
        link_tab = []  # store all link definitions here
        for l in links:
            if l["kind"] == pymupdf.LINK_GOTO and (l["page"] not in pno_src):
                continue  # GOTO link target not in copied pages
            annot_text = cre_annot(l, xref_dst, pno_src, ctm)
            if annot_text:
                link_tab.append(annot_text)
        if link_tab != []:
            page_dst._addAnnot_FromString( tuple(link_tab))
    #pymupdf.log( 'utils.do_links() returning.')


def getLinkText(page: pymupdf.Page, lnk: dict) -> str:
    # --------------------------------------------------------------------------
    # define skeletons for /Annots object texts
    # --------------------------------------------------------------------------
    ctm = page.transformation_matrix
    ictm = ~ctm
    r = lnk["from"]
    rect = _format_g(tuple(r * ictm))

    annot = ""
    if lnk["kind"] == pymupdf.LINK_GOTO:
        if lnk["page"] >= 0:
            txt = pymupdf.annot_skel["goto1"]  # annot_goto
            pno = lnk["page"]
            xref = page.parent.page_xref(pno)
            pnt = lnk.get("to", pymupdf.Point(0, 0))  # destination point
            dest_page = page.parent[pno]
            dest_ctm = dest_page.transformation_matrix
            dest_ictm = ~dest_ctm
            ipnt = pnt * dest_ictm
            annot = txt(xref, ipnt.x, ipnt.y, lnk.get("zoom", 0), rect)
        else:
            txt = pymupdf.annot_skel["goto2"]  # annot_goto_n
            annot = txt(pymupdf.get_pdf_str(lnk["to"]), rect)

    elif lnk["kind"] == pymupdf.LINK_GOTOR:
        if lnk["page"] >= 0:
            txt = pymupdf.annot_skel["gotor1"]  # annot_gotor
            pnt = lnk.get("to", pymupdf.Point(0, 0))  # destination point
            if type(pnt) is not pymupdf.Point:
                pnt = pymupdf.Point(0, 0)
            annot = txt(
                lnk["page"],
                pnt.x,
                pnt.y,
                lnk.get("zoom", 0),
                lnk["file"],
                lnk["file"],
                rect,
            )
        else:
            txt = pymupdf.annot_skel["gotor2"]  # annot_gotor_n
            annot = txt(pymupdf.get_pdf_str(lnk["to"]), lnk["file"], rect)

    elif lnk["kind"] == pymupdf.LINK_LAUNCH:
        txt = pymupdf.annot_skel["launch"]  # annot_launch
        annot = txt(lnk["file"], lnk["file"], rect)

    elif lnk["kind"] == pymupdf.LINK_URI:
        txt = pymupdf.annot_skel["uri"]  # txt = annot_uri
        annot = txt(lnk["uri"], rect)

    elif lnk["kind"] == pymupdf.LINK_NAMED:
        txt = pymupdf.annot_skel["named"]  # annot_named
        lname = lnk.get("name")  # check presence of key
        if lname is None:  # if missing, fall back to alternative
            lname = lnk["nameddest"]
        annot = txt(lname, rect)
    if not annot:
        return annot

    # add a /NM PDF key to the object definition
    link_names = dict(  # existing ids and their xref
        [(x[0], x[2]) for x in page.annot_xrefs() if x[1] == pymupdf.PDF_ANNOT_LINK]   # pylint: disable=no-member
    )

    old_name = lnk.get("id", "")  # id value in the argument

    if old_name and (lnk["xref"], old_name) in link_names.items():
        name = old_name  # no new name if this is an update only
    else:
        i = 0
        stem = pymupdf.TOOLS.set_annot_stem() + "-L%i"
        while True:
            name = stem % i
            if name not in link_names.values():
                break
            i += 1
    # add /NM key to object definition
    annot = annot.replace("/Link", "/Link/NM(%s)" % name)
    return annot


def delete_widget(page: pymupdf.Page, widget: pymupdf.Widget) -> pymupdf.Widget:
    """Delete widget from page and return the next one."""
    pymupdf.CheckParent(page)
    annot = getattr(widget, "_annot", None)
    if annot is None:
        raise ValueError("bad type: widget")
    nextwidget = widget.next
    page.delete_annot(annot)
    widget._annot.parent = None
    keylist = list(widget.__dict__.keys())
    for key in keylist:
        del widget.__dict__[key]
    return nextwidget


def update_link(page: pymupdf.Page, lnk: dict) -> None:
    """Update a link on the current page."""
    pymupdf.CheckParent(page)
    annot = getLinkText(page, lnk)
    if annot == "":
        raise ValueError("link kind not supported")

    page.parent.update_object(lnk["xref"], annot, page=page)


def insert_link(page: pymupdf.Page, lnk: dict, mark: bool = True) -> None:
    """Insert a new link for the current page."""
    pymupdf.CheckParent(page)
    annot = getLinkText(page, lnk)
    if annot == "":
        raise ValueError("link kind not supported")
    page._addAnnot_FromString((annot,))


def insert_textbox(
    page: pymupdf.Page,
    rect: rect_like,
    buffer: typing.Union[str, list],
    *,
    fontname: str = "helv",
    fontfile: OptStr = None,
    set_simple: int = 0,
    encoding: int = 0,
    fontsize: float = 11,
    lineheight: OptFloat = None,
    color: OptSeq = None,
    fill: OptSeq = None,
    expandtabs: int = 1,
    align: int = 0,
    rotate: int = 0,
    render_mode: int = 0,
    miter_limit: float = 1,
    border_width: float = 0.05,
    morph: OptSeq = None,
    overlay: bool = True,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> float:
    """Insert text into a given rectangle.

    Notes:
        Creates a Shape object, uses its same-named method and commits it.
    Parameters:
        rect: (rect-like) area to use for text.
        buffer: text to be inserted
        fontname: a Base-14 font, font name or '/name'
        fontfile: name of a font file
        fontsize: font size
        lineheight: overwrite the font property
        color: RGB color triple
        expandtabs: handles tabulators with string function
        align: left, center, right, justified
        rotate: 0, 90, 180, or 270 degrees
        morph: morph box with a matrix and a fixpoint
        overlay: put text in foreground or background
    Returns:
        unused or deficit rectangle area (float)
    """
    img = page.new_shape()
    rc = img.insert_textbox(
        rect,
        buffer,
        fontsize=fontsize,
        lineheight=lineheight,
        fontname=fontname,
        fontfile=fontfile,
        set_simple=set_simple,
        encoding=encoding,
        color=color,
        fill=fill,
        expandtabs=expandtabs,
        render_mode=render_mode,
        miter_limit=miter_limit,
        border_width=border_width,
        align=align,
        rotate=rotate,
        morph=morph,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    if rc >= 0:
        img.commit(overlay)
    return rc


def insert_text(
    page: pymupdf.Page,
    point: point_like,
    text: typing.Union[str, list],
    *,
    fontsize: float = 11,
    lineheight: OptFloat = None,
    fontname: str = "helv",
    fontfile: OptStr = None,
    set_simple: int = 0,
    encoding: int = 0,
    color: OptSeq = None,
    fill: OptSeq = None,
    border_width: float = 0.05,
    miter_limit: float = 1,
    render_mode: int = 0,
    rotate: int = 0,
    morph: OptSeq = None,
    overlay: bool = True,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
):

    img = page.new_shape()
    rc = img.insert_text(
        point,
        text,
        fontsize=fontsize,
        lineheight=lineheight,
        fontname=fontname,
        fontfile=fontfile,
        set_simple=set_simple,
        encoding=encoding,
        color=color,
        fill=fill,
        border_width=border_width,
        render_mode=render_mode,
        miter_limit=miter_limit,
        rotate=rotate,
        morph=morph,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    if rc >= 0:
        img.commit(overlay)
    return rc


def insert_htmlbox(
    page,
    rect,
    text,
    *,
    css=None,
    scale_low=0,
    archive=None,
    rotate=0,
    oc=0,
    opacity=1,
    overlay=True,
) -> float:
    """Insert text with optional HTML tags and stylings into a rectangle.

    Args:
        rect: (rect-like) rectangle into which the text should be placed.
        text: (str) text with optional HTML tags and stylings.
        css: (str) CSS styling commands.
        scale_low: (float) force-fit content by scaling it down. Must be in
            range [0, 1]. If 1, no scaling will take place. If 0, arbitrary
            down-scaling is acceptable. A value of 0.1 would mean that content
            may be scaled down by at most 90%.
        archive: Archive object pointing to locations of used fonts or images
        rotate: (int) rotate the text in the box by a multiple of 90 degrees.
        oc: (int) the xref of an OCG / OCMD (Optional Content).
        opacity: (float) set opacity of inserted content.
        overlay: (bool) put text on top of page content.
    Returns:
        A tuple of floats (spare_height, scale).
        spare_height: -1 if content did not fit, else >= 0. It is the height of the
               unused (still available) rectangle stripe. Positive only if
               scale_min = 1 (no down scaling).
        scale: downscaling factor, 0 < scale <= 1. Set to 0 if spare_height = -1 (no fit).
    """

    # normalize rotation angle
    if not rotate % 90 == 0:
        raise ValueError("bad rotation angle")
    while rotate < 0:
        rotate += 360
    while rotate >= 360:
        rotate -= 360

    if not 0 <= scale_low <= 1:
        raise ValueError("'scale_low' must be in [0, 1]")

    if css is None:
        css = ""

    rect = pymupdf.Rect(rect)
    if rotate in (90, 270):
        temp_rect = pymupdf.Rect(0, 0, rect.height, rect.width)
    else:
        temp_rect = pymupdf.Rect(0, 0, rect.width, rect.height)

    # use a small border by default
    mycss = "body {margin:1px;}" + css  # append user CSS

    # either make a story, or accept a given one
    if isinstance(text, str):  # if a string, convert to a Story
        story = pymupdf.Story(html=text, user_css=mycss, archive=archive)
    elif isinstance(text, pymupdf.Story):
        story = text
    else:
        raise ValueError("'text' must be a string or a Story")
    # ----------------------------------------------------------------
    # Find a scaling factor that lets our story fit in
    # ----------------------------------------------------------------
    scale_max = None if scale_low == 0 else 1 / scale_low

    fit = story.fit_scale(temp_rect, scale_min=1, scale_max=scale_max)
    if not fit.big_enough:  # there was no fit
        return (-1, scale_low)

    filled = fit.filled
    scale = 1 / fit.parameter  # shrink factor

    spare_height = fit.rect.y1 - filled[3]  # unused room at rectangle bottom
    # Note: due to MuPDF's logic this may be negative even for successful fits.
    if scale != 1 or spare_height < 0:  # if scaling occurred, set spare_height to 0
        spare_height = 0

    def rect_function(*args):
        return fit.rect, fit.rect, pymupdf.Identity

    # draw story on temp PDF page
    doc = story.write_with_links(rect_function)

    # Insert opacity if requested.
    # For this, we prepend a command to the /Contents.
    if 0 <= opacity < 1:
        tpage = doc[0]  # load page
        # generate /ExtGstate for the page
        alp0 = tpage._set_opacity(CA=opacity, ca=opacity)
        s = f"/{alp0} gs\n"  # generate graphic state command
        pymupdf.TOOLS._insert_contents(tpage, s.encode(), 0)

    # put result in target page
    page.show_pdf_page(rect, doc, 0, rotate=rotate, oc=oc, overlay=overlay)

    # -------------------------------------------------------------------------
    # re-insert links in target rect (show_pdf_page cannot copy annotations)
    # -------------------------------------------------------------------------
    # scaled center point of fit.rect
    mp1 = (fit.rect.tl + fit.rect.br) / 2 * scale

    # center point of target rect
    mp2 = (rect.tl + rect.br) / 2

    # compute link positioning matrix:
    # - move center of scaled-down fit.rect to (0,0)
    # - rotate
    # - move (0,0) to center of target rect
    mat = (
        pymupdf.Matrix(scale, 0, 0, scale, -mp1.x, -mp1.y)
        * pymupdf.Matrix(-rotate)
        * pymupdf.Matrix(1, 0, 0, 1, mp2.x, mp2.y)
    )

    # copy over links
    for link in doc[0].get_links():
        link["from"] *= mat
        page.insert_link(link)

    return spare_height, scale


def new_page(
    doc: pymupdf.Document,
    pno: int = -1,
    width: float = 595,
    height: float = 842,
) -> pymupdf.Page:
    """Create and return a new page object.

    Args:
        pno: (int) insert before this page. Default: after last page.
        width: (float) page width in points. Default: 595 (ISO A4 width).
        height: (float) page height in points. Default 842 (ISO A4 height).
    Returns:
        A pymupdf.Page object.
    """
    doc._newPage(pno, width=width, height=height)
    return doc[pno]


def insert_page(
    doc: pymupdf.Document,
    pno: int,
    text: typing.Union[str, list, None] = None,
    fontsize: float = 11,
    width: float = 595,
    height: float = 842,
    fontname: str = "helv",
    fontfile: OptStr = None,
    color: OptSeq = (0,),
) -> int:
    """Create a new PDF page and insert some text.

    Notes:
        Function combining pymupdf.Document.new_page() and pymupdf.Page.insert_text().
        For parameter details see these methods.
    """
    page = doc.new_page(pno=pno, width=width, height=height)
    if not bool(text):
        return 0
    rc = page.insert_text(
        (50, 72),
        text,
        fontsize=fontsize,
        fontname=fontname,
        fontfile=fontfile,
        color=color,
    )
    return rc


def draw_line(
    page: pymupdf.Page,
    p1: point_like,
    p2: point_like,
    color: OptSeq = (0,),
    dashes: OptStr = None,
    width: float = 1,
    lineCap: int = 0,
    lineJoin: int = 0,
    overlay: bool = True,
    morph: OptSeq = None,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc=0,
) -> pymupdf.Point:
    """Draw a line from point p1 to point p2."""
    img = page.new_shape()
    p = img.draw_line(pymupdf.Point(p1), pymupdf.Point(p2))
    img.finish(
        color=color,
        dashes=dashes,
        width=width,
        closePath=False,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return p


def draw_squiggle(
    page: pymupdf.Page,
    p1: point_like,
    p2: point_like,
    breadth: float = 2,
    color: OptSeq = (0,),
    dashes: OptStr = None,
    width: float = 1,
    lineCap: int = 0,
    lineJoin: int = 0,
    overlay: bool = True,
    morph: OptSeq = None,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> pymupdf.Point:
    """Draw a squiggly line from point p1 to point p2."""
    img = page.new_shape()
    p = img.draw_squiggle(pymupdf.Point(p1), pymupdf.Point(p2), breadth=breadth)
    img.finish(
        color=color,
        dashes=dashes,
        width=width,
        closePath=False,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return p


def draw_zigzag(
    page: pymupdf.Page,
    p1: point_like,
    p2: point_like,
    breadth: float = 2,
    color: OptSeq = (0,),
    dashes: OptStr = None,
    width: float = 1,
    lineCap: int = 0,
    lineJoin: int = 0,
    overlay: bool = True,
    morph: OptSeq = None,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> pymupdf.Point:
    """Draw a zigzag line from point p1 to point p2."""
    img = page.new_shape()
    p = img.draw_zigzag(pymupdf.Point(p1), pymupdf.Point(p2), breadth=breadth)
    img.finish(
        color=color,
        dashes=dashes,
        width=width,
        closePath=False,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return p


def draw_rect(
        page: pymupdf.Page,
        rect: rect_like,
        color: OptSeq = (0,),
        fill: OptSeq = None,
        dashes: OptStr = None,
        width: float = 1,
        lineCap: int = 0,
        lineJoin: int = 0,
        morph: OptSeq = None,
        overlay: bool = True,
        stroke_opacity: float = 1,
        fill_opacity: float = 1,
        oc: int = 0,
        radius=None,
        ) -> pymupdf.Point:
    '''
    Draw a rectangle. See Shape class method for details.
    '''
    img = page.new_shape()
    Q = img.draw_rect(pymupdf.Rect(rect), radius=radius)
    img.finish(
        color=color,
        fill=fill,
        dashes=dashes,
        width=width,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return Q


def draw_quad(
    page: pymupdf.Page,
    quad: quad_like,
    color: OptSeq = (0,),
    fill: OptSeq = None,
    dashes: OptStr = None,
    width: float = 1,
    lineCap: int = 0,
    lineJoin: int = 0,
    morph: OptSeq = None,
    overlay: bool = True,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> pymupdf.Point:
    """Draw a quadrilateral."""
    img = page.new_shape()
    Q = img.draw_quad(pymupdf.Quad(quad))
    img.finish(
        color=color,
        fill=fill,
        dashes=dashes,
        width=width,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return Q


def draw_polyline(
    page: pymupdf.Page,
    points: list,
    color: OptSeq = (0,),
    fill: OptSeq = None,
    dashes: OptStr = None,
    width: float = 1,
    morph: OptSeq = None,
    lineCap: int = 0,
    lineJoin: int = 0,
    overlay: bool = True,
    closePath: bool = False,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> pymupdf.Point:
    """Draw multiple connected line segments."""
    img = page.new_shape()
    Q = img.draw_polyline(points)
    img.finish(
        color=color,
        fill=fill,
        dashes=dashes,
        width=width,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        closePath=closePath,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return Q


def draw_circle(
    page: pymupdf.Page,
    center: point_like,
    radius: float,
    color: OptSeq = (0,),
    fill: OptSeq = None,
    morph: OptSeq = None,
    dashes: OptStr = None,
    width: float = 1,
    lineCap: int = 0,
    lineJoin: int = 0,
    overlay: bool = True,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> pymupdf.Point:
    """Draw a circle given its center and radius."""
    img = page.new_shape()
    Q = img.draw_circle(pymupdf.Point(center), radius)
    img.finish(
        color=color,
        fill=fill,
        dashes=dashes,
        width=width,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)
    return Q


def draw_oval(
    page: pymupdf.Page,
    rect: typing.Union[rect_like, quad_like],
    color: OptSeq = (0,),
    fill: OptSeq = None,
    dashes: OptStr = None,
    morph: OptSeq = None,
    width: float = 1,
    lineCap: int = 0,
    lineJoin: int = 0,
    overlay: bool = True,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> pymupdf.Point:
    """Draw an oval given its containing rectangle or quad."""
    img = page.new_shape()
    Q = img.draw_oval(rect)
    img.finish(
        color=color,
        fill=fill,
        dashes=dashes,
        width=width,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return Q


def draw_curve(
    page: pymupdf.Page,
    p1: point_like,
    p2: point_like,
    p3: point_like,
    color: OptSeq = (0,),
    fill: OptSeq = None,
    dashes: OptStr = None,
    width: float = 1,
    morph: OptSeq = None,
    closePath: bool = False,
    lineCap: int = 0,
    lineJoin: int = 0,
    overlay: bool = True,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> pymupdf.Point:
    """Draw a special Bezier curve from p1 to p3, generating control points on lines p1 to p2 and p2 to p3."""
    img = page.new_shape()
    Q = img.draw_curve(pymupdf.Point(p1), pymupdf.Point(p2), pymupdf.Point(p3))
    img.finish(
        color=color,
        fill=fill,
        dashes=dashes,
        width=width,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        closePath=closePath,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return Q


def draw_bezier(
    page: pymupdf.Page,
    p1: point_like,
    p2: point_like,
    p3: point_like,
    p4: point_like,
    color: OptSeq = (0,),
    fill: OptSeq = None,
    dashes: OptStr = None,
    width: float = 1,
    morph: OptStr = None,
    closePath: bool = False,
    lineCap: int = 0,
    lineJoin: int = 0,
    overlay: bool = True,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> pymupdf.Point:
    """Draw a general cubic Bezier curve from p1 to p4 using control points p2 and p3."""
    img = page.new_shape()
    Q = img.draw_bezier(pymupdf.Point(p1), pymupdf.Point(p2), pymupdf.Point(p3), pymupdf.Point(p4))
    img.finish(
        color=color,
        fill=fill,
        dashes=dashes,
        width=width,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        closePath=closePath,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return Q


def draw_sector(
    page: pymupdf.Page,
    center: point_like,
    point: point_like,
    beta: float,
    color: OptSeq = (0,),
    fill: OptSeq = None,
    dashes: OptStr = None,
    fullSector: bool = True,
    morph: OptSeq = None,
    width: float = 1,
    closePath: bool = False,
    lineCap: int = 0,
    lineJoin: int = 0,
    overlay: bool = True,
    stroke_opacity: float = 1,
    fill_opacity: float = 1,
    oc: int = 0,
) -> pymupdf.Point:
    """Draw a circle sector given circle center, one arc end point and the angle of the arc.

    Parameters:
        center -- center of circle
        point -- arc end point
        beta -- angle of arc (degrees)
        fullSector -- connect arc ends with center
    """
    img = page.new_shape()
    Q = img.draw_sector(pymupdf.Point(center), pymupdf.Point(point), beta, fullSector=fullSector)
    img.finish(
        color=color,
        fill=fill,
        dashes=dashes,
        width=width,
        lineCap=lineCap,
        lineJoin=lineJoin,
        morph=morph,
        closePath=closePath,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        oc=oc,
    )
    img.commit(overlay)

    return Q


# ----------------------------------------------------------------------
# Name:        wx.lib.colourdb.py
# Purpose:     Adds a bunch of colour names and RGB values to the
#              colour database so they can be found by name
#
# Author:      Robin Dunn
#
# Created:     13-March-2001
# Copyright:   (c) 2001-2017 by Total Control Software
# Licence:     wxWindows license
# Tags:        phoenix-port, unittest, documented
# ----------------------------------------------------------------------


def getColorList() -> list:
    """
    Returns a list of upper-case colour names.
    :rtype: list of strings
    """
    return [name for name, r, g, b in pymupdf.colors_wx_list()]


def getColorInfoList() -> list:
    """
    Returns list of (name, red, gree, blue) tuples, where:
        name: upper-case color name.
        read, green, blue: integers in range 0..255.
    :rtype: list of tuples
    """
    return pymupdf.colors_wx_list()


def getColor(name: str) -> tuple:
    """Retrieve RGB color in PDF format by name.

    Returns:
        a triple of floats in range 0 to 1. In case of name-not-found, "white" is returned.
    """
    return pymupdf.colors_pdf_dict().get(name.lower(), (1, 1, 1))


def getColorHSV(name: str) -> tuple:
    """Retrieve the hue, saturation, value triple of a color name.

    Returns:
        a triple (degree, percent, percent). If not found (-1, -1, -1) is returned.
    """
    try:
        x = getColorInfoList()[getColorList().index(name.upper())]
    except Exception:
        if g_exceptions_verbose:    pymupdf.exception_info()
        return (-1, -1, -1)

    r = x[1] / 255.0
    g = x[2] / 255.0
    b = x[3] / 255.0
    cmax = max(r, g, b)
    V = round(cmax * 100, 1)
    cmin = min(r, g, b)
    delta = cmax - cmin
    if delta == 0:
        hue = 0
    elif cmax == r:
        hue = 60.0 * (((g - b) / delta) % 6)
    elif cmax == g:
        hue = 60.0 * (((b - r) / delta) + 2)
    else:
        hue = 60.0 * (((r - g) / delta) + 4)

    H = int(round(hue))

    if cmax == 0:
        sat = 0
    else:
        sat = delta / cmax
    S = int(round(sat * 100))

    return (H, S, V)


def _get_font_properties(doc: pymupdf.Document, xref: int) -> tuple:
    fontname, ext, stype, buffer = doc.extract_font(xref)
    asc = 0.8
    dsc = -0.2
    if ext == "":
        return fontname, ext, stype, asc, dsc

    if buffer:
        try:
            font = pymupdf.Font(fontbuffer=buffer)
            asc = font.ascender
            dsc = font.descender
            bbox = font.bbox
            if asc - dsc < 1:
                if bbox.y0 < dsc:
                    dsc = bbox.y0
                asc = 1 - dsc
        except Exception:
            pymupdf.exception_info()
            asc *= 1.2
            dsc *= 1.2
        return fontname, ext, stype, asc, dsc
    if ext != "n/a":
        try:
            font = pymupdf.Font(fontname)
            asc = font.ascender
            dsc = font.descender
        except Exception:
            pymupdf.exception_info()
            asc *= 1.2
            dsc *= 1.2
    else:
        asc *= 1.2
        dsc *= 1.2
    return fontname, ext, stype, asc, dsc


def get_char_widths(
    doc: pymupdf.Document, xref: int, limit: int = 256, idx: int = 0, fontdict: OptDict = None
) -> list:
    """Get list of glyph information of a font.

    Notes:
        Must be provided by its XREF number. If we already dealt with the
        font, it will be recorded in doc.FontInfos. Otherwise we insert an
        entry there.
        Finally we return the glyphs for the font. This is a list of
        (glyph, width) where glyph is an integer controlling the char
        appearance, and width is a float controlling the char's spacing:
        width * fontsize is the actual space.
        For 'simple' fonts, glyph == ord(char) will usually be true.
        Exceptions are 'Symbol' and 'ZapfDingbats'. We are providing data for these directly here.
    """
    fontinfo = pymupdf.CheckFontInfo(doc, xref)
    if fontinfo is None:  # not recorded yet: create it
        if fontdict is None:
            name, ext, stype, asc, dsc = _get_font_properties(doc, xref)
            fontdict = {
                "name": name,
                "type": stype,
                "ext": ext,
                "ascender": asc,
                "descender": dsc,
            }
        else:
            name = fontdict["name"]
            ext = fontdict["ext"]
            stype = fontdict["type"]
            ordering = fontdict["ordering"]
            simple = fontdict["simple"]

        if ext == "":
            raise ValueError("xref is not a font")

        # check for 'simple' fonts
        if stype in ("Type1", "MMType1", "TrueType"):
            simple = True
        else:
            simple = False

        # check for CJK fonts
        if name in ("Fangti", "Ming"):
            ordering = 0
        elif name in ("Heiti", "Song"):
            ordering = 1
        elif name in ("Gothic", "Mincho"):
            ordering = 2
        elif name in ("Dotum", "Batang"):
            ordering = 3
        else:
            ordering = -1

        fontdict["simple"] = simple

        if name == "ZapfDingbats":
            glyphs = pymupdf.zapf_glyphs
        elif name == "Symbol":
            glyphs = pymupdf.symbol_glyphs
        else:
            glyphs = None

        fontdict["glyphs"] = glyphs
        fontdict["ordering"] = ordering
        fontinfo = [xref, fontdict]
        doc.FontInfos.append(fontinfo)
    else:
        fontdict = fontinfo[1]
        glyphs = fontdict["glyphs"]
        simple = fontdict["simple"]
        ordering = fontdict["ordering"]

    if glyphs is None:
        oldlimit = 0
    else:
        oldlimit = len(glyphs)

    mylimit = max(256, limit)

    if mylimit <= oldlimit:
        return glyphs

    if ordering < 0:  # not a CJK font
        glyphs = doc._get_char_widths(
            xref, fontdict["name"], fontdict["ext"], fontdict["ordering"], mylimit, idx
        )
    else:  # CJK fonts use char codes and width = 1
        glyphs = None

    fontdict["glyphs"] = glyphs
    fontinfo[1] = fontdict
    pymupdf.UpdateFontInfo(doc, fontinfo)

    return glyphs


class Shape:
    """Create a new shape."""

    @staticmethod
    def horizontal_angle(C, P):
        """Return the angle to the horizontal for the connection from C to P.
        This uses the arcus sine function and resolves its inherent ambiguity by
        looking up in which quadrant vector S = P - C is located.
        """
        S = pymupdf.Point(P - C).unit  # unit vector 'C' -> 'P'
        alfa = math.asin(abs(S.y))  # absolute angle from horizontal
        if S.x < 0:  # make arcsin result unique
            if S.y <= 0:  # bottom-left
                alfa = -(math.pi - alfa)
            else:  # top-left
                alfa = math.pi - alfa
        else:
            if S.y >= 0:  # top-right
                pass
            else:  # bottom-right
                alfa = -alfa
        return alfa

    def __init__(self, page: pymupdf.Page):
        pymupdf.CheckParent(page)
        self.page = page
        self.doc = page.parent
        if not self.doc.is_pdf:
            raise ValueError("is no PDF")
        self.height = page.mediabox_size.y
        self.width = page.mediabox_size.x
        self.x = page.cropbox_position.x
        self.y = page.cropbox_position.y

        self.pctm = page.transformation_matrix  # page transf. matrix
        self.ipctm = ~self.pctm  # inverted transf. matrix

        self.draw_cont = ""
        self.text_cont = ""
        self.totalcont = ""
        self.last_point = None
        self.rect = None

    def updateRect(self, x):
        if self.rect is None:
            if len(x) == 2:
                self.rect = pymupdf.Rect(x, x)
            else:
                self.rect = pymupdf.Rect(x)

        else:
            if len(x) == 2:
                x = pymupdf.Point(x)
                self.rect.x0 = min(self.rect.x0, x.x)
                self.rect.y0 = min(self.rect.y0, x.y)
                self.rect.x1 = max(self.rect.x1, x.x)
                self.rect.y1 = max(self.rect.y1, x.y)
            else:
                x = pymupdf.Rect(x)
                self.rect.x0 = min(self.rect.x0, x.x0)
                self.rect.y0 = min(self.rect.y0, x.y0)
                self.rect.x1 = max(self.rect.x1, x.x1)
                self.rect.y1 = max(self.rect.y1, x.y1)

    def draw_line(self, p1: point_like, p2: point_like) -> pymupdf.Point:
        """Draw a line between two points."""
        p1 = pymupdf.Point(p1)
        p2 = pymupdf.Point(p2)
        if not (self.last_point == p1):
            self.draw_cont += _format_g(pymupdf.JM_TUPLE(p1 * self.ipctm)) + " m\n"
            self.last_point = p1
            self.updateRect(p1)

        self.draw_cont += _format_g(pymupdf.JM_TUPLE(p2 * self.ipctm)) + " l\n"
        self.updateRect(p2)
        self.last_point = p2
        return self.last_point

    def draw_polyline(self, points: list) -> pymupdf.Point:
        """Draw several connected line segments."""
        for i, p in enumerate(points):
            if i == 0:
                if not (self.last_point == pymupdf.Point(p)):
                    self.draw_cont += _format_g(pymupdf.JM_TUPLE(pymupdf.Point(p) * self.ipctm)) + " m\n"
                    self.last_point = pymupdf.Point(p)
            else:
                self.draw_cont += _format_g(pymupdf.JM_TUPLE(pymupdf.Point(p) * self.ipctm)) + " l\n"
            self.updateRect(p)

        self.last_point = pymupdf.Point(points[-1])
        return self.last_point

    def draw_bezier(
        self,
        p1: point_like,
        p2: point_like,
        p3: point_like,
        p4: point_like,
    ) -> pymupdf.Point:
        """Draw a standard cubic Bezier curve."""
        p1 = pymupdf.Point(p1)
        p2 = pymupdf.Point(p2)
        p3 = pymupdf.Point(p3)
        p4 = pymupdf.Point(p4)
        if not (self.last_point == p1):
            self.draw_cont += _format_g(pymupdf.JM_TUPLE(p1 * self.ipctm)) + " m\n"
        args = pymupdf.JM_TUPLE(list(p2 * self.ipctm) + list(p3 * self.ipctm) + list(p4 * self.ipctm))
        self.draw_cont += _format_g(args) + " c\n"
        self.updateRect(p1)
        self.updateRect(p2)
        self.updateRect(p3)
        self.updateRect(p4)
        self.last_point = p4
        return self.last_point

    def draw_oval(self, tetra: typing.Union[quad_like, rect_like]) -> pymupdf.Point:
        """Draw an ellipse inside a tetrapod."""
        if len(tetra) != 4:
            raise ValueError("invalid arg length")
        if hasattr(tetra[0], "__float__"):
            q = pymupdf.Rect(tetra).quad
        else:
            q = pymupdf.Quad(tetra)

        mt = q.ul + (q.ur - q.ul) * 0.5
        mr = q.ur + (q.lr - q.ur) * 0.5
        mb = q.ll + (q.lr - q.ll) * 0.5
        ml = q.ul + (q.ll - q.ul) * 0.5
        if not (self.last_point == ml):
            self.draw_cont += _format_g(pymupdf.JM_TUPLE(ml * self.ipctm)) + " m\n"
            self.last_point = ml
        self.draw_curve(ml, q.ll, mb)
        self.draw_curve(mb, q.lr, mr)
        self.draw_curve(mr, q.ur, mt)
        self.draw_curve(mt, q.ul, ml)
        self.updateRect(q.rect)
        self.last_point = ml
        return self.last_point

    def draw_circle(self, center: point_like, radius: float) -> pymupdf.Point:
        """Draw a circle given its center and radius."""
        if not radius > pymupdf.EPSILON:
            raise ValueError("radius must be positive")
        center = pymupdf.Point(center)
        p1 = center - (radius, 0)
        return self.draw_sector(center, p1, 360, fullSector=False)

    def draw_curve(
        self,
        p1: point_like,
        p2: point_like,
        p3: point_like,
    ) -> pymupdf.Point:
        """Draw a curve between points using one control point."""
        kappa = 0.55228474983
        p1 = pymupdf.Point(p1)
        p2 = pymupdf.Point(p2)
        p3 = pymupdf.Point(p3)
        k1 = p1 + (p2 - p1) * kappa
        k2 = p3 + (p2 - p3) * kappa
        return self.draw_bezier(p1, k1, k2, p3)

    def draw_sector(
        self,
        center: point_like,
        point: point_like,
        beta: float,
        fullSector: bool = True,
    ) -> pymupdf.Point:
        """Draw a circle sector."""
        center = pymupdf.Point(center)
        point = pymupdf.Point(point)
        l3 = lambda a, b: _format_g((a, b)) + " m\n"
        l4 = lambda a, b, c, d, e, f: _format_g((a, b, c, d, e, f)) + " c\n"
        l5 = lambda a, b: _format_g((a, b)) + " l\n"
        betar = math.radians(-beta)
        w360 = math.radians(math.copysign(360, betar)) * (-1)
        w90 = math.radians(math.copysign(90, betar))
        w45 = w90 / 2
        while abs(betar) > 2 * math.pi:
            betar += w360  # bring angle below 360 degrees
        if not (self.last_point == point):
            self.draw_cont += l3(*pymupdf.JM_TUPLE(point * self.ipctm))
            self.last_point = point
        Q = pymupdf.Point(0, 0)  # just make sure it exists
        C = center
        P = point
        S = P - C  # vector 'center' -> 'point'
        rad = abs(S)  # circle radius

        if not rad > pymupdf.EPSILON:
            raise ValueError("radius must be positive")

        alfa = self.horizontal_angle(center, point)
        while abs(betar) > abs(w90):  # draw 90 degree arcs
            q1 = C.x + math.cos(alfa + w90) * rad
            q2 = C.y + math.sin(alfa + w90) * rad
            Q = pymupdf.Point(q1, q2)  # the arc's end point
            r1 = C.x + math.cos(alfa + w45) * rad / math.cos(w45)
            r2 = C.y + math.sin(alfa + w45) * rad / math.cos(w45)
            R = pymupdf.Point(r1, r2)  # crossing point of tangents
            kappah = (1 - math.cos(w45)) * 4 / 3 / abs(R - Q)
            kappa = kappah * abs(P - Q)
            cp1 = P + (R - P) * kappa  # control point 1
            cp2 = Q + (R - Q) * kappa  # control point 2
            self.draw_cont += l4(*pymupdf.JM_TUPLE(
                list(cp1 * self.ipctm) + list(cp2 * self.ipctm) + list(Q * self.ipctm)
            ))

            betar -= w90  # reduce param angle by 90 deg
            alfa += w90  # advance start angle by 90 deg
            P = Q  # advance to arc end point
        # draw (remaining) arc
        if abs(betar) > 1e-3:  # significant degrees left?
            beta2 = betar / 2
            q1 = C.x + math.cos(alfa + betar) * rad
            q2 = C.y + math.sin(alfa + betar) * rad
            Q = pymupdf.Point(q1, q2)  # the arc's end point
            r1 = C.x + math.cos(alfa + beta2) * rad / math.cos(beta2)
            r2 = C.y + math.sin(alfa + beta2) * rad / math.cos(beta2)
            R = pymupdf.Point(r1, r2)  # crossing point of tangents
            # kappa height is 4/3 of segment height
            kappah = (1 - math.cos(beta2)) * 4 / 3 / abs(R - Q)  # kappa height
            kappa = kappah * abs(P - Q) / (1 - math.cos(betar))
            cp1 = P + (R - P) * kappa  # control point 1
            cp2 = Q + (R - Q) * kappa  # control point 2
            self.draw_cont += l4(*pymupdf.JM_TUPLE(
                list(cp1 * self.ipctm) + list(cp2 * self.ipctm) + list(Q * self.ipctm)
            ))
        if fullSector:
            self.draw_cont += l3(*pymupdf.JM_TUPLE(point * self.ipctm))
            self.draw_cont += l5(*pymupdf.JM_TUPLE(center * self.ipctm))
            self.draw_cont += l5(*pymupdf.JM_TUPLE(Q * self.ipctm))
        self.last_point = Q
        return self.last_point

    def draw_rect(self, rect: rect_like, *, radius=None) -> pymupdf.Point:
        """Draw a rectangle.

        Args:
            radius: if not None, the rectangle will have rounded corners.
                This is the radius of the curvature, given as percentage of
                the rectangle width or height. Valid are values 0 < v <= 0.5.
                For a sequence of two values, the corners will have different
                radii. Otherwise, the percentage will be computed from the
                shorter side. A value of (0.5, 0.5) will draw an ellipse.
        """
        r = pymupdf.Rect(rect)
        if radius is None:  # standard rectangle
            self.draw_cont += _format_g(pymupdf.JM_TUPLE(
                list(r.bl * self.ipctm) + [r.width, r.height]
            )) + " re\n"
            self.updateRect(r)
            self.last_point = r.tl
            return self.last_point
        # rounded corners requested. This requires 1 or 2 values, each
        # with 0 < value <= 0.5
        if hasattr(radius, "__float__"):
            if radius <= 0 or radius > 0.5:
                raise ValueError(f"bad radius value {radius}.")
            d = min(r.width, r.height) * radius
            px = (d, 0)
            py = (0, d)
        elif hasattr(radius, "__len__") and len(radius) == 2:
            rx, ry = radius
            px = (rx * r.width, 0)
            py = (0, ry * r.height)
            if min(rx, ry) <= 0 or max(rx, ry) > 0.5:
                raise ValueError(f"bad radius value {radius}.")
        else:
            raise ValueError(f"bad radius value {radius}.")

        lp = self.draw_line(r.tl + py, r.bl - py)
        lp = self.draw_curve(lp, r.bl, r.bl + px)

        lp = self.draw_line(lp, r.br - px)
        lp = self.draw_curve(lp, r.br, r.br - py)

        lp = self.draw_line(lp, r.tr + py)
        lp = self.draw_curve(lp, r.tr, r.tr - px)

        lp = self.draw_line(lp, r.tl + px)
        self.last_point = self.draw_curve(lp, r.tl, r.tl + py)

        self.updateRect(r)
        return self.last_point

    def draw_quad(self, quad: quad_like) -> pymupdf.Point:
        """Draw a Quad."""
        q = pymupdf.Quad(quad)
        return self.draw_polyline([q.ul, q.ll, q.lr, q.ur, q.ul])

    def draw_zigzag(
        self,
        p1: point_like,
        p2: point_like,
        breadth: float = 2,
    ) -> pymupdf.Point:
        """Draw a zig-zagged line from p1 to p2."""
        p1 = pymupdf.Point(p1)
        p2 = pymupdf.Point(p2)
        S = p2 - p1  # vector start - end
        rad = abs(S)  # distance of points
        cnt = 4 * int(round(rad / (4 * breadth), 0))  # always take full phases
        if cnt < 4:
            raise ValueError("points too close")
        mb = rad / cnt  # revised breadth
        matrix = pymupdf.Matrix(pymupdf.util_hor_matrix(p1, p2))  # normalize line to x-axis
        i_mat = ~matrix  # get original position
        points = []  # stores edges
        for i in range(1, cnt):
            if i % 4 == 1:  # point "above" connection
                p = pymupdf.Point(i, -1) * mb
            elif i % 4 == 3:  # point "below" connection
                p = pymupdf.Point(i, 1) * mb
            else:  # ignore others
                continue
            points.append(p * i_mat)
        self.draw_polyline([p1] + points + [p2])  # add start and end points
        return p2

    def draw_squiggle(
        self,
        p1: point_like,
        p2: point_like,
        breadth=2,
    ) -> pymupdf.Point:
        """Draw a squiggly line from p1 to p2."""
        p1 = pymupdf.Point(p1)
        p2 = pymupdf.Point(p2)
        S = p2 - p1  # vector start - end
        rad = abs(S)  # distance of points
        cnt = 4 * int(round(rad / (4 * breadth), 0))  # always take full phases
        if cnt < 4:
            raise ValueError("points too close")
        mb = rad / cnt  # revised breadth
        matrix = pymupdf.Matrix(pymupdf.util_hor_matrix(p1, p2))  # normalize line to x-axis
        i_mat = ~matrix  # get original position
        k = 2.4142135623765633  # y of draw_curve helper point

        points = []  # stores edges
        for i in range(1, cnt):
            if i % 4 == 1:  # point "above" connection
                p = pymupdf.Point(i, -k) * mb
            elif i % 4 == 3:  # point "below" connection
                p = pymupdf.Point(i, k) * mb
            else:  # else on connection line
                p = pymupdf.Point(i, 0) * mb
            points.append(p * i_mat)

        points = [p1] + points + [p2]
        cnt = len(points)
        i = 0
        while i + 2 < cnt:
            self.draw_curve(points[i], points[i + 1], points[i + 2])
            i += 2
        return p2

    # ==============================================================================
    # Shape.insert_text
    # ==============================================================================
    def insert_text(
        self,
        point: point_like,
        buffer: typing.Union[str, list],
        *,
        fontsize: float = 11,
        lineheight: OptFloat = None,
        fontname: str = "helv",
        fontfile: OptStr = None,
        set_simple: bool = 0,
        encoding: int = 0,
        color: OptSeq = None,
        fill: OptSeq = None,
        render_mode: int = 0,
        border_width: float = 0.05,
        miter_limit: float = 1,
        rotate: int = 0,
        morph: OptSeq = None,
        stroke_opacity: float = 1,
        fill_opacity: float = 1,
        oc: int = 0,
    ) -> int:

        # ensure 'text' is a list of strings, worth dealing with
        if not bool(buffer):
            return 0

        if type(buffer) not in (list, tuple):
            text = buffer.splitlines()
        else:
            text = buffer

        if not len(text) > 0:
            return 0

        point = pymupdf.Point(point)
        try:
            maxcode = max([ord(c) for c in " ".join(text)])
        except Exception:
            pymupdf.exception_info()
            return 0

        # ensure valid 'fontname'
        fname = fontname
        if fname.startswith("/"):
            fname = fname[1:]

        xref = self.page.insert_font(
            fontname=fname, fontfile=fontfile, encoding=encoding, set_simple=set_simple
        )
        fontinfo = pymupdf.CheckFontInfo(self.doc, xref)

        fontdict = fontinfo[1]
        ordering = fontdict["ordering"]
        simple = fontdict["simple"]
        bfname = fontdict["name"]
        ascender = fontdict["ascender"]
        descender = fontdict["descender"]
        if lineheight:
            lheight = fontsize * lineheight
        elif ascender - descender <= 1:
            lheight = fontsize * 1.2
        else:
            lheight = fontsize * (ascender - descender)

        if maxcode > 255:
            glyphs = self.doc.get_char_widths(xref, maxcode + 1)
        else:
            glyphs = fontdict["glyphs"]

        tab = []
        for t in text:
            if simple and bfname not in ("Symbol", "ZapfDingbats"):
                g = None
            else:
                g = glyphs
            tab.append(pymupdf.getTJstr(t, g, simple, ordering))
        text = tab

        color_str = pymupdf.ColorCode(color, "c")
        fill_str = pymupdf.ColorCode(fill, "f")
        if not fill and render_mode == 0:  # ensure fill color when 0 Tr
            fill = color
            fill_str = pymupdf.ColorCode(color, "f")

        morphing = pymupdf.CheckMorph(morph)
        rot = rotate
        if rot % 90 != 0:
            raise ValueError("bad rotate value")

        while rot < 0:
            rot += 360
        rot = rot % 360  # text rotate = 0, 90, 270, 180

        templ1 = lambda a, b, c, d, e, f, g: f"\nq\n{a}{b}BT\n{c}1 0 0 1 {_format_g((d, e))} Tm\n/{f} {_format_g(g)} Tf "
        templ2 = lambda a: f"TJ\n0 -{_format_g(a)} TD\n"
        cmp90 = "0 1 -1 0 0 0 cm\n"  # rotates 90 deg counter-clockwise
        cmm90 = "0 -1 1 0 0 0 cm\n"  # rotates 90 deg clockwise
        cm180 = "-1 0 0 -1 0 0 cm\n"  # rotates by 180 deg.
        height = self.height
        width = self.width

        # setting up for standard rotation directions
        # case rotate = 0
        if morphing:
            m1 = pymupdf.Matrix(1, 0, 0, 1, morph[0].x + self.x, height - morph[0].y - self.y)
            mat = ~m1 * morph[1] * m1
            cm = _format_g(pymupdf.JM_TUPLE(mat)) + " cm\n"
        else:
            cm = ""
        top = height - point.y - self.y  # start of 1st char
        left = point.x + self.x  # start of 1. char
        space = top  # space available
        #headroom = point.y + self.y  # distance to page border
        if rot == 90:
            left = height - point.y - self.y
            top = -point.x - self.x
            cm += cmp90
            space = width - abs(top)
            #headroom = point.x + self.x

        elif rot == 270:
            left = -height + point.y + self.y
            top = point.x + self.x
            cm += cmm90
            space = abs(top)
            #headroom = width - point.x - self.x

        elif rot == 180:
            left = -point.x - self.x
            top = -height + point.y + self.y
            cm += cm180
            space = abs(point.y + self.y)
            #headroom = height - point.y - self.y

        optcont = self.page._get_optional_content(oc)
        if optcont is not None:
            bdc = "/OC /%s BDC\n" % optcont
            emc = "EMC\n"
        else:
            bdc = emc = ""

        alpha = self.page._set_opacity(CA=stroke_opacity, ca=fill_opacity)
        if alpha is None:
            alpha = ""
        else:
            alpha = "/%s gs\n" % alpha
        nres = templ1(bdc, alpha, cm, left, top, fname, fontsize)

        if render_mode > 0:
            nres += "%i Tr " % render_mode
            nres += _format_g(border_width * fontsize) + " w "
            if miter_limit is not None:
                nres += _format_g(miter_limit) + " M "
        if color is not None:
            nres += color_str
        if fill is not None:
            nres += fill_str

        # =========================================================================
        #   start text insertion
        # =========================================================================
        nres += text[0]
        nlines = 1  # set output line counter
        if len(text) > 1:
            nres += templ2(lheight)  # line 1
        else:
            nres += 'TJ'
        for i in range(1, len(text)):
            if space < lheight:
                break  # no space left on page
            if i > 1:
                nres += "\nT* "
            nres += text[i] + 'TJ'
            space -= lheight
            nlines += 1

        nres += "\nET\n%sQ\n" % emc

        # =========================================================================
        #   end of text insertion
        # =========================================================================
        # update the /Contents object
        self.text_cont += nres
        return nlines

    # ==============================================================================
    # Shape.insert_textbox
    # ==============================================================================
    def insert_textbox(
        self,
        rect: rect_like,
        buffer: typing.Union[str, list],
        *,
        fontname: OptStr = "helv",
        fontfile: OptStr = None,
        fontsize: float = 11,
        lineheight: OptFloat = None,
        set_simple: bool = 0,
        encoding: int = 0,
        color: OptSeq = None,
        fill: OptSeq = None,
        expandtabs: int = 1,
        border_width: float = 0.05,
        miter_limit: float = 1,
        align: int = 0,
        render_mode: int = 0,
        rotate: int = 0,
        morph: OptSeq = None,
        stroke_opacity: float = 1,
        fill_opacity: float = 1,
        oc: int = 0,
    ) -> float:
        """Insert text into a given rectangle.

        Args:
            rect -- the textbox to fill
            buffer -- text to be inserted
            fontname -- a Base-14 font, font name or '/name'
            fontfile -- name of a font file
            fontsize -- font size
            lineheight -- overwrite the font property
            color -- RGB stroke color triple
            fill -- RGB fill color triple
            render_mode -- text rendering control
            border_width -- thickness of glyph borders as percentage of fontsize
            expandtabs -- handles tabulators with string function
            align -- left, center, right, justified
            rotate -- 0, 90, 180, or 270 degrees
            morph -- morph box with a matrix and a fixpoint
        Returns:
            unused or deficit rectangle area (float)
        """
        rect = pymupdf.Rect(rect)
        if rect.is_empty or rect.is_infinite:
            raise ValueError("text box must be finite and not empty")

        color_str = pymupdf.ColorCode(color, "c")
        fill_str = pymupdf.ColorCode(fill, "f")
        if fill is None and render_mode == 0:  # ensure fill color for 0 Tr
            fill = color
            fill_str = pymupdf.ColorCode(color, "f")

        optcont = self.page._get_optional_content(oc)
        if optcont is not None:
            bdc = "/OC /%s BDC\n" % optcont
            emc = "EMC\n"
        else:
            bdc = emc = ""

        # determine opacity / transparency
        alpha = self.page._set_opacity(CA=stroke_opacity, ca=fill_opacity)
        if alpha is None:
            alpha = ""
        else:
            alpha = "/%s gs\n" % alpha

        if rotate % 90 != 0:
            raise ValueError("rotate must be multiple of 90")

        rot = rotate
        while rot < 0:
            rot += 360
        rot = rot % 360

        # is buffer worth of dealing with?
        if not bool(buffer):
            return rect.height if rot in (0, 180) else rect.width

        cmp90 = "0 1 -1 0 0 0 cm\n"  # rotates counter-clockwise
        cmm90 = "0 -1 1 0 0 0 cm\n"  # rotates clockwise
        cm180 = "-1 0 0 -1 0 0 cm\n"  # rotates by 180 deg.
        height = self.height

        fname = fontname
        if fname.startswith("/"):
            fname = fname[1:]

        xref = self.page.insert_font(
            fontname=fname, fontfile=fontfile, encoding=encoding, set_simple=set_simple
        )
        fontinfo = pymupdf.CheckFontInfo(self.doc, xref)

        fontdict = fontinfo[1]
        ordering = fontdict["ordering"]
        simple = fontdict["simple"]
        glyphs = fontdict["glyphs"]
        bfname = fontdict["name"]
        ascender = fontdict["ascender"]
        descender = fontdict["descender"]

        if lineheight:
            lheight_factor = lineheight
        elif ascender - descender <= 1:
            lheight_factor = 1.2
        else:
            lheight_factor = ascender - descender
        lheight = fontsize * lheight_factor

        # create a list from buffer, split into its lines
        if type(buffer) in (list, tuple):
            t0 = "\n".join(buffer)
        else:
            t0 = buffer

        maxcode = max([ord(c) for c in t0])
        # replace invalid char codes for simple fonts
        if simple and maxcode > 255:
            t0 = "".join([c if ord(c) < 256 else "?" for c in t0])

        t0 = t0.splitlines()

        glyphs = self.doc.get_char_widths(xref, maxcode + 1)
        if simple and bfname not in ("Symbol", "ZapfDingbats"):
            tj_glyphs = None
        else:
            tj_glyphs = glyphs

        # ----------------------------------------------------------------------
        # calculate pixel length of a string
        # ----------------------------------------------------------------------
        def pixlen(x):
            """Calculate pixel length of x."""
            if ordering < 0:
                return sum([glyphs[ord(c)][1] for c in x]) * fontsize
            else:
                return len(x) * fontsize

        # ---------------------------------------------------------------------

        if ordering < 0:
            blen = glyphs[32][1] * fontsize  # pixel size of space character
        else:
            blen = fontsize

        text = ""  # output buffer

        if pymupdf.CheckMorph(morph):
            m1 = pymupdf.Matrix(
                1, 0, 0, 1, morph[0].x + self.x, self.height - morph[0].y - self.y
            )
            mat = ~m1 * morph[1] * m1
            cm = _format_g(pymupdf.JM_TUPLE(mat)) + " cm\n"
        else:
            cm = ""

        # ---------------------------------------------------------------------
        # adjust for text orientation / rotation
        # ---------------------------------------------------------------------
        progr = 1  # direction of line progress
        c_pnt = pymupdf.Point(0, fontsize * ascender)  # used for line progress
        if rot == 0:  # normal orientation
            point = rect.tl + c_pnt  # line 1 is 'lheight' below top
            maxwidth = rect.width  # pixels available in one line
            maxheight = rect.height  # available text height

        elif rot == 90:  # rotate counter clockwise
            c_pnt = pymupdf.Point(fontsize * ascender, 0)  # progress in x-direction
            point = rect.bl + c_pnt  # line 1 'lheight' away from left
            maxwidth = rect.height  # pixels available in one line
            maxheight = rect.width  # available text height
            cm += cmp90

        elif rot == 180:  # text upside down
            # progress upwards in y direction
            c_pnt = -pymupdf.Point(0, fontsize * ascender)
            point = rect.br + c_pnt  # line 1 'lheight' above bottom
            maxwidth = rect.width  # pixels available in one line
            progr = -1  # subtract lheight for next line
            maxheight =rect.height  # available text height
            cm += cm180

        else:  # rotate clockwise (270 or -90)
            # progress from right to left
            c_pnt = -pymupdf.Point(fontsize * ascender, 0)
            point = rect.tr + c_pnt  # line 1 'lheight' left of right
            maxwidth = rect.height  # pixels available in one line
            progr = -1  # subtract lheight for next line
            maxheight = rect.width  # available text height
            cm += cmm90

        # =====================================================================
        # line loop
        # =====================================================================
        just_tab = []  # 'justify' indicators per line

        for i, line in enumerate(t0):
            line_t = line.expandtabs(expandtabs).split(" ")  # split into words
            num_words = len(line_t)
            lbuff = ""  # init line buffer
            rest = maxwidth  # available line pixels
            # =================================================================
            # word loop
            # =================================================================
            for j in range(num_words):
                word = line_t[j]
                pl_w = pixlen(word)  # pixel len of word
                if rest >= pl_w:  # does it fit on the line?
                    lbuff += word + " "  # yes, append word
                    rest -= pl_w + blen  # update available line space
                    continue  # next word

                # word doesn't fit - output line (if not empty)
                if lbuff:
                    lbuff = lbuff.rstrip() + "\n"  # line full, append line break
                    text += lbuff  # append to total text
                    just_tab.append(True)  # can align-justify

                lbuff = ""  # re-init line buffer
                rest = maxwidth  # re-init avail. space

                if pl_w <= maxwidth:  # word shorter than 1 line?
                    lbuff = word + " "  # start the line with it
                    rest = maxwidth - pl_w - blen  # update free space
                    continue

                # long word: split across multiple lines - char by char ...
                if len(just_tab) > 0:
                    just_tab[-1] = False  # cannot align-justify
                for c in word:
                    if pixlen(lbuff) <= maxwidth - pixlen(c):
                        lbuff += c
                    else:  # line full
                        lbuff += "\n"  # close line
                        text += lbuff  # append to text
                        just_tab.append(False)  # cannot align-justify
                        lbuff = c  # start new line with this char

                lbuff += " "  # finish long word
                rest = maxwidth - pixlen(lbuff)  # long word stored

            if lbuff:  # unprocessed line content?
                text += lbuff.rstrip()  # append to text
                just_tab.append(False)  # cannot align-justify

            if i < len(t0) - 1:  # not the last line?
                text += "\n"  # insert line break

        # compute used part of the textbox
        if text.endswith("\n"):
            text = text[:-1]
        lb_count = text.count("\n") + 1  # number of lines written

        # text height = line count * line height plus one descender value
        text_height = lheight * lb_count - descender * fontsize

        more = text_height - maxheight  # difference to height limit
        if more > pymupdf.EPSILON:  # landed too much outside rect
            return (-1) * more  # return deficit, don't output

        more = abs(more)
        if more < pymupdf.EPSILON:
            more = 0  # don't bother with epsilons
        nres = "\nq\n%s%sBT\n" % (bdc, alpha) + cm  # initialize output buffer
        templ = lambda a, b, c, d: f"1 0 0 1 {_format_g((a, b))} Tm /{c} {_format_g(d)} Tf "
        # center, right, justify: output each line with its own specifics
        text_t = text.splitlines()  # split text in lines again
        just_tab[-1] = False  # never justify last line
        for i, t in enumerate(text_t):
            spacing = 0
            pl = maxwidth - pixlen(t)  # length of empty line part
            pnt = point + c_pnt * (i * lheight_factor)  # text start of line
            if align == 1:  # center: right shift by half width
                if rot in (0, 180):
                    pnt = pnt + pymupdf.Point(pl / 2, 0) * progr
                else:
                    pnt = pnt - pymupdf.Point(0, pl / 2) * progr
            elif align == 2:  # right: right shift by full width
                if rot in (0, 180):
                    pnt = pnt + pymupdf.Point(pl, 0) * progr
                else:
                    pnt = pnt - pymupdf.Point(0, pl) * progr
            elif align == 3:  # justify
                spaces = t.count(" ")  # number of spaces in line
                if spaces > 0 and just_tab[i]:  # if any, and we may justify
                    spacing = pl / spaces  # make every space this much larger
                else:
                    spacing = 0  # keep normal space length
            top = height - pnt.y - self.y
            left = pnt.x + self.x
            if rot == 90:
                left = height - pnt.y - self.y
                top = -pnt.x - self.x
            elif rot == 270:
                left = -height + pnt.y + self.y
                top = pnt.x + self.x
            elif rot == 180:
                left = -pnt.x - self.x
                top = -height + pnt.y + self.y

            nres += templ(left, top, fname, fontsize)

            if render_mode > 0:
                nres += "%i Tr " % render_mode
                nres += _format_g(border_width * fontsize) + " w "
                if miter_limit is not None:
                    nres += _format_g(miter_limit) + " M "

            if align == 3:
                nres += _format_g(spacing) + " Tw "

            if color is not None:
                nres += color_str
            if fill is not None:
                nres += fill_str
            nres += "%sTJ\n" % pymupdf.getTJstr(t, tj_glyphs, simple, ordering)

        nres += "ET\n%sQ\n" % emc

        self.text_cont += nres
        self.updateRect(rect)
        return more

    def finish(
        self,
        width: float = 1,
        color: OptSeq = (0,),
        fill: OptSeq = None,
        lineCap: int = 0,
        lineJoin: int = 0,
        dashes: OptStr = None,
        even_odd: bool = False,
        morph: OptSeq = None,
        closePath: bool = True,
        fill_opacity: float = 1,
        stroke_opacity: float = 1,
        oc: int = 0,
    ) -> None:
        """Finish the current drawing segment.

        Notes:
            Apply colors, opacity, dashes, line style and width, or
            morphing. Also whether to close the path
            by connecting last to first point.
        """
        if self.draw_cont == "":  # treat empty contents as no-op
            return

        if width == 0:  # border color makes no sense then
            color = None
        elif color is None:  # vice versa
            width = 0
        # if color == None and fill == None:
        #     raise ValueError("at least one of 'color' or 'fill' must be given")
        color_str = pymupdf.ColorCode(color, "c")  # ensure proper color string
        fill_str = pymupdf.ColorCode(fill, "f")  # ensure proper fill string

        optcont = self.page._get_optional_content(oc)
        if optcont is not None:
            self.draw_cont = "/OC /%s BDC\n" % optcont + self.draw_cont
            emc = "EMC\n"
        else:
            emc = ""

        alpha = self.page._set_opacity(CA=stroke_opacity, ca=fill_opacity)
        if alpha is not None:
            self.draw_cont = "/%s gs\n" % alpha + self.draw_cont

        if width != 1 and width != 0:
            self.draw_cont += _format_g(width) + " w\n"

        if lineCap != 0:
            self.draw_cont = "%i J\n" % lineCap + self.draw_cont
        if lineJoin != 0:
            self.draw_cont = "%i j\n" % lineJoin + self.draw_cont

        if dashes not in (None, "", "[] 0"):
            self.draw_cont = "%s d\n" % dashes + self.draw_cont

        if closePath:
            self.draw_cont += "h\n"
            self.last_point = None

        if color is not None:
            self.draw_cont += color_str

        if fill is not None:
            self.draw_cont += fill_str
            if color is not None:
                if not even_odd:
                    self.draw_cont += "B\n"
                else:
                    self.draw_cont += "B*\n"
            else:
                if not even_odd:
                    self.draw_cont += "f\n"
                else:
                    self.draw_cont += "f*\n"
        else:
            self.draw_cont += "S\n"

        self.draw_cont += emc
        if pymupdf.CheckMorph(morph):
            m1 = pymupdf.Matrix(
                1, 0, 0, 1, morph[0].x + self.x, self.height - morph[0].y - self.y
            )
            mat = ~m1 * morph[1] * m1
            self.draw_cont = _format_g(pymupdf.JM_TUPLE(mat)) + " cm\n" + self.draw_cont

        self.totalcont += "\nq\n" + self.draw_cont + "Q\n"
        self.draw_cont = ""
        self.last_point = None
        return

    def commit(self, overlay: bool = True) -> None:
        """Update the page's /Contents object with Shape data.

        The argument controls whether data appear in foreground (default)
        or background.
        """
        pymupdf.CheckParent(self.page)  # doc may have died meanwhile
        self.totalcont += self.text_cont
        self.totalcont = self.totalcont.encode()

        if self.totalcont:
            if overlay:
                self.page.wrap_contents()  # ensure a balanced graphics state
            # make /Contents object with dummy stream
            xref = pymupdf.TOOLS._insert_contents(self.page, b" ", overlay)
            # update it with potential compression
            self.doc.update_stream(xref, self.totalcont)

        self.last_point = None  # clean up ...
        self.rect = None  #
        self.draw_cont = ""  # for potential ...
        self.text_cont = ""  # ...
        self.totalcont = ""  # re-use


def apply_redactions(
    page: pymupdf.Page, images: int = 2, graphics: int = 1, text: int = 0
) -> bool:
    """Apply the redaction annotations of the page.

    Args:
        page: the PDF page.
        images:
              0 - ignore images
              1 - remove all overlapping images
              2 - blank out overlapping image parts
              3 - remove image unless invisible
        graphics:
              0 - ignore graphics
              1 - remove graphics if contained in rectangle
              2 - remove all overlapping graphics
        text:
              0 - remove text
              1 - ignore text
    """

    def center_rect(annot_rect, new_text, font, fsize):
        """Calculate minimal sub-rectangle for the overlay text.

        Notes:
            Because 'insert_textbox' supports no vertical text centering,
            we calculate an approximate number of lines here and return a
            sub-rect with smaller height, which should still be sufficient.
        Args:
            annot_rect: the annotation rectangle
            new_text: the text to insert.
            font: the fontname. Must be one of the CJK or Base-14 set, else
                the rectangle is returned unchanged.
            fsize: the fontsize
        Returns:
            A rectangle to use instead of the annot rectangle.
        """
        if not new_text or annot_rect.width <= pymupdf.EPSILON:
            return annot_rect
        try:
            text_width = pymupdf.get_text_length(new_text, font, fsize)
        except (ValueError, mupdf.FzErrorBase):  # unsupported font
            if g_exceptions_verbose:
                pymupdf.exception_info()
            return annot_rect
        line_height = fsize * 1.2
        limit = annot_rect.width
        h = math.ceil(text_width / limit) * line_height  # estimate rect height
        if h >= annot_rect.height:
            return annot_rect
        r = annot_rect
        y = (annot_rect.tl.y + annot_rect.bl.y - h) * 0.5
        r.y0 = y
        return r

    pymupdf.CheckParent(page)
    doc = page.parent
    if doc.is_encrypted or doc.is_closed:
        raise ValueError("document closed or encrypted")
    if not doc.is_pdf:
        raise ValueError("is no PDF")

    redact_annots = []  # storage of annot values
    for annot in page.annots(
        types=(pymupdf.PDF_ANNOT_REDACT,)  # pylint: disable=no-member
    ):
        # loop redactions
        redact_annots.append(annot._get_redact_values())  # save annot values

    if redact_annots == []:  # any redactions on this page?
        return False  # no redactions

    rc = page._apply_redactions(text, images, graphics)  # call MuPDF
    if not rc:  # should not happen really
        raise ValueError("Error applying redactions.")

    # now write replacement text in old redact rectangles
    shape = page.new_shape()
    for redact in redact_annots:
        annot_rect = redact["rect"]
        fill = redact["fill"]
        if fill:
            shape.draw_rect(annot_rect)  # colorize the rect background
            shape.finish(fill=fill, color=fill)
        if "text" in redact.keys():  # if we also have text
            new_text = redact["text"]
            align = redact.get("align", 0)
            fname = redact["fontname"]
            fsize = redact["fontsize"]
            color = redact["text_color"]
            # try finding vertical centered sub-rect
            trect = center_rect(annot_rect, new_text, fname, fsize)

            rc = -1
            while rc < 0 and fsize >= 4:  # while not enough room
                # (re-) try insertion
                rc = shape.insert_textbox(
                    trect,
                    new_text,
                    fontname=fname,
                    fontsize=fsize,
                    color=color,
                    align=align,
                )
                fsize -= 0.5  # reduce font if unsuccessful
    shape.commit()  # append new contents object
    return True


# ------------------------------------------------------------------------------
# Remove potentially sensitive data from a PDF. Similar to the Adobe
# Acrobat 'sanitize' function
# ------------------------------------------------------------------------------
def scrub(
    doc: pymupdf.Document,
    attached_files: bool = True,
    clean_pages: bool = True,
    embedded_files: bool = True,
    hidden_text: bool = True,
    javascript: bool = True,
    metadata: bool = True,
    redactions: bool = True,
    redact_images: int = 0,
    remove_links: bool = True,
    reset_fields: bool = True,
    reset_responses: bool = True,
    thumbnails: bool = True,
    xml_metadata: bool = True,
) -> None:
    def remove_hidden(cont_lines):
        """Remove hidden text from a PDF page.

        Args:
            cont_lines: list of lines with /Contents content. Should have status
                from after page.cleanContents().

        Returns:
            List of /Contents lines from which hidden text has been removed.

        Notes:
            The input must have been created after the page's /Contents object(s)
            have been cleaned with page.cleanContents(). This ensures a standard
            formatting: one command per line, single spaces between operators.
            This allows for drastic simplification of this code.
        """
        out_lines = []  # will return this
        in_text = False  # indicate if within BT/ET object
        suppress = False  # indicate text suppression active
        make_return = False
        for line in cont_lines:
            if line == b"BT":  # start of text object
                in_text = True  # switch on
                out_lines.append(line)  # output it
                continue
            if line == b"ET":  # end of text object
                in_text = False  # switch off
                out_lines.append(line)  # output it
                continue
            if line == b"3 Tr":  # text suppression operator
                suppress = True  # switch on
                make_return = True
                continue
            if line[-2:] == b"Tr" and line[0] != b"3":
                suppress = False  # text rendering changed
                out_lines.append(line)
                continue
            if line == b"Q":  # unstack command also switches off
                suppress = False
                out_lines.append(line)
                continue
            if suppress and in_text:  # suppress hidden lines
                continue
            out_lines.append(line)
        if make_return:
            return out_lines
        else:
            return None

    if not doc.is_pdf:  # only works for PDF
        raise ValueError("is no PDF")
    if doc.is_encrypted or doc.is_closed:
        raise ValueError("closed or encrypted doc")

    if not clean_pages:
        hidden_text = False
        redactions = False

    if metadata:
        doc.set_metadata({})  # remove standard metadata

    for page in doc:
        if reset_fields:
            # reset form fields (widgets)
            for widget in page.widgets():
                widget.reset()

        if remove_links:
            links = page.get_links()  # list of all links on page
            for link in links:  # remove all links
                page.delete_link(link)

        found_redacts = False
        for annot in page.annots():
            if annot.type[0] == mupdf.PDF_ANNOT_FILE_ATTACHMENT and attached_files:
                annot.update_file(buffer=b" ")  # set file content to empty
            if reset_responses:
                annot.delete_responses()
            if annot.type[0] == pymupdf.PDF_ANNOT_REDACT:  # pylint: disable=no-member
                found_redacts = True

        if redactions and found_redacts:
            page.apply_redactions(images=redact_images)

        if not (clean_pages or hidden_text):
            continue  # done with the page

        page.clean_contents()
        if not page.get_contents():
            continue
        if hidden_text:
            xref = page.get_contents()[0]  # only one b/o cleaning!
            cont = doc.xref_stream(xref)
            cont_lines = remove_hidden(cont.splitlines())  # remove hidden text
            if cont_lines:  # something was actually removed
                cont = b"\n".join(cont_lines)
                doc.update_stream(xref, cont)  # rewrite the page /Contents

        if thumbnails:  # remove page thumbnails?
            if doc.xref_get_key(page.xref, "Thumb")[0] != "null":
                doc.xref_set_key(page.xref, "Thumb", "null")

    # pages are scrubbed, now perform document-wide scrubbing
    # remove embedded files
    if embedded_files:
        for name in doc.embfile_names():
            doc.embfile_del(name)

    if xml_metadata:
        doc.del_xml_metadata()
    if not (xml_metadata or javascript):
        xref_limit = 0
    else:
        xref_limit = doc.xref_length()
    for xref in range(1, xref_limit):
        if not doc.xref_object(xref):
            msg = "bad xref %i - clean PDF before scrubbing" % xref
            raise ValueError(msg)
        if javascript and doc.xref_get_key(xref, "S")[1] == "/JavaScript":
            # a /JavaScript action object
            obj = "<</S/JavaScript/JS()>>"  # replace with a null JavaScript
            doc.update_object(xref, obj)  # update this object
            continue  # no further handling

        if not xml_metadata:
            continue

        if doc.xref_get_key(xref, "Type")[1] == "/Metadata":
            # delete any metadata object directly
            doc.update_object(xref, "<<>>")
            doc.update_stream(xref, b"deleted", new=True)
            continue

        if doc.xref_get_key(xref, "Metadata")[0] != "null":
            doc.xref_set_key(xref, "Metadata", "null")


def _show_fz_text( text):
    #if mupdf_cppyy:
    #    assert isinstance( text, cppyy.gbl.mupdf.Text)
    #else:
    #    assert isinstance( text, mupdf.Text)
    num_spans = 0
    num_chars = 0
    span = text.m_internal.head
    while 1:
        if not span:
            break
        num_spans += 1
        num_chars += span.len
        span = span.next
    return f'num_spans={num_spans} num_chars={num_chars}'

def fill_textbox(
    writer: pymupdf.TextWriter,
    rect: rect_like,
    text: typing.Union[str, list],
    pos: point_like = None,
    font: typing.Optional[pymupdf.Font] = None,
    fontsize: float = 11,
    lineheight: OptFloat = None,
    align: int = 0,
    warn: bool = None,
    right_to_left: bool = False,
    small_caps: bool = False,
) -> tuple:
    """Fill a rectangle with text.

    Args:
        writer: pymupdf.TextWriter object (= "self")
        rect: rect-like to receive the text.
        text: string or list/tuple of strings.
        pos: point-like start position of first word.
        font: pymupdf.Font object (default pymupdf.Font('helv')).
        fontsize: the fontsize.
        lineheight: overwrite the font property
        align: (int) 0 = left, 1 = center, 2 = right, 3 = justify
        warn: (bool) text overflow action: none, warn, or exception
        right_to_left: (bool) indicate right-to-left language.
    """
    rect = pymupdf.Rect(rect)
    if rect.is_empty:
        raise ValueError("fill rect must not empty.")
    if type(font) is not pymupdf.Font:
        font = pymupdf.Font("helv")

    def textlen(x):
        """Return length of a string."""
        return font.text_length(
            x, fontsize=fontsize, small_caps=small_caps
        )  # abbreviation

    def char_lengths(x):
        """Return list of single character lengths for a string."""
        return font.char_lengths(x, fontsize=fontsize, small_caps=small_caps)

    def append_this(pos, text):
        ret = writer.append(
                pos, text, font=font, fontsize=fontsize, small_caps=small_caps
                )
        return ret

    tolerance = fontsize * 0.2  # extra distance to left border
    space_len = textlen(" ")
    std_width = rect.width - tolerance
    std_start = rect.x0 + tolerance

    def norm_words(width, words):
        """Cut any word in pieces no longer than 'width'."""
        nwords = []
        word_lengths = []
        for w in words:
            wl_lst = char_lengths(w)
            wl = sum(wl_lst)
            if wl <= width:  # nothing to do - copy over
                nwords.append(w)
                word_lengths.append(wl)
                continue

            # word longer than rect width - split it in parts
            n = len(wl_lst)
            while n > 0:
                wl = sum(wl_lst[:n])
                if wl <= width:
                    nwords.append(w[:n])
                    word_lengths.append(wl)
                    w = w[n:]
                    wl_lst = wl_lst[n:]
                    n = len(wl_lst)
                else:
                    n -= 1
        return nwords, word_lengths

    def output_justify(start, line):
        """Justified output of a line."""
        # ignore leading / trailing / multiple spaces
        words = [w for w in line.split(" ") if w != ""]
        nwords = len(words)
        if nwords == 0:
            return
        if nwords == 1:  # single word cannot be justified
            append_this(start, words[0])
            return
        tl = sum([textlen(w) for w in words])  # total word lengths
        gaps = nwords - 1  # number of word gaps
        gapl = (std_width - tl) / gaps  # width of each gap
        for w in words:
            _, lp = append_this(start, w)  # output one word
            start.x = lp.x + gapl  # next start at word end plus gap
        return

    asc = font.ascender
    dsc = font.descender
    if not lineheight:
        if asc - dsc <= 1:
            lheight = 1.2
        else:
            lheight = asc - dsc
    else:
        lheight = lineheight

    LINEHEIGHT = fontsize * lheight  # effective line height
    width = std_width  # available horizontal space

    # starting point of text
    if pos is not None:
        pos = pymupdf.Point(pos)
    else:  # default is just below rect top-left
        pos = rect.tl + (tolerance, fontsize * asc)
    if pos not in rect:
        raise ValueError("Text must start in rectangle.")

    # calculate displacement factor for alignment
    if align == pymupdf.TEXT_ALIGN_CENTER:
        factor = 0.5
    elif align == pymupdf.TEXT_ALIGN_RIGHT:
        factor = 1.0
    else:
        factor = 0

    # split in lines if just a string was given
    if type(text) is str:
        textlines = text.splitlines()
    else:
        textlines = []
        for line in text:
            textlines.extend(line.splitlines())

    max_lines = int((rect.y1 - pos.y) / LINEHEIGHT) + 1

    new_lines = []  # the final list of textbox lines
    no_justify = []  # no justify for these line numbers
    for i, line in enumerate(textlines):
        if line in ("", " "):
            new_lines.append((line, space_len))
            width = rect.width - tolerance
            no_justify.append((len(new_lines) - 1))
            continue
        if i == 0:
            width = rect.x1 - pos.x
        else:
            width = rect.width - tolerance

        if right_to_left:  # reverses Arabic / Hebrew text front to back
            line = writer.clean_rtl(line)
        tl = textlen(line)
        if tl <= width:  # line short enough
            new_lines.append((line, tl))
            no_justify.append((len(new_lines) - 1))
            continue

        # we need to split the line in fitting parts
        words = line.split(" ")  # the words in the line

        # cut in parts any words that are longer than rect width
        words, word_lengths = norm_words(width, words)

        n = len(words)
        while True:
            line0 = " ".join(words[:n])
            wl = sum(word_lengths[:n]) + space_len * (n - 1)
            if wl <= width:
                new_lines.append((line0, wl))
                words = words[n:]
                word_lengths = word_lengths[n:]
                n = len(words)
                line0 = None
            else:
                n -= 1

            if len(words) == 0:
                break
            assert n

    # -------------------------------------------------------------------------
    # List of lines created. Each item is (text, tl), where 'tl' is the PDF
    # output length (float) and 'text' is the text. Except for justified text,
    # this is output-ready.
    # -------------------------------------------------------------------------
    nlines = len(new_lines)
    if nlines > max_lines:
        msg = "Only fitting %i of %i lines." % (max_lines, nlines)
        if warn is None:
            pass
        elif warn:
            pymupdf.message("Warning: " + msg)
        else:
            raise ValueError(msg)

    start = pymupdf.Point()
    no_justify += [len(new_lines) - 1]  # no justifying of last line
    for i in range(max_lines):
        try:
            line, tl = new_lines.pop(0)
        except IndexError:
            if g_exceptions_verbose >= 2:   pymupdf.exception_info()
            break

        if right_to_left:  # Arabic, Hebrew
            line = "".join(reversed(line))

        if i == 0:  # may have different start for first line
            start = pos

        if align == pymupdf.TEXT_ALIGN_JUSTIFY and i not in no_justify and tl < std_width:
            output_justify(start, line)
            start.x = std_start
            start.y += LINEHEIGHT
            continue

        if i > 0 or pos.x == std_start:  # left, center, right alignments
            start.x += (width - tl) * factor

        append_this(start, line)
        start.x = std_start
        start.y += LINEHEIGHT

    return new_lines  # return non-written lines


# ------------------------------------------------------------------------
# Optional Content functions
# ------------------------------------------------------------------------
def get_oc(doc: pymupdf.Document, xref: int) -> int:
    """Return optional content object xref for an image or form xobject.

    Args:
        xref: (int) xref number of an image or form xobject.
    """
    if doc.is_closed or doc.is_encrypted:
        raise ValueError("document close or encrypted")
    t, name = doc.xref_get_key(xref, "Subtype")
    if t != "name" or name not in ("/Image", "/Form"):
        raise ValueError("bad object type at xref %i" % xref)
    t, oc = doc.xref_get_key(xref, "OC")
    if t != "xref":
        return 0
    rc = int(oc.replace("0 R", ""))
    return rc


def set_oc(doc: pymupdf.Document, xref: int, oc: int) -> None:
    """Attach optional content object to image or form xobject.

    Args:
        xref: (int) xref number of an image or form xobject
        oc: (int) xref number of an OCG or OCMD
    """
    if doc.is_closed or doc.is_encrypted:
        raise ValueError("document close or encrypted")
    t, name = doc.xref_get_key(xref, "Subtype")
    if t != "name" or name not in ("/Image", "/Form"):
        raise ValueError("bad object type at xref %i" % xref)
    if oc > 0:
        t, name = doc.xref_get_key(oc, "Type")
        if t != "name" or name not in ("/OCG", "/OCMD"):
            raise ValueError("bad object type at xref %i" % oc)
    if oc == 0 and "OC" in doc.xref_get_keys(xref):
        doc.xref_set_key(xref, "OC", "null")
        return None
    doc.xref_set_key(xref, "OC", "%i 0 R" % oc)
    return None


def set_ocmd(
    doc: pymupdf.Document,
    xref: int = 0,
    ocgs: typing.Union[list, None] = None,
    policy: OptStr = None,
    ve: typing.Union[list, None] = None,
) -> int:
    """Create or update an OCMD object in a PDF document.

    Args:
        xref: (int) 0 for creating a new object, otherwise update existing one.
        ocgs: (list) OCG xref numbers, which shall be subject to 'policy'.
        policy: one of 'AllOn', 'AllOff', 'AnyOn', 'AnyOff' (any casing).
        ve: (list) visibility expression. Use instead of 'ocgs' with 'policy'.

    Returns:
        Xref of the created or updated OCMD.
    """

    all_ocgs = set(doc.get_ocgs().keys())

    def ve_maker(ve):
        if type(ve) not in (list, tuple) or len(ve) < 2:
            raise ValueError("bad 've' format: %s" % ve)
        if ve[0].lower() not in ("and", "or", "not"):
            raise ValueError("bad operand: %s" % ve[0])
        if ve[0].lower() == "not" and len(ve) != 2:
            raise ValueError("bad 've' format: %s" % ve)
        item = "[/%s" % ve[0].title()
        for x in ve[1:]:
            if type(x) is int:
                if x not in all_ocgs:
                    raise ValueError("bad OCG %i" % x)
                item += " %i 0 R" % x
            else:
                item += " %s" % ve_maker(x)
        item += "]"
        return item

    text = "<</Type/OCMD"

    if ocgs and type(ocgs) in (list, tuple):  # some OCGs are provided
        s = set(ocgs).difference(all_ocgs)  # contains illegal xrefs
        if s != set():
            msg = "bad OCGs: %s" % s
            raise ValueError(msg)
        text += "/OCGs[" + " ".join(map(lambda x: "%i 0 R" % x, ocgs)) + "]"

    if policy:
        policy = str(policy).lower()
        pols = {
            "anyon": "AnyOn",
            "allon": "AllOn",
            "anyoff": "AnyOff",
            "alloff": "AllOff",
        }
        if policy not in ("anyon", "allon", "anyoff", "alloff"):
            raise ValueError("bad policy: %s" % policy)
        text += "/P/%s" % pols[policy]

    if ve:
        text += "/VE%s" % ve_maker(ve)

    text += ">>"

    # make new object or replace old OCMD (check type first)
    if xref == 0:
        xref = doc.get_new_xref()
    elif "/Type/OCMD" not in doc.xref_object(xref, compressed=True):
        raise ValueError("bad xref or not an OCMD")
    doc.update_object(xref, text)
    return xref


def get_ocmd(doc: pymupdf.Document, xref: int) -> dict:
    """Return the definition of an OCMD (optional content membership dictionary).

    Recognizes PDF dict keys /OCGs (PDF array of OCGs), /P (policy string) and
    /VE (visibility expression, PDF array). Via string manipulation, this
    info is converted to a Python dictionary with keys "xref", "ocgs", "policy"
    and "ve" - ready to recycle as input for 'set_ocmd()'.
    """

    if xref not in range(doc.xref_length()):
        raise ValueError("bad xref")
    text = doc.xref_object(xref, compressed=True)
    if "/Type/OCMD" not in text:
        raise ValueError("bad object type")
    textlen = len(text)

    p0 = text.find("/OCGs[")  # look for /OCGs key
    p1 = text.find("]", p0)
    if p0 < 0 or p1 < 0:  # no OCGs found
        ocgs = None
    else:
        ocgs = text[p0 + 6 : p1].replace("0 R", " ").split()
        ocgs = list(map(int, ocgs))

    p0 = text.find("/P/")  # look for /P policy key
    if p0 < 0:
        policy = None
    else:
        p1 = text.find("ff", p0)
        if p1 < 0:
            p1 = text.find("on", p0)
        if p1 < 0:  # some irregular syntax
            raise ValueError("bad object at xref")
        else:
            policy = text[p0 + 3 : p1 + 2]

    p0 = text.find("/VE[")  # look for /VE visibility expression key
    if p0 < 0:  # no visibility expression found
        ve = None
    else:
        lp = rp = 0  # find end of /VE by finding last ']'.
        p1 = p0
        while lp < 1 or lp != rp:
            p1 += 1
            if not p1 < textlen:  # some irregular syntax
                raise ValueError("bad object at xref")
            if text[p1] == "[":
                lp += 1
            if text[p1] == "]":
                rp += 1
        # p1 now positioned at the last "]"
        ve = text[p0 + 3 : p1 + 1]  # the PDF /VE array
        ve = (
            ve.replace("/And", '"and",')
            .replace("/Not", '"not",')
            .replace("/Or", '"or",')
        )
        ve = ve.replace(" 0 R]", "]").replace(" 0 R", ",").replace("][", "],[")
        import json
        try:
            ve = json.loads(ve)
        except Exception:
            pymupdf.exception_info()
            pymupdf.message(f"bad /VE key: {ve!r}")
            raise
    return {"xref": xref, "ocgs": ocgs, "policy": policy, "ve": ve}


"""
Handle page labels for PDF documents.

Reading
-------
* compute the label of a page
* find page number(s) having the given label.

Writing
-------
Supports setting (defining) page labels for PDF documents.

A big Thank You goes to WILLIAM CHAPMAN who contributed the idea and
significant parts of the following code during late December 2020
through early January 2021.
"""


def rule_dict(item):
    """Make a Python dict from a PDF page label rule.

    Args:
        item -- a tuple (pno, rule) with the start page number and the rule
                string like <</S/D...>>.
    Returns:
        A dict like
        {'startpage': int, 'prefix': str, 'style': str, 'firstpagenum': int}.
    """
    # Jorj McKie, 2021-01-06

    pno, rule = item
    rule = rule[2:-2].split("/")[1:]  # strip "<<" and ">>"
    d = {"startpage": pno, "prefix": "", "firstpagenum": 1}
    skip = False
    for i, item in enumerate(rule): # pylint: disable=redefined-argument-from-local
        if skip:  # this item has already been processed
            skip = False  # deactivate skipping again
            continue
        if item == "S":  # style specification
            d["style"] = rule[i + 1]  # next item has the style
            skip = True  # do not process next item again
            continue
        if item.startswith("P"):  # prefix specification: extract the string
            x = item[1:].replace("(", "").replace(")", "")
            d["prefix"] = x
            continue
        if item.startswith("St"):  # start page number specification
            x = int(item[2:])
            d["firstpagenum"] = x
    return d


def get_label_pno(pgNo, labels):
    """Return the label for this page number.

    Args:
        pgNo: page number, 0-based.
        labels: result of doc._get_page_labels().
    Returns:
        The label (str) of the page number. Errors return an empty string.
    """
    # Jorj McKie, 2021-01-06

    item = [x for x in labels if x[0] <= pgNo][-1]
    rule = rule_dict(item)
    prefix = rule.get("prefix", "")
    style = rule.get("style", "")
    # make sure we start at 0 when enumerating the alphabet
    delta = -1 if style in ("a", "A") else 0
    pagenumber = pgNo - rule["startpage"] + rule["firstpagenum"] + delta
    return construct_label(style, prefix, pagenumber)


def get_label(page):
    """Return the label for this PDF page.

    Args:
        page: page object.
    Returns:
        The label (str) of the page. Errors return an empty string.
    """
    # Jorj McKie, 2021-01-06

    labels = page.parent._get_page_labels()
    if not labels:
        return ""
    labels.sort()
    return get_label_pno(page.number, labels)


def get_page_numbers(doc, label, only_one=False):
    """Return a list of page numbers with the given label.

    Args:
        doc: PDF document object (resp. 'self').
        label: (str) label.
        only_one: (bool) stop searching after first hit.
    Returns:
        List of page numbers having this label.
    """
    # Jorj McKie, 2021-01-06

    numbers = []
    if not label:
        return numbers
    labels = doc._get_page_labels()
    if labels == []:
        return numbers
    for i in range(doc.page_count):
        plabel = get_label_pno(i, labels)
        if plabel == label:
            numbers.append(i)
            if only_one:
                break
    return numbers


def construct_label(style, prefix, pno) -> str:
    """Construct a label based on style, prefix and page number."""
    # William Chapman, 2021-01-06

    n_str = ""
    if style == "D":
        n_str = str(pno)
    elif style == "r":
        n_str = integerToRoman(pno).lower()
    elif style == "R":
        n_str = integerToRoman(pno).upper()
    elif style == "a":
        n_str = integerToLetter(pno).lower()
    elif style == "A":
        n_str = integerToLetter(pno).upper()
    result = prefix + n_str
    return result


def integerToLetter(i) -> str:
    """Returns letter sequence string for integer i."""
    # William Chapman, Jorj McKie, 2021-01-06
    import string
    ls = string.ascii_uppercase
    n, a = 1, i
    while pow(26, n) <= a:
        a -= int(math.pow(26, n))
        n += 1

    str_t = ""
    for j in reversed(range(n)):
        f, g = divmod(a, int(math.pow(26, j)))
        str_t += ls[f]
        a = g
    return str_t


def integerToRoman(num: int) -> str:
    """Return roman numeral for an integer."""
    # William Chapman, Jorj McKie, 2021-01-06

    roman = (
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    )

    def roman_num(num):
        for r, ltr in roman:
            x, _ = divmod(num, r)
            yield ltr * x
            num -= r * x
            if num <= 0:
                break

    return "".join([a for a in roman_num(num)])


def get_page_labels(doc):
    """Return page label definitions in PDF document.

    Args:
        doc: PDF document (resp. 'self').
    Returns:
        A list of dictionaries with the following format:
        {'startpage': int, 'prefix': str, 'style': str, 'firstpagenum': int}.
    """
    # Jorj McKie, 2021-01-10
    return [rule_dict(item) for item in doc._get_page_labels()]


def set_page_labels(doc, labels):
    """Add / replace page label definitions in PDF document.

    Args:
        doc: PDF document (resp. 'self').
        labels: list of label dictionaries like:
        {'startpage': int, 'prefix': str, 'style': str, 'firstpagenum': int},
        as returned by get_page_labels().
    """
    # William Chapman, 2021-01-06

    def create_label_str(label):
        """Convert Python label dict to corresponding PDF rule string.

        Args:
            label: (dict) build rule for the label.
        Returns:
            PDF label rule string wrapped in "<<", ">>".
        """
        s = "%i<<" % label["startpage"]
        if label.get("prefix", "") != "":
            s += "/P(%s)" % label["prefix"]
        if label.get("style", "") != "":
            s += "/S/%s" % label["style"]
        if label.get("firstpagenum", 1) > 1:
            s += "/St %i" % label["firstpagenum"]
        s += ">>"
        return s

    def create_nums(labels):
        """Return concatenated string of all labels rules.

        Args:
            labels: (list) dictionaries as created by function 'rule_dict'.
        Returns:
            PDF compatible string for page label definitions, ready to be
            enclosed in PDF array 'Nums[...]'.
        """
        labels.sort(key=lambda x: x["startpage"])
        s = "".join([create_label_str(label) for label in labels])
        return s

    doc._set_page_labels(create_nums(labels))


# End of Page Label Code -------------------------------------------------


def has_links(doc: pymupdf.Document) -> bool:
    """Check whether there are links on any page."""
    if doc.is_closed:
        raise ValueError("document closed")
    if not doc.is_pdf:
        raise ValueError("is no PDF")
    for i in range(doc.page_count):
        for item in doc.page_annot_xrefs(i):
            if item[1] == pymupdf.PDF_ANNOT_LINK:  # pylint: disable=no-member
                return True
    return False


def has_annots(doc: pymupdf.Document) -> bool:
    """Check whether there are annotations on any page."""
    if doc.is_closed:
        raise ValueError("document closed")
    if not doc.is_pdf:
        raise ValueError("is no PDF")
    for i in range(doc.page_count):
        for item in doc.page_annot_xrefs(i):
            # pylint: disable=no-member
            if not (item[1] == pymupdf.PDF_ANNOT_LINK or item[1] == pymupdf.PDF_ANNOT_WIDGET):  # pylint: disable=no-member
                return True
    return False


# -------------------------------------------------------------------
# Functions to recover the quad contained in a text extraction bbox
# -------------------------------------------------------------------
def recover_bbox_quad(line_dir: tuple, span: dict, bbox: tuple) -> pymupdf.Quad:
    """Compute the quad located inside the bbox.

    The bbox may be any of the resp. tuples occurring inside the given span.

    Args:
        line_dir: (tuple) 'line["dir"]' of the owning line or None.
        span: (dict) the span. May be from get_texttrace() method.
        bbox: (tuple) the bbox of the span or any of its characters.
    Returns:
        The quad which is wrapped by the bbox.
    """
    if line_dir is None:
        line_dir = span["dir"]
    cos, sin = line_dir
    bbox = pymupdf.Rect(bbox)  # make it a rect
    if pymupdf.TOOLS.set_small_glyph_heights():  # ==> just fontsize as height
        d = 1
    else:
        d = span["ascender"] - span["descender"]

    height = d * span["size"]  # the quad's rectangle height
    # The following are distances from the bbox corners, at which we find the
    # respective quad points. The computation depends on in which quadrant the
    # text writing angle is located.
    hs = height * sin
    hc = height * cos
    if hc >= 0 and hs <= 0:  # quadrant 1
        ul = bbox.bl - (0, hc)
        ur = bbox.tr + (hs, 0)
        ll = bbox.bl - (hs, 0)
        lr = bbox.tr + (0, hc)
    elif hc <= 0 and hs <= 0:  # quadrant 2
        ul = bbox.br + (hs, 0)
        ur = bbox.tl - (0, hc)
        ll = bbox.br + (0, hc)
        lr = bbox.tl - (hs, 0)
    elif hc <= 0 and hs >= 0:  # quadrant 3
        ul = bbox.tr - (0, hc)
        ur = bbox.bl + (hs, 0)
        ll = bbox.tr - (hs, 0)
        lr = bbox.bl + (0, hc)
    else:  # quadrant 4
        ul = bbox.tl + (hs, 0)
        ur = bbox.br - (0, hc)
        ll = bbox.tl + (0, hc)
        lr = bbox.br - (hs, 0)
    return pymupdf.Quad(ul, ur, ll, lr)


def recover_quad(line_dir: tuple, span: dict) -> pymupdf.Quad:
    """Recover the quadrilateral of a text span.

    Args:
        line_dir: (tuple) 'line["dir"]' of the owning line.
        span: the span.
    Returns:
        The quadrilateral enveloping the span's text.
    """
    if type(line_dir) is not tuple or len(line_dir) != 2:
        raise ValueError("bad line dir argument")
    if type(span) is not dict:
        raise ValueError("bad span argument")
    return recover_bbox_quad(line_dir, span, span["bbox"])


def recover_line_quad(line: dict, spans: list = None) -> pymupdf.Quad:
    """Calculate the line quad for 'dict' / 'rawdict' text extractions.

    The lower quad points are those of the first, resp. last span quad.
    The upper points are determined by the maximum span quad height.
    From this, compute a rect with bottom-left in (0, 0), convert this to a
    quad and rotate and shift back to cover the text of the spans.

    Args:
        spans: (list, optional) sub-list of spans to consider.
    Returns:
        pymupdf.Quad covering selected spans.
    """
    if spans is None:  # no sub-selection
        spans = line["spans"]  # all spans
    if len(spans) == 0:
        raise ValueError("bad span list")
    line_dir = line["dir"]  # text direction
    cos, sin = line_dir
    q0 = recover_quad(line_dir, spans[0])  # quad of first span
    if len(spans) > 1:  # get quad of last span
        q1 = recover_quad(line_dir, spans[-1])
    else:
        q1 = q0  # last = first

    line_ll = q0.ll  # lower-left of line quad
    line_lr = q1.lr  # lower-right of line quad

    mat0 = pymupdf.planish_line(line_ll, line_lr)

    # map base line to x-axis such that line_ll goes to (0, 0)
    x_lr = line_lr * mat0

    small = pymupdf.TOOLS.set_small_glyph_heights()  # small glyph heights?

    h = max(
        [s["size"] * (1 if small else (s["ascender"] - s["descender"])) for s in spans]
    )

    line_rect = pymupdf.Rect(0, -h, x_lr.x, 0)  # line rectangle
    line_quad = line_rect.quad  # make it a quad and:
    line_quad *= ~mat0
    return line_quad


def recover_span_quad(line_dir: tuple, span: dict, chars: list = None) -> pymupdf.Quad:
    """Calculate the span quad for 'dict' / 'rawdict' text extractions.

    Notes:
        There are two execution paths:
        1. For the full span quad, the result of 'recover_quad' is returned.
        2. For the quad of a sub-list of characters, the char quads are
           computed and joined. This is only supported for the "rawdict"
           extraction option.

    Args:
        line_dir: (tuple) 'line["dir"]' of the owning line.
        span: (dict) the span.
        chars: (list, optional) sub-list of characters to consider.
    Returns:
        pymupdf.Quad covering selected characters.
    """
    if line_dir is None:  # must be a span from get_texttrace()
        line_dir = span["dir"]
    if chars is None:  # no sub-selection
        return recover_quad(line_dir, span)
    if "chars" not in span.keys():
        raise ValueError("need 'rawdict' option to sub-select chars")

    q0 = recover_char_quad(line_dir, span, chars[0])  # quad of first char
    if len(chars) > 1:  # get quad of last char
        q1 = recover_char_quad(line_dir, span, chars[-1])
    else:
        q1 = q0  # last = first

    span_ll = q0.ll  # lower-left of span quad
    span_lr = q1.lr  # lower-right of span quad
    mat0 = pymupdf.planish_line(span_ll, span_lr)
    # map base line to x-axis such that span_ll goes to (0, 0)
    x_lr = span_lr * mat0

    small = pymupdf.TOOLS.set_small_glyph_heights()  # small glyph heights?
    h = span["size"] * (1 if small else (span["ascender"] - span["descender"]))

    span_rect = pymupdf.Rect(0, -h, x_lr.x, 0)  # line rectangle
    span_quad = span_rect.quad  # make it a quad and:
    span_quad *= ~mat0  # rotate back and shift back
    return span_quad


def recover_char_quad(line_dir: tuple, span: dict, char: dict) -> pymupdf.Quad:
    """Recover the quadrilateral of a text character.

    This requires the "rawdict" option of text extraction.

    Args:
        line_dir: (tuple) 'line["dir"]' of the span's line.
        span: (dict) the span dict.
        char: (dict) the character dict.
    Returns:
        The quadrilateral enveloping the character.
    """
    if line_dir is None:
        line_dir = span["dir"]
    if type(line_dir) is not tuple or len(line_dir) != 2:
        raise ValueError("bad line dir argument")
    if type(span) is not dict:
        raise ValueError("bad span argument")
    if type(char) is dict:
        bbox = pymupdf.Rect(char["bbox"])
    elif type(char) is tuple:
        bbox = pymupdf.Rect(char[3])
    else:
        raise ValueError("bad span argument")

    return recover_bbox_quad(line_dir, span, bbox)


# -------------------------------------------------------------------
# Building font subsets using fontTools
# -------------------------------------------------------------------
def subset_fonts(doc: pymupdf.Document, verbose: bool = False, fallback: bool = False) -> OptInt:
    """Build font subsets in a PDF.

    Eligible fonts are potentially replaced by smaller versions. Page text is
    NOT rewritten and thus should retain properties like being hidden or
    controlled by optional content.

    This method by default uses MuPDF's own internal feature to create subset
    fonts. As this is a new function, errors may still occur. In this case,
    please fall back to using the previous version by using "fallback=True".
    Fallback mode requires the external package 'fontTools'.

    Args:
        fallback: use the older deprecated implementation.
        verbose: only used by fallback mode.

    Returns:
        The new MuPDF-based code returns None.  The deprecated fallback
        mode returns 0 if there are no fonts to subset.  Otherwise, it
        returns the decrease in fontsize (the difference in fontsize),
        measured in bytes.
    """
    # Font binaries: -  "buffer" -> (names, xrefs, (unicodes, glyphs))
    # An embedded font is uniquely defined by its fontbuffer only. It may have
    # multiple names and xrefs.
    # Once the sets of used unicodes and glyphs are known, we compute a
    # smaller version of the buffer user package fontTools.

    if not fallback:  # by default use MuPDF function
        pdf = mupdf.pdf_document_from_fz_document(doc)
        mupdf.pdf_subset_fonts2(pdf, list(range(doc.page_count)))
        return

    font_buffers = {}

    def get_old_widths(xref):
        """Retrieve old font '/W' and '/DW' values."""
        df = doc.xref_get_key(xref, "DescendantFonts")
        if df[0] != "array":  # only handle xref specifications
            return None, None
        df_xref = int(df[1][1:-1].replace("0 R", ""))
        widths = doc.xref_get_key(df_xref, "W")
        if widths[0] != "array":  # no widths key found
            widths = None
        else:
            widths = widths[1]
        dwidths = doc.xref_get_key(df_xref, "DW")
        if dwidths[0] != "int":
            dwidths = None
        else:
            dwidths = dwidths[1]
        return widths, dwidths

    def set_old_widths(xref, widths, dwidths):
        """Restore the old '/W' and '/DW' in subsetted font.

        If either parameter is None or evaluates to False, the corresponding
        dictionary key will be set to null.
        """
        df = doc.xref_get_key(xref, "DescendantFonts")
        if df[0] != "array":  # only handle xref specs
            return None
        df_xref = int(df[1][1:-1].replace("0 R", ""))
        if (type(widths) is not str or not widths) and doc.xref_get_key(df_xref, "W")[
            0
        ] != "null":
            doc.xref_set_key(df_xref, "W", "null")
        else:
            doc.xref_set_key(df_xref, "W", widths)
        if (type(dwidths) is not str or not dwidths) and doc.xref_get_key(
            df_xref, "DW"
        )[0] != "null":
            doc.xref_set_key(df_xref, "DW", "null")
        else:
            doc.xref_set_key(df_xref, "DW", dwidths)
        return None

    def set_subset_fontname(new_xref):
        """Generate a name prefix to tag a font as subset.

        We use a random generator to select 6 upper case ASCII characters.
        The prefixed name must be put in the font xref as the "/BaseFont" value
        and in the FontDescriptor object as the '/FontName' value.
        """
        # The following generates a prefix like 'ABCDEF+'
        import random
        import string
        prefix = "".join(random.choices(tuple(string.ascii_uppercase), k=6)) + "+"
        font_str = doc.xref_object(new_xref, compressed=True)
        font_str = font_str.replace("/BaseFont/", "/BaseFont/" + prefix)
        df = doc.xref_get_key(new_xref, "DescendantFonts")
        if df[0] == "array":
            df_xref = int(df[1][1:-1].replace("0 R", ""))
            fd = doc.xref_get_key(df_xref, "FontDescriptor")
            if fd[0] == "xref":
                fd_xref = int(fd[1].replace("0 R", ""))
                fd_str = doc.xref_object(fd_xref, compressed=True)
                fd_str = fd_str.replace("/FontName/", "/FontName/" + prefix)
                doc.update_object(fd_xref, fd_str)
        doc.update_object(new_xref, font_str)

    def build_subset(buffer, unc_set, gid_set):
        """Build font subset using fontTools.

        Args:
            buffer: (bytes) the font given as a binary buffer.
            unc_set: (set) required glyph ids.
        Returns:
            Either None if subsetting is unsuccessful or the subset font buffer.
        """
        try:
            import fontTools.subset as fts
        except ImportError:
            if g_exceptions_verbose:    pymupdf.exception_info()
            pymupdf.message("This method requires fontTools to be installed.")
            raise
        import tempfile
        with tempfile.TemporaryDirectory() as tmp_dir:
            oldfont_path = f"{tmp_dir}/oldfont.ttf"
            newfont_path = f"{tmp_dir}/newfont.ttf"
            uncfile_path = f"{tmp_dir}/uncfile.txt"
            args = [
                oldfont_path,
                "--retain-gids",
                f"--output-file={newfont_path}",
                "--layout-features=*",
                "--passthrough-tables",
                "--ignore-missing-glyphs",
                "--ignore-missing-unicodes",
                "--symbol-cmap",
            ]

            # store glyph ids or unicodes as file
            with open(f"{tmp_dir}/uncfile.txt", "w", encoding='utf8') as unc_file:
                if 0xFFFD in unc_set:  # error unicode exists -> use glyphs
                    args.append(f"--gids-file={uncfile_path}")
                    gid_set.add(189)
                    unc_list = list(gid_set)
                    for unc in unc_list:
                        unc_file.write("%i\n" % unc)
                else:
                    args.append(f"--unicodes-file={uncfile_path}")
                    unc_set.add(255)
                    unc_list = list(unc_set)
                    for unc in unc_list:
                        unc_file.write("%04x\n" % unc)

            # store fontbuffer as a file
            with open(oldfont_path, "wb") as fontfile:
                fontfile.write(buffer)
            try:
                os.remove(newfont_path)  # remove old file
            except Exception:
                pass
            try:  # invoke fontTools subsetter
                fts.main(args)
                font = pymupdf.Font(fontfile=newfont_path)
                new_buffer = font.buffer  # subset font binary
                if font.glyph_count == 0:  # intercept empty font
                    new_buffer = None
            except Exception:
                pymupdf.exception_info()
                new_buffer = None
        return new_buffer

    def repl_fontnames(doc):
        """Populate 'font_buffers'.

        For each font candidate, store its xref and the list of names
        by which PDF text may refer to it (there may be multiple).
        """

        def norm_name(name):
            """Recreate font name that contains PDF hex codes.

            E.g. #20 -> space, chr(32)
            """
            while "#" in name:
                p = name.find("#")
                c = int(name[p + 1 : p + 3], 16)
                name = name.replace(name[p : p + 3], chr(c))
            return name

        def get_fontnames(doc, item):
            """Return a list of fontnames for an item of page.get_fonts().

            There may be multiple names e.g. for Type0 fonts.
            """
            fontname = item[3]
            names = [fontname]
            fontname = doc.xref_get_key(item[0], "BaseFont")[1][1:]
            fontname = norm_name(fontname)
            if fontname not in names:
                names.append(fontname)
            descendents = doc.xref_get_key(item[0], "DescendantFonts")
            if descendents[0] != "array":
                return names
            descendents = descendents[1][1:-1]
            if descendents.endswith(" 0 R"):
                xref = int(descendents[:-4])
                descendents = doc.xref_object(xref, compressed=True)
            p1 = descendents.find("/BaseFont")
            if p1 >= 0:
                p2 = descendents.find("/", p1 + 1)
                p1 = min(descendents.find("/", p2 + 1), descendents.find(">>", p2 + 1))
                fontname = descendents[p2 + 1 : p1]
                fontname = norm_name(fontname)
                if fontname not in names:
                    names.append(fontname)
            return names

        for i in range(doc.page_count):
            for f in doc.get_page_fonts(i, full=True):
                font_xref = f[0]  # font xref
                font_ext = f[1]  # font file extension
                basename = f[3]  # font basename

                if font_ext not in (  # skip if not supported by fontTools
                    "otf",
                    "ttf",
                    "woff",
                    "woff2",
                ):
                    continue
                # skip fonts which already are subsets
                if len(basename) > 6 and basename[6] == "+":
                    continue

                extr = doc.extract_font(font_xref)
                fontbuffer = extr[-1]
                names = get_fontnames(doc, f)
                name_set, xref_set, subsets = font_buffers.get(
                    fontbuffer, (set(), set(), (set(), set()))
                )
                xref_set.add(font_xref)
                for name in names:
                    name_set.add(name)
                font = pymupdf.Font(fontbuffer=fontbuffer)
                name_set.add(font.name)
                del font
                font_buffers[fontbuffer] = (name_set, xref_set, subsets)

    def find_buffer_by_name(name):
        for buffer, (name_set, _, _) in font_buffers.items():
            if name in name_set:
                return buffer
        return None

    # -----------------
    # main function
    # -----------------
    repl_fontnames(doc)  # populate font information
    if not font_buffers:  # nothing found to do
        if verbose:
            pymupdf.message(f'No fonts to subset.')
        return 0

    old_fontsize = 0
    new_fontsize = 0
    for fontbuffer in font_buffers.keys():
        old_fontsize += len(fontbuffer)

    # Scan page text for usage of subsettable fonts
    for page in doc:
        # go through the text and extend set of used glyphs by font
        # we use a modified MuPDF trace device, which delivers us glyph ids.
        for span in page.get_texttrace():
            if type(span) is not dict:  # skip useless information
                continue
            fontname = span["font"][:33]  # fontname for the span
            buffer = find_buffer_by_name(fontname)
            if buffer is None:
                continue
            name_set, xref_set, (set_ucs, set_gid) = font_buffers[buffer]
            for c in span["chars"]:
                set_ucs.add(c[0])  # unicode
                set_gid.add(c[1])  # glyph id
            font_buffers[buffer] = (name_set, xref_set, (set_ucs, set_gid))

    # build the font subsets
    for old_buffer, (name_set, xref_set, subsets) in font_buffers.items():
        new_buffer = build_subset(old_buffer, subsets[0], subsets[1])
        fontname = list(name_set)[0]
        if new_buffer is None or len(new_buffer) >= len(old_buffer):
            # subset was not created or did not get smaller
            if verbose:
                pymupdf.message(f'Cannot subset {fontname!r}.')
            continue
        if verbose:
            pymupdf.message(f"Built subset of font {fontname!r}.")
        val = doc._insert_font(fontbuffer=new_buffer)  # store subset font in PDF
        new_xref = val[0]  # get its xref
        set_subset_fontname(new_xref)  # tag fontname as subset font
        font_str = doc.xref_object(  # get its object definition
            new_xref,
            compressed=True,
        )
        # walk through the original font xrefs and replace each by the subset def
        for font_xref in xref_set:
            # we need the original '/W' and '/DW' width values
            width_table, def_width = get_old_widths(font_xref)
            # ... and replace original font definition at xref with it
            doc.update_object(font_xref, font_str)
            # now copy over old '/W' and '/DW' values
            if width_table or def_width:
                set_old_widths(font_xref, width_table, def_width)
        # 'new_xref' remains unused in the PDF and must be removed
        # by garbage collection.
        new_fontsize += len(new_buffer)

    return old_fontsize - new_fontsize


# -------------------------------------------------------------------
# Copy XREF object to another XREF
# -------------------------------------------------------------------
def xref_copy(doc: pymupdf.Document, source: int, target: int, *, keep: list = None) -> None:
    """Copy a PDF dictionary object to another one given their xref numbers.

    Args:
        doc: PDF document object
        source: source xref number
        target: target xref number, the xref must already exist
        keep: an optional list of 1st level keys in target that should not be
              removed before copying.
    Notes:
        This works similar to the copy() method of dictionaries in Python. The
        source may be a stream object.
    """
    if doc.xref_is_stream(source):
        # read new xref stream, maintaining compression
        stream = doc.xref_stream_raw(source)
        doc.update_stream(
            target,
            stream,
            compress=False,  # keeps source compression
            new=True,  # in case target is no stream
        )

    # empty the target completely, observe exceptions
    if keep is None:
        keep = []
    for key in doc.xref_get_keys(target):
        if key in keep:
            continue
        doc.xref_set_key(target, key, "null")
    # copy over all source dict items
    for key in doc.xref_get_keys(source):
        item = doc.xref_get_key(source, key)
        doc.xref_set_key(target, key, item[1])


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\__init__.py
# ================================================================================

# module pyparsing.py
#
# Copyright (c) 2003-2022  Paul T. McGuire
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

__doc__ = """
pyparsing module - Classes and methods to define and execute parsing grammars
=============================================================================

The pyparsing module is an alternative approach to creating and
executing simple grammars, vs. the traditional lex/yacc approach, or the
use of regular expressions.  With pyparsing, you don't need to learn
a new syntax for defining grammars or matching expressions - the parsing
module provides a library of classes that you use to construct the
grammar directly in Python.

Here is a program to parse "Hello, World!" (or any greeting of the form
``"<salutation>, <addressee>!"``), built up using :class:`Word`,
:class:`Literal`, and :class:`And` elements
(the :meth:`'+'<ParserElement.__add__>` operators create :class:`And` expressions,
and the strings are auto-converted to :class:`Literal` expressions)::

    from pyparsing import Word, alphas

    # define grammar of a greeting
    greet = Word(alphas) + "," + Word(alphas) + "!"

    hello = "Hello, World!"
    print(hello, "->", greet.parse_string(hello))

The program outputs the following::

    Hello, World! -> ['Hello', ',', 'World', '!']

The Python representation of the grammar is quite readable, owing to the
self-explanatory class names, and the use of :class:`'+'<And>`,
:class:`'|'<MatchFirst>`, :class:`'^'<Or>` and :class:`'&'<Each>` operators.

The :class:`ParseResults` object returned from
:class:`ParserElement.parse_string` can be
accessed as a nested list, a dictionary, or an object with named
attributes.

The pyparsing module handles some of the problems that are typically
vexing when writing text parsers:

  - extra or missing whitespace (the above program will also handle
    "Hello,World!", "Hello  ,  World  !", etc.)
  - quoted strings
  - embedded comments


Getting Started -
-----------------
Visit the classes :class:`ParserElement` and :class:`ParseResults` to
see the base classes that most other pyparsing
classes inherit from. Use the docstrings for examples of how to:

 - construct literal match expressions from :class:`Literal` and
   :class:`CaselessLiteral` classes
 - construct character word-group expressions using the :class:`Word`
   class
 - see how to create repetitive expressions using :class:`ZeroOrMore`
   and :class:`OneOrMore` classes
 - use :class:`'+'<And>`, :class:`'|'<MatchFirst>`, :class:`'^'<Or>`,
   and :class:`'&'<Each>` operators to combine simple expressions into
   more complex ones
 - associate names with your parsed results using
   :class:`ParserElement.set_results_name`
 - access the parsed data, which is returned as a :class:`ParseResults`
   object
 - find some helpful expression short-cuts like :class:`DelimitedList`
   and :class:`one_of`
 - find more useful common expressions in the :class:`pyparsing_common`
   namespace class
"""
from typing import NamedTuple


class version_info(NamedTuple):
    major: int
    minor: int
    micro: int
    releaselevel: str
    serial: int

    @property
    def __version__(self):
        return (
            f"{self.major}.{self.minor}.{self.micro}"
            + (
                f"{'r' if self.releaselevel[0] == 'c' else ''}{self.releaselevel[0]}{self.serial}",
                "",
            )[self.releaselevel == "final"]
        )

    def __str__(self):
        return f"{__name__} {self.__version__} / {__version_time__}"

    def __repr__(self):
        return f"{__name__}.{type(self).__name__}({', '.join('{}={!r}'.format(*nv) for nv in zip(self._fields, self))})"


__version_info__ = version_info(3, 2, 3, "final", 1)
__version_time__ = "25 Mar 2025 01:38 UTC"
__version__ = __version_info__.__version__
__versionTime__ = __version_time__
__author__ = "Paul McGuire <ptmcg.gm+pyparsing@gmail.com>"

from .util import *
from .exceptions import *
from .actions import *
from .core import __diag__, __compat__
from .results import *
from .core import *
from .core import _builtin_exprs as core_builtin_exprs
from .helpers import *
from .helpers import _builtin_exprs as helper_builtin_exprs

from .unicode import unicode_set, UnicodeRangeList, pyparsing_unicode as unicode
from .testing import pyparsing_test as testing
from .common import (
    pyparsing_common as common,
    _builtin_exprs as common_builtin_exprs,
)

# Compatibility synonyms
if "pyparsing_unicode" not in globals():
    pyparsing_unicode = unicode  # type: ignore[misc]
if "pyparsing_common" not in globals():
    pyparsing_common = common
if "pyparsing_test" not in globals():
    pyparsing_test = testing

core_builtin_exprs += common_builtin_exprs + helper_builtin_exprs


__all__ = [
    "__version__",
    "__version_time__",
    "__author__",
    "__compat__",
    "__diag__",
    "And",
    "AtLineStart",
    "AtStringStart",
    "CaselessKeyword",
    "CaselessLiteral",
    "CharsNotIn",
    "CloseMatch",
    "Combine",
    "DelimitedList",
    "Dict",
    "Each",
    "Empty",
    "FollowedBy",
    "Forward",
    "GoToColumn",
    "Group",
    "IndentedBlock",
    "Keyword",
    "LineEnd",
    "LineStart",
    "Literal",
    "Located",
    "PrecededBy",
    "MatchFirst",
    "NoMatch",
    "NotAny",
    "OneOrMore",
    "OnlyOnce",
    "OpAssoc",
    "Opt",
    "Optional",
    "Or",
    "ParseBaseException",
    "ParseElementEnhance",
    "ParseException",
    "ParseExpression",
    "ParseFatalException",
    "ParseResults",
    "ParseSyntaxException",
    "ParserElement",
    "PositionToken",
    "QuotedString",
    "RecursiveGrammarException",
    "Regex",
    "SkipTo",
    "StringEnd",
    "StringStart",
    "Suppress",
    "Tag",
    "Token",
    "TokenConverter",
    "White",
    "Word",
    "WordEnd",
    "WordStart",
    "ZeroOrMore",
    "Char",
    "alphanums",
    "alphas",
    "alphas8bit",
    "any_close_tag",
    "any_open_tag",
    "autoname_elements",
    "c_style_comment",
    "col",
    "common_html_entity",
    "condition_as_parse_action",
    "counted_array",
    "cpp_style_comment",
    "dbl_quoted_string",
    "dbl_slash_comment",
    "delimited_list",
    "dict_of",
    "empty",
    "hexnums",
    "html_comment",
    "identchars",
    "identbodychars",
    "infix_notation",
    "java_style_comment",
    "line",
    "line_end",
    "line_start",
    "lineno",
    "make_html_tags",
    "make_xml_tags",
    "match_only_at_col",
    "match_previous_expr",
    "match_previous_literal",
    "nested_expr",
    "null_debug_action",
    "nums",
    "one_of",
    "original_text_for",
    "printables",
    "punc8bit",
    "pyparsing_common",
    "pyparsing_test",
    "pyparsing_unicode",
    "python_style_comment",
    "quoted_string",
    "remove_quotes",
    "replace_with",
    "replace_html_entity",
    "rest_of_line",
    "sgl_quoted_string",
    "srange",
    "string_end",
    "string_start",
    "token_map",
    "trace_parse_action",
    "ungroup",
    "unicode_set",
    "unicode_string",
    "with_attribute",
    "with_class",
    # pre-PEP8 compatibility names
    "__versionTime__",
    "anyCloseTag",
    "anyOpenTag",
    "cStyleComment",
    "commonHTMLEntity",
    "conditionAsParseAction",
    "countedArray",
    "cppStyleComment",
    "dblQuotedString",
    "dblSlashComment",
    "delimitedList",
    "dictOf",
    "htmlComment",
    "indentedBlock",
    "infixNotation",
    "javaStyleComment",
    "lineEnd",
    "lineStart",
    "locatedExpr",
    "makeHTMLTags",
    "makeXMLTags",
    "matchOnlyAtCol",
    "matchPreviousExpr",
    "matchPreviousLiteral",
    "nestedExpr",
    "nullDebugAction",
    "oneOf",
    "opAssoc",
    "originalTextFor",
    "pythonStyleComment",
    "quotedString",
    "removeQuotes",
    "replaceHTMLEntity",
    "replaceWith",
    "restOfLine",
    "sglQuotedString",
    "stringEnd",
    "stringStart",
    "tokenMap",
    "traceParseAction",
    "unicodeString",
    "withAttribute",
    "withClass",
    "common",
    "unicode",
    "testing",
]


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\actions.py
# ================================================================================

# actions.py
from __future__ import annotations

from typing import Union, Callable, Any

from .exceptions import ParseException
from .util import col, replaced_by_pep8
from .results import ParseResults


ParseAction = Union[
    Callable[[], Any],
    Callable[[ParseResults], Any],
    Callable[[int, ParseResults], Any],
    Callable[[str, int, ParseResults], Any],
]


class OnlyOnce:
    """
    Wrapper for parse actions, to ensure they are only called once.
    Note: parse action signature must include all 3 arguments.
    """

    def __init__(self, method_call: Callable[[str, int, ParseResults], Any]) -> None:
        from .core import _trim_arity

        self.callable = _trim_arity(method_call)
        self.called = False

    def __call__(self, s: str, l: int, t: ParseResults) -> ParseResults:
        if not self.called:
            results = self.callable(s, l, t)
            self.called = True
            return results
        raise ParseException(s, l, "OnlyOnce obj called multiple times w/out reset")

    def reset(self):
        """
        Allow the associated parse action to be called once more.
        """

        self.called = False


def match_only_at_col(n: int) -> ParseAction:
    """
    Helper method for defining parse actions that require matching at
    a specific column in the input text.
    """

    def verify_col(strg: str, locn: int, toks: ParseResults) -> None:
        if col(locn, strg) != n:
            raise ParseException(strg, locn, f"matched token not at column {n}")

    return verify_col


def replace_with(repl_str: str) -> ParseAction:
    """
    Helper method for common parse actions that simply return
    a literal value.  Especially useful when used with
    :class:`transform_string<ParserElement.transform_string>` ().

    Example::

        num = Word(nums).set_parse_action(lambda toks: int(toks[0]))
        na = one_of("N/A NA").set_parse_action(replace_with(math.nan))
        term = na | num

        term[1, ...].parse_string("324 234 N/A 234") # -> [324, 234, nan, 234]
    """
    return lambda s, l, t: [repl_str]


def remove_quotes(s: str, l: int, t: ParseResults) -> Any:
    """
    Helper parse action for removing quotation marks from parsed
    quoted strings.

    Example::

        # by default, quotation marks are included in parsed results
        quoted_string.parse_string("'Now is the Winter of our Discontent'") # -> ["'Now is the Winter of our Discontent'"]

        # use remove_quotes to strip quotation marks from parsed results
        quoted_string.set_parse_action(remove_quotes)
        quoted_string.parse_string("'Now is the Winter of our Discontent'") # -> ["Now is the Winter of our Discontent"]
    """
    return t[0][1:-1]


def with_attribute(*args: tuple[str, str], **attr_dict) -> ParseAction:
    """
    Helper to create a validating parse action to be used with start
    tags created with :class:`make_xml_tags` or
    :class:`make_html_tags`. Use ``with_attribute`` to qualify
    a starting tag with a required attribute value, to avoid false
    matches on common tags such as ``<TD>`` or ``<DIV>``.

    Call ``with_attribute`` with a series of attribute names and
    values. Specify the list of filter attributes names and values as:

    - keyword arguments, as in ``(align="right")``, or
    - as an explicit dict with ``**`` operator, when an attribute
      name is also a Python reserved word, as in ``**{"class":"Customer", "align":"right"}``
    - a list of name-value tuples, as in ``(("ns1:class", "Customer"), ("ns2:align", "right"))``

    For attribute names with a namespace prefix, you must use the second
    form.  Attribute names are matched insensitive to upper/lower case.

    If just testing for ``class`` (with or without a namespace), use
    :class:`with_class`.

    To verify that the attribute exists, but without specifying a value,
    pass ``with_attribute.ANY_VALUE`` as the value.

    Example::

        html = '''
            <div>
            Some text
            <div type="grid">1 4 0 1 0</div>
            <div type="graph">1,3 2,3 1,1</div>
            <div>this has no type</div>
            </div>
        '''
        div,div_end = make_html_tags("div")

        # only match div tag having a type attribute with value "grid"
        div_grid = div().set_parse_action(with_attribute(type="grid"))
        grid_expr = div_grid + SkipTo(div | div_end)("body")
        for grid_header in grid_expr.search_string(html):
            print(grid_header.body)

        # construct a match with any div tag having a type attribute, regardless of the value
        div_any_type = div().set_parse_action(with_attribute(type=with_attribute.ANY_VALUE))
        div_expr = div_any_type + SkipTo(div | div_end)("body")
        for div_header in div_expr.search_string(html):
            print(div_header.body)

    prints::

        1 4 0 1 0

        1 4 0 1 0
        1,3 2,3 1,1
    """
    attrs_list: list[tuple[str, str]] = []
    if args:
        attrs_list.extend(args)
    else:
        attrs_list.extend(attr_dict.items())

    def pa(s: str, l: int, tokens: ParseResults) -> None:
        for attrName, attrValue in attrs_list:
            if attrName not in tokens:
                raise ParseException(s, l, "no matching attribute " + attrName)
            if attrValue != with_attribute.ANY_VALUE and tokens[attrName] != attrValue:  # type: ignore [attr-defined]
                raise ParseException(
                    s,
                    l,
                    f"attribute {attrName!r} has value {tokens[attrName]!r}, must be {attrValue!r}",
                )

    return pa


with_attribute.ANY_VALUE = object()  # type: ignore [attr-defined]


def with_class(classname: str, namespace: str = "") -> ParseAction:
    """
    Simplified version of :class:`with_attribute` when
    matching on a div class - made difficult because ``class`` is
    a reserved word in Python.

    Example::

        html = '''
            <div>
            Some text
            <div class="grid">1 4 0 1 0</div>
            <div class="graph">1,3 2,3 1,1</div>
            <div>this &lt;div&gt; has no class</div>
            </div>

        '''
        div,div_end = make_html_tags("div")
        div_grid = div().set_parse_action(with_class("grid"))

        grid_expr = div_grid + SkipTo(div | div_end)("body")
        for grid_header in grid_expr.search_string(html):
            print(grid_header.body)

        div_any_type = div().set_parse_action(with_class(withAttribute.ANY_VALUE))
        div_expr = div_any_type + SkipTo(div | div_end)("body")
        for div_header in div_expr.search_string(html):
            print(div_header.body)

    prints::

        1 4 0 1 0

        1 4 0 1 0
        1,3 2,3 1,1
    """
    classattr = f"{namespace}:class" if namespace else "class"
    return with_attribute(**{classattr: classname})


# Compatibility synonyms
# fmt: off
replaceWith = replaced_by_pep8("replaceWith", replace_with)
removeQuotes = replaced_by_pep8("removeQuotes", remove_quotes)
withAttribute = replaced_by_pep8("withAttribute", with_attribute)
withClass = replaced_by_pep8("withClass", with_class)
matchOnlyAtCol = replaced_by_pep8("matchOnlyAtCol", match_only_at_col)
# fmt: on


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\common.py
# ================================================================================

# common.py
from .core import *
from .helpers import DelimitedList, any_open_tag, any_close_tag
from datetime import datetime


# some other useful expressions - using lower-case class name since we are really using this as a namespace
class pyparsing_common:
    """Here are some common low-level expressions that may be useful in
    jump-starting parser development:

    - numeric forms (:class:`integers<integer>`, :class:`reals<real>`,
      :class:`scientific notation<sci_real>`)
    - common :class:`programming identifiers<identifier>`
    - network addresses (:class:`MAC<mac_address>`,
      :class:`IPv4<ipv4_address>`, :class:`IPv6<ipv6_address>`)
    - ISO8601 :class:`dates<iso8601_date>` and
      :class:`datetime<iso8601_datetime>`
    - :class:`UUID<uuid>`
    - :class:`comma-separated list<comma_separated_list>`
    - :class:`url`

    Parse actions:

    - :class:`convert_to_integer`
    - :class:`convert_to_float`
    - :class:`convert_to_date`
    - :class:`convert_to_datetime`
    - :class:`strip_html_tags`
    - :class:`upcase_tokens`
    - :class:`downcase_tokens`

    Example::

        pyparsing_common.number.run_tests('''
            # any int or real number, returned as the appropriate type
            100
            -100
            +100
            3.14159
            6.02e23
            1e-12
            ''')

        pyparsing_common.fnumber.run_tests('''
            # any int or real number, returned as float
            100
            -100
            +100
            3.14159
            6.02e23
            1e-12
            ''')

        pyparsing_common.hex_integer.run_tests('''
            # hex numbers
            100
            FF
            ''')

        pyparsing_common.fraction.run_tests('''
            # fractions
            1/2
            -3/4
            ''')

        pyparsing_common.mixed_integer.run_tests('''
            # mixed fractions
            1
            1/2
            -3/4
            1-3/4
            ''')

        import uuid
        pyparsing_common.uuid.set_parse_action(token_map(uuid.UUID))
        pyparsing_common.uuid.run_tests('''
            # uuid
            12345678-1234-5678-1234-567812345678
            ''')

    prints::

        # any int or real number, returned as the appropriate type
        100
        [100]

        -100
        [-100]

        +100
        [100]

        3.14159
        [3.14159]

        6.02e23
        [6.02e+23]

        1e-12
        [1e-12]

        # any int or real number, returned as float
        100
        [100.0]

        -100
        [-100.0]

        +100
        [100.0]

        3.14159
        [3.14159]

        6.02e23
        [6.02e+23]

        1e-12
        [1e-12]

        # hex numbers
        100
        [256]

        FF
        [255]

        # fractions
        1/2
        [0.5]

        -3/4
        [-0.75]

        # mixed fractions
        1
        [1]

        1/2
        [0.5]

        -3/4
        [-0.75]

        1-3/4
        [1.75]

        # uuid
        12345678-1234-5678-1234-567812345678
        [UUID('12345678-1234-5678-1234-567812345678')]
    """

    convert_to_integer = token_map(int)
    """
    Parse action for converting parsed integers to Python int
    """

    convert_to_float = token_map(float)
    """
    Parse action for converting parsed numbers to Python float
    """

    integer = Word(nums).set_name("integer").set_parse_action(convert_to_integer)
    """expression that parses an unsigned integer, returns an int"""

    hex_integer = (
        Word(hexnums).set_name("hex integer").set_parse_action(token_map(int, 16))
    )
    """expression that parses a hexadecimal integer, returns an int"""

    signed_integer = (
        Regex(r"[+-]?\d+")
        .set_name("signed integer")
        .set_parse_action(convert_to_integer)
    )
    """expression that parses an integer with optional leading sign, returns an int"""

    fraction = (
        signed_integer().set_parse_action(convert_to_float)
        + "/"
        + signed_integer().set_parse_action(convert_to_float)
    ).set_name("fraction")
    """fractional expression of an integer divided by an integer, returns a float"""
    fraction.add_parse_action(lambda tt: tt[0] / tt[-1])

    mixed_integer = (
        fraction | signed_integer + Opt(Opt("-").suppress() + fraction)
    ).set_name("fraction or mixed integer-fraction")
    """mixed integer of the form 'integer - fraction', with optional leading integer, returns float"""
    mixed_integer.add_parse_action(sum)

    real = (
        Regex(r"[+-]?(?:\d+\.\d*|\.\d+)")
        .set_name("real number")
        .set_parse_action(convert_to_float)
    )
    """expression that parses a floating point number and returns a float"""

    sci_real = (
        Regex(r"[+-]?(?:\d+(?:[eE][+-]?\d+)|(?:\d+\.\d*|\.\d+)(?:[eE][+-]?\d+)?)")
        .set_name("real number with scientific notation")
        .set_parse_action(convert_to_float)
    )
    """expression that parses a floating point number with optional
    scientific notation and returns a float"""

    # streamlining this expression makes the docs nicer-looking
    number = (sci_real | real | signed_integer).set_name("number").streamline()
    """any numeric expression, returns the corresponding Python type"""

    fnumber = (
        Regex(r"[+-]?\d+\.?\d*(?:[eE][+-]?\d+)?")
        .set_name("fnumber")
        .set_parse_action(convert_to_float)
    )
    """any int or real number, returned as float"""

    ieee_float = (
        Regex(r"(?i:[+-]?(?:(?:\d+\.?\d*(?:e[+-]?\d+)?)|nan|inf(?:inity)?))")
        .set_name("ieee_float")
        .set_parse_action(convert_to_float)
    )
    """any floating-point literal (int, real number, infinity, or NaN), returned as float"""

    identifier = Word(identchars, identbodychars).set_name("identifier")
    """typical code identifier (leading alpha or '_', followed by 0 or more alphas, nums, or '_')"""

    ipv4_address = Regex(
        r"(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})){3}"
    ).set_name("IPv4 address")
    "IPv4 address (``0.0.0.0 - 255.255.255.255``)"

    _ipv6_part = Regex(r"[0-9a-fA-F]{1,4}").set_name("hex_integer")
    _full_ipv6_address = (_ipv6_part + (":" + _ipv6_part) * 7).set_name(
        "full IPv6 address"
    )
    _short_ipv6_address = (
        Opt(_ipv6_part + (":" + _ipv6_part) * (0, 6))
        + "::"
        + Opt(_ipv6_part + (":" + _ipv6_part) * (0, 6))
    ).set_name("short IPv6 address")
    _short_ipv6_address.add_condition(
        lambda t: sum(1 for tt in t if pyparsing_common._ipv6_part.matches(tt)) < 8
    )
    _mixed_ipv6_address = ("::ffff:" + ipv4_address).set_name("mixed IPv6 address")
    ipv6_address = Combine(
        (_full_ipv6_address | _mixed_ipv6_address | _short_ipv6_address).set_name(
            "IPv6 address"
        )
    ).set_name("IPv6 address")
    "IPv6 address (long, short, or mixed form)"

    mac_address = Regex(
        r"[0-9a-fA-F]{2}([:.-])[0-9a-fA-F]{2}(?:\1[0-9a-fA-F]{2}){4}"
    ).set_name("MAC address")
    "MAC address xx:xx:xx:xx:xx (may also have '-' or '.' delimiters)"

    @staticmethod
    def convert_to_date(fmt: str = "%Y-%m-%d"):
        """
        Helper to create a parse action for converting parsed date string to Python datetime.date

        Params -
        - fmt - format to be passed to datetime.strptime (default= ``"%Y-%m-%d"``)

        Example::

            date_expr = pyparsing_common.iso8601_date.copy()
            date_expr.set_parse_action(pyparsing_common.convert_to_date())
            print(date_expr.parse_string("1999-12-31"))

        prints::

            [datetime.date(1999, 12, 31)]
        """

        def cvt_fn(ss, ll, tt):
            try:
                return datetime.strptime(tt[0], fmt).date()
            except ValueError as ve:
                raise ParseException(ss, ll, str(ve))

        return cvt_fn

    @staticmethod
    def convert_to_datetime(fmt: str = "%Y-%m-%dT%H:%M:%S.%f"):
        """Helper to create a parse action for converting parsed
        datetime string to Python datetime.datetime

        Params -
        - fmt - format to be passed to datetime.strptime (default= ``"%Y-%m-%dT%H:%M:%S.%f"``)

        Example::

            dt_expr = pyparsing_common.iso8601_datetime.copy()
            dt_expr.set_parse_action(pyparsing_common.convert_to_datetime())
            print(dt_expr.parse_string("1999-12-31T23:59:59.999"))

        prints::

            [datetime.datetime(1999, 12, 31, 23, 59, 59, 999000)]
        """

        def cvt_fn(s, l, t):
            try:
                return datetime.strptime(t[0], fmt)
            except ValueError as ve:
                raise ParseException(s, l, str(ve))

        return cvt_fn

    iso8601_date = Regex(
        r"(?P<year>\d{4})(?:-(?P<month>\d\d)(?:-(?P<day>\d\d))?)?"
    ).set_name("ISO8601 date")
    "ISO8601 date (``yyyy-mm-dd``)"

    iso8601_datetime = Regex(
        r"(?P<year>\d{4})-(?P<month>\d\d)-(?P<day>\d\d)[T ](?P<hour>\d\d):(?P<minute>\d\d)(:(?P<second>\d\d(\.\d*)?)?)?(?P<tz>Z|[+-]\d\d:?\d\d)?"
    ).set_name("ISO8601 datetime")
    "ISO8601 datetime (``yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)``) - trailing seconds, milliseconds, and timezone optional; accepts separating ``'T'`` or ``' '``"

    uuid = Regex(r"[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}").set_name("UUID")
    "UUID (``xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx``)"

    _html_stripper = any_open_tag.suppress() | any_close_tag.suppress()

    @staticmethod
    def strip_html_tags(s: str, l: int, tokens: ParseResults):
        """Parse action to remove HTML tags from web page HTML source

        Example::

            # strip HTML links from normal text
            text = '<td>More info at the <a href="https://github.com/pyparsing/pyparsing/wiki">pyparsing</a> wiki page</td>'
            td, td_end = make_html_tags("TD")
            table_text = td + SkipTo(td_end).set_parse_action(pyparsing_common.strip_html_tags)("body") + td_end
            print(table_text.parse_string(text).body)

        Prints::

            More info at the pyparsing wiki page
        """
        return pyparsing_common._html_stripper.transform_string(tokens[0])

    _commasepitem = (
        Combine(
            OneOrMore(
                ~Literal(",")
                + ~LineEnd()
                + Word(printables, exclude_chars=",")
                + Opt(White(" \t") + ~FollowedBy(LineEnd() | ","))
            )
        )
        .streamline()
        .set_name("commaItem")
    )
    comma_separated_list = DelimitedList(
        Opt(quoted_string.copy() | _commasepitem, default="")
    ).set_name("comma separated list")
    """Predefined expression of 1 or more printable words or quoted strings, separated by commas."""

    upcase_tokens = staticmethod(token_map(lambda t: t.upper()))
    """Parse action to convert tokens to upper case."""

    downcase_tokens = staticmethod(token_map(lambda t: t.lower()))
    """Parse action to convert tokens to lower case."""

    # fmt: off
    url = Regex(
        # https://mathiasbynens.be/demo/url-regex
        # https://gist.github.com/dperini/729294
        r"(?P<url>" +
        # protocol identifier (optional)
        # short syntax // still required
        r"(?:(?:(?P<scheme>https?|ftp):)?\/\/)" +
        # user:pass BasicAuth (optional)
        r"(?:(?P<auth>\S+(?::\S*)?)@)?" +
        r"(?P<host>" +
        # IP address exclusion
        # private & local networks
        r"(?!(?:10|127)(?:\.\d{1,3}){3})" +
        r"(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})" +
        r"(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})" +
        # IP address dotted notation octets
        # excludes loopback network 0.0.0.0
        # excludes reserved space >= 224.0.0.0
        # excludes network & broadcast addresses
        # (first & last IP address of each class)
        r"(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])" +
        r"(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}" +
        r"(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))" +
        r"|" +
        # host & domain names, may end with dot
        # can be replaced by a shortest alternative
        # (?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.)+
        r"(?:" +
        r"(?:" +
        r"[a-z0-9\u00a1-\uffff]" +
        r"[a-z0-9\u00a1-\uffff_-]{0,62}" +
        r")?" +
        r"[a-z0-9\u00a1-\uffff]\." +
        r")+" +
        # TLD identifier name, may end with dot
        r"(?:[a-z\u00a1-\uffff]{2,}\.?)" +
        r")" +
        # port number (optional)
        r"(:(?P<port>\d{2,5}))?" +
        # resource path (optional)
        r"(?P<path>\/[^?# ]*)?" +
        # query string (optional)
        r"(\?(?P<query>[^#]*))?" +
        # fragment (optional)
        r"(#(?P<fragment>\S*))?" +
        r")"
    ).set_name("url")
    """URL (http/https/ftp scheme)"""
    # fmt: on

    # pre-PEP8 compatibility names
    # fmt: off
    convertToInteger = staticmethod(replaced_by_pep8("convertToInteger", convert_to_integer))
    convertToFloat = staticmethod(replaced_by_pep8("convertToFloat", convert_to_float))
    convertToDate = staticmethod(replaced_by_pep8("convertToDate", convert_to_date))
    convertToDatetime = staticmethod(replaced_by_pep8("convertToDatetime", convert_to_datetime))
    stripHTMLTags = staticmethod(replaced_by_pep8("stripHTMLTags", strip_html_tags))
    upcaseTokens = staticmethod(replaced_by_pep8("upcaseTokens", upcase_tokens))
    downcaseTokens = staticmethod(replaced_by_pep8("downcaseTokens", downcase_tokens))
    # fmt: on


_builtin_exprs = [
    v for v in vars(pyparsing_common).values() if isinstance(v, ParserElement)
]


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\core.py
# ================================================================================

#
# core.py
#
from __future__ import annotations

import collections.abc
from collections import deque
import os
import typing
from typing import (
    Any,
    Callable,
    Generator,
    NamedTuple,
    Sequence,
    TextIO,
    Union,
    cast,
)
from abc import ABC, abstractmethod
from enum import Enum
import string
import copy
import warnings
import re
import sys
from collections.abc import Iterable
import traceback
import types
from operator import itemgetter
from functools import wraps
from threading import RLock
from pathlib import Path

from .util import (
    _FifoCache,
    _UnboundedCache,
    __config_flags,
    _collapse_string_to_ranges,
    _escape_regex_range_chars,
    _flatten,
    LRUMemo as _LRUMemo,
    UnboundedMemo as _UnboundedMemo,
    replaced_by_pep8,
)
from .exceptions import *
from .actions import *
from .results import ParseResults, _ParseResultsWithOffset
from .unicode import pyparsing_unicode

_MAX_INT = sys.maxsize
str_type: tuple[type, ...] = (str, bytes)

#
# Copyright (c) 2003-2022  Paul T. McGuire
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

from functools import cached_property


class __compat__(__config_flags):
    """
    A cross-version compatibility configuration for pyparsing features that will be
    released in a future version. By setting values in this configuration to True,
    those features can be enabled in prior versions for compatibility development
    and testing.

    - ``collect_all_And_tokens`` - flag to enable fix for Issue #63 that fixes erroneous grouping
      of results names when an :class:`And` expression is nested within an :class:`Or` or :class:`MatchFirst`;
      maintained for compatibility, but setting to ``False`` no longer restores pre-2.3.1
      behavior
    """

    _type_desc = "compatibility"

    collect_all_And_tokens = True

    _all_names = [__ for __ in locals() if not __.startswith("_")]
    _fixed_names = """
        collect_all_And_tokens
        """.split()


class __diag__(__config_flags):
    _type_desc = "diagnostic"

    warn_multiple_tokens_in_named_alternation = False
    warn_ungrouped_named_tokens_in_collection = False
    warn_name_set_on_empty_Forward = False
    warn_on_parse_using_empty_Forward = False
    warn_on_assignment_to_Forward = False
    warn_on_multiple_string_args_to_oneof = False
    warn_on_match_first_with_lshift_operator = False
    enable_debug_on_named_expressions = False

    _all_names = [__ for __ in locals() if not __.startswith("_")]
    _warning_names = [name for name in _all_names if name.startswith("warn")]
    _debug_names = [name for name in _all_names if name.startswith("enable_debug")]

    @classmethod
    def enable_all_warnings(cls) -> None:
        for name in cls._warning_names:
            cls.enable(name)


class Diagnostics(Enum):
    """
    Diagnostic configuration (all default to disabled)

    - ``warn_multiple_tokens_in_named_alternation`` - flag to enable warnings when a results
      name is defined on a :class:`MatchFirst` or :class:`Or` expression with one or more :class:`And` subexpressions
    - ``warn_ungrouped_named_tokens_in_collection`` - flag to enable warnings when a results
      name is defined on a containing expression with ungrouped subexpressions that also
      have results names
    - ``warn_name_set_on_empty_Forward`` - flag to enable warnings when a :class:`Forward` is defined
      with a results name, but has no contents defined
    - ``warn_on_parse_using_empty_Forward`` - flag to enable warnings when a :class:`Forward` is
      defined in a grammar but has never had an expression attached to it
    - ``warn_on_assignment_to_Forward`` - flag to enable warnings when a :class:`Forward` is defined
      but is overwritten by assigning using ``'='`` instead of ``'<<='`` or ``'<<'``
    - ``warn_on_multiple_string_args_to_oneof`` - flag to enable warnings when :class:`one_of` is
      incorrectly called with multiple str arguments
    - ``enable_debug_on_named_expressions`` - flag to auto-enable debug on all subsequent
      calls to :class:`ParserElement.set_name`

    Diagnostics are enabled/disabled by calling :class:`enable_diag` and :class:`disable_diag`.
    All warnings can be enabled by calling :class:`enable_all_warnings`.
    """

    warn_multiple_tokens_in_named_alternation = 0
    warn_ungrouped_named_tokens_in_collection = 1
    warn_name_set_on_empty_Forward = 2
    warn_on_parse_using_empty_Forward = 3
    warn_on_assignment_to_Forward = 4
    warn_on_multiple_string_args_to_oneof = 5
    warn_on_match_first_with_lshift_operator = 6
    enable_debug_on_named_expressions = 7


def enable_diag(diag_enum: Diagnostics) -> None:
    """
    Enable a global pyparsing diagnostic flag (see :class:`Diagnostics`).
    """
    __diag__.enable(diag_enum.name)


def disable_diag(diag_enum: Diagnostics) -> None:
    """
    Disable a global pyparsing diagnostic flag (see :class:`Diagnostics`).
    """
    __diag__.disable(diag_enum.name)


def enable_all_warnings() -> None:
    """
    Enable all global pyparsing diagnostic warnings (see :class:`Diagnostics`).
    """
    __diag__.enable_all_warnings()


# hide abstract class
del __config_flags


def _should_enable_warnings(
    cmd_line_warn_options: typing.Iterable[str], warn_env_var: typing.Optional[str]
) -> bool:
    enable = bool(warn_env_var)
    for warn_opt in cmd_line_warn_options:
        w_action, w_message, w_category, w_module, w_line = (warn_opt + "::::").split(
            ":"
        )[:5]
        if not w_action.lower().startswith("i") and (
            not (w_message or w_category or w_module) or w_module == "pyparsing"
        ):
            enable = True
        elif w_action.lower().startswith("i") and w_module in ("pyparsing", ""):
            enable = False
    return enable


if _should_enable_warnings(
    sys.warnoptions, os.environ.get("PYPARSINGENABLEALLWARNINGS")
):
    enable_all_warnings()


# build list of single arg builtins, that can be used as parse actions
# fmt: off
_single_arg_builtins = {
    sum, len, sorted, reversed, list, tuple, set, any, all, min, max
}
# fmt: on

_generatorType = types.GeneratorType
ParseImplReturnType = tuple[int, Any]
PostParseReturnType = Union[ParseResults, Sequence[ParseResults]]

ParseCondition = Union[
    Callable[[], bool],
    Callable[[ParseResults], bool],
    Callable[[int, ParseResults], bool],
    Callable[[str, int, ParseResults], bool],
]
ParseFailAction = Callable[[str, int, "ParserElement", Exception], None]
DebugStartAction = Callable[[str, int, "ParserElement", bool], None]
DebugSuccessAction = Callable[
    [str, int, int, "ParserElement", ParseResults, bool], None
]
DebugExceptionAction = Callable[[str, int, "ParserElement", Exception, bool], None]


alphas: str = string.ascii_uppercase + string.ascii_lowercase
identchars: str = pyparsing_unicode.Latin1.identchars
identbodychars: str = pyparsing_unicode.Latin1.identbodychars
nums: str = "0123456789"
hexnums: str = nums + "ABCDEFabcdef"
alphanums: str = alphas + nums
printables: str = "".join([c for c in string.printable if c not in string.whitespace])


class _ParseActionIndexError(Exception):
    """
    Internal wrapper around IndexError so that IndexErrors raised inside
    parse actions aren't misinterpreted as IndexErrors raised inside
    ParserElement parseImpl methods.
    """

    def __init__(self, msg: str, exc: BaseException) -> None:
        self.msg: str = msg
        self.exc: BaseException = exc


_trim_arity_call_line: traceback.StackSummary = None  # type: ignore[assignment]
pa_call_line_synth = ()


def _trim_arity(func, max_limit=3):
    """decorator to trim function calls to match the arity of the target"""
    global _trim_arity_call_line, pa_call_line_synth

    if func in _single_arg_builtins:
        return lambda s, l, t: func(t)

    limit = 0
    found_arity = False

    # synthesize what would be returned by traceback.extract_stack at the call to
    # user's parse action 'func', so that we don't incur call penalty at parse time

    # fmt: off
    LINE_DIFF = 9
    # IF ANY CODE CHANGES, EVEN JUST COMMENTS OR BLANK LINES, BETWEEN THE NEXT LINE AND
    # THE CALL TO FUNC INSIDE WRAPPER, LINE_DIFF MUST BE MODIFIED!!!!
    _trim_arity_call_line = _trim_arity_call_line or traceback.extract_stack(limit=2)[-1]
    pa_call_line_synth = pa_call_line_synth or (_trim_arity_call_line[0], _trim_arity_call_line[1] + LINE_DIFF)

    def wrapper(*args):
        nonlocal found_arity, limit
        if found_arity:
            return func(*args[limit:])
        while 1:
            try:
                ret = func(*args[limit:])
                found_arity = True
                return ret
            except TypeError as te:
                # re-raise TypeErrors if they did not come from our arity testing
                if found_arity:
                    raise
                else:
                    tb = te.__traceback__
                    frames = traceback.extract_tb(tb, limit=2)
                    frame_summary = frames[-1]
                    trim_arity_type_error = (
                        [frame_summary[:2]][-1][:2] == pa_call_line_synth
                    )
                    del tb

                    if trim_arity_type_error:
                        if limit < max_limit:
                            limit += 1
                            continue

                    raise
            except IndexError as ie:
                # wrap IndexErrors inside a _ParseActionIndexError
                raise _ParseActionIndexError(
                    "IndexError raised in parse action", ie
                ).with_traceback(None)
    # fmt: on

    # copy func name to wrapper for sensible debug output
    # (can't use functools.wraps, since that messes with function signature)
    func_name = getattr(func, "__name__", getattr(func, "__class__").__name__)
    wrapper.__name__ = func_name
    wrapper.__doc__ = func.__doc__

    return wrapper


def condition_as_parse_action(
    fn: ParseCondition, message: typing.Optional[str] = None, fatal: bool = False
) -> ParseAction:
    """
    Function to convert a simple predicate function that returns ``True`` or ``False``
    into a parse action. Can be used in places when a parse action is required
    and :class:`ParserElement.add_condition` cannot be used (such as when adding a condition
    to an operator level in :class:`infix_notation`).

    Optional keyword arguments:

    - ``message`` - define a custom message to be used in the raised exception
    - ``fatal`` - if True, will raise :class:`ParseFatalException` to stop parsing immediately;
      otherwise will raise :class:`ParseException`

    """
    msg = message if message is not None else "failed user-defined condition"
    exc_type = ParseFatalException if fatal else ParseException
    fn = _trim_arity(fn)

    @wraps(fn)
    def pa(s, l, t):
        if not bool(fn(s, l, t)):
            raise exc_type(s, l, msg)

    return pa


def _default_start_debug_action(
    instring: str, loc: int, expr: ParserElement, cache_hit: bool = False
):
    cache_hit_str = "*" if cache_hit else ""
    print(
        (
            f"{cache_hit_str}Match {expr} at loc {loc}({lineno(loc, instring)},{col(loc, instring)})\n"
            f"  {line(loc, instring)}\n"
            f"  {'^':>{col(loc, instring)}}"
        )
    )


def _default_success_debug_action(
    instring: str,
    startloc: int,
    endloc: int,
    expr: ParserElement,
    toks: ParseResults,
    cache_hit: bool = False,
):
    cache_hit_str = "*" if cache_hit else ""
    print(f"{cache_hit_str}Matched {expr} -> {toks.as_list()}")


def _default_exception_debug_action(
    instring: str,
    loc: int,
    expr: ParserElement,
    exc: Exception,
    cache_hit: bool = False,
):
    cache_hit_str = "*" if cache_hit else ""
    print(f"{cache_hit_str}Match {expr} failed, {type(exc).__name__} raised: {exc}")


def null_debug_action(*args):
    """'Do-nothing' debug action, to suppress debugging output during parsing."""


class ParserElement(ABC):
    """Abstract base level parser element class."""

    DEFAULT_WHITE_CHARS: str = " \n\t\r"
    verbose_stacktrace: bool = False
    _literalStringClass: type = None  # type: ignore[assignment]

    @staticmethod
    def set_default_whitespace_chars(chars: str) -> None:
        r"""
        Overrides the default whitespace chars

        Example::

            # default whitespace chars are space, <TAB> and newline
            Word(alphas)[1, ...].parse_string("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']

            # change to just treat newline as significant
            ParserElement.set_default_whitespace_chars(" \t")
            Word(alphas)[1, ...].parse_string("abc def\nghi jkl")  # -> ['abc', 'def']
        """
        ParserElement.DEFAULT_WHITE_CHARS = chars

        # update whitespace all parse expressions defined in this module
        for expr in _builtin_exprs:
            if expr.copyDefaultWhiteChars:
                expr.whiteChars = set(chars)

    @staticmethod
    def inline_literals_using(cls: type) -> None:
        """
        Set class to be used for inclusion of string literals into a parser.

        Example::

            # default literal class used is Literal
            integer = Word(nums)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")

            date_str.parse_string("1999/12/31")  # -> ['1999', '/', '12', '/', '31']


            # change to Suppress
            ParserElement.inline_literals_using(Suppress)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")

            date_str.parse_string("1999/12/31")  # -> ['1999', '12', '31']
        """
        ParserElement._literalStringClass = cls

    @classmethod
    def using_each(cls, seq, **class_kwargs):
        """
        Yields a sequence of ``class(obj, **class_kwargs)`` for obj in seq.

        Example::

            LPAR, RPAR, LBRACE, RBRACE, SEMI = Suppress.using_each("(){};")

        """
        yield from (cls(obj, **class_kwargs) for obj in seq)

    class DebugActions(NamedTuple):
        debug_try: typing.Optional[DebugStartAction]
        debug_match: typing.Optional[DebugSuccessAction]
        debug_fail: typing.Optional[DebugExceptionAction]

    def __init__(self, savelist: bool = False) -> None:
        self.parseAction: list[ParseAction] = list()
        self.failAction: typing.Optional[ParseFailAction] = None
        self.customName: str = None  # type: ignore[assignment]
        self._defaultName: typing.Optional[str] = None
        self.resultsName: str = None  # type: ignore[assignment]
        self.saveAsList = savelist
        self.skipWhitespace = True
        self.whiteChars = set(ParserElement.DEFAULT_WHITE_CHARS)
        self.copyDefaultWhiteChars = True
        # used when checking for left-recursion
        self._may_return_empty = False
        self.keepTabs = False
        self.ignoreExprs: list[ParserElement] = list()
        self.debug = False
        self.streamlined = False
        # optimize exception handling for subclasses that don't advance parse index
        self.mayIndexError = True
        self.errmsg: Union[str, None] = ""
        # mark results names as modal (report only last) or cumulative (list all)
        self.modalResults = True
        # custom debug actions
        self.debugActions = self.DebugActions(None, None, None)
        # avoid redundant calls to preParse
        self.callPreparse = True
        self.callDuringTry = False
        self.suppress_warnings_: list[Diagnostics] = []
        self.show_in_diagram = True

    @property
    def mayReturnEmpty(self):
        return self._may_return_empty

    @mayReturnEmpty.setter
    def mayReturnEmpty(self, value):
        self._may_return_empty = value

    def suppress_warning(self, warning_type: Diagnostics) -> ParserElement:
        """
        Suppress warnings emitted for a particular diagnostic on this expression.

        Example::

            base = pp.Forward()
            base.suppress_warning(Diagnostics.warn_on_parse_using_empty_Forward)

            # statement would normally raise a warning, but is now suppressed
            print(base.parse_string("x"))

        """
        self.suppress_warnings_.append(warning_type)
        return self

    def visit_all(self):
        """General-purpose method to yield all expressions and sub-expressions
        in a grammar. Typically just for internal use.
        """
        to_visit = deque([self])
        seen = set()
        while to_visit:
            cur = to_visit.popleft()

            # guard against looping forever through recursive grammars
            if cur in seen:
                continue
            seen.add(cur)

            to_visit.extend(cur.recurse())
            yield cur

    def copy(self) -> ParserElement:
        """
        Make a copy of this :class:`ParserElement`.  Useful for defining
        different parse actions for the same parsing pattern, using copies of
        the original parse element.

        Example::

            integer = Word(nums).set_parse_action(lambda toks: int(toks[0]))
            integerK = integer.copy().add_parse_action(lambda toks: toks[0] * 1024) + Suppress("K")
            integerM = integer.copy().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress("M")

            print((integerK | integerM | integer)[1, ...].parse_string("5K 100 640K 256M"))

        prints::

            [5120, 100, 655360, 268435456]

        Equivalent form of ``expr.copy()`` is just ``expr()``::

            integerM = integer().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress("M")
        """
        cpy = copy.copy(self)
        cpy.parseAction = self.parseAction[:]
        cpy.ignoreExprs = self.ignoreExprs[:]
        if self.copyDefaultWhiteChars:
            cpy.whiteChars = set(ParserElement.DEFAULT_WHITE_CHARS)
        return cpy

    def set_results_name(
        self, name: str, list_all_matches: bool = False, *, listAllMatches: bool = False
    ) -> ParserElement:
        """
        Define name for referencing matching tokens as a nested attribute
        of the returned parse results.

        Normally, results names are assigned as you would assign keys in a dict:
        any existing value is overwritten by later values. If it is necessary to
        keep all values captured for a particular results name, call ``set_results_name``
        with ``list_all_matches`` = True.

        NOTE: ``set_results_name`` returns a *copy* of the original :class:`ParserElement` object;
        this is so that the client can define a basic element, such as an
        integer, and reference it in multiple places with different names.

        You can also set results names using the abbreviated syntax,
        ``expr("name")`` in place of ``expr.set_results_name("name")``
        - see :class:`__call__`. If ``list_all_matches`` is required, use
        ``expr("name*")``.

        Example::

            integer = Word(nums)
            date_str = (integer.set_results_name("year") + '/'
                        + integer.set_results_name("month") + '/'
                        + integer.set_results_name("day"))

            # equivalent form:
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
        """
        listAllMatches = listAllMatches or list_all_matches
        return self._setResultsName(name, listAllMatches)

    def _setResultsName(self, name, list_all_matches=False) -> ParserElement:
        if name is None:
            return self
        newself = self.copy()
        if name.endswith("*"):
            name = name[:-1]
            list_all_matches = True
        newself.resultsName = name
        newself.modalResults = not list_all_matches
        return newself

    def set_break(self, break_flag: bool = True) -> ParserElement:
        """
        Method to invoke the Python pdb debugger when this element is
        about to be parsed. Set ``break_flag`` to ``True`` to enable, ``False`` to
        disable.
        """
        if break_flag:
            _parseMethod = self._parse

            def breaker(instring, loc, do_actions=True, callPreParse=True):
                # this call to breakpoint() is intentional, not a checkin error
                breakpoint()
                return _parseMethod(instring, loc, do_actions, callPreParse)

            breaker._originalParseMethod = _parseMethod  # type: ignore [attr-defined]
            self._parse = breaker  # type: ignore [method-assign]
        elif hasattr(self._parse, "_originalParseMethod"):
            self._parse = self._parse._originalParseMethod  # type: ignore [method-assign]
        return self

    def set_parse_action(self, *fns: ParseAction, **kwargs: Any) -> ParserElement:
        """
        Define one or more actions to perform when successfully matching parse element definition.

        Parse actions can be called to perform data conversions, do extra validation,
        update external data structures, or enhance or replace the parsed tokens.
        Each parse action ``fn`` is a callable method with 0-3 arguments, called as
        ``fn(s, loc, toks)`` , ``fn(loc, toks)`` , ``fn(toks)`` , or just ``fn()`` , where:

        - ``s``    = the original string being parsed (see note below)
        - ``loc``  = the location of the matching substring
        - ``toks`` = a list of the matched tokens, packaged as a :class:`ParseResults` object

        The parsed tokens are passed to the parse action as ParseResults. They can be
        modified in place using list-style append, extend, and pop operations to update
        the parsed list elements; and with dictionary-style item set and del operations
        to add, update, or remove any named results. If the tokens are modified in place,
        it is not necessary to return them with a return statement.

        Parse actions can also completely replace the given tokens, with another ``ParseResults``
        object, or with some entirely different object (common for parse actions that perform data
        conversions). A convenient way to build a new parse result is to define the values
        using a dict, and then create the return value using :class:`ParseResults.from_dict`.

        If None is passed as the ``fn`` parse action, all previously added parse actions for this
        expression are cleared.

        Optional keyword arguments:

        - ``call_during_try`` = (default= ``False``) indicate if parse action should be run during
          lookaheads and alternate testing. For parse actions that have side effects, it is
          important to only call the parse action once it is determined that it is being
          called as part of a successful parse. For parse actions that perform additional
          validation, then call_during_try should be passed as True, so that the validation
          code is included in the preliminary "try" parses.

        Note: the default parsing behavior is to expand tabs in the input string
        before starting the parsing process.  See :class:`parse_string` for more
        information on parsing strings containing ``<TAB>`` s, and suggested
        methods to maintain a consistent view of the parsed string, the parse
        location, and line and column positions within the parsed string.

        Example::

            # parse dates in the form YYYY/MM/DD

            # use parse action to convert toks from str to int at parse time
            def convert_to_int(toks):
                return int(toks[0])

            # use a parse action to verify that the date is a valid date
            def is_valid_date(instring, loc, toks):
                from datetime import date
                year, month, day = toks[::2]
                try:
                    date(year, month, day)
                except ValueError:
                    raise ParseException(instring, loc, "invalid date given")

            integer = Word(nums)
            date_str = integer + '/' + integer + '/' + integer

            # add parse actions
            integer.set_parse_action(convert_to_int)
            date_str.set_parse_action(is_valid_date)

            # note that integer fields are now ints, not strings
            date_str.run_tests('''
                # successful parse - note that integer fields were converted to ints
                1999/12/31

                # fail - invalid date
                1999/13/31
                ''')
        """
        if list(fns) == [None]:
            self.parseAction.clear()
            return self

        if not all(callable(fn) for fn in fns):
            raise TypeError("parse actions must be callable")
        self.parseAction[:] = [_trim_arity(fn) for fn in fns]
        self.callDuringTry = kwargs.get(
            "call_during_try", kwargs.get("callDuringTry", False)
        )

        return self

    def add_parse_action(self, *fns: ParseAction, **kwargs: Any) -> ParserElement:
        """
        Add one or more parse actions to expression's list of parse actions. See :class:`set_parse_action`.

        See examples in :class:`copy`.
        """
        self.parseAction += [_trim_arity(fn) for fn in fns]
        self.callDuringTry = self.callDuringTry or kwargs.get(
            "call_during_try", kwargs.get("callDuringTry", False)
        )
        return self

    def add_condition(self, *fns: ParseCondition, **kwargs: Any) -> ParserElement:
        """Add a boolean predicate function to expression's list of parse actions. See
        :class:`set_parse_action` for function call signatures. Unlike ``set_parse_action``,
        functions passed to ``add_condition`` need to return boolean success/fail of the condition.

        Optional keyword arguments:

        - ``message`` = define a custom message to be used in the raised exception
        - ``fatal`` = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise
          ParseException
        - ``call_during_try`` = boolean to indicate if this method should be called during internal tryParse calls,
          default=False

        Example::

            integer = Word(nums).set_parse_action(lambda toks: int(toks[0]))
            year_int = integer.copy()
            year_int.add_condition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
            date_str = year_int + '/' + integer + '/' + integer

            result = date_str.parse_string("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0),
                                                                         (line:1, col:1)
        """
        for fn in fns:
            self.parseAction.append(
                condition_as_parse_action(
                    fn,
                    message=str(kwargs.get("message")),
                    fatal=bool(kwargs.get("fatal", False)),
                )
            )

        self.callDuringTry = self.callDuringTry or kwargs.get(
            "call_during_try", kwargs.get("callDuringTry", False)
        )
        return self

    def set_fail_action(self, fn: ParseFailAction) -> ParserElement:
        """
        Define action to perform if parsing fails at this expression.
        Fail acton fn is a callable function that takes the arguments
        ``fn(s, loc, expr, err)`` where:

        - ``s`` = string being parsed
        - ``loc`` = location where expression match was attempted and failed
        - ``expr`` = the parse expression that failed
        - ``err`` = the exception thrown

        The function returns no value.  It may throw :class:`ParseFatalException`
        if it is desired to stop parsing immediately."""
        self.failAction = fn
        return self

    def _skipIgnorables(self, instring: str, loc: int) -> int:
        if not self.ignoreExprs:
            return loc
        exprsFound = True
        ignore_expr_fns = [e._parse for e in self.ignoreExprs]
        last_loc = loc
        while exprsFound:
            exprsFound = False
            for ignore_fn in ignore_expr_fns:
                try:
                    while 1:
                        loc, dummy = ignore_fn(instring, loc)
                        exprsFound = True
                except ParseException:
                    pass
            # check if all ignore exprs matched but didn't actually advance the parse location
            if loc == last_loc:
                break
            last_loc = loc
        return loc

    def preParse(self, instring: str, loc: int) -> int:
        if self.ignoreExprs:
            loc = self._skipIgnorables(instring, loc)

        if self.skipWhitespace:
            instrlen = len(instring)
            white_chars = self.whiteChars
            while loc < instrlen and instring[loc] in white_chars:
                loc += 1

        return loc

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        return loc, []

    def postParse(self, instring, loc, tokenlist):
        return tokenlist

    # @profile
    def _parseNoCache(
        self, instring, loc, do_actions=True, callPreParse=True
    ) -> tuple[int, ParseResults]:
        debugging = self.debug  # and do_actions)
        len_instring = len(instring)

        if debugging or self.failAction:
            # print("Match {} at loc {}({}, {})".format(self, loc, lineno(loc, instring), col(loc, instring)))
            try:
                if callPreParse and self.callPreparse:
                    pre_loc = self.preParse(instring, loc)
                else:
                    pre_loc = loc
                tokens_start = pre_loc
                if self.debugActions.debug_try:
                    self.debugActions.debug_try(instring, tokens_start, self, False)
                if self.mayIndexError or pre_loc >= len_instring:
                    try:
                        loc, tokens = self.parseImpl(instring, pre_loc, do_actions)
                    except IndexError:
                        raise ParseException(instring, len_instring, self.errmsg, self)
                else:
                    loc, tokens = self.parseImpl(instring, pre_loc, do_actions)
            except Exception as err:
                # print("Exception raised:", err)
                if self.debugActions.debug_fail:
                    self.debugActions.debug_fail(
                        instring, tokens_start, self, err, False
                    )
                if self.failAction:
                    self.failAction(instring, tokens_start, self, err)
                raise
        else:
            if callPreParse and self.callPreparse:
                pre_loc = self.preParse(instring, loc)
            else:
                pre_loc = loc
            tokens_start = pre_loc
            if self.mayIndexError or pre_loc >= len_instring:
                try:
                    loc, tokens = self.parseImpl(instring, pre_loc, do_actions)
                except IndexError:
                    raise ParseException(instring, len_instring, self.errmsg, self)
            else:
                loc, tokens = self.parseImpl(instring, pre_loc, do_actions)

        tokens = self.postParse(instring, loc, tokens)

        ret_tokens = ParseResults(
            tokens, self.resultsName, asList=self.saveAsList, modal=self.modalResults
        )
        if self.parseAction and (do_actions or self.callDuringTry):
            if debugging:
                try:
                    for fn in self.parseAction:
                        try:
                            tokens = fn(instring, tokens_start, ret_tokens)  # type: ignore [call-arg, arg-type]
                        except IndexError as parse_action_exc:
                            exc = ParseException("exception raised in parse action")
                            raise exc from parse_action_exc

                        if tokens is not None and tokens is not ret_tokens:
                            ret_tokens = ParseResults(
                                tokens,
                                self.resultsName,
                                asList=self.saveAsList
                                and isinstance(tokens, (ParseResults, list)),
                                modal=self.modalResults,
                            )
                except Exception as err:
                    # print "Exception raised in user parse action:", err
                    if self.debugActions.debug_fail:
                        self.debugActions.debug_fail(
                            instring, tokens_start, self, err, False
                        )
                    raise
            else:
                for fn in self.parseAction:
                    try:
                        tokens = fn(instring, tokens_start, ret_tokens)  # type: ignore [call-arg, arg-type]
                    except IndexError as parse_action_exc:
                        exc = ParseException("exception raised in parse action")
                        raise exc from parse_action_exc

                    if tokens is not None and tokens is not ret_tokens:
                        ret_tokens = ParseResults(
                            tokens,
                            self.resultsName,
                            asList=self.saveAsList
                            and isinstance(tokens, (ParseResults, list)),
                            modal=self.modalResults,
                        )
        if debugging:
            # print("Matched", self, "->", ret_tokens.as_list())
            if self.debugActions.debug_match:
                self.debugActions.debug_match(
                    instring, tokens_start, loc, self, ret_tokens, False
                )

        return loc, ret_tokens

    def try_parse(
        self,
        instring: str,
        loc: int,
        *,
        raise_fatal: bool = False,
        do_actions: bool = False,
    ) -> int:
        try:
            return self._parse(instring, loc, do_actions=do_actions)[0]
        except ParseFatalException:
            if raise_fatal:
                raise
            raise ParseException(instring, loc, self.errmsg, self)

    def can_parse_next(self, instring: str, loc: int, do_actions: bool = False) -> bool:
        try:
            self.try_parse(instring, loc, do_actions=do_actions)
        except (ParseException, IndexError):
            return False
        else:
            return True

    # cache for left-recursion in Forward references
    recursion_lock = RLock()
    recursion_memos: collections.abc.MutableMapping[
        tuple[int, Forward, bool], tuple[int, Union[ParseResults, Exception]]
    ] = {}

    class _CacheType(typing.Protocol):
        """
        Class to be used for packrat and left-recursion cacheing of results
        and exceptions.
        """

        not_in_cache: bool

        def get(self, *args) -> typing.Any: ...

        def set(self, *args) -> None: ...

        def clear(self) -> None: ...

    class NullCache(dict):
        """
        A null cache type for initialization of the packrat_cache class variable.
        If/when enable_packrat() is called, this null cache will be replaced by a
        proper _CacheType class instance.
        """

        not_in_cache: bool = True

        def get(self, *args) -> typing.Any: ...

        def set(self, *args) -> None: ...

        def clear(self) -> None: ...

    # class-level argument cache for optimizing repeated calls when backtracking
    # through recursive expressions
    packrat_cache: _CacheType = NullCache()
    packrat_cache_lock = RLock()
    packrat_cache_stats = [0, 0]

    # this method gets repeatedly called during backtracking with the same arguments -
    # we can cache these arguments and save ourselves the trouble of re-parsing the contained expression
    def _parseCache(
        self, instring, loc, do_actions=True, callPreParse=True
    ) -> tuple[int, ParseResults]:
        HIT, MISS = 0, 1
        lookup = (self, instring, loc, callPreParse, do_actions)
        with ParserElement.packrat_cache_lock:
            cache = ParserElement.packrat_cache
            value = cache.get(lookup)
            if value is cache.not_in_cache:
                ParserElement.packrat_cache_stats[MISS] += 1
                try:
                    value = self._parseNoCache(instring, loc, do_actions, callPreParse)
                except ParseBaseException as pe:
                    # cache a copy of the exception, without the traceback
                    cache.set(lookup, pe.__class__(*pe.args))
                    raise
                else:
                    cache.set(lookup, (value[0], value[1].copy(), loc))
                    return value
            else:
                ParserElement.packrat_cache_stats[HIT] += 1
                if self.debug and self.debugActions.debug_try:
                    try:
                        self.debugActions.debug_try(instring, loc, self, cache_hit=True)  # type: ignore [call-arg]
                    except TypeError:
                        pass
                if isinstance(value, Exception):
                    if self.debug and self.debugActions.debug_fail:
                        try:
                            self.debugActions.debug_fail(
                                instring, loc, self, value, cache_hit=True  # type: ignore [call-arg]
                            )
                        except TypeError:
                            pass
                    raise value

                value = cast(tuple[int, ParseResults, int], value)
                loc_, result, endloc = value[0], value[1].copy(), value[2]
                if self.debug and self.debugActions.debug_match:
                    try:
                        self.debugActions.debug_match(
                            instring, loc_, endloc, self, result, cache_hit=True  # type: ignore [call-arg]
                        )
                    except TypeError:
                        pass

                return loc_, result

    _parse = _parseNoCache

    @staticmethod
    def reset_cache() -> None:
        ParserElement.packrat_cache.clear()
        ParserElement.packrat_cache_stats[:] = [0] * len(
            ParserElement.packrat_cache_stats
        )
        ParserElement.recursion_memos.clear()

    _packratEnabled = False
    _left_recursion_enabled = False

    @staticmethod
    def disable_memoization() -> None:
        """
        Disables active Packrat or Left Recursion parsing and their memoization

        This method also works if neither Packrat nor Left Recursion are enabled.
        This makes it safe to call before activating Packrat nor Left Recursion
        to clear any previous settings.
        """
        ParserElement.reset_cache()
        ParserElement._left_recursion_enabled = False
        ParserElement._packratEnabled = False
        ParserElement._parse = ParserElement._parseNoCache

    @staticmethod
    def enable_left_recursion(
        cache_size_limit: typing.Optional[int] = None, *, force=False
    ) -> None:
        """
        Enables "bounded recursion" parsing, which allows for both direct and indirect
        left-recursion. During parsing, left-recursive :class:`Forward` elements are
        repeatedly matched with a fixed recursion depth that is gradually increased
        until finding the longest match.

        Example::

            import pyparsing as pp
            pp.ParserElement.enable_left_recursion()

            E = pp.Forward("E")
            num = pp.Word(pp.nums)
            # match `num`, or `num '+' num`, or `num '+' num '+' num`, ...
            E <<= E + '+' - num | num

            print(E.parse_string("1+2+3"))

        Recursion search naturally memoizes matches of ``Forward`` elements and may
        thus skip reevaluation of parse actions during backtracking. This may break
        programs with parse actions which rely on strict ordering of side-effects.

        Parameters:

        - ``cache_size_limit`` - (default=``None``) - memoize at most this many
          ``Forward`` elements during matching; if ``None`` (the default),
          memoize all ``Forward`` elements.

        Bounded Recursion parsing works similar but not identical to Packrat parsing,
        thus the two cannot be used together. Use ``force=True`` to disable any
        previous, conflicting settings.
        """
        if force:
            ParserElement.disable_memoization()
        elif ParserElement._packratEnabled:
            raise RuntimeError("Packrat and Bounded Recursion are not compatible")
        if cache_size_limit is None:
            ParserElement.recursion_memos = _UnboundedMemo()
        elif cache_size_limit > 0:
            ParserElement.recursion_memos = _LRUMemo(capacity=cache_size_limit)  # type: ignore[assignment]
        else:
            raise NotImplementedError(f"Memo size of {cache_size_limit}")
        ParserElement._left_recursion_enabled = True

    @staticmethod
    def enable_packrat(
        cache_size_limit: Union[int, None] = 128, *, force: bool = False
    ) -> None:
        """
        Enables "packrat" parsing, which adds memoizing to the parsing logic.
        Repeated parse attempts at the same string location (which happens
        often in many complex grammars) can immediately return a cached value,
        instead of re-executing parsing/validating code.  Memoizing is done of
        both valid results and parsing exceptions.

        Parameters:

        - ``cache_size_limit`` - (default= ``128``) - if an integer value is provided
          will limit the size of the packrat cache; if None is passed, then
          the cache size will be unbounded; if 0 is passed, the cache will
          be effectively disabled.

        This speedup may break existing programs that use parse actions that
        have side-effects.  For this reason, packrat parsing is disabled when
        you first import pyparsing.  To activate the packrat feature, your
        program must call the class method :class:`ParserElement.enable_packrat`.
        For best results, call ``enable_packrat()`` immediately after
        importing pyparsing.

        Example::

            import pyparsing
            pyparsing.ParserElement.enable_packrat()

        Packrat parsing works similar but not identical to Bounded Recursion parsing,
        thus the two cannot be used together. Use ``force=True`` to disable any
        previous, conflicting settings.
        """
        if force:
            ParserElement.disable_memoization()
        elif ParserElement._left_recursion_enabled:
            raise RuntimeError("Packrat and Bounded Recursion are not compatible")

        if ParserElement._packratEnabled:
            return

        ParserElement._packratEnabled = True
        if cache_size_limit is None:
            ParserElement.packrat_cache = _UnboundedCache()
        else:
            ParserElement.packrat_cache = _FifoCache(cache_size_limit)
        ParserElement._parse = ParserElement._parseCache

    def parse_string(
        self, instring: str, parse_all: bool = False, *, parseAll: bool = False
    ) -> ParseResults:
        """
        Parse a string with respect to the parser definition. This function is intended as the primary interface to the
        client code.

        :param instring: The input string to be parsed.
        :param parse_all: If set, the entire input string must match the grammar.
        :param parseAll: retained for pre-PEP8 compatibility, will be removed in a future release.
        :raises ParseException: Raised if ``parse_all`` is set and the input string does not match the whole grammar.
        :returns: the parsed data as a :class:`ParseResults` object, which may be accessed as a `list`, a `dict`, or
          an object with attributes if the given parser includes results names.

        If the input string is required to match the entire grammar, ``parse_all`` flag must be set to ``True``. This
        is also equivalent to ending the grammar with :class:`StringEnd`\\ ().

        To report proper column numbers, ``parse_string`` operates on a copy of the input string where all tabs are
        converted to spaces (8 spaces per tab, as per the default in ``string.expandtabs``). If the input string
        contains tabs and the grammar uses parse actions that use the ``loc`` argument to index into the string
        being parsed, one can ensure a consistent view of the input string by doing one of the following:

        - calling ``parse_with_tabs`` on your grammar before calling ``parse_string`` (see :class:`parse_with_tabs`),
        - define your parse action using the full ``(s,loc,toks)`` signature, and reference the input string using the
          parse action's ``s`` argument, or
        - explicitly expand the tabs in your input string before calling ``parse_string``.

        Examples:

        By default, partial matches are OK.

        >>> res = Word('a').parse_string('aaaaabaaa')
        >>> print(res)
        ['aaaaa']

        The parsing behavior varies by the inheriting class of this abstract class. Please refer to the children
        directly to see more examples.

        It raises an exception if parse_all flag is set and instring does not match the whole grammar.

        >>> res = Word('a').parse_string('aaaaabaaa', parse_all=True)
        Traceback (most recent call last):
        ...
        pyparsing.ParseException: Expected end of text, found 'b'  (at char 5), (line:1, col:6)
        """
        parseAll = parse_all or parseAll

        ParserElement.reset_cache()
        if not self.streamlined:
            self.streamline()
        for e in self.ignoreExprs:
            e.streamline()
        if not self.keepTabs:
            instring = instring.expandtabs()
        try:
            loc, tokens = self._parse(instring, 0)
            if parseAll:
                loc = self.preParse(instring, loc)
                se = Empty() + StringEnd().set_debug(False)
                se._parse(instring, loc)
        except _ParseActionIndexError as pa_exc:
            raise pa_exc.exc
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise

            # catch and re-raise exception from here, clearing out pyparsing internal stack trace
            raise exc.with_traceback(None)
        else:
            return tokens

    def scan_string(
        self,
        instring: str,
        max_matches: int = _MAX_INT,
        overlap: bool = False,
        always_skip_whitespace=True,
        *,
        debug: bool = False,
        maxMatches: int = _MAX_INT,
    ) -> Generator[tuple[ParseResults, int, int], None, None]:
        """
        Scan the input string for expression matches.  Each match will return the
        matching tokens, start location, and end location.  May be called with optional
        ``max_matches`` argument, to clip scanning after 'n' matches are found.  If
        ``overlap`` is specified, then overlapping matches will be reported.

        Note that the start and end locations are reported relative to the string
        being parsed.  See :class:`parse_string` for more information on parsing
        strings with embedded tabs.

        Example::

            source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
            print(source)
            for tokens, start, end in Word(alphas).scan_string(source):
                print(' '*start + '^'*(end-start))
                print(' '*start + tokens[0])

        prints::

            sldjf123lsdjjkf345sldkjf879lkjsfd987
            ^^^^^
            sldjf
                    ^^^^^^^
                    lsdjjkf
                              ^^^^^^
                              sldkjf
                                       ^^^^^^
                                       lkjsfd
        """
        maxMatches = min(maxMatches, max_matches)
        if not self.streamlined:
            self.streamline()
        for e in self.ignoreExprs:
            e.streamline()

        if not self.keepTabs:
            instring = str(instring).expandtabs()
        instrlen = len(instring)
        loc = 0
        if always_skip_whitespace:
            preparser = Empty()
            preparser.ignoreExprs = self.ignoreExprs
            preparser.whiteChars = self.whiteChars
            preparseFn = preparser.preParse
        else:
            preparseFn = self.preParse
        parseFn = self._parse
        ParserElement.resetCache()
        matches = 0
        try:
            while loc <= instrlen and matches < maxMatches:
                try:
                    preloc: int = preparseFn(instring, loc)
                    nextLoc: int
                    tokens: ParseResults
                    nextLoc, tokens = parseFn(instring, preloc, callPreParse=False)
                except ParseException:
                    loc = preloc + 1
                else:
                    if nextLoc > loc:
                        matches += 1
                        if debug:
                            print(
                                {
                                    "tokens": tokens.asList(),
                                    "start": preloc,
                                    "end": nextLoc,
                                }
                            )
                        yield tokens, preloc, nextLoc
                        if overlap:
                            nextloc = preparseFn(instring, loc)
                            if nextloc > loc:
                                loc = nextLoc
                            else:
                                loc += 1
                        else:
                            loc = nextLoc
                    else:
                        loc = preloc + 1
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise

            # catch and re-raise exception from here, clears out pyparsing internal stack trace
            raise exc.with_traceback(None)

    def transform_string(self, instring: str, *, debug: bool = False) -> str:
        """
        Extension to :class:`scan_string`, to modify matching text with modified tokens that may
        be returned from a parse action.  To use ``transform_string``, define a grammar and
        attach a parse action to it that modifies the returned token list.
        Invoking ``transform_string()`` on a target string will then scan for matches,
        and replace the matched text patterns according to the logic in the parse
        action.  ``transform_string()`` returns the resulting transformed string.

        Example::

            wd = Word(alphas)
            wd.set_parse_action(lambda toks: toks[0].title())

            print(wd.transform_string("now is the winter of our discontent made glorious summer by this sun of york."))

        prints::

            Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
        """
        out: list[str] = []
        lastE = 0
        # force preservation of <TAB>s, to minimize unwanted transformation of string, and to
        # keep string locs straight between transform_string and scan_string
        self.keepTabs = True
        try:
            for t, s, e in self.scan_string(instring, debug=debug):
                if s > lastE:
                    out.append(instring[lastE:s])
                lastE = e

                if not t:
                    continue

                if isinstance(t, ParseResults):
                    out += t.as_list()
                elif isinstance(t, Iterable) and not isinstance(t, str_type):
                    out.extend(t)
                else:
                    out.append(t)

            out.append(instring[lastE:])
            out = [o for o in out if o]
            return "".join([str(s) for s in _flatten(out)])
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise

            # catch and re-raise exception from here, clears out pyparsing internal stack trace
            raise exc.with_traceback(None)

    def search_string(
        self,
        instring: str,
        max_matches: int = _MAX_INT,
        *,
        debug: bool = False,
        maxMatches: int = _MAX_INT,
    ) -> ParseResults:
        """
        Another extension to :class:`scan_string`, simplifying the access to the tokens found
        to match the given parse expression.  May be called with optional
        ``max_matches`` argument, to clip searching after 'n' matches are found.

        Example::

            # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
            cap_word = Word(alphas.upper(), alphas.lower())

            print(cap_word.search_string("More than Iron, more than Lead, more than Gold I need Electricity"))

            # the sum() builtin can be used to merge results into a single ParseResults object
            print(sum(cap_word.search_string("More than Iron, more than Lead, more than Gold I need Electricity")))

        prints::

            [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
            ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
        """
        maxMatches = min(maxMatches, max_matches)
        try:
            return ParseResults(
                [
                    t
                    for t, s, e in self.scan_string(
                        instring, maxMatches, always_skip_whitespace=False, debug=debug
                    )
                ]
            )
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise

            # catch and re-raise exception from here, clears out pyparsing internal stack trace
            raise exc.with_traceback(None)

    def split(
        self,
        instring: str,
        maxsplit: int = _MAX_INT,
        include_separators: bool = False,
        *,
        includeSeparators=False,
    ) -> Generator[str, None, None]:
        """
        Generator method to split a string using the given expression as a separator.
        May be called with optional ``maxsplit`` argument, to limit the number of splits;
        and the optional ``include_separators`` argument (default= ``False``), if the separating
        matching text should be included in the split results.

        Example::

            punc = one_of(list(".,;:/-!?"))
            print(list(punc.split("This, this?, this sentence, is badly punctuated!")))

        prints::

            ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
        """
        includeSeparators = includeSeparators or include_separators
        last = 0
        for t, s, e in self.scan_string(instring, max_matches=maxsplit):
            yield instring[last:s]
            if includeSeparators:
                yield t[0]
            last = e
        yield instring[last:]

    def __add__(self, other) -> ParserElement:
        """
        Implementation of ``+`` operator - returns :class:`And`. Adding strings to a :class:`ParserElement`
        converts them to :class:`Literal`\\ s by default.

        Example::

            greet = Word(alphas) + "," + Word(alphas) + "!"
            hello = "Hello, World!"
            print(hello, "->", greet.parse_string(hello))

        prints::

            Hello, World! -> ['Hello', ',', 'World', '!']

        ``...`` may be used as a parse expression as a short form of :class:`SkipTo`::

            Literal('start') + ... + Literal('end')

        is equivalent to::

            Literal('start') + SkipTo('end')("_skipped*") + Literal('end')

        Note that the skipped text is returned with '_skipped' as a results name,
        and to support having multiple skips in the same parser, the value returned is
        a list of all skipped text.
        """
        if other is Ellipsis:
            return _PendingSkip(self)

        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return And([self, other])

    def __radd__(self, other) -> ParserElement:
        """
        Implementation of ``+`` operator when left operand is not a :class:`ParserElement`
        """
        if other is Ellipsis:
            return SkipTo(self)("_skipped*") + self

        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return other + self

    def __sub__(self, other) -> ParserElement:
        """
        Implementation of ``-`` operator, returns :class:`And` with error stop
        """
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return self + And._ErrorStop() + other

    def __rsub__(self, other) -> ParserElement:
        """
        Implementation of ``-`` operator when left operand is not a :class:`ParserElement`
        """
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return other - self

    def __mul__(self, other) -> ParserElement:
        """
        Implementation of ``*`` operator, allows use of ``expr * 3`` in place of
        ``expr + expr + expr``.  Expressions may also be multiplied by a 2-integer
        tuple, similar to ``{min, max}`` multipliers in regular expressions.  Tuples
        may also include ``None`` as in:

        - ``expr*(n, None)`` or ``expr*(n, )`` is equivalent
          to ``expr*n + ZeroOrMore(expr)``
          (read as "at least n instances of ``expr``")
        - ``expr*(None, n)`` is equivalent to ``expr*(0, n)``
          (read as "0 to n instances of ``expr``")
        - ``expr*(None, None)`` is equivalent to ``ZeroOrMore(expr)``
        - ``expr*(1, None)`` is equivalent to ``OneOrMore(expr)``

        Note that ``expr*(None, n)`` does not raise an exception if
        more than n exprs exist in the input stream; that is,
        ``expr*(None, n)`` does not enforce a maximum number of expr
        occurrences.  If this behavior is desired, then write
        ``expr*(None, n) + ~expr``
        """
        if other is Ellipsis:
            other = (0, None)
        elif isinstance(other, tuple) and other[:1] == (Ellipsis,):
            other = ((0,) + other[1:] + (None,))[:2]

        if not isinstance(other, (int, tuple)):
            return NotImplemented

        if isinstance(other, int):
            minElements, optElements = other, 0
        else:
            other = tuple(o if o is not Ellipsis else None for o in other)
            other = (other + (None, None))[:2]
            if other[0] is None:
                other = (0, other[1])
            if isinstance(other[0], int) and other[1] is None:
                if other[0] == 0:
                    return ZeroOrMore(self)
                if other[0] == 1:
                    return OneOrMore(self)
                else:
                    return self * other[0] + ZeroOrMore(self)
            elif isinstance(other[0], int) and isinstance(other[1], int):
                minElements, optElements = other
                optElements -= minElements
            else:
                return NotImplemented

        if minElements < 0:
            raise ValueError("cannot multiply ParserElement by negative value")
        if optElements < 0:
            raise ValueError(
                "second tuple value must be greater or equal to first tuple value"
            )
        if minElements == optElements == 0:
            return And([])

        if optElements:

            def makeOptionalList(n):
                if n > 1:
                    return Opt(self + makeOptionalList(n - 1))
                else:
                    return Opt(self)

            if minElements:
                if minElements == 1:
                    ret = self + makeOptionalList(optElements)
                else:
                    ret = And([self] * minElements) + makeOptionalList(optElements)
            else:
                ret = makeOptionalList(optElements)
        else:
            if minElements == 1:
                ret = self
            else:
                ret = And([self] * minElements)
        return ret

    def __rmul__(self, other) -> ParserElement:
        return self.__mul__(other)

    def __or__(self, other) -> ParserElement:
        """
        Implementation of ``|`` operator - returns :class:`MatchFirst`
        """
        if other is Ellipsis:
            return _PendingSkip(self, must_skip=True)

        if isinstance(other, str_type):
            # `expr | ""` is equivalent to `Opt(expr)`
            if other == "":
                return Opt(self)
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return MatchFirst([self, other])

    def __ror__(self, other) -> ParserElement:
        """
        Implementation of ``|`` operator when left operand is not a :class:`ParserElement`
        """
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return other | self

    def __xor__(self, other) -> ParserElement:
        """
        Implementation of ``^`` operator - returns :class:`Or`
        """
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return Or([self, other])

    def __rxor__(self, other) -> ParserElement:
        """
        Implementation of ``^`` operator when left operand is not a :class:`ParserElement`
        """
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return other ^ self

    def __and__(self, other) -> ParserElement:
        """
        Implementation of ``&`` operator - returns :class:`Each`
        """
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return Each([self, other])

    def __rand__(self, other) -> ParserElement:
        """
        Implementation of ``&`` operator when left operand is not a :class:`ParserElement`
        """
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return other & self

    def __invert__(self) -> ParserElement:
        """
        Implementation of ``~`` operator - returns :class:`NotAny`
        """
        return NotAny(self)

    # disable __iter__ to override legacy use of sequential access to __getitem__ to
    # iterate over a sequence
    __iter__ = None

    def __getitem__(self, key):
        """
        use ``[]`` indexing notation as a short form for expression repetition:

        - ``expr[n]`` is equivalent to ``expr*n``
        - ``expr[m, n]`` is equivalent to ``expr*(m, n)``
        - ``expr[n, ...]`` or ``expr[n,]`` is equivalent
             to ``expr*n + ZeroOrMore(expr)``
             (read as "at least n instances of ``expr``")
        - ``expr[..., n]`` is equivalent to ``expr*(0, n)``
             (read as "0 to n instances of ``expr``")
        - ``expr[...]`` and ``expr[0, ...]`` are equivalent to ``ZeroOrMore(expr)``
        - ``expr[1, ...]`` is equivalent to ``OneOrMore(expr)``

        ``None`` may be used in place of ``...``.

        Note that ``expr[..., n]`` and ``expr[m, n]`` do not raise an exception
        if more than ``n`` ``expr``\\ s exist in the input stream.  If this behavior is
        desired, then write ``expr[..., n] + ~expr``.

        For repetition with a stop_on expression, use slice notation:

        - ``expr[...: end_expr]`` and ``expr[0, ...: end_expr]`` are equivalent to ``ZeroOrMore(expr, stop_on=end_expr)``
        - ``expr[1, ...: end_expr]`` is equivalent to ``OneOrMore(expr, stop_on=end_expr)``

        """

        stop_on_defined = False
        stop_on = NoMatch()
        if isinstance(key, slice):
            key, stop_on = key.start, key.stop
            if key is None:
                key = ...
            stop_on_defined = True
        elif isinstance(key, tuple) and isinstance(key[-1], slice):
            key, stop_on = (key[0], key[1].start), key[1].stop
            stop_on_defined = True

        # convert single arg keys to tuples
        if isinstance(key, str_type):
            key = (key,)
        try:
            iter(key)
        except TypeError:
            key = (key, key)

        if len(key) > 2:
            raise TypeError(
                f"only 1 or 2 index arguments supported ({key[:5]}{f'... [{len(key)}]' if len(key) > 5 else ''})"
            )

        # clip to 2 elements
        ret = self * tuple(key[:2])
        ret = typing.cast(_MultipleMatch, ret)

        if stop_on_defined:
            ret.stopOn(stop_on)

        return ret

    def __call__(self, name: typing.Optional[str] = None) -> ParserElement:
        """
        Shortcut for :class:`set_results_name`, with ``list_all_matches=False``.

        If ``name`` is given with a trailing ``'*'`` character, then ``list_all_matches`` will be
        passed as ``True``.

        If ``name`` is omitted, same as calling :class:`copy`.

        Example::

            # these are equivalent
            userdata = Word(alphas).set_results_name("name") + Word(nums + "-").set_results_name("socsecno")
            userdata = Word(alphas)("name") + Word(nums + "-")("socsecno")
        """
        if name is not None:
            return self._setResultsName(name)

        return self.copy()

    def suppress(self) -> ParserElement:
        """
        Suppresses the output of this :class:`ParserElement`; useful to keep punctuation from
        cluttering up returned output.
        """
        return Suppress(self)

    def ignore_whitespace(self, recursive: bool = True) -> ParserElement:
        """
        Enables the skipping of whitespace before matching the characters in the
        :class:`ParserElement`'s defined pattern.

        :param recursive: If ``True`` (the default), also enable whitespace skipping in child elements (if any)
        """
        self.skipWhitespace = True
        return self

    def leave_whitespace(self, recursive: bool = True) -> ParserElement:
        """
        Disables the skipping of whitespace before matching the characters in the
        :class:`ParserElement`'s defined pattern.  This is normally only used internally by
        the pyparsing module, but may be needed in some whitespace-sensitive grammars.

        :param recursive: If true (the default), also disable whitespace skipping in child elements (if any)
        """
        self.skipWhitespace = False
        return self

    def set_whitespace_chars(
        self, chars: Union[set[str], str], copy_defaults: bool = False
    ) -> ParserElement:
        """
        Overrides the default whitespace chars
        """
        self.skipWhitespace = True
        self.whiteChars = set(chars)
        self.copyDefaultWhiteChars = copy_defaults
        return self

    def parse_with_tabs(self) -> ParserElement:
        """
        Overrides default behavior to expand ``<TAB>`` s to spaces before parsing the input string.
        Must be called before ``parse_string`` when the input grammar contains elements that
        match ``<TAB>`` characters.
        """
        self.keepTabs = True
        return self

    def ignore(self, other: ParserElement) -> ParserElement:
        """
        Define expression to be ignored (e.g., comments) while doing pattern
        matching; may be called repeatedly, to define multiple comment or other
        ignorable patterns.

        Example::

            patt = Word(alphas)[...]
            patt.parse_string('ablaj /* comment */ lskjd')
            # -> ['ablaj']

            patt.ignore(c_style_comment)
            patt.parse_string('ablaj /* comment */ lskjd')
            # -> ['ablaj', 'lskjd']
        """
        if isinstance(other, str_type):
            other = Suppress(other)

        if isinstance(other, Suppress):
            if other not in self.ignoreExprs:
                self.ignoreExprs.append(other)
        else:
            self.ignoreExprs.append(Suppress(other.copy()))
        return self

    def set_debug_actions(
        self,
        start_action: DebugStartAction,
        success_action: DebugSuccessAction,
        exception_action: DebugExceptionAction,
    ) -> ParserElement:
        """
        Customize display of debugging messages while doing pattern matching:

        - ``start_action`` - method to be called when an expression is about to be parsed;
          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, cache_hit: bool)``

        - ``success_action`` - method to be called when an expression has successfully parsed;
          should have the signature ``fn(input_string: str, start_location: int, end_location: int, expression: ParserELement, parsed_tokens: ParseResults, cache_hit: bool)``

        - ``exception_action`` - method to be called when expression fails to parse;
          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, exception: Exception, cache_hit: bool)``
        """
        self.debugActions = self.DebugActions(
            start_action or _default_start_debug_action,  # type: ignore[truthy-function]
            success_action or _default_success_debug_action,  # type: ignore[truthy-function]
            exception_action or _default_exception_debug_action,  # type: ignore[truthy-function]
        )
        self.debug = True
        return self

    def set_debug(self, flag: bool = True, recurse: bool = False) -> ParserElement:
        """
        Enable display of debugging messages while doing pattern matching.
        Set ``flag`` to ``True`` to enable, ``False`` to disable.
        Set ``recurse`` to ``True`` to set the debug flag on this expression and all sub-expressions.

        Example::

            wd = Word(alphas).set_name("alphaword")
            integer = Word(nums).set_name("numword")
            term = wd | integer

            # turn on debugging for wd
            wd.set_debug()

            term[1, ...].parse_string("abc 123 xyz 890")

        prints::

            Match alphaword at loc 0(1,1)
            Matched alphaword -> ['abc']
            Match alphaword at loc 3(1,4)
            Exception raised:Expected alphaword (at char 4), (line:1, col:5)
            Match alphaword at loc 7(1,8)
            Matched alphaword -> ['xyz']
            Match alphaword at loc 11(1,12)
            Exception raised:Expected alphaword (at char 12), (line:1, col:13)
            Match alphaword at loc 15(1,16)
            Exception raised:Expected alphaword (at char 15), (line:1, col:16)

        The output shown is that produced by the default debug actions - custom debug actions can be
        specified using :class:`set_debug_actions`. Prior to attempting
        to match the ``wd`` expression, the debugging message ``"Match <exprname> at loc <n>(<line>,<col>)"``
        is shown. Then if the parse succeeds, a ``"Matched"`` message is shown, or an ``"Exception raised"``
        message is shown. Also note the use of :class:`set_name` to assign a human-readable name to the expression,
        which makes debugging and exception messages easier to understand - for instance, the default
        name created for the :class:`Word` expression without calling ``set_name`` is ``"W:(A-Za-z)"``.
        """
        if recurse:
            for expr in self.visit_all():
                expr.set_debug(flag, recurse=False)
            return self

        if flag:
            self.set_debug_actions(
                _default_start_debug_action,
                _default_success_debug_action,
                _default_exception_debug_action,
            )
        else:
            self.debug = False
        return self

    @property
    def default_name(self) -> str:
        if self._defaultName is None:
            self._defaultName = self._generateDefaultName()
        return self._defaultName

    @abstractmethod
    def _generateDefaultName(self) -> str:
        """
        Child classes must define this method, which defines how the ``default_name`` is set.
        """

    def set_name(self, name: typing.Optional[str]) -> ParserElement:
        """
        Define name for this expression, makes debugging and exception messages clearer. If
        `__diag__.enable_debug_on_named_expressions` is set to True, setting a name will also
        enable debug for this expression.

        If `name` is None, clears any custom name for this expression, and clears the
        debug flag is it was enabled via `__diag__.enable_debug_on_named_expressions`.

        Example::

            integer = Word(nums)
            integer.parse_string("ABC")  # -> Exception: Expected W:(0-9) (at char 0), (line:1, col:1)

            integer.set_name("integer")
            integer.parse_string("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
        """
        self.customName = name  # type: ignore[assignment]
        self.errmsg = f"Expected {str(self)}"

        if __diag__.enable_debug_on_named_expressions:
            self.set_debug(name is not None)

        return self

    @property
    def name(self) -> str:
        # This will use a user-defined name if available, but otherwise defaults back to the auto-generated name
        return self.customName if self.customName is not None else self.default_name

    @name.setter
    def name(self, new_name) -> None:
        self.set_name(new_name)

    def __str__(self) -> str:
        return self.name

    def __repr__(self) -> str:
        return str(self)

    def streamline(self) -> ParserElement:
        self.streamlined = True
        self._defaultName = None
        return self

    def recurse(self) -> list[ParserElement]:
        return []

    def _checkRecursion(self, parseElementList):
        subRecCheckList = parseElementList[:] + [self]
        for e in self.recurse():
            e._checkRecursion(subRecCheckList)

    def validate(self, validateTrace=None) -> None:
        """
        Check defined expressions for valid structure, check for infinite recursive definitions.
        """
        warnings.warn(
            "ParserElement.validate() is deprecated, and should not be used to check for left recursion",
            DeprecationWarning,
            stacklevel=2,
        )
        self._checkRecursion([])

    def parse_file(
        self,
        file_or_filename: Union[str, Path, TextIO],
        encoding: str = "utf-8",
        parse_all: bool = False,
        *,
        parseAll: bool = False,
    ) -> ParseResults:
        """
        Execute the parse expression on the given file or filename.
        If a filename is specified (instead of a file object),
        the entire file is opened, read, and closed before parsing.
        """
        parseAll = parseAll or parse_all
        try:
            file_or_filename = typing.cast(TextIO, file_or_filename)
            file_contents = file_or_filename.read()
        except AttributeError:
            file_or_filename = typing.cast(str, file_or_filename)
            with open(file_or_filename, "r", encoding=encoding) as f:
                file_contents = f.read()
        try:
            return self.parse_string(file_contents, parseAll)
        except ParseBaseException as exc:
            if ParserElement.verbose_stacktrace:
                raise

            # catch and re-raise exception from here, clears out pyparsing internal stack trace
            raise exc.with_traceback(None)

    def __eq__(self, other):
        if self is other:
            return True
        elif isinstance(other, str_type):
            return self.matches(other, parse_all=True)
        elif isinstance(other, ParserElement):
            return vars(self) == vars(other)
        return False

    def __hash__(self):
        return id(self)

    def matches(
        self, test_string: str, parse_all: bool = True, *, parseAll: bool = True
    ) -> bool:
        """
        Method for quick testing of a parser against a test string. Good for simple
        inline microtests of sub expressions while building up larger parser.

        Parameters:

        - ``test_string`` - to test against this expression for a match
        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests

        Example::

            expr = Word(nums)
            assert expr.matches("100")
        """
        parseAll = parseAll and parse_all
        try:
            self.parse_string(str(test_string), parse_all=parseAll)
            return True
        except ParseBaseException:
            return False

    def run_tests(
        self,
        tests: Union[str, list[str]],
        parse_all: bool = True,
        comment: typing.Optional[Union[ParserElement, str]] = "#",
        full_dump: bool = True,
        print_results: bool = True,
        failure_tests: bool = False,
        post_parse: typing.Optional[
            Callable[[str, ParseResults], typing.Optional[str]]
        ] = None,
        file: typing.Optional[TextIO] = None,
        with_line_numbers: bool = False,
        *,
        parseAll: bool = True,
        fullDump: bool = True,
        printResults: bool = True,
        failureTests: bool = False,
        postParse: typing.Optional[
            Callable[[str, ParseResults], typing.Optional[str]]
        ] = None,
    ) -> tuple[bool, list[tuple[str, Union[ParseResults, Exception]]]]:
        """
        Execute the parse expression on a series of test strings, showing each
        test, the parsed results or where the parse failed. Quick and easy way to
        run a parse expression against a list of sample strings.

        Parameters:

        - ``tests`` - a list of separate test strings, or a multiline string of test strings
        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests
        - ``comment`` - (default= ``'#'``) - expression for indicating embedded comments in the test
          string; pass None to disable comment filtering
        - ``full_dump`` - (default= ``True``) - dump results as list followed by results names in nested outline;
          if False, only dump nested list
        - ``print_results`` - (default= ``True``) prints test output to stdout
        - ``failure_tests`` - (default= ``False``) indicates if these tests are expected to fail parsing
        - ``post_parse`` - (default= ``None``) optional callback for successful parse results; called as
          `fn(test_string, parse_results)` and returns a string to be added to the test output
        - ``file`` - (default= ``None``) optional file-like object to which test output will be written;
          if None, will default to ``sys.stdout``
        - ``with_line_numbers`` - default= ``False``) show test strings with line and column numbers

        Returns: a (success, results) tuple, where success indicates that all tests succeeded
        (or failed if ``failure_tests`` is True), and the results contain a list of lines of each
        test's output

        Example::

            number_expr = pyparsing_common.number.copy()

            result = number_expr.run_tests('''
                # unsigned integer
                100
                # negative integer
                -100
                # float with scientific notation
                6.02e23
                # integer with scientific notation
                1e-12
                ''')
            print("Success" if result[0] else "Failed!")

            result = number_expr.run_tests('''
                # stray character
                100Z
                # missing leading digit before '.'
                -.100
                # too many '.'
                3.14.159
                ''', failure_tests=True)
            print("Success" if result[0] else "Failed!")

        prints::

            # unsigned integer
            100
            [100]

            # negative integer
            -100
            [-100]

            # float with scientific notation
            6.02e23
            [6.02e+23]

            # integer with scientific notation
            1e-12
            [1e-12]

            Success

            # stray character
            100Z
               ^
            FAIL: Expected end of text (at char 3), (line:1, col:4)

            # missing leading digit before '.'
            -.100
            ^
            FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)

            # too many '.'
            3.14.159
                ^
            FAIL: Expected end of text (at char 4), (line:1, col:5)

            Success

        Each test string must be on a single line. If you want to test a string that spans multiple
        lines, create a test like this::

            expr.run_tests(r"this is a test\\n of strings that spans \\n 3 lines")

        (Note that this is a raw string literal, you must include the leading ``'r'``.)
        """
        from .testing import pyparsing_test

        parseAll = parseAll and parse_all
        fullDump = fullDump and full_dump
        printResults = printResults and print_results
        failureTests = failureTests or failure_tests
        postParse = postParse or post_parse
        if isinstance(tests, str_type):
            tests = typing.cast(str, tests)
            line_strip = type(tests).strip
            tests = [line_strip(test_line) for test_line in tests.rstrip().splitlines()]
        comment_specified = comment is not None
        if comment_specified:
            if isinstance(comment, str_type):
                comment = typing.cast(str, comment)
                comment = Literal(comment)
        comment = typing.cast(ParserElement, comment)
        if file is None:
            file = sys.stdout
        print_ = file.write

        result: Union[ParseResults, Exception]
        allResults: list[tuple[str, Union[ParseResults, Exception]]] = []
        comments: list[str] = []
        success = True
        NL = Literal(r"\n").add_parse_action(replace_with("\n")).ignore(quoted_string)
        BOM = "\ufeff"
        nlstr = "\n"
        for t in tests:
            if comment_specified and comment.matches(t, False) or comments and not t:
                comments.append(
                    pyparsing_test.with_line_numbers(t) if with_line_numbers else t
                )
                continue
            if not t:
                continue
            out = [
                f"{nlstr}{nlstr.join(comments) if comments else ''}",
                pyparsing_test.with_line_numbers(t) if with_line_numbers else t,
            ]
            comments.clear()
            try:
                # convert newline marks to actual newlines, and strip leading BOM if present
                t = NL.transform_string(t.lstrip(BOM))
                result = self.parse_string(t, parse_all=parseAll)
            except ParseBaseException as pe:
                fatal = "(FATAL) " if isinstance(pe, ParseFatalException) else ""
                out.append(pe.explain())
                out.append(f"FAIL: {fatal}{pe}")
                if ParserElement.verbose_stacktrace:
                    out.extend(traceback.format_tb(pe.__traceback__))
                success = success and failureTests
                result = pe
            except Exception as exc:
                tag = "FAIL-EXCEPTION"

                # see if this exception was raised in a parse action
                tb = exc.__traceback__
                it = iter(traceback.walk_tb(tb))
                for f, line in it:
                    if (f.f_code.co_filename, line) == pa_call_line_synth:
                        next_f = next(it)[0]
                        tag += f" (raised in parse action {next_f.f_code.co_name!r})"
                        break

                out.append(f"{tag}: {type(exc).__name__}: {exc}")
                if ParserElement.verbose_stacktrace:
                    out.extend(traceback.format_tb(exc.__traceback__))
                success = success and failureTests
                result = exc
            else:
                success = success and not failureTests
                if postParse is not None:
                    try:
                        pp_value = postParse(t, result)
                        if pp_value is not None:
                            if isinstance(pp_value, ParseResults):
                                out.append(pp_value.dump())
                            else:
                                out.append(str(pp_value))
                        else:
                            out.append(result.dump())
                    except Exception as e:
                        out.append(result.dump(full=fullDump))
                        out.append(
                            f"{postParse.__name__} failed: {type(e).__name__}: {e}"
                        )
                else:
                    out.append(result.dump(full=fullDump))
            out.append("")

            if printResults:
                print_("\n".join(out))

            allResults.append((t, result))

        return success, allResults

    def create_diagram(
        self,
        output_html: Union[TextIO, Path, str],
        vertical: int = 3,
        show_results_names: bool = False,
        show_groups: bool = False,
        embed: bool = False,
        show_hidden: bool = False,
        **kwargs,
    ) -> None:
        """
        Create a railroad diagram for the parser.

        Parameters:

        - ``output_html`` (str or file-like object) - output target for generated
          diagram HTML
        - ``vertical`` (int) - threshold for formatting multiple alternatives vertically
          instead of horizontally (default=3)
        - ``show_results_names`` - bool flag whether diagram should show annotations for
          defined results names
        - ``show_groups`` - bool flag whether groups should be highlighted with an unlabeled surrounding box
        - ``show_hidden`` - bool flag to show diagram elements for internal elements that are usually hidden
        - ``embed`` - bool flag whether generated HTML should omit <HEAD>, <BODY>, and <DOCTYPE> tags to embed
          the resulting HTML in an enclosing HTML source
        - ``head`` - str containing additional HTML to insert into the <HEAD> section of the generated code;
          can be used to insert custom CSS styling
        - ``body`` - str containing additional HTML to insert at the beginning of the <BODY> section of the
          generated code

        Additional diagram-formatting keyword arguments can also be included;
        see railroad.Diagram class.
        """

        try:
            from .diagram import to_railroad, railroad_to_html
        except ImportError as ie:
            raise Exception(
                "must ``pip install pyparsing[diagrams]`` to generate parser railroad diagrams"
            ) from ie

        self.streamline()

        railroad = to_railroad(
            self,
            vertical=vertical,
            show_results_names=show_results_names,
            show_groups=show_groups,
            show_hidden=show_hidden,
            diagram_kwargs=kwargs,
        )
        if not isinstance(output_html, (str, Path)):
            # we were passed a file-like object, just write to it
            output_html.write(railroad_to_html(railroad, embed=embed, **kwargs))
            return

        with open(output_html, "w", encoding="utf-8") as diag_file:
            diag_file.write(railroad_to_html(railroad, embed=embed, **kwargs))

    # Compatibility synonyms
    # fmt: off
    inlineLiteralsUsing = staticmethod(replaced_by_pep8("inlineLiteralsUsing", inline_literals_using))
    setDefaultWhitespaceChars = staticmethod(replaced_by_pep8(
        "setDefaultWhitespaceChars", set_default_whitespace_chars
    ))
    disableMemoization = staticmethod(replaced_by_pep8("disableMemoization", disable_memoization))
    enableLeftRecursion = staticmethod(replaced_by_pep8("enableLeftRecursion", enable_left_recursion))
    enablePackrat = staticmethod(replaced_by_pep8("enablePackrat", enable_packrat))
    resetCache = staticmethod(replaced_by_pep8("resetCache", reset_cache))

    setResultsName = replaced_by_pep8("setResultsName", set_results_name)
    setBreak = replaced_by_pep8("setBreak", set_break)
    setParseAction = replaced_by_pep8("setParseAction", set_parse_action)
    addParseAction = replaced_by_pep8("addParseAction", add_parse_action)
    addCondition = replaced_by_pep8("addCondition", add_condition)
    setFailAction = replaced_by_pep8("setFailAction", set_fail_action)
    tryParse = replaced_by_pep8("tryParse", try_parse)
    parseString = replaced_by_pep8("parseString", parse_string)
    scanString = replaced_by_pep8("scanString", scan_string)
    transformString = replaced_by_pep8("transformString", transform_string)
    searchString = replaced_by_pep8("searchString", search_string)
    ignoreWhitespace = replaced_by_pep8("ignoreWhitespace", ignore_whitespace)
    leaveWhitespace = replaced_by_pep8("leaveWhitespace", leave_whitespace)
    setWhitespaceChars = replaced_by_pep8("setWhitespaceChars", set_whitespace_chars)
    parseWithTabs = replaced_by_pep8("parseWithTabs", parse_with_tabs)
    setDebugActions = replaced_by_pep8("setDebugActions", set_debug_actions)
    setDebug = replaced_by_pep8("setDebug", set_debug)
    setName = replaced_by_pep8("setName", set_name)
    parseFile = replaced_by_pep8("parseFile", parse_file)
    runTests = replaced_by_pep8("runTests", run_tests)
    canParseNext = replaced_by_pep8("canParseNext", can_parse_next)
    defaultName = default_name
    # fmt: on


class _PendingSkip(ParserElement):
    # internal placeholder class to hold a place were '...' is added to a parser element,
    # once another ParserElement is added, this placeholder will be replaced with a SkipTo
    def __init__(self, expr: ParserElement, must_skip: bool = False) -> None:
        super().__init__()
        self.anchor = expr
        self.must_skip = must_skip

    def _generateDefaultName(self) -> str:
        return str(self.anchor + Empty()).replace("Empty", "...")

    def __add__(self, other) -> ParserElement:
        skipper = SkipTo(other).set_name("...")("_skipped*")
        if self.must_skip:

            def must_skip(t):
                if not t._skipped or t._skipped.as_list() == [""]:
                    del t[0]
                    t.pop("_skipped", None)

            def show_skip(t):
                if t._skipped.as_list()[-1:] == [""]:
                    t.pop("_skipped")
                    t["_skipped"] = f"missing <{self.anchor!r}>"

            return (
                self.anchor + skipper().add_parse_action(must_skip)
                | skipper().add_parse_action(show_skip)
            ) + other

        return self.anchor + skipper + other

    def __repr__(self):
        return self.defaultName

    def parseImpl(self, *args) -> ParseImplReturnType:
        raise Exception(
            "use of `...` expression without following SkipTo target expression"
        )


class Token(ParserElement):
    """Abstract :class:`ParserElement` subclass, for defining atomic
    matching patterns.
    """

    def __init__(self) -> None:
        super().__init__(savelist=False)

    def _generateDefaultName(self) -> str:
        return type(self).__name__


class NoMatch(Token):
    """
    A token that will never match.
    """

    def __init__(self) -> None:
        super().__init__()
        self._may_return_empty = True
        self.mayIndexError = False
        self.errmsg = "Unmatchable token"

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        raise ParseException(instring, loc, self.errmsg, self)


class Literal(Token):
    """
    Token to exactly match a specified string.

    Example::

        Literal('abc').parse_string('abc')  # -> ['abc']
        Literal('abc').parse_string('abcdef')  # -> ['abc']
        Literal('abc').parse_string('ab')  # -> Exception: Expected "abc"

    For case-insensitive matching, use :class:`CaselessLiteral`.

    For keyword matching (force word break before and after the matched string),
    use :class:`Keyword` or :class:`CaselessKeyword`.
    """

    def __new__(cls, match_string: str = "", *, matchString: str = ""):
        # Performance tuning: select a subclass with optimized parseImpl
        if cls is Literal:
            match_string = matchString or match_string
            if not match_string:
                return super().__new__(Empty)
            if len(match_string) == 1:
                return super().__new__(_SingleCharLiteral)

        # Default behavior
        return super().__new__(cls)

    # Needed to make copy.copy() work correctly if we customize __new__
    def __getnewargs__(self):
        return (self.match,)

    def __init__(self, match_string: str = "", *, matchString: str = "") -> None:
        super().__init__()
        match_string = matchString or match_string
        self.match = match_string
        self.matchLen = len(match_string)
        self.firstMatchChar = match_string[:1]
        self.errmsg = f"Expected {self.name}"
        self._may_return_empty = False
        self.mayIndexError = False

    def _generateDefaultName(self) -> str:
        return repr(self.match)

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if instring[loc] == self.firstMatchChar and instring.startswith(
            self.match, loc
        ):
            return loc + self.matchLen, self.match
        raise ParseException(instring, loc, self.errmsg, self)


class Empty(Literal):
    """
    An empty token, will always match.
    """

    def __init__(self, match_string="", *, matchString="") -> None:
        super().__init__("")
        self._may_return_empty = True
        self.mayIndexError = False

    def _generateDefaultName(self) -> str:
        return "Empty"

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        return loc, []


class _SingleCharLiteral(Literal):
    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if instring[loc] == self.firstMatchChar:
            return loc + 1, self.match
        raise ParseException(instring, loc, self.errmsg, self)


ParserElement._literalStringClass = Literal


class Keyword(Token):
    """
    Token to exactly match a specified string as a keyword, that is,
    it must be immediately preceded and followed by whitespace or
    non-keyword characters. Compare with :class:`Literal`:

    - ``Literal("if")`` will match the leading ``'if'`` in
      ``'ifAndOnlyIf'``.
    - ``Keyword("if")`` will not; it will only match the leading
      ``'if'`` in ``'if x=1'``, or ``'if(y==2)'``

    Accepts two optional constructor arguments in addition to the
    keyword string:

    - ``ident_chars`` is a string of characters that would be valid
      identifier characters, defaulting to all alphanumerics + "_" and
      "$"
    - ``caseless`` allows case-insensitive matching, default is ``False``.

    Example::

        Keyword("start").parse_string("start")  # -> ['start']
        Keyword("start").parse_string("starting")  # -> Exception

    For case-insensitive matching, use :class:`CaselessKeyword`.
    """

    DEFAULT_KEYWORD_CHARS = alphanums + "_$"

    def __init__(
        self,
        match_string: str = "",
        ident_chars: typing.Optional[str] = None,
        caseless: bool = False,
        *,
        matchString: str = "",
        identChars: typing.Optional[str] = None,
    ) -> None:
        super().__init__()
        identChars = identChars or ident_chars
        if identChars is None:
            identChars = Keyword.DEFAULT_KEYWORD_CHARS
        match_string = matchString or match_string
        self.match = match_string
        self.matchLen = len(match_string)
        self.firstMatchChar = match_string[:1]
        if not self.firstMatchChar:
            raise ValueError("null string passed to Keyword; use Empty() instead")
        self.errmsg = f"Expected {type(self).__name__} {self.name}"
        self._may_return_empty = False
        self.mayIndexError = False
        self.caseless = caseless
        if caseless:
            self.caselessmatch = match_string.upper()
            identChars = identChars.upper()
        self.identChars = set(identChars)

    def _generateDefaultName(self) -> str:
        return repr(self.match)

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        errmsg = self.errmsg or ""
        errloc = loc
        if self.caseless:
            if instring[loc : loc + self.matchLen].upper() == self.caselessmatch:
                if loc == 0 or instring[loc - 1].upper() not in self.identChars:
                    if (
                        loc >= len(instring) - self.matchLen
                        or instring[loc + self.matchLen].upper() not in self.identChars
                    ):
                        return loc + self.matchLen, self.match

                    # followed by keyword char
                    errmsg += ", was immediately followed by keyword character"
                    errloc = loc + self.matchLen
                else:
                    # preceded by keyword char
                    errmsg += ", keyword was immediately preceded by keyword character"
                    errloc = loc - 1
            # else no match just raise plain exception

        elif (
            instring[loc] == self.firstMatchChar
            and self.matchLen == 1
            or instring.startswith(self.match, loc)
        ):
            if loc == 0 or instring[loc - 1] not in self.identChars:
                if (
                    loc >= len(instring) - self.matchLen
                    or instring[loc + self.matchLen] not in self.identChars
                ):
                    return loc + self.matchLen, self.match

                # followed by keyword char
                errmsg += ", keyword was immediately followed by keyword character"
                errloc = loc + self.matchLen
            else:
                # preceded by keyword char
                errmsg += ", keyword was immediately preceded by keyword character"
                errloc = loc - 1
        # else no match just raise plain exception

        raise ParseException(instring, errloc, errmsg, self)

    @staticmethod
    def set_default_keyword_chars(chars) -> None:
        """
        Overrides the default characters used by :class:`Keyword` expressions.
        """
        Keyword.DEFAULT_KEYWORD_CHARS = chars

    # Compatibility synonyms
    setDefaultKeywordChars = staticmethod(
        replaced_by_pep8("setDefaultKeywordChars", set_default_keyword_chars)
    )


class CaselessLiteral(Literal):
    """
    Token to match a specified string, ignoring case of letters.
    Note: the matched results will always be in the case of the given
    match string, NOT the case of the input text.

    Example::

        CaselessLiteral("CMD")[1, ...].parse_string("cmd CMD Cmd10")
        # -> ['CMD', 'CMD', 'CMD']

    (Contrast with example for :class:`CaselessKeyword`.)
    """

    def __init__(self, match_string: str = "", *, matchString: str = "") -> None:
        match_string = matchString or match_string
        super().__init__(match_string.upper())
        # Preserve the defining literal.
        self.returnString = match_string
        self.errmsg = f"Expected {self.name}"

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if instring[loc : loc + self.matchLen].upper() == self.match:
            return loc + self.matchLen, self.returnString
        raise ParseException(instring, loc, self.errmsg, self)


class CaselessKeyword(Keyword):
    """
    Caseless version of :class:`Keyword`.

    Example::

        CaselessKeyword("CMD")[1, ...].parse_string("cmd CMD Cmd10")
        # -> ['CMD', 'CMD']

    (Contrast with example for :class:`CaselessLiteral`.)
    """

    def __init__(
        self,
        match_string: str = "",
        ident_chars: typing.Optional[str] = None,
        *,
        matchString: str = "",
        identChars: typing.Optional[str] = None,
    ) -> None:
        identChars = identChars or ident_chars
        match_string = matchString or match_string
        super().__init__(match_string, identChars, caseless=True)


class CloseMatch(Token):
    """A variation on :class:`Literal` which matches "close" matches,
    that is, strings with at most 'n' mismatching characters.
    :class:`CloseMatch` takes parameters:

    - ``match_string`` - string to be matched
    - ``caseless`` - a boolean indicating whether to ignore casing when comparing characters
    - ``max_mismatches`` - (``default=1``) maximum number of
      mismatches allowed to count as a match

    The results from a successful parse will contain the matched text
    from the input string and the following named results:

    - ``mismatches`` - a list of the positions within the
      match_string where mismatches were found
    - ``original`` - the original match_string used to compare
      against the input string

    If ``mismatches`` is an empty list, then the match was an exact
    match.

    Example::

        patt = CloseMatch("ATCATCGAATGGA")
        patt.parse_string("ATCATCGAAXGGA") # -> (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']})
        patt.parse_string("ATCAXCGAAXGGA") # -> Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1)

        # exact match
        patt.parse_string("ATCATCGAATGGA") # -> (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']})

        # close match allowing up to 2 mismatches
        patt = CloseMatch("ATCATCGAATGGA", max_mismatches=2)
        patt.parse_string("ATCAXCGAAXGGA") # -> (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']})
    """

    def __init__(
        self,
        match_string: str,
        max_mismatches: typing.Optional[int] = None,
        *,
        maxMismatches: int = 1,
        caseless=False,
    ) -> None:
        maxMismatches = max_mismatches if max_mismatches is not None else maxMismatches
        super().__init__()
        self.match_string = match_string
        self.maxMismatches = maxMismatches
        self.errmsg = f"Expected {self.match_string!r} (with up to {self.maxMismatches} mismatches)"
        self.caseless = caseless
        self.mayIndexError = False
        self._may_return_empty = False

    def _generateDefaultName(self) -> str:
        return f"{type(self).__name__}:{self.match_string!r}"

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        start = loc
        instrlen = len(instring)
        maxloc = start + len(self.match_string)

        if maxloc <= instrlen:
            match_string = self.match_string
            match_stringloc = 0
            mismatches = []
            maxMismatches = self.maxMismatches

            for match_stringloc, s_m in enumerate(
                zip(instring[loc:maxloc], match_string)
            ):
                src, mat = s_m
                if self.caseless:
                    src, mat = src.lower(), mat.lower()

                if src != mat:
                    mismatches.append(match_stringloc)
                    if len(mismatches) > maxMismatches:
                        break
            else:
                loc = start + match_stringloc + 1
                results = ParseResults([instring[start:loc]])
                results["original"] = match_string
                results["mismatches"] = mismatches
                return loc, results

        raise ParseException(instring, loc, self.errmsg, self)


class Word(Token):
    """Token for matching words composed of allowed character sets.

    Parameters:

    - ``init_chars`` - string of all characters that should be used to
      match as a word; "ABC" will match "AAA", "ABAB", "CBAC", etc.;
      if ``body_chars`` is also specified, then this is the string of
      initial characters
    - ``body_chars`` - string of characters that
      can be used for matching after a matched initial character as
      given in ``init_chars``; if omitted, same as the initial characters
      (default=``None``)
    - ``min`` - minimum number of characters to match (default=1)
    - ``max`` - maximum number of characters to match (default=0)
    - ``exact`` - exact number of characters to match (default=0)
    - ``as_keyword`` - match as a keyword (default=``False``)
    - ``exclude_chars`` - characters that might be
      found in the input ``body_chars`` string but which should not be
      accepted for matching ;useful to define a word of all
      printables except for one or two characters, for instance
      (default=``None``)

    :class:`srange` is useful for defining custom character set strings
    for defining :class:`Word` expressions, using range notation from
    regular expression character sets.

    A common mistake is to use :class:`Word` to match a specific literal
    string, as in ``Word("Address")``. Remember that :class:`Word`
    uses the string argument to define *sets* of matchable characters.
    This expression would match "Add", "AAA", "dAred", or any other word
    made up of the characters 'A', 'd', 'r', 'e', and 's'. To match an
    exact literal string, use :class:`Literal` or :class:`Keyword`.

    pyparsing includes helper strings for building Words:

    - :class:`alphas`
    - :class:`nums`
    - :class:`alphanums`
    - :class:`hexnums`
    - :class:`alphas8bit` (alphabetic characters in ASCII range 128-255
      - accented, tilded, umlauted, etc.)
    - :class:`punc8bit` (non-alphabetic characters in ASCII range
      128-255 - currency, symbols, superscripts, diacriticals, etc.)
    - :class:`printables` (any non-whitespace character)

    ``alphas``, ``nums``, and ``printables`` are also defined in several
    Unicode sets - see :class:`pyparsing_unicode``.

    Example::

        # a word composed of digits
        integer = Word(nums) # equivalent to Word("0123456789") or Word(srange("0-9"))

        # a word with a leading capital, and zero or more lowercase
        capitalized_word = Word(alphas.upper(), alphas.lower())

        # hostnames are alphanumeric, with leading alpha, and '-'
        hostname = Word(alphas, alphanums + '-')

        # roman numeral (not a strict parser, accepts invalid mix of characters)
        roman = Word("IVXLCDM")

        # any string of non-whitespace characters, except for ','
        csv_value = Word(printables, exclude_chars=",")
    """

    def __init__(
        self,
        init_chars: str = "",
        body_chars: typing.Optional[str] = None,
        min: int = 1,
        max: int = 0,
        exact: int = 0,
        as_keyword: bool = False,
        exclude_chars: typing.Optional[str] = None,
        *,
        initChars: typing.Optional[str] = None,
        bodyChars: typing.Optional[str] = None,
        asKeyword: bool = False,
        excludeChars: typing.Optional[str] = None,
    ) -> None:
        initChars = initChars or init_chars
        bodyChars = bodyChars or body_chars
        asKeyword = asKeyword or as_keyword
        excludeChars = excludeChars or exclude_chars
        super().__init__()
        if not initChars:
            raise ValueError(
                f"invalid {type(self).__name__}, initChars cannot be empty string"
            )

        initChars_set = set(initChars)
        if excludeChars:
            excludeChars_set = set(excludeChars)
            initChars_set -= excludeChars_set
            if bodyChars:
                bodyChars = "".join(set(bodyChars) - excludeChars_set)
        self.initChars = initChars_set
        self.initCharsOrig = "".join(sorted(initChars_set))

        if bodyChars:
            self.bodyChars = set(bodyChars)
            self.bodyCharsOrig = "".join(sorted(bodyChars))
        else:
            self.bodyChars = initChars_set
            self.bodyCharsOrig = self.initCharsOrig

        self.maxSpecified = max > 0

        if min < 1:
            raise ValueError(
                "cannot specify a minimum length < 1; use Opt(Word()) if zero-length word is permitted"
            )

        if self.maxSpecified and min > max:
            raise ValueError(
                f"invalid args, if min and max both specified min must be <= max (min={min}, max={max})"
            )

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            min = max = exact
            self.maxLen = exact
            self.minLen = exact

        self.errmsg = f"Expected {self.name}"
        self.mayIndexError = False
        self.asKeyword = asKeyword
        if self.asKeyword:
            self.errmsg += " as a keyword"

        # see if we can make a regex for this Word
        if " " not in (self.initChars | self.bodyChars):
            if len(self.initChars) == 1:
                re_leading_fragment = re.escape(self.initCharsOrig)
            else:
                re_leading_fragment = f"[{_collapse_string_to_ranges(self.initChars)}]"

            if self.bodyChars == self.initChars:
                if max == 0 and self.minLen == 1:
                    repeat = "+"
                elif max == 1:
                    repeat = ""
                else:
                    if self.minLen != self.maxLen:
                        repeat = f"{{{self.minLen},{'' if self.maxLen == _MAX_INT else self.maxLen}}}"
                    else:
                        repeat = f"{{{self.minLen}}}"
                self.reString = f"{re_leading_fragment}{repeat}"
            else:
                if max == 1:
                    re_body_fragment = ""
                    repeat = ""
                else:
                    re_body_fragment = f"[{_collapse_string_to_ranges(self.bodyChars)}]"
                    if max == 0 and self.minLen == 1:
                        repeat = "*"
                    elif max == 2:
                        repeat = "?" if min <= 1 else ""
                    else:
                        if min != max:
                            repeat = f"{{{min - 1 if min > 0 else ''},{max - 1 if max > 0 else ''}}}"
                        else:
                            repeat = f"{{{min - 1 if min > 0 else ''}}}"

                self.reString = f"{re_leading_fragment}{re_body_fragment}{repeat}"

            if self.asKeyword:
                self.reString = rf"\b{self.reString}\b"

            try:
                self.re = re.compile(self.reString)
            except re.error:
                self.re = None  # type: ignore[assignment]
            else:
                self.re_match = self.re.match
                self.parseImpl = self.parseImpl_regex  # type: ignore[method-assign]

    def _generateDefaultName(self) -> str:
        def charsAsStr(s):
            max_repr_len = 16
            s = _collapse_string_to_ranges(s, re_escape=False)

            if len(s) > max_repr_len:
                return s[: max_repr_len - 3] + "..."

            return s

        if self.initChars != self.bodyChars:
            base = f"W:({charsAsStr(self.initChars)}, {charsAsStr(self.bodyChars)})"
        else:
            base = f"W:({charsAsStr(self.initChars)})"

        # add length specification
        if self.minLen > 1 or self.maxLen != _MAX_INT:
            if self.minLen == self.maxLen:
                if self.minLen == 1:
                    return base[2:]
                else:
                    return base + f"{{{self.minLen}}}"
            elif self.maxLen == _MAX_INT:
                return base + f"{{{self.minLen},...}}"
            else:
                return base + f"{{{self.minLen},{self.maxLen}}}"
        return base

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if instring[loc] not in self.initChars:
            raise ParseException(instring, loc, self.errmsg, self)

        start = loc
        loc += 1
        instrlen = len(instring)
        body_chars: set[str] = self.bodyChars
        maxloc = start + self.maxLen
        maxloc = min(maxloc, instrlen)
        while loc < maxloc and instring[loc] in body_chars:
            loc += 1

        throw_exception = False
        if loc - start < self.minLen:
            throw_exception = True
        elif self.maxSpecified and loc < instrlen and instring[loc] in body_chars:
            throw_exception = True
        elif self.asKeyword and (
            (start > 0 and instring[start - 1] in body_chars)
            or (loc < instrlen and instring[loc] in body_chars)
        ):
            throw_exception = True

        if throw_exception:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]

    def parseImpl_regex(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        result = self.re_match(instring, loc)
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        return loc, result.group()


class Char(Word):
    """A short-cut class for defining :class:`Word` ``(characters, exact=1)``,
    when defining a match of any single character in a string of
    characters.
    """

    def __init__(
        self,
        charset: str,
        as_keyword: bool = False,
        exclude_chars: typing.Optional[str] = None,
        *,
        asKeyword: bool = False,
        excludeChars: typing.Optional[str] = None,
    ) -> None:
        asKeyword = asKeyword or as_keyword
        excludeChars = excludeChars or exclude_chars
        super().__init__(
            charset, exact=1, as_keyword=asKeyword, exclude_chars=excludeChars
        )


class Regex(Token):
    r"""Token for matching strings that match a given regular
    expression. Defined with string specifying the regular expression in
    a form recognized by the stdlib Python  `re module <https://docs.python.org/3/library/re.html>`_.
    If the given regex contains named groups (defined using ``(?P<name>...)``),
    these will be preserved as named :class:`ParseResults`.

    If instead of the Python stdlib ``re`` module you wish to use a different RE module
    (such as the ``regex`` module), you can do so by building your ``Regex`` object with
    a compiled RE that was compiled using ``regex``.

    Example::

        realnum = Regex(r"[+-]?\d+\.\d*")
        # ref: https://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression
        roman = Regex(r"M{0,4}(CM|CD|D?{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})")

        # named fields in a regex will be returned as named results
        date = Regex(r'(?P<year>\d{4})-(?P<month>\d\d?)-(?P<day>\d\d?)')

        # the Regex class will accept re's compiled using the regex module
        import regex
        parser = pp.Regex(regex.compile(r'[0-9]'))
    """

    def __init__(
        self,
        pattern: Any,
        flags: Union[re.RegexFlag, int] = 0,
        as_group_list: bool = False,
        as_match: bool = False,
        *,
        asGroupList: bool = False,
        asMatch: bool = False,
    ) -> None:
        """The parameters ``pattern`` and ``flags`` are passed
        to the ``re.compile()`` function as-is. See the Python
        `re module <https://docs.python.org/3/library/re.html>`_ module for an
        explanation of the acceptable patterns and flags.
        """
        super().__init__()
        asGroupList = asGroupList or as_group_list
        asMatch = asMatch or as_match

        if isinstance(pattern, str_type):
            if not pattern:
                raise ValueError("null string passed to Regex; use Empty() instead")

            self._re = None
            self._may_return_empty = None  # type: ignore [assignment]
            self.reString = self.pattern = pattern

        elif hasattr(pattern, "pattern") and hasattr(pattern, "match"):
            self._re = pattern
            self._may_return_empty = None  # type: ignore [assignment]
            self.pattern = self.reString = pattern.pattern

        elif callable(pattern):
            # defer creating this pattern until we really need it
            self.pattern = pattern
            self._may_return_empty = None  # type: ignore [assignment]
            self._re = None

        else:
            raise TypeError(
                "Regex may only be constructed with a string or a compiled RE object,"
                " or a callable that takes no arguments and returns a string or a"
                " compiled RE object"
            )

        self.flags = flags
        self.errmsg = f"Expected {self.name}"
        self.mayIndexError = False
        self.asGroupList = asGroupList
        self.asMatch = asMatch
        if self.asGroupList:
            self.parseImpl = self.parseImplAsGroupList  # type: ignore [method-assign]
        if self.asMatch:
            self.parseImpl = self.parseImplAsMatch  # type: ignore [method-assign]

    @cached_property
    def re(self) -> re.Pattern:
        if self._re:
            return self._re

        if callable(self.pattern):
            # replace self.pattern with the string returned by calling self.pattern()
            self.pattern = cast(Callable[[], str], self.pattern)()

            # see if we got a compiled RE back instead of a str - if so, we're done
            if hasattr(self.pattern, "pattern") and hasattr(self.pattern, "match"):
                self._re = cast(re.Pattern[str], self.pattern)
                self.pattern = self.reString = self._re.pattern
                return self._re

        try:
            self._re = re.compile(self.pattern, self.flags)
        except re.error:
            raise ValueError(f"invalid pattern ({self.pattern!r}) passed to Regex")
        else:
            self._may_return_empty = self.re.match("", pos=0) is not None
            return self._re

    @cached_property
    def re_match(self) -> Callable[[str, int], Any]:
        return self.re.match

    @property
    def mayReturnEmpty(self):
        if self._may_return_empty is None:
            # force compile of regex pattern, to set may_return_empty flag
            self.re  # noqa
        return self._may_return_empty

    @mayReturnEmpty.setter
    def mayReturnEmpty(self, value):
        self._may_return_empty = value

    def _generateDefaultName(self) -> str:
        unescaped = repr(self.pattern).replace("\\\\", "\\")
        return f"Re:({unescaped})"

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        # explicit check for matching past the length of the string;
        # this is done because the re module will not complain about
        # a match with `pos > len(instring)`, it will just return ""
        if loc > len(instring) and self.mayReturnEmpty:
            raise ParseException(instring, loc, self.errmsg, self)

        result = self.re_match(instring, loc)
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        ret = ParseResults(result.group())
        d = result.groupdict()

        for k, v in d.items():
            ret[k] = v

        return loc, ret

    def parseImplAsGroupList(self, instring, loc, do_actions=True):
        if loc > len(instring) and self.mayReturnEmpty:
            raise ParseException(instring, loc, self.errmsg, self)

        result = self.re_match(instring, loc)
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        ret = result.groups()
        return loc, ret

    def parseImplAsMatch(self, instring, loc, do_actions=True):
        if loc > len(instring) and self.mayReturnEmpty:
            raise ParseException(instring, loc, self.errmsg, self)

        result = self.re_match(instring, loc)
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        loc = result.end()
        ret = result
        return loc, ret

    def sub(self, repl: str) -> ParserElement:
        r"""
        Return :class:`Regex` with an attached parse action to transform the parsed
        result as if called using `re.sub(expr, repl, string) <https://docs.python.org/3/library/re.html#re.sub>`_.

        Example::

            make_html = Regex(r"(\w+):(.*?):").sub(r"<\1>\2</\1>")
            print(make_html.transform_string("h1:main title:"))
            # prints "<h1>main title</h1>"
        """
        if self.asGroupList:
            raise TypeError("cannot use sub() with Regex(as_group_list=True)")

        if self.asMatch and callable(repl):
            raise TypeError(
                "cannot use sub() with a callable with Regex(as_match=True)"
            )

        if self.asMatch:

            def pa(tokens):
                return tokens[0].expand(repl)

        else:

            def pa(tokens):
                return self.re.sub(repl, tokens[0])

        return self.add_parse_action(pa)


class QuotedString(Token):
    r"""
    Token for matching strings that are delimited by quoting characters.

    Defined with the following parameters:

    - ``quote_char`` - string of one or more characters defining the
      quote delimiting string
    - ``esc_char`` - character to re_escape quotes, typically backslash
      (default= ``None``)
    - ``esc_quote`` - special quote sequence to re_escape an embedded quote
      string (such as SQL's ``""`` to re_escape an embedded ``"``)
      (default= ``None``)
    - ``multiline`` - boolean indicating whether quotes can span
      multiple lines (default= ``False``)
    - ``unquote_results`` - boolean indicating whether the matched text
      should be unquoted (default= ``True``)
    - ``end_quote_char`` - string of one or more characters defining the
      end of the quote delimited string (default= ``None``  => same as
      quote_char)
    - ``convert_whitespace_escapes`` - convert escaped whitespace
      (``'\t'``, ``'\n'``, etc.) to actual whitespace
      (default= ``True``)

    Example::

        qs = QuotedString('"')
        print(qs.search_string('lsjdf "This is the quote" sldjf'))
        complex_qs = QuotedString('{{', end_quote_char='}}')
        print(complex_qs.search_string('lsjdf {{This is the "quote"}} sldjf'))
        sql_qs = QuotedString('"', esc_quote='""')
        print(sql_qs.search_string('lsjdf "This is the quote with ""embedded"" quotes" sldjf'))

    prints::

        [['This is the quote']]
        [['This is the "quote"']]
        [['This is the quote with "embedded" quotes']]
    """

    ws_map = dict(((r"\t", "\t"), (r"\n", "\n"), (r"\f", "\f"), (r"\r", "\r")))

    def __init__(
        self,
        quote_char: str = "",
        esc_char: typing.Optional[str] = None,
        esc_quote: typing.Optional[str] = None,
        multiline: bool = False,
        unquote_results: bool = True,
        end_quote_char: typing.Optional[str] = None,
        convert_whitespace_escapes: bool = True,
        *,
        quoteChar: str = "",
        escChar: typing.Optional[str] = None,
        escQuote: typing.Optional[str] = None,
        unquoteResults: bool = True,
        endQuoteChar: typing.Optional[str] = None,
        convertWhitespaceEscapes: bool = True,
    ) -> None:
        super().__init__()
        esc_char = escChar or esc_char
        esc_quote = escQuote or esc_quote
        unquote_results = unquoteResults and unquote_results
        end_quote_char = endQuoteChar or end_quote_char
        convert_whitespace_escapes = (
            convertWhitespaceEscapes and convert_whitespace_escapes
        )
        quote_char = quoteChar or quote_char

        # remove white space from quote chars
        quote_char = quote_char.strip()
        if not quote_char:
            raise ValueError("quote_char cannot be the empty string")

        if end_quote_char is None:
            end_quote_char = quote_char
        else:
            end_quote_char = end_quote_char.strip()
            if not end_quote_char:
                raise ValueError("end_quote_char cannot be the empty string")

        self.quote_char: str = quote_char
        self.quote_char_len: int = len(quote_char)
        self.first_quote_char: str = quote_char[0]
        self.end_quote_char: str = end_quote_char
        self.end_quote_char_len: int = len(end_quote_char)
        self.esc_char: str = esc_char or ""
        self.has_esc_char: bool = esc_char is not None
        self.esc_quote: str = esc_quote or ""
        self.unquote_results: bool = unquote_results
        self.convert_whitespace_escapes: bool = convert_whitespace_escapes
        self.multiline = multiline
        self.re_flags = re.RegexFlag(0)

        # fmt: off
        # build up re pattern for the content between the quote delimiters
        inner_pattern: list[str] = []

        if esc_quote:
            inner_pattern.append(rf"(?:{re.escape(esc_quote)})")

        if esc_char:
            inner_pattern.append(rf"(?:{re.escape(esc_char)}.)")

        if len(self.end_quote_char) > 1:
            inner_pattern.append(
                "(?:"
                + "|".join(
                    f"(?:{re.escape(self.end_quote_char[:i])}(?!{re.escape(self.end_quote_char[i:])}))"
                    for i in range(len(self.end_quote_char) - 1, 0, -1)
                )
                + ")"
            )

        if self.multiline:
            self.re_flags |= re.MULTILINE | re.DOTALL
            inner_pattern.append(
                rf"(?:[^{_escape_regex_range_chars(self.end_quote_char[0])}"
                rf"{(_escape_regex_range_chars(self.esc_char) if self.has_esc_char else '')}])"
            )
        else:
            inner_pattern.append(
                rf"(?:[^{_escape_regex_range_chars(self.end_quote_char[0])}\n\r"
                rf"{(_escape_regex_range_chars(self.esc_char) if self.has_esc_char else '')}])"
            )

        self.pattern = "".join(
            [
                re.escape(self.quote_char),
                "(?:",
                '|'.join(inner_pattern),
                ")*",
                re.escape(self.end_quote_char),
            ]
        )

        if self.unquote_results:
            if self.convert_whitespace_escapes:
                self.unquote_scan_re = re.compile(
                    rf"({'|'.join(re.escape(k) for k in self.ws_map)})"
                    rf"|(\\[0-7]{3}|\\0|\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4})"
                    rf"|({re.escape(self.esc_char)}.)"
                    rf"|(\n|.)",
                    flags=self.re_flags,
                )
            else:
                self.unquote_scan_re = re.compile(
                    rf"({re.escape(self.esc_char)}.)"
                    rf"|(\n|.)",
                    flags=self.re_flags
                )
        # fmt: on

        try:
            self.re = re.compile(self.pattern, self.re_flags)
            self.reString = self.pattern
            self.re_match = self.re.match
        except re.error:
            raise ValueError(f"invalid pattern {self.pattern!r} passed to Regex")

        self.errmsg = f"Expected {self.name}"
        self.mayIndexError = False
        self._may_return_empty = True

    def _generateDefaultName(self) -> str:
        if self.quote_char == self.end_quote_char and isinstance(
            self.quote_char, str_type
        ):
            return f"string enclosed in {self.quote_char!r}"

        return f"quoted string, starting with {self.quote_char} ending with {self.end_quote_char}"

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        # check first character of opening quote to see if that is a match
        # before doing the more complicated regex match
        result = (
            instring[loc] == self.first_quote_char
            and self.re_match(instring, loc)
            or None
        )
        if not result:
            raise ParseException(instring, loc, self.errmsg, self)

        # get ending loc and matched string from regex matching result
        loc = result.end()
        ret = result.group()

        def convert_escaped_numerics(s: str) -> str:
            if s == "0":
                return "\0"
            if s.isdigit() and len(s) == 3:
                return chr(int(s, base=8))
            elif s.startswith(("u", "x")):
                return chr(int(s[1:], base=16))
            else:
                return s

        if self.unquote_results:
            # strip off quotes
            ret = ret[self.quote_char_len : -self.end_quote_char_len]

            if isinstance(ret, str_type):
                # fmt: off
                if self.convert_whitespace_escapes:
                    # as we iterate over matches in the input string,
                    # collect from whichever match group of the unquote_scan_re
                    # regex matches (only 1 group will match at any given time)
                    ret = "".join(
                        # match group 1 matches \t, \n, etc.
                        self.ws_map[match.group(1)] if match.group(1)
                        # match group 2 matches escaped octal, null, hex, and Unicode
                        # sequences
                        else convert_escaped_numerics(match.group(2)[1:]) if match.group(2)
                        # match group 3 matches escaped characters
                        else match.group(3)[-1] if match.group(3)
                        # match group 4 matches any character
                        else match.group(4)
                        for match in self.unquote_scan_re.finditer(ret)
                    )
                else:
                    ret = "".join(
                        # match group 1 matches escaped characters
                        match.group(1)[-1] if match.group(1)
                        # match group 2 matches any character
                        else match.group(2)
                        for match in self.unquote_scan_re.finditer(ret)
                    )
                # fmt: on

                # replace escaped quotes
                if self.esc_quote:
                    ret = ret.replace(self.esc_quote, self.end_quote_char)

        return loc, ret


class CharsNotIn(Token):
    """Token for matching words composed of characters *not* in a given
    set (will include whitespace in matched characters if not listed in
    the provided exclusion set - see example). Defined with string
    containing all disallowed characters, and an optional minimum,
    maximum, and/or exact length.  The default value for ``min`` is
    1 (a minimum value < 1 is not valid); the default values for
    ``max`` and ``exact`` are 0, meaning no maximum or exact
    length restriction.

    Example::

        # define a comma-separated-value as anything that is not a ','
        csv_value = CharsNotIn(',')
        print(DelimitedList(csv_value).parse_string("dkls,lsdkjf,s12 34,@!#,213"))

    prints::

        ['dkls', 'lsdkjf', 's12 34', '@!#', '213']
    """

    def __init__(
        self,
        not_chars: str = "",
        min: int = 1,
        max: int = 0,
        exact: int = 0,
        *,
        notChars: str = "",
    ) -> None:
        super().__init__()
        self.skipWhitespace = False
        self.notChars = not_chars or notChars
        self.notCharsSet = set(self.notChars)

        if min < 1:
            raise ValueError(
                "cannot specify a minimum length < 1; use"
                " Opt(CharsNotIn()) if zero-length char group is permitted"
            )

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

        self.errmsg = f"Expected {self.name}"
        self._may_return_empty = self.minLen == 0
        self.mayIndexError = False

    def _generateDefaultName(self) -> str:
        not_chars_str = _collapse_string_to_ranges(self.notChars)
        if len(not_chars_str) > 16:
            return f"!W:({self.notChars[: 16 - 3]}...)"
        else:
            return f"!W:({self.notChars})"

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        notchars = self.notCharsSet
        if instring[loc] in notchars:
            raise ParseException(instring, loc, self.errmsg, self)

        start = loc
        loc += 1
        maxlen = min(start + self.maxLen, len(instring))
        while loc < maxlen and instring[loc] not in notchars:
            loc += 1

        if loc - start < self.minLen:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]


class White(Token):
    """Special matching class for matching whitespace.  Normally,
    whitespace is ignored by pyparsing grammars.  This class is included
    when some whitespace structures are significant.  Define with
    a string containing the whitespace characters to be matched; default
    is ``" \\t\\r\\n"``.  Also takes optional ``min``,
    ``max``, and ``exact`` arguments, as defined for the
    :class:`Word` class.
    """

    whiteStrs = {
        " ": "<SP>",
        "\t": "<TAB>",
        "\n": "<LF>",
        "\r": "<CR>",
        "\f": "<FF>",
        "\u00A0": "<NBSP>",
        "\u1680": "<OGHAM_SPACE_MARK>",
        "\u180E": "<MONGOLIAN_VOWEL_SEPARATOR>",
        "\u2000": "<EN_QUAD>",
        "\u2001": "<EM_QUAD>",
        "\u2002": "<EN_SPACE>",
        "\u2003": "<EM_SPACE>",
        "\u2004": "<THREE-PER-EM_SPACE>",
        "\u2005": "<FOUR-PER-EM_SPACE>",
        "\u2006": "<SIX-PER-EM_SPACE>",
        "\u2007": "<FIGURE_SPACE>",
        "\u2008": "<PUNCTUATION_SPACE>",
        "\u2009": "<THIN_SPACE>",
        "\u200A": "<HAIR_SPACE>",
        "\u200B": "<ZERO_WIDTH_SPACE>",
        "\u202F": "<NNBSP>",
        "\u205F": "<MMSP>",
        "\u3000": "<IDEOGRAPHIC_SPACE>",
    }

    def __init__(
        self, ws: str = " \t\r\n", min: int = 1, max: int = 0, exact: int = 0
    ) -> None:
        super().__init__()
        self.matchWhite = ws
        self.set_whitespace_chars(
            "".join(c for c in self.whiteStrs if c not in self.matchWhite),
            copy_defaults=True,
        )
        # self.leave_whitespace()
        self._may_return_empty = True
        self.errmsg = f"Expected {self.name}"

        self.minLen = min

        if max > 0:
            self.maxLen = max
        else:
            self.maxLen = _MAX_INT

        if exact > 0:
            self.maxLen = exact
            self.minLen = exact

    def _generateDefaultName(self) -> str:
        return "".join(White.whiteStrs[c] for c in self.matchWhite)

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if instring[loc] not in self.matchWhite:
            raise ParseException(instring, loc, self.errmsg, self)
        start = loc
        loc += 1
        maxloc = start + self.maxLen
        maxloc = min(maxloc, len(instring))
        while loc < maxloc and instring[loc] in self.matchWhite:
            loc += 1

        if loc - start < self.minLen:
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, instring[start:loc]


class PositionToken(Token):
    def __init__(self) -> None:
        super().__init__()
        self._may_return_empty = True
        self.mayIndexError = False


class GoToColumn(PositionToken):
    """Token to advance to a specific column of input text; useful for
    tabular report scraping.
    """

    def __init__(self, colno: int) -> None:
        super().__init__()
        self.col = colno

    def preParse(self, instring: str, loc: int) -> int:
        if col(loc, instring) == self.col:
            return loc

        instrlen = len(instring)
        if self.ignoreExprs:
            loc = self._skipIgnorables(instring, loc)
        while (
            loc < instrlen
            and instring[loc].isspace()
            and col(loc, instring) != self.col
        ):
            loc += 1

        return loc

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        thiscol = col(loc, instring)
        if thiscol > self.col:
            raise ParseException(instring, loc, "Text not in expected column", self)
        newloc = loc + self.col - thiscol
        ret = instring[loc:newloc]
        return newloc, ret


class LineStart(PositionToken):
    r"""Matches if current position is at the beginning of a line within
    the parse string

    Example::

        test = '''\
        AAA this line
        AAA and this line
          AAA but not this one
        B AAA and definitely not this one
        '''

        for t in (LineStart() + 'AAA' + rest_of_line).search_string(test):
            print(t)

    prints::

        ['AAA', ' this line']
        ['AAA', ' and this line']

    """

    def __init__(self) -> None:
        super().__init__()
        self.leave_whitespace()
        self.orig_whiteChars = set() | self.whiteChars
        self.whiteChars.discard("\n")
        self.skipper = Empty().set_whitespace_chars(self.whiteChars)
        self.set_name("start of line")

    def preParse(self, instring: str, loc: int) -> int:
        if loc == 0:
            return loc

        ret = self.skipper.preParse(instring, loc)

        if "\n" in self.orig_whiteChars:
            while instring[ret : ret + 1] == "\n":
                ret = self.skipper.preParse(instring, ret + 1)

        return ret

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if col(loc, instring) == 1:
            return loc, []
        raise ParseException(instring, loc, self.errmsg, self)


class LineEnd(PositionToken):
    """Matches if current position is at the end of a line within the
    parse string
    """

    def __init__(self) -> None:
        super().__init__()
        self.whiteChars.discard("\n")
        self.set_whitespace_chars(self.whiteChars, copy_defaults=False)
        self.set_name("end of line")

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if loc < len(instring):
            if instring[loc] == "\n":
                return loc + 1, "\n"
            else:
                raise ParseException(instring, loc, self.errmsg, self)
        elif loc == len(instring):
            return loc + 1, []
        else:
            raise ParseException(instring, loc, self.errmsg, self)


class StringStart(PositionToken):
    """Matches if current position is at the beginning of the parse
    string
    """

    def __init__(self) -> None:
        super().__init__()
        self.set_name("start of text")

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        # see if entire string up to here is just whitespace and ignoreables
        if loc != 0 and loc != self.preParse(instring, 0):
            raise ParseException(instring, loc, self.errmsg, self)

        return loc, []


class StringEnd(PositionToken):
    """
    Matches if current position is at the end of the parse string
    """

    def __init__(self) -> None:
        super().__init__()
        self.set_name("end of text")

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if loc < len(instring):
            raise ParseException(instring, loc, self.errmsg, self)
        if loc == len(instring):
            return loc + 1, []
        if loc > len(instring):
            return loc, []

        raise ParseException(instring, loc, self.errmsg, self)


class WordStart(PositionToken):
    """Matches if the current position is at the beginning of a
    :class:`Word`, and is not preceded by any character in a given
    set of ``word_chars`` (default= ``printables``). To emulate the
    ``\b`` behavior of regular expressions, use
    ``WordStart(alphanums)``. ``WordStart`` will also match at
    the beginning of the string being parsed, or at the beginning of
    a line.
    """

    def __init__(
        self, word_chars: str = printables, *, wordChars: str = printables
    ) -> None:
        wordChars = word_chars if wordChars == printables else wordChars
        super().__init__()
        self.wordChars = set(wordChars)
        self.set_name("start of a word")

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if loc != 0:
            if (
                instring[loc - 1] in self.wordChars
                or instring[loc] not in self.wordChars
            ):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []


class WordEnd(PositionToken):
    """Matches if the current position is at the end of a :class:`Word`,
    and is not followed by any character in a given set of ``word_chars``
    (default= ``printables``). To emulate the ``\b`` behavior of
    regular expressions, use ``WordEnd(alphanums)``. ``WordEnd``
    will also match at the end of the string being parsed, or at the end
    of a line.
    """

    def __init__(
        self, word_chars: str = printables, *, wordChars: str = printables
    ) -> None:
        wordChars = word_chars if wordChars == printables else wordChars
        super().__init__()
        self.wordChars = set(wordChars)
        self.skipWhitespace = False
        self.set_name("end of a word")

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        instrlen = len(instring)
        if instrlen > 0 and loc < instrlen:
            if (
                instring[loc] in self.wordChars
                or instring[loc - 1] not in self.wordChars
            ):
                raise ParseException(instring, loc, self.errmsg, self)
        return loc, []


class Tag(Token):
    """
    A meta-element for inserting a named result into the parsed
    tokens that may be checked later in a parse action or while
    processing the parsed results. Accepts an optional tag value,
    defaulting to `True`.

    Example::

        end_punc = "." | ("!" + Tag("enthusiastic")))
        greeting = "Hello," + Word(alphas) + end_punc

        result = greeting.parse_string("Hello, World.")
        print(result.dump())

        result = greeting.parse_string("Hello, World!")
        print(result.dump())

    prints::

        ['Hello,', 'World', '.']

        ['Hello,', 'World', '!']
        - enthusiastic: True
    """

    def __init__(self, tag_name: str, value: Any = True) -> None:
        super().__init__()
        self._may_return_empty = True
        self.mayIndexError = False
        self.leave_whitespace()
        self.tag_name = tag_name
        self.tag_value = value
        self.add_parse_action(self._add_tag)
        self.show_in_diagram = False

    def _add_tag(self, tokens: ParseResults):
        tokens[self.tag_name] = self.tag_value

    def _generateDefaultName(self) -> str:
        return f"{type(self).__name__}:{self.tag_name}={self.tag_value!r}"


class ParseExpression(ParserElement):
    """Abstract subclass of ParserElement, for combining and
    post-processing parsed tokens.
    """

    def __init__(
        self, exprs: typing.Iterable[ParserElement], savelist: bool = False
    ) -> None:
        super().__init__(savelist)
        self.exprs: list[ParserElement]
        if isinstance(exprs, _generatorType):
            exprs = list(exprs)

        if isinstance(exprs, str_type):
            self.exprs = [self._literalStringClass(exprs)]
        elif isinstance(exprs, ParserElement):
            self.exprs = [exprs]
        elif isinstance(exprs, Iterable):
            exprs = list(exprs)
            # if sequence of strings provided, wrap with Literal
            if any(isinstance(expr, str_type) for expr in exprs):
                exprs = (
                    self._literalStringClass(e) if isinstance(e, str_type) else e
                    for e in exprs
                )
            self.exprs = list(exprs)
        else:
            try:
                self.exprs = list(exprs)
            except TypeError:
                self.exprs = [exprs]
        self.callPreparse = False

    def recurse(self) -> list[ParserElement]:
        return self.exprs[:]

    def append(self, other) -> ParserElement:
        self.exprs.append(other)
        self._defaultName = None
        return self

    def leave_whitespace(self, recursive: bool = True) -> ParserElement:
        """
        Extends ``leave_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on
           all contained expressions.
        """
        super().leave_whitespace(recursive)

        if recursive:
            self.exprs = [e.copy() for e in self.exprs]
            for e in self.exprs:
                e.leave_whitespace(recursive)
        return self

    def ignore_whitespace(self, recursive: bool = True) -> ParserElement:
        """
        Extends ``ignore_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on
           all contained expressions.
        """
        super().ignore_whitespace(recursive)
        if recursive:
            self.exprs = [e.copy() for e in self.exprs]
            for e in self.exprs:
                e.ignore_whitespace(recursive)
        return self

    def ignore(self, other) -> ParserElement:
        if isinstance(other, Suppress):
            if other not in self.ignoreExprs:
                super().ignore(other)
                for e in self.exprs:
                    e.ignore(self.ignoreExprs[-1])
        else:
            super().ignore(other)
            for e in self.exprs:
                e.ignore(self.ignoreExprs[-1])
        return self

    def _generateDefaultName(self) -> str:
        return f"{type(self).__name__}:({self.exprs})"

    def streamline(self) -> ParserElement:
        if self.streamlined:
            return self

        super().streamline()

        for e in self.exprs:
            e.streamline()

        # collapse nested :class:`And`'s of the form ``And(And(And(a, b), c), d)`` to ``And(a, b, c, d)``
        # but only if there are no parse actions or resultsNames on the nested And's
        # (likewise for :class:`Or`'s and :class:`MatchFirst`'s)
        if len(self.exprs) == 2:
            other = self.exprs[0]
            if (
                isinstance(other, self.__class__)
                and not other.parseAction
                and other.resultsName is None
                and not other.debug
            ):
                self.exprs = other.exprs[:] + [self.exprs[1]]
                self._defaultName = None
                self._may_return_empty |= other.mayReturnEmpty
                self.mayIndexError |= other.mayIndexError

            other = self.exprs[-1]
            if (
                isinstance(other, self.__class__)
                and not other.parseAction
                and other.resultsName is None
                and not other.debug
            ):
                self.exprs = self.exprs[:-1] + other.exprs[:]
                self._defaultName = None
                self._may_return_empty |= other.mayReturnEmpty
                self.mayIndexError |= other.mayIndexError

        self.errmsg = f"Expected {self}"

        return self

    def validate(self, validateTrace=None) -> None:
        warnings.warn(
            "ParserElement.validate() is deprecated, and should not be used to check for left recursion",
            DeprecationWarning,
            stacklevel=2,
        )
        tmp = (validateTrace if validateTrace is not None else [])[:] + [self]
        for e in self.exprs:
            e.validate(tmp)
        self._checkRecursion([])

    def copy(self) -> ParserElement:
        ret = super().copy()
        ret = typing.cast(ParseExpression, ret)
        ret.exprs = [e.copy() for e in self.exprs]
        return ret

    def _setResultsName(self, name, list_all_matches=False) -> ParserElement:
        if not (
            __diag__.warn_ungrouped_named_tokens_in_collection
            and Diagnostics.warn_ungrouped_named_tokens_in_collection
            not in self.suppress_warnings_
        ):
            return super()._setResultsName(name, list_all_matches)

        for e in self.exprs:
            if (
                isinstance(e, ParserElement)
                and e.resultsName
                and (
                    Diagnostics.warn_ungrouped_named_tokens_in_collection
                    not in e.suppress_warnings_
                )
            ):
                warning = (
                    "warn_ungrouped_named_tokens_in_collection:"
                    f" setting results name {name!r} on {type(self).__name__} expression"
                    f" collides with {e.resultsName!r} on contained expression"
                )
                warnings.warn(warning, stacklevel=3)
                break

        return super()._setResultsName(name, list_all_matches)

    # Compatibility synonyms
    # fmt: off
    leaveWhitespace = replaced_by_pep8("leaveWhitespace", leave_whitespace)
    ignoreWhitespace = replaced_by_pep8("ignoreWhitespace", ignore_whitespace)
    # fmt: on


class And(ParseExpression):
    """
    Requires all given :class:`ParserElement` s to be found in the given order.
    Expressions may be separated by whitespace.
    May be constructed using the ``'+'`` operator.
    May also be constructed using the ``'-'`` operator, which will
    suppress backtracking.

    Example::

        integer = Word(nums)
        name_expr = Word(alphas)[1, ...]

        expr = And([integer("id"), name_expr("name"), integer("age")])
        # more easily written as:
        expr = integer("id") + name_expr("name") + integer("age")
    """

    class _ErrorStop(Empty):
        def __init__(self, *args, **kwargs) -> None:
            super().__init__(*args, **kwargs)
            self.leave_whitespace()

        def _generateDefaultName(self) -> str:
            return "-"

    def __init__(
        self,
        exprs_arg: typing.Iterable[Union[ParserElement, str]],
        savelist: bool = True,
    ) -> None:
        # instantiate exprs as a list, converting strs to ParserElements
        exprs: list[ParserElement] = [
            self._literalStringClass(e) if isinstance(e, str) else e for e in exprs_arg
        ]

        # convert any Ellipsis elements to SkipTo
        if Ellipsis in exprs:

            # Ellipsis cannot be the last element
            if exprs[-1] is Ellipsis:
                raise Exception("cannot construct And with sequence ending in ...")

            tmp: list[ParserElement] = []
            for cur_expr, next_expr in zip(exprs, exprs[1:]):
                if cur_expr is Ellipsis:
                    tmp.append(SkipTo(next_expr)("_skipped*"))
                else:
                    tmp.append(cur_expr)

            exprs[:-1] = tmp

        super().__init__(exprs, savelist)
        if self.exprs:
            self._may_return_empty = all(e.mayReturnEmpty for e in self.exprs)
            if not isinstance(self.exprs[0], White):
                self.set_whitespace_chars(
                    self.exprs[0].whiteChars,
                    copy_defaults=self.exprs[0].copyDefaultWhiteChars,
                )
                self.skipWhitespace = self.exprs[0].skipWhitespace
            else:
                self.skipWhitespace = False
        else:
            self._may_return_empty = True
        self.callPreparse = True

    def streamline(self) -> ParserElement:
        # collapse any _PendingSkip's
        if self.exprs and any(
            isinstance(e, ParseExpression)
            and e.exprs
            and isinstance(e.exprs[-1], _PendingSkip)
            for e in self.exprs[:-1]
        ):
            deleted_expr_marker = NoMatch()
            for i, e in enumerate(self.exprs[:-1]):
                if e is deleted_expr_marker:
                    continue
                if (
                    isinstance(e, ParseExpression)
                    and e.exprs
                    and isinstance(e.exprs[-1], _PendingSkip)
                ):
                    e.exprs[-1] = e.exprs[-1] + self.exprs[i + 1]
                    self.exprs[i + 1] = deleted_expr_marker
            self.exprs = [e for e in self.exprs if e is not deleted_expr_marker]

        super().streamline()

        # link any IndentedBlocks to the prior expression
        prev: ParserElement
        cur: ParserElement
        for prev, cur in zip(self.exprs, self.exprs[1:]):
            # traverse cur or any first embedded expr of cur looking for an IndentedBlock
            # (but watch out for recursive grammar)
            seen = set()
            while True:
                if id(cur) in seen:
                    break
                seen.add(id(cur))
                if isinstance(cur, IndentedBlock):
                    prev.add_parse_action(
                        lambda s, l, t, cur_=cur: setattr(
                            cur_, "parent_anchor", col(l, s)
                        )
                    )
                    break
                subs = cur.recurse()
                next_first = next(iter(subs), None)
                if next_first is None:
                    break
                cur = typing.cast(ParserElement, next_first)

        self._may_return_empty = all(e.mayReturnEmpty for e in self.exprs)
        return self

    def parseImpl(self, instring, loc, do_actions=True):
        # pass False as callPreParse arg to _parse for first element, since we already
        # pre-parsed the string as part of our And pre-parsing
        loc, resultlist = self.exprs[0]._parse(
            instring, loc, do_actions, callPreParse=False
        )
        errorStop = False
        for e in self.exprs[1:]:
            # if isinstance(e, And._ErrorStop):
            if type(e) is And._ErrorStop:
                errorStop = True
                continue
            if errorStop:
                try:
                    loc, exprtokens = e._parse(instring, loc, do_actions)
                except ParseSyntaxException:
                    raise
                except ParseBaseException as pe:
                    pe.__traceback__ = None
                    raise ParseSyntaxException._from_exception(pe)
                except IndexError:
                    raise ParseSyntaxException(
                        instring, len(instring), self.errmsg, self
                    )
            else:
                loc, exprtokens = e._parse(instring, loc, do_actions)
            resultlist += exprtokens
        return loc, resultlist

    def __iadd__(self, other):
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return self.append(other)  # And([self, other])

    def _checkRecursion(self, parseElementList):
        subRecCheckList = parseElementList[:] + [self]
        for e in self.exprs:
            e._checkRecursion(subRecCheckList)
            if not e.mayReturnEmpty:
                break

    def _generateDefaultName(self) -> str:
        inner = " ".join(str(e) for e in self.exprs)
        # strip off redundant inner {}'s
        while len(inner) > 1 and inner[0 :: len(inner) - 1] == "{}":
            inner = inner[1:-1]
        return f"{{{inner}}}"


class Or(ParseExpression):
    """Requires that at least one :class:`ParserElement` is found. If
    two expressions match, the expression that matches the longest
    string will be used. May be constructed using the ``'^'``
    operator.

    Example::

        # construct Or using '^' operator

        number = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums))
        print(number.search_string("123 3.1416 789"))

    prints::

        [['123'], ['3.1416'], ['789']]
    """

    def __init__(
        self, exprs: typing.Iterable[ParserElement], savelist: bool = False
    ) -> None:
        super().__init__(exprs, savelist)
        if self.exprs:
            self._may_return_empty = any(e.mayReturnEmpty for e in self.exprs)
            self.skipWhitespace = all(e.skipWhitespace for e in self.exprs)
        else:
            self._may_return_empty = True

    def streamline(self) -> ParserElement:
        super().streamline()
        if self.exprs:
            self._may_return_empty = any(e.mayReturnEmpty for e in self.exprs)
            self.saveAsList = any(e.saveAsList for e in self.exprs)
            self.skipWhitespace = all(
                e.skipWhitespace and not isinstance(e, White) for e in self.exprs
            )
        else:
            self.saveAsList = False
        return self

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        maxExcLoc = -1
        maxException = None
        matches: list[tuple[int, ParserElement]] = []
        fatals: list[ParseFatalException] = []
        if all(e.callPreparse for e in self.exprs):
            loc = self.preParse(instring, loc)
        for e in self.exprs:
            try:
                loc2 = e.try_parse(instring, loc, raise_fatal=True)
            except ParseFatalException as pfe:
                pfe.__traceback__ = None
                pfe.parser_element = e
                fatals.append(pfe)
                maxException = None
                maxExcLoc = -1
            except ParseException as err:
                if not fatals:
                    err.__traceback__ = None
                    if err.loc > maxExcLoc:
                        maxException = err
                        maxExcLoc = err.loc
            except IndexError:
                if len(instring) > maxExcLoc:
                    maxException = ParseException(
                        instring, len(instring), e.errmsg, self
                    )
                    maxExcLoc = len(instring)
            else:
                # save match among all matches, to retry longest to shortest
                matches.append((loc2, e))

        if matches:
            # re-evaluate all matches in descending order of length of match, in case attached actions
            # might change whether or how much they match of the input.
            matches.sort(key=itemgetter(0), reverse=True)

            if not do_actions:
                # no further conditions or parse actions to change the selection of
                # alternative, so the first match will be the best match
                best_expr = matches[0][1]
                return best_expr._parse(instring, loc, do_actions)

            longest: tuple[int, typing.Optional[ParseResults]] = -1, None
            for loc1, expr1 in matches:
                if loc1 <= longest[0]:
                    # already have a longer match than this one will deliver, we are done
                    return longest

                try:
                    loc2, toks = expr1._parse(instring, loc, do_actions)
                except ParseException as err:
                    err.__traceback__ = None
                    if err.loc > maxExcLoc:
                        maxException = err
                        maxExcLoc = err.loc
                else:
                    if loc2 >= loc1:
                        return loc2, toks
                    # didn't match as much as before
                    elif loc2 > longest[0]:
                        longest = loc2, toks

            if longest != (-1, None):
                return longest

        if fatals:
            if len(fatals) > 1:
                fatals.sort(key=lambda e: -e.loc)
                if fatals[0].loc == fatals[1].loc:
                    fatals.sort(key=lambda e: (-e.loc, -len(str(e.parser_element))))
            max_fatal = fatals[0]
            raise max_fatal

        if maxException is not None:
            # infer from this check that all alternatives failed at the current position
            # so emit this collective error message instead of any single error message
            parse_start_loc = self.preParse(instring, loc)
            if maxExcLoc == parse_start_loc:
                maxException.msg = self.errmsg or ""
            raise maxException

        raise ParseException(instring, loc, "no defined alternatives to match", self)

    def __ixor__(self, other):
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return self.append(other)  # Or([self, other])

    def _generateDefaultName(self) -> str:
        return f"{{{' ^ '.join(str(e) for e in self.exprs)}}}"

    def _setResultsName(self, name, list_all_matches=False) -> ParserElement:
        if (
            __diag__.warn_multiple_tokens_in_named_alternation
            and Diagnostics.warn_multiple_tokens_in_named_alternation
            not in self.suppress_warnings_
        ):
            if any(
                isinstance(e, And)
                and Diagnostics.warn_multiple_tokens_in_named_alternation
                not in e.suppress_warnings_
                for e in self.exprs
            ):
                warning = (
                    "warn_multiple_tokens_in_named_alternation:"
                    f" setting results name {name!r} on {type(self).__name__} expression"
                    " will return a list of all parsed tokens in an And alternative,"
                    " in prior versions only the first token was returned; enclose"
                    " contained argument in Group"
                )
                warnings.warn(warning, stacklevel=3)

        return super()._setResultsName(name, list_all_matches)


class MatchFirst(ParseExpression):
    """Requires that at least one :class:`ParserElement` is found. If
    more than one expression matches, the first one listed is the one that will
    match. May be constructed using the ``'|'`` operator.

    Example::

        # construct MatchFirst using '|' operator

        # watch the order of expressions to match
        number = Word(nums) | Combine(Word(nums) + '.' + Word(nums))
        print(number.search_string("123 3.1416 789")) #  Fail! -> [['123'], ['3'], ['1416'], ['789']]

        # put more selective expression first
        number = Combine(Word(nums) + '.' + Word(nums)) | Word(nums)
        print(number.search_string("123 3.1416 789")) #  Better -> [['123'], ['3.1416'], ['789']]
    """

    def __init__(
        self, exprs: typing.Iterable[ParserElement], savelist: bool = False
    ) -> None:
        super().__init__(exprs, savelist)
        if self.exprs:
            self._may_return_empty = any(e.mayReturnEmpty for e in self.exprs)
            self.skipWhitespace = all(e.skipWhitespace for e in self.exprs)
        else:
            self._may_return_empty = True

    def streamline(self) -> ParserElement:
        if self.streamlined:
            return self

        super().streamline()
        if self.exprs:
            self.saveAsList = any(e.saveAsList for e in self.exprs)
            self._may_return_empty = any(e.mayReturnEmpty for e in self.exprs)
            self.skipWhitespace = all(
                e.skipWhitespace and not isinstance(e, White) for e in self.exprs
            )
        else:
            self.saveAsList = False
            self._may_return_empty = True
        return self

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        maxExcLoc = -1
        maxException = None

        for e in self.exprs:
            try:
                return e._parse(instring, loc, do_actions)
            except ParseFatalException as pfe:
                pfe.__traceback__ = None
                pfe.parser_element = e
                raise
            except ParseException as err:
                if err.loc > maxExcLoc:
                    maxException = err
                    maxExcLoc = err.loc
            except IndexError:
                if len(instring) > maxExcLoc:
                    maxException = ParseException(
                        instring, len(instring), e.errmsg, self
                    )
                    maxExcLoc = len(instring)

        if maxException is not None:
            # infer from this check that all alternatives failed at the current position
            # so emit this collective error message instead of any individual error message
            parse_start_loc = self.preParse(instring, loc)
            if maxExcLoc == parse_start_loc:
                maxException.msg = self.errmsg or ""
            raise maxException

        raise ParseException(instring, loc, "no defined alternatives to match", self)

    def __ior__(self, other):
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return self.append(other)  # MatchFirst([self, other])

    def _generateDefaultName(self) -> str:
        return f"{{{' | '.join(str(e) for e in self.exprs)}}}"

    def _setResultsName(self, name, list_all_matches=False) -> ParserElement:
        if (
            __diag__.warn_multiple_tokens_in_named_alternation
            and Diagnostics.warn_multiple_tokens_in_named_alternation
            not in self.suppress_warnings_
        ):
            if any(
                isinstance(e, And)
                and Diagnostics.warn_multiple_tokens_in_named_alternation
                not in e.suppress_warnings_
                for e in self.exprs
            ):
                warning = (
                    "warn_multiple_tokens_in_named_alternation:"
                    f" setting results name {name!r} on {type(self).__name__} expression"
                    " will return a list of all parsed tokens in an And alternative,"
                    " in prior versions only the first token was returned; enclose"
                    " contained argument in Group"
                )
                warnings.warn(warning, stacklevel=3)

        return super()._setResultsName(name, list_all_matches)


class Each(ParseExpression):
    """Requires all given :class:`ParserElement` s to be found, but in
    any order. Expressions may be separated by whitespace.

    May be constructed using the ``'&'`` operator.

    Example::

        color = one_of("RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN")
        shape_type = one_of("SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON")
        integer = Word(nums)
        shape_attr = "shape:" + shape_type("shape")
        posn_attr = "posn:" + Group(integer("x") + ',' + integer("y"))("posn")
        color_attr = "color:" + color("color")
        size_attr = "size:" + integer("size")

        # use Each (using operator '&') to accept attributes in any order
        # (shape and posn are required, color and size are optional)
        shape_spec = shape_attr & posn_attr & Opt(color_attr) & Opt(size_attr)

        shape_spec.run_tests('''
            shape: SQUARE color: BLACK posn: 100, 120
            shape: CIRCLE size: 50 color: BLUE posn: 50,80
            color:GREEN size:20 shape:TRIANGLE posn:20,40
            '''
            )

    prints::

        shape: SQUARE color: BLACK posn: 100, 120
        ['shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']]
        - color: BLACK
        - posn: ['100', ',', '120']
          - x: 100
          - y: 120
        - shape: SQUARE


        shape: CIRCLE size: 50 color: BLUE posn: 50,80
        ['shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']]
        - color: BLUE
        - posn: ['50', ',', '80']
          - x: 50
          - y: 80
        - shape: CIRCLE
        - size: 50


        color: GREEN size: 20 shape: TRIANGLE posn: 20,40
        ['color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']]
        - color: GREEN
        - posn: ['20', ',', '40']
          - x: 20
          - y: 40
        - shape: TRIANGLE
        - size: 20
    """

    def __init__(
        self, exprs: typing.Iterable[ParserElement], savelist: bool = True
    ) -> None:
        super().__init__(exprs, savelist)
        if self.exprs:
            self._may_return_empty = all(e.mayReturnEmpty for e in self.exprs)
        else:
            self._may_return_empty = True
        self.skipWhitespace = True
        self.initExprGroups = True
        self.saveAsList = True

    def __iand__(self, other):
        if isinstance(other, str_type):
            other = self._literalStringClass(other)
        if not isinstance(other, ParserElement):
            return NotImplemented
        return self.append(other)  # Each([self, other])

    def streamline(self) -> ParserElement:
        super().streamline()
        if self.exprs:
            self._may_return_empty = all(e.mayReturnEmpty for e in self.exprs)
        else:
            self._may_return_empty = True
        return self

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if self.initExprGroups:
            self.opt1map = dict(
                (id(e.expr), e) for e in self.exprs if isinstance(e, Opt)
            )
            opt1 = [e.expr for e in self.exprs if isinstance(e, Opt)]
            opt2 = [
                e
                for e in self.exprs
                if e.mayReturnEmpty and not isinstance(e, (Opt, Regex, ZeroOrMore))
            ]
            self.optionals = opt1 + opt2
            self.multioptionals = [
                e.expr.set_results_name(e.resultsName, list_all_matches=True)
                for e in self.exprs
                if isinstance(e, _MultipleMatch)
            ]
            self.multirequired = [
                e.expr.set_results_name(e.resultsName, list_all_matches=True)
                for e in self.exprs
                if isinstance(e, OneOrMore)
            ]
            self.required = [
                e for e in self.exprs if not isinstance(e, (Opt, ZeroOrMore, OneOrMore))
            ]
            self.required += self.multirequired
            self.initExprGroups = False

        tmpLoc = loc
        tmpReqd = self.required[:]
        tmpOpt = self.optionals[:]
        multis = self.multioptionals[:]
        matchOrder: list[ParserElement] = []

        keepMatching = True
        failed: list[ParserElement] = []
        fatals: list[ParseFatalException] = []
        while keepMatching:
            tmpExprs = tmpReqd + tmpOpt + multis
            failed.clear()
            fatals.clear()
            for e in tmpExprs:
                try:
                    tmpLoc = e.try_parse(instring, tmpLoc, raise_fatal=True)
                except ParseFatalException as pfe:
                    pfe.__traceback__ = None
                    pfe.parser_element = e
                    fatals.append(pfe)
                    failed.append(e)
                except ParseException:
                    failed.append(e)
                else:
                    matchOrder.append(self.opt1map.get(id(e), e))
                    if e in tmpReqd:
                        tmpReqd.remove(e)
                    elif e in tmpOpt:
                        tmpOpt.remove(e)
            if len(failed) == len(tmpExprs):
                keepMatching = False

        # look for any ParseFatalExceptions
        if fatals:
            if len(fatals) > 1:
                fatals.sort(key=lambda e: -e.loc)
                if fatals[0].loc == fatals[1].loc:
                    fatals.sort(key=lambda e: (-e.loc, -len(str(e.parser_element))))
            max_fatal = fatals[0]
            raise max_fatal

        if tmpReqd:
            missing = ", ".join([str(e) for e in tmpReqd])
            raise ParseException(
                instring,
                loc,
                f"Missing one or more required elements ({missing})",
            )

        # add any unmatched Opts, in case they have default values defined
        matchOrder += [e for e in self.exprs if isinstance(e, Opt) and e.expr in tmpOpt]

        total_results = ParseResults([])
        for e in matchOrder:
            loc, results = e._parse(instring, loc, do_actions)
            total_results += results

        return loc, total_results

    def _generateDefaultName(self) -> str:
        return f"{{{' & '.join(str(e) for e in self.exprs)}}}"


class ParseElementEnhance(ParserElement):
    """Abstract subclass of :class:`ParserElement`, for combining and
    post-processing parsed tokens.
    """

    def __init__(self, expr: Union[ParserElement, str], savelist: bool = False) -> None:
        super().__init__(savelist)
        if isinstance(expr, str_type):
            expr_str = typing.cast(str, expr)
            if issubclass(self._literalStringClass, Token):
                expr = self._literalStringClass(expr_str)  # type: ignore[call-arg]
            elif issubclass(type(self), self._literalStringClass):
                expr = Literal(expr_str)
            else:
                expr = self._literalStringClass(Literal(expr_str))  # type: ignore[assignment, call-arg]
        expr = typing.cast(ParserElement, expr)
        self.expr = expr
        if expr is not None:
            self.mayIndexError = expr.mayIndexError
            self._may_return_empty = expr.mayReturnEmpty
            self.set_whitespace_chars(
                expr.whiteChars, copy_defaults=expr.copyDefaultWhiteChars
            )
            self.skipWhitespace = expr.skipWhitespace
            self.saveAsList = expr.saveAsList
            self.callPreparse = expr.callPreparse
            self.ignoreExprs.extend(expr.ignoreExprs)

    def recurse(self) -> list[ParserElement]:
        return [self.expr] if self.expr is not None else []

    def parseImpl(self, instring, loc, do_actions=True):
        if self.expr is None:
            raise ParseException(instring, loc, "No expression defined", self)

        try:
            return self.expr._parse(instring, loc, do_actions, callPreParse=False)
        except ParseSyntaxException:
            raise
        except ParseBaseException as pbe:
            pbe.pstr = pbe.pstr or instring
            pbe.loc = pbe.loc or loc
            pbe.parser_element = pbe.parser_element or self
            if not isinstance(self, Forward) and self.customName is not None:
                if self.errmsg:
                    pbe.msg = self.errmsg
            raise

    def leave_whitespace(self, recursive: bool = True) -> ParserElement:
        super().leave_whitespace(recursive)

        if recursive:
            if self.expr is not None:
                self.expr = self.expr.copy()
                self.expr.leave_whitespace(recursive)
        return self

    def ignore_whitespace(self, recursive: bool = True) -> ParserElement:
        super().ignore_whitespace(recursive)

        if recursive:
            if self.expr is not None:
                self.expr = self.expr.copy()
                self.expr.ignore_whitespace(recursive)
        return self

    def ignore(self, other) -> ParserElement:
        if not isinstance(other, Suppress) or other not in self.ignoreExprs:
            super().ignore(other)
            if self.expr is not None:
                self.expr.ignore(self.ignoreExprs[-1])

        return self

    def streamline(self) -> ParserElement:
        super().streamline()
        if self.expr is not None:
            self.expr.streamline()
        return self

    def _checkRecursion(self, parseElementList):
        if self in parseElementList:
            raise RecursiveGrammarException(parseElementList + [self])
        subRecCheckList = parseElementList[:] + [self]
        if self.expr is not None:
            self.expr._checkRecursion(subRecCheckList)

    def validate(self, validateTrace=None) -> None:
        warnings.warn(
            "ParserElement.validate() is deprecated, and should not be used to check for left recursion",
            DeprecationWarning,
            stacklevel=2,
        )
        if validateTrace is None:
            validateTrace = []
        tmp = validateTrace[:] + [self]
        if self.expr is not None:
            self.expr.validate(tmp)
        self._checkRecursion([])

    def _generateDefaultName(self) -> str:
        return f"{type(self).__name__}:({self.expr})"

    # Compatibility synonyms
    # fmt: off
    leaveWhitespace = replaced_by_pep8("leaveWhitespace", leave_whitespace)
    ignoreWhitespace = replaced_by_pep8("ignoreWhitespace", ignore_whitespace)
    # fmt: on


class IndentedBlock(ParseElementEnhance):
    """
    Expression to match one or more expressions at a given indentation level.
    Useful for parsing text where structure is implied by indentation (like Python source code).
    """

    class _Indent(Empty):
        def __init__(self, ref_col: int) -> None:
            super().__init__()
            self.errmsg = f"expected indent at column {ref_col}"
            self.add_condition(lambda s, l, t: col(l, s) == ref_col)

    class _IndentGreater(Empty):
        def __init__(self, ref_col: int) -> None:
            super().__init__()
            self.errmsg = f"expected indent at column greater than {ref_col}"
            self.add_condition(lambda s, l, t: col(l, s) > ref_col)

    def __init__(
        self, expr: ParserElement, *, recursive: bool = False, grouped: bool = True
    ) -> None:
        super().__init__(expr, savelist=True)
        # if recursive:
        #     raise NotImplementedError("IndentedBlock with recursive is not implemented")
        self._recursive = recursive
        self._grouped = grouped
        self.parent_anchor = 1

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        # advance parse position to non-whitespace by using an Empty()
        # this should be the column to be used for all subsequent indented lines
        anchor_loc = Empty().preParse(instring, loc)

        # see if self.expr matches at the current location - if not it will raise an exception
        # and no further work is necessary
        self.expr.try_parse(instring, anchor_loc, do_actions=do_actions)

        indent_col = col(anchor_loc, instring)
        peer_detect_expr = self._Indent(indent_col)

        inner_expr = Empty() + peer_detect_expr + self.expr
        if self._recursive:
            sub_indent = self._IndentGreater(indent_col)
            nested_block = IndentedBlock(
                self.expr, recursive=self._recursive, grouped=self._grouped
            )
            nested_block.set_debug(self.debug)
            nested_block.parent_anchor = indent_col
            inner_expr += Opt(sub_indent + nested_block)

        inner_expr.set_name(f"inner {hex(id(inner_expr))[-4:].upper()}@{indent_col}")
        block = OneOrMore(inner_expr)

        trailing_undent = self._Indent(self.parent_anchor) | StringEnd()

        if self._grouped:
            wrapper = Group
        else:
            wrapper = lambda expr: expr  # type: ignore[misc, assignment]
        return (wrapper(block) + Optional(trailing_undent)).parseImpl(
            instring, anchor_loc, do_actions
        )


class AtStringStart(ParseElementEnhance):
    """Matches if expression matches at the beginning of the parse
    string::

        AtStringStart(Word(nums)).parse_string("123")
        # prints ["123"]

        AtStringStart(Word(nums)).parse_string("    123")
        # raises ParseException
    """

    def __init__(self, expr: Union[ParserElement, str]) -> None:
        super().__init__(expr)
        self.callPreparse = False

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if loc != 0:
            raise ParseException(instring, loc, "not found at string start")
        return super().parseImpl(instring, loc, do_actions)


class AtLineStart(ParseElementEnhance):
    r"""Matches if an expression matches at the beginning of a line within
    the parse string

    Example::

        test = '''\
        AAA this line
        AAA and this line
          AAA but not this one
        B AAA and definitely not this one
        '''

        for t in (AtLineStart('AAA') + rest_of_line).search_string(test):
            print(t)

    prints::

        ['AAA', ' this line']
        ['AAA', ' and this line']

    """

    def __init__(self, expr: Union[ParserElement, str]) -> None:
        super().__init__(expr)
        self.callPreparse = False

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if col(loc, instring) != 1:
            raise ParseException(instring, loc, "not found at line start")
        return super().parseImpl(instring, loc, do_actions)


class FollowedBy(ParseElementEnhance):
    """Lookahead matching of the given parse expression.
    ``FollowedBy`` does *not* advance the parsing position within
    the input string, it only verifies that the specified parse
    expression matches at the current position.  ``FollowedBy``
    always returns a null token list. If any results names are defined
    in the lookahead expression, those *will* be returned for access by
    name.

    Example::

        # use FollowedBy to match a label only if it is followed by a ':'
        data_word = Word(alphas)
        label = data_word + FollowedBy(':')
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))

        attr_expr[1, ...].parse_string("shape: SQUARE color: BLACK posn: upper left").pprint()

    prints::

        [['shape', 'SQUARE'], ['color', 'BLACK'], ['posn', 'upper left']]
    """

    def __init__(self, expr: Union[ParserElement, str]) -> None:
        super().__init__(expr)
        self._may_return_empty = True

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        # by using self._expr.parse and deleting the contents of the returned ParseResults list
        # we keep any named results that were defined in the FollowedBy expression
        _, ret = self.expr._parse(instring, loc, do_actions=do_actions)
        del ret[:]

        return loc, ret


class PrecededBy(ParseElementEnhance):
    """Lookbehind matching of the given parse expression.
    ``PrecededBy`` does not advance the parsing position within the
    input string, it only verifies that the specified parse expression
    matches prior to the current position.  ``PrecededBy`` always
    returns a null token list, but if a results name is defined on the
    given expression, it is returned.

    Parameters:

    - ``expr`` - expression that must match prior to the current parse
      location
    - ``retreat`` - (default= ``None``) - (int) maximum number of characters
      to lookbehind prior to the current parse location

    If the lookbehind expression is a string, :class:`Literal`,
    :class:`Keyword`, or a :class:`Word` or :class:`CharsNotIn`
    with a specified exact or maximum length, then the retreat
    parameter is not required. Otherwise, retreat must be specified to
    give a maximum number of characters to look back from
    the current parse position for a lookbehind match.

    Example::

        # VB-style variable names with type prefixes
        int_var = PrecededBy("#") + pyparsing_common.identifier
        str_var = PrecededBy("$") + pyparsing_common.identifier

    """

    def __init__(self, expr: Union[ParserElement, str], retreat: int = 0) -> None:
        super().__init__(expr)
        self.expr = self.expr().leave_whitespace()
        self._may_return_empty = True
        self.mayIndexError = False
        self.exact = False
        if isinstance(expr, str_type):
            expr = typing.cast(str, expr)
            retreat = len(expr)
            self.exact = True
        elif isinstance(expr, (Literal, Keyword)):
            retreat = expr.matchLen
            self.exact = True
        elif isinstance(expr, (Word, CharsNotIn)) and expr.maxLen != _MAX_INT:
            retreat = expr.maxLen
            self.exact = True
        elif isinstance(expr, PositionToken):
            retreat = 0
            self.exact = True
        self.retreat = retreat
        self.errmsg = f"not preceded by {expr}"
        self.skipWhitespace = False
        self.parseAction.append(lambda s, l, t: t.__delitem__(slice(None, None)))

    def parseImpl(self, instring, loc=0, do_actions=True) -> ParseImplReturnType:
        if self.exact:
            if loc < self.retreat:
                raise ParseException(instring, loc, self.errmsg, self)
            start = loc - self.retreat
            _, ret = self.expr._parse(instring, start)
            return loc, ret

        # retreat specified a maximum lookbehind window, iterate
        test_expr = self.expr + StringEnd()
        instring_slice = instring[max(0, loc - self.retreat) : loc]
        last_expr: ParseBaseException = ParseException(instring, loc, self.errmsg, self)

        for offset in range(1, min(loc, self.retreat + 1) + 1):
            try:
                # print('trying', offset, instring_slice, repr(instring_slice[loc - offset:]))
                _, ret = test_expr._parse(instring_slice, len(instring_slice) - offset)
            except ParseBaseException as pbe:
                last_expr = pbe
            else:
                break
        else:
            raise last_expr

        return loc, ret


class Located(ParseElementEnhance):
    """
    Decorates a returned token with its starting and ending
    locations in the input string.

    This helper adds the following results names:

    - ``locn_start`` - location where matched expression begins
    - ``locn_end`` - location where matched expression ends
    - ``value`` - the actual parsed results

    Be careful if the input text contains ``<TAB>`` characters, you
    may want to call :class:`ParserElement.parse_with_tabs`

    Example::

        wd = Word(alphas)
        for match in Located(wd).search_string("ljsdf123lksdjjf123lkkjj1222"):
            print(match)

    prints::

        [0, ['ljsdf'], 5]
        [8, ['lksdjjf'], 15]
        [18, ['lkkjj'], 23]

    """

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        start = loc
        loc, tokens = self.expr._parse(instring, start, do_actions, callPreParse=False)
        ret_tokens = ParseResults([start, tokens, loc])
        ret_tokens["locn_start"] = start
        ret_tokens["value"] = tokens
        ret_tokens["locn_end"] = loc
        if self.resultsName:
            # must return as a list, so that the name will be attached to the complete group
            return loc, [ret_tokens]
        else:
            return loc, ret_tokens


class NotAny(ParseElementEnhance):
    """
    Lookahead to disallow matching with the given parse expression.
    ``NotAny`` does *not* advance the parsing position within the
    input string, it only verifies that the specified parse expression
    does *not* match at the current position.  Also, ``NotAny`` does
    *not* skip over leading whitespace. ``NotAny`` always returns
    a null token list.  May be constructed using the ``'~'`` operator.

    Example::

        AND, OR, NOT = map(CaselessKeyword, "AND OR NOT".split())

        # take care not to mistake keywords for identifiers
        ident = ~(AND | OR | NOT) + Word(alphas)
        boolean_term = Opt(NOT) + ident

        # very crude boolean expression - to support parenthesis groups and
        # operation hierarchy, use infix_notation
        boolean_expr = boolean_term + ((AND | OR) + boolean_term)[...]

        # integers that are followed by "." are actually floats
        integer = Word(nums) + ~Char(".")
    """

    def __init__(self, expr: Union[ParserElement, str]) -> None:
        super().__init__(expr)
        # do NOT use self.leave_whitespace(), don't want to propagate to exprs
        # self.leave_whitespace()
        self.skipWhitespace = False

        self._may_return_empty = True
        self.errmsg = f"Found unwanted token, {self.expr}"

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if self.expr.can_parse_next(instring, loc, do_actions=do_actions):
            raise ParseException(instring, loc, self.errmsg, self)
        return loc, []

    def _generateDefaultName(self) -> str:
        return f"~{{{self.expr}}}"


class _MultipleMatch(ParseElementEnhance):
    def __init__(
        self,
        expr: Union[str, ParserElement],
        stop_on: typing.Optional[Union[ParserElement, str]] = None,
        *,
        stopOn: typing.Optional[Union[ParserElement, str]] = None,
    ) -> None:
        super().__init__(expr)
        stopOn = stopOn or stop_on
        self.saveAsList = True
        ender = stopOn
        if isinstance(ender, str_type):
            ender = self._literalStringClass(ender)
        self.stopOn(ender)

    def stopOn(self, ender) -> ParserElement:
        if isinstance(ender, str_type):
            ender = self._literalStringClass(ender)
        self.not_ender = ~ender if ender is not None else None
        return self

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        self_expr_parse = self.expr._parse
        self_skip_ignorables = self._skipIgnorables
        check_ender = False
        if self.not_ender is not None:
            try_not_ender = self.not_ender.try_parse
            check_ender = True

        # must be at least one (but first see if we are the stopOn sentinel;
        # if so, fail)
        if check_ender:
            try_not_ender(instring, loc)
        loc, tokens = self_expr_parse(instring, loc, do_actions)
        try:
            hasIgnoreExprs = not not self.ignoreExprs
            while 1:
                if check_ender:
                    try_not_ender(instring, loc)
                if hasIgnoreExprs:
                    preloc = self_skip_ignorables(instring, loc)
                else:
                    preloc = loc
                loc, tmptokens = self_expr_parse(instring, preloc, do_actions)
                tokens += tmptokens
        except (ParseException, IndexError):
            pass

        return loc, tokens

    def _setResultsName(self, name, list_all_matches=False) -> ParserElement:
        if (
            __diag__.warn_ungrouped_named_tokens_in_collection
            and Diagnostics.warn_ungrouped_named_tokens_in_collection
            not in self.suppress_warnings_
        ):
            for e in [self.expr] + self.expr.recurse():
                if (
                    isinstance(e, ParserElement)
                    and e.resultsName
                    and (
                        Diagnostics.warn_ungrouped_named_tokens_in_collection
                        not in e.suppress_warnings_
                    )
                ):
                    warning = (
                        "warn_ungrouped_named_tokens_in_collection:"
                        f" setting results name {name!r} on {type(self).__name__} expression"
                        f" collides with {e.resultsName!r} on contained expression"
                    )
                    warnings.warn(warning, stacklevel=3)
                    break

        return super()._setResultsName(name, list_all_matches)


class OneOrMore(_MultipleMatch):
    """
    Repetition of one or more of the given expression.

    Parameters:

    - ``expr`` - expression that must match one or more times
    - ``stop_on`` - (default= ``None``) - expression for a terminating sentinel
      (only required if the sentinel would ordinarily match the repetition
      expression)

    Example::

        data_word = Word(alphas)
        label = data_word + FollowedBy(':')
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).set_parse_action(' '.join))

        text = "shape: SQUARE posn: upper left color: BLACK"
        attr_expr[1, ...].parse_string(text).pprint()  # Fail! read 'color' as data instead of next label -> [['shape', 'SQUARE color']]

        # use stop_on attribute for OneOrMore to avoid reading label string as part of the data
        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))
        OneOrMore(attr_expr).parse_string(text).pprint() # Better -> [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'BLACK']]

        # could also be written as
        (attr_expr * (1,)).parse_string(text).pprint()
    """

    def _generateDefaultName(self) -> str:
        return f"{{{self.expr}}}..."


class ZeroOrMore(_MultipleMatch):
    """
    Optional repetition of zero or more of the given expression.

    Parameters:

    - ``expr`` - expression that must match zero or more times
    - ``stop_on`` - expression for a terminating sentinel
      (only required if the sentinel would ordinarily match the repetition
      expression) - (default= ``None``)

    Example: similar to :class:`OneOrMore`
    """

    def __init__(
        self,
        expr: Union[str, ParserElement],
        stop_on: typing.Optional[Union[ParserElement, str]] = None,
        *,
        stopOn: typing.Optional[Union[ParserElement, str]] = None,
    ) -> None:
        super().__init__(expr, stopOn=stopOn or stop_on)
        self._may_return_empty = True

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        try:
            return super().parseImpl(instring, loc, do_actions)
        except (ParseException, IndexError):
            return loc, ParseResults([], name=self.resultsName)

    def _generateDefaultName(self) -> str:
        return f"[{self.expr}]..."


class DelimitedList(ParseElementEnhance):
    def __init__(
        self,
        expr: Union[str, ParserElement],
        delim: Union[str, ParserElement] = ",",
        combine: bool = False,
        min: typing.Optional[int] = None,
        max: typing.Optional[int] = None,
        *,
        allow_trailing_delim: bool = False,
    ) -> None:
        """Helper to define a delimited list of expressions - the delimiter
        defaults to ','. By default, the list elements and delimiters can
        have intervening whitespace, and comments, but this can be
        overridden by passing ``combine=True`` in the constructor. If
        ``combine`` is set to ``True``, the matching tokens are
        returned as a single token string, with the delimiters included;
        otherwise, the matching tokens are returned as a list of tokens,
        with the delimiters suppressed.

        If ``allow_trailing_delim`` is set to True, then the list may end with
        a delimiter.

        Example::

            DelimitedList(Word(alphas)).parse_string("aa,bb,cc") # -> ['aa', 'bb', 'cc']
            DelimitedList(Word(hexnums), delim=':', combine=True).parse_string("AA:BB:CC:DD:EE") # -> ['AA:BB:CC:DD:EE']
        """
        if isinstance(expr, str_type):
            expr = ParserElement._literalStringClass(expr)
        expr = typing.cast(ParserElement, expr)

        if min is not None and min < 1:
            raise ValueError("min must be greater than 0")

        if max is not None and min is not None and max < min:
            raise ValueError("max must be greater than, or equal to min")

        self.content = expr
        self.raw_delim = str(delim)
        self.delim = delim
        self.combine = combine
        if not combine:
            self.delim = Suppress(delim)
        self.min = min or 1
        self.max = max
        self.allow_trailing_delim = allow_trailing_delim

        delim_list_expr = self.content + (self.delim + self.content) * (
            self.min - 1,
            None if self.max is None else self.max - 1,
        )
        if self.allow_trailing_delim:
            delim_list_expr += Opt(self.delim)

        if self.combine:
            delim_list_expr = Combine(delim_list_expr)

        super().__init__(delim_list_expr, savelist=True)

    def _generateDefaultName(self) -> str:
        content_expr = self.content.streamline()
        return f"{content_expr} [{self.raw_delim} {content_expr}]..."


class _NullToken:
    def __bool__(self):
        return False

    def __str__(self):
        return ""


class Opt(ParseElementEnhance):
    """
    Optional matching of the given expression.

    Parameters:

    - ``expr`` - expression that must match zero or more times
    - ``default`` (optional) - value to be returned if the optional expression is not found.

    Example::

        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier
        zip = Combine(Word(nums, exact=5) + Opt('-' + Word(nums, exact=4)))
        zip.run_tests('''
            # traditional ZIP code
            12345

            # ZIP+4 form
            12101-0001

            # invalid ZIP
            98765-
            ''')

    prints::

        # traditional ZIP code
        12345
        ['12345']

        # ZIP+4 form
        12101-0001
        ['12101-0001']

        # invalid ZIP
        98765-
             ^
        FAIL: Expected end of text (at char 5), (line:1, col:6)
    """

    __optionalNotMatched = _NullToken()

    def __init__(
        self, expr: Union[ParserElement, str], default: Any = __optionalNotMatched
    ) -> None:
        super().__init__(expr, savelist=False)
        self.saveAsList = self.expr.saveAsList
        self.defaultValue = default
        self._may_return_empty = True

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        self_expr = self.expr
        try:
            loc, tokens = self_expr._parse(
                instring, loc, do_actions, callPreParse=False
            )
        except (ParseException, IndexError):
            default_value = self.defaultValue
            if default_value is not self.__optionalNotMatched:
                if self_expr.resultsName:
                    tokens = ParseResults([default_value])
                    tokens[self_expr.resultsName] = default_value
                else:
                    tokens = [default_value]  # type: ignore[assignment]
            else:
                tokens = []  # type: ignore[assignment]
        return loc, tokens

    def _generateDefaultName(self) -> str:
        inner = str(self.expr)
        # strip off redundant inner {}'s
        while len(inner) > 1 and inner[0 :: len(inner) - 1] == "{}":
            inner = inner[1:-1]
        return f"[{inner}]"


Optional = Opt


class SkipTo(ParseElementEnhance):
    """
    Token for skipping over all undefined text until the matched
    expression is found.

    Parameters:

    - ``expr`` - target expression marking the end of the data to be skipped
    - ``include`` - if ``True``, the target expression is also parsed
      (the skipped text and target expression are returned as a 2-element
      list) (default= ``False``).
    - ``ignore`` - (default= ``None``) used to define grammars (typically quoted strings and
      comments) that might contain false matches to the target expression
    - ``fail_on`` - (default= ``None``) define expressions that are not allowed to be
      included in the skipped test; if found before the target expression is found,
      the :class:`SkipTo` is not a match

    Example::

        report = '''
            Outstanding Issues Report - 1 Jan 2000

               # | Severity | Description                               |  Days Open
            -----+----------+-------------------------------------------+-----------
             101 | Critical | Intermittent system crash                 |          6
              94 | Cosmetic | Spelling error on Login ('log|n')         |         14
              79 | Minor    | System slow when running too many reports |         47
            '''
        integer = Word(nums)
        SEP = Suppress('|')
        # use SkipTo to simply match everything up until the next SEP
        # - ignore quoted strings, so that a '|' character inside a quoted string does not match
        # - parse action will call token.strip() for each matched token, i.e., the description body
        string_data = SkipTo(SEP, ignore=quoted_string)
        string_data.set_parse_action(token_map(str.strip))
        ticket_expr = (integer("issue_num") + SEP
                      + string_data("sev") + SEP
                      + string_data("desc") + SEP
                      + integer("days_open"))

        for tkt in ticket_expr.search_string(report):
            print tkt.dump()

    prints::

        ['101', 'Critical', 'Intermittent system crash', '6']
        - days_open: '6'
        - desc: 'Intermittent system crash'
        - issue_num: '101'
        - sev: 'Critical'
        ['94', 'Cosmetic', "Spelling error on Login ('log|n')", '14']
        - days_open: '14'
        - desc: "Spelling error on Login ('log|n')"
        - issue_num: '94'
        - sev: 'Cosmetic'
        ['79', 'Minor', 'System slow when running too many reports', '47']
        - days_open: '47'
        - desc: 'System slow when running too many reports'
        - issue_num: '79'
        - sev: 'Minor'
    """

    def __init__(
        self,
        other: Union[ParserElement, str],
        include: bool = False,
        ignore: typing.Optional[Union[ParserElement, str]] = None,
        fail_on: typing.Optional[Union[ParserElement, str]] = None,
        *,
        failOn: typing.Optional[Union[ParserElement, str]] = None,
    ) -> None:
        super().__init__(other)
        failOn = failOn or fail_on
        self.ignoreExpr = ignore
        self._may_return_empty = True
        self.mayIndexError = False
        self.includeMatch = include
        self.saveAsList = False
        if isinstance(failOn, str_type):
            self.failOn = self._literalStringClass(failOn)
        else:
            self.failOn = failOn
        self.errmsg = f"No match found for {self.expr}"
        self.ignorer = Empty().leave_whitespace()
        self._update_ignorer()

    def _update_ignorer(self):
        # rebuild internal ignore expr from current ignore exprs and assigned ignoreExpr
        self.ignorer.ignoreExprs.clear()
        for e in self.expr.ignoreExprs:
            self.ignorer.ignore(e)
        if self.ignoreExpr:
            self.ignorer.ignore(self.ignoreExpr)

    def ignore(self, expr):
        super().ignore(expr)
        self._update_ignorer()

    def parseImpl(self, instring, loc, do_actions=True):
        startloc = loc
        instrlen = len(instring)
        self_expr_parse = self.expr._parse
        self_failOn_canParseNext = (
            self.failOn.canParseNext if self.failOn is not None else None
        )
        ignorer_try_parse = self.ignorer.try_parse if self.ignorer.ignoreExprs else None

        tmploc = loc
        while tmploc <= instrlen:
            if self_failOn_canParseNext is not None:
                # break if failOn expression matches
                if self_failOn_canParseNext(instring, tmploc):
                    break

            if ignorer_try_parse is not None:
                # advance past ignore expressions
                prev_tmploc = tmploc
                while 1:
                    try:
                        tmploc = ignorer_try_parse(instring, tmploc)
                    except ParseBaseException:
                        break
                    # see if all ignorers matched, but didn't actually ignore anything
                    if tmploc == prev_tmploc:
                        break
                    prev_tmploc = tmploc

            try:
                self_expr_parse(instring, tmploc, do_actions=False, callPreParse=False)
            except (ParseException, IndexError):
                # no match, advance loc in string
                tmploc += 1
            else:
                # matched skipto expr, done
                break

        else:
            # ran off the end of the input string without matching skipto expr, fail
            raise ParseException(instring, loc, self.errmsg, self)

        # build up return values
        loc = tmploc
        skiptext = instring[startloc:loc]
        skipresult = ParseResults(skiptext)

        if self.includeMatch:
            loc, mat = self_expr_parse(instring, loc, do_actions, callPreParse=False)
            skipresult += mat

        return loc, skipresult


class Forward(ParseElementEnhance):
    """
    Forward declaration of an expression to be defined later -
    used for recursive grammars, such as algebraic infix notation.
    When the expression is known, it is assigned to the ``Forward``
    variable using the ``'<<'`` operator.

    Note: take care when assigning to ``Forward`` not to overlook
    precedence of operators.

    Specifically, ``'|'`` has a lower precedence than ``'<<'``, so that::

        fwd_expr << a | b | c

    will actually be evaluated as::

        (fwd_expr << a) | b | c

    thereby leaving b and c out as parseable alternatives.  It is recommended that you
    explicitly group the values inserted into the ``Forward``::

        fwd_expr << (a | b | c)

    Converting to use the ``'<<='`` operator instead will avoid this problem.

    See :class:`ParseResults.pprint` for an example of a recursive
    parser created using ``Forward``.
    """

    def __init__(
        self, other: typing.Optional[Union[ParserElement, str]] = None
    ) -> None:
        self.caller_frame = traceback.extract_stack(limit=2)[0]
        super().__init__(other, savelist=False)  # type: ignore[arg-type]
        self.lshift_line = None

    def __lshift__(self, other) -> Forward:
        if hasattr(self, "caller_frame"):
            del self.caller_frame
        if isinstance(other, str_type):
            other = self._literalStringClass(other)

        if not isinstance(other, ParserElement):
            return NotImplemented

        self.expr = other
        self.streamlined = other.streamlined
        self.mayIndexError = self.expr.mayIndexError
        self._may_return_empty = self.expr.mayReturnEmpty
        self.set_whitespace_chars(
            self.expr.whiteChars, copy_defaults=self.expr.copyDefaultWhiteChars
        )
        self.skipWhitespace = self.expr.skipWhitespace
        self.saveAsList = self.expr.saveAsList
        self.ignoreExprs.extend(self.expr.ignoreExprs)
        self.lshift_line = traceback.extract_stack(limit=2)[-2]  # type: ignore[assignment]
        return self

    def __ilshift__(self, other) -> Forward:
        if not isinstance(other, ParserElement):
            return NotImplemented

        return self << other

    def __or__(self, other) -> ParserElement:
        caller_line = traceback.extract_stack(limit=2)[-2]
        if (
            __diag__.warn_on_match_first_with_lshift_operator
            and caller_line == self.lshift_line
            and Diagnostics.warn_on_match_first_with_lshift_operator
            not in self.suppress_warnings_
        ):
            warnings.warn(
                "warn_on_match_first_with_lshift_operator:"
                " using '<<' operator with '|' is probably an error, use '<<='",
                stacklevel=2,
            )
        ret = super().__or__(other)
        return ret

    def __del__(self):
        # see if we are getting dropped because of '=' reassignment of var instead of '<<=' or '<<'
        if (
            self.expr is None
            and __diag__.warn_on_assignment_to_Forward
            and Diagnostics.warn_on_assignment_to_Forward not in self.suppress_warnings_
        ):
            warnings.warn_explicit(
                "warn_on_assignment_to_Forward:"
                " Forward defined here but no expression attached later using '<<=' or '<<'",
                UserWarning,
                filename=self.caller_frame.filename,
                lineno=self.caller_frame.lineno,
            )

    def parseImpl(self, instring, loc, do_actions=True) -> ParseImplReturnType:
        if (
            self.expr is None
            and __diag__.warn_on_parse_using_empty_Forward
            and Diagnostics.warn_on_parse_using_empty_Forward
            not in self.suppress_warnings_
        ):
            # walk stack until parse_string, scan_string, search_string, or transform_string is found
            parse_fns = (
                "parse_string",
                "scan_string",
                "search_string",
                "transform_string",
            )
            tb = traceback.extract_stack(limit=200)
            for i, frm in enumerate(reversed(tb), start=1):
                if frm.name in parse_fns:
                    stacklevel = i + 1
                    break
            else:
                stacklevel = 2
            warnings.warn(
                "warn_on_parse_using_empty_Forward:"
                " Forward expression was never assigned a value, will not parse any input",
                stacklevel=stacklevel,
            )
        if not ParserElement._left_recursion_enabled:
            return super().parseImpl(instring, loc, do_actions)
        # ## Bounded Recursion algorithm ##
        # Recursion only needs to be processed at ``Forward`` elements, since they are
        # the only ones that can actually refer to themselves. The general idea is
        # to handle recursion stepwise: We start at no recursion, then recurse once,
        # recurse twice, ..., until more recursion offers no benefit (we hit the bound).
        #
        # The "trick" here is that each ``Forward`` gets evaluated in two contexts
        # - to *match* a specific recursion level, and
        # - to *search* the bounded recursion level
        # and the two run concurrently. The *search* must *match* each recursion level
        # to find the best possible match. This is handled by a memo table, which
        # provides the previous match to the next level match attempt.
        #
        # See also "Left Recursion in Parsing Expression Grammars", Medeiros et al.
        #
        # There is a complication since we not only *parse* but also *transform* via
        # actions: We do not want to run the actions too often while expanding. Thus,
        # we expand using `do_actions=False` and only run `do_actions=True` if the next
        # recursion level is acceptable.
        with ParserElement.recursion_lock:
            memo = ParserElement.recursion_memos
            try:
                # we are parsing at a specific recursion expansion - use it as-is
                prev_loc, prev_result = memo[loc, self, do_actions]
                if isinstance(prev_result, Exception):
                    raise prev_result
                return prev_loc, prev_result.copy()
            except KeyError:
                act_key = (loc, self, True)
                peek_key = (loc, self, False)
                # we are searching for the best recursion expansion - keep on improving
                # both `do_actions` cases must be tracked separately here!
                prev_loc, prev_peek = memo[peek_key] = (
                    loc - 1,
                    ParseException(
                        instring, loc, "Forward recursion without base case", self
                    ),
                )
                if do_actions:
                    memo[act_key] = memo[peek_key]
                while True:
                    try:
                        new_loc, new_peek = super().parseImpl(instring, loc, False)
                    except ParseException:
                        # we failed before getting any match - do not hide the error
                        if isinstance(prev_peek, Exception):
                            raise
                        new_loc, new_peek = prev_loc, prev_peek
                    # the match did not get better: we are done
                    if new_loc <= prev_loc:
                        if do_actions:
                            # replace the match for do_actions=False as well,
                            # in case the action did backtrack
                            prev_loc, prev_result = memo[peek_key] = memo[act_key]
                            del memo[peek_key], memo[act_key]
                            return prev_loc, copy.copy(prev_result)
                        del memo[peek_key]
                        return prev_loc, copy.copy(prev_peek)
                    # the match did get better: see if we can improve further
                    if do_actions:
                        try:
                            memo[act_key] = super().parseImpl(instring, loc, True)
                        except ParseException as e:
                            memo[peek_key] = memo[act_key] = (new_loc, e)
                            raise
                    prev_loc, prev_peek = memo[peek_key] = new_loc, new_peek

    def leave_whitespace(self, recursive: bool = True) -> ParserElement:
        self.skipWhitespace = False
        return self

    def ignore_whitespace(self, recursive: bool = True) -> ParserElement:
        self.skipWhitespace = True
        return self

    def streamline(self) -> ParserElement:
        if not self.streamlined:
            self.streamlined = True
            if self.expr is not None:
                self.expr.streamline()
        return self

    def validate(self, validateTrace=None) -> None:
        warnings.warn(
            "ParserElement.validate() is deprecated, and should not be used to check for left recursion",
            DeprecationWarning,
            stacklevel=2,
        )
        if validateTrace is None:
            validateTrace = []

        if self not in validateTrace:
            tmp = validateTrace[:] + [self]
            if self.expr is not None:
                self.expr.validate(tmp)
        self._checkRecursion([])

    def _generateDefaultName(self) -> str:
        # Avoid infinite recursion by setting a temporary _defaultName
        save_default_name = self._defaultName
        self._defaultName = ": ..."

        # Use the string representation of main expression.
        try:
            if self.expr is not None:
                ret_string = str(self.expr)[:1000]
            else:
                ret_string = "None"
        except Exception:
            ret_string = "..."

        self._defaultName = save_default_name
        return f"{type(self).__name__}: {ret_string}"

    def copy(self) -> ParserElement:
        if self.expr is not None:
            return super().copy()
        else:
            ret = Forward()
            ret <<= self
            return ret

    def _setResultsName(self, name, list_all_matches=False) -> ParserElement:
        # fmt: off
        if (
            __diag__.warn_name_set_on_empty_Forward
            and Diagnostics.warn_name_set_on_empty_Forward not in self.suppress_warnings_
            and self.expr is None
        ):
            warning = (
                "warn_name_set_on_empty_Forward:"
                f" setting results name {name!r} on {type(self).__name__} expression"
                " that has no contained expression"
            )
            warnings.warn(warning, stacklevel=3)
        # fmt: on

        return super()._setResultsName(name, list_all_matches)

    # Compatibility synonyms
    # fmt: off
    leaveWhitespace = replaced_by_pep8("leaveWhitespace", leave_whitespace)
    ignoreWhitespace = replaced_by_pep8("ignoreWhitespace", ignore_whitespace)
    # fmt: on


class TokenConverter(ParseElementEnhance):
    """
    Abstract subclass of :class:`ParseElementEnhance`, for converting parsed results.
    """

    def __init__(self, expr: Union[ParserElement, str], savelist=False) -> None:
        super().__init__(expr)  # , savelist)
        self.saveAsList = False


class Combine(TokenConverter):
    """Converter to concatenate all matching tokens to a single string.
    By default, the matching patterns must also be contiguous in the
    input string; this can be disabled by specifying
    ``'adjacent=False'`` in the constructor.

    Example::

        real = Word(nums) + '.' + Word(nums)
        print(real.parse_string('3.1416')) # -> ['3', '.', '1416']
        # will also erroneously match the following
        print(real.parse_string('3. 1416')) # -> ['3', '.', '1416']

        real = Combine(Word(nums) + '.' + Word(nums))
        print(real.parse_string('3.1416')) # -> ['3.1416']
        # no match when there are internal spaces
        print(real.parse_string('3. 1416')) # -> Exception: Expected W:(0123...)
    """

    def __init__(
        self,
        expr: ParserElement,
        join_string: str = "",
        adjacent: bool = True,
        *,
        joinString: typing.Optional[str] = None,
    ) -> None:
        super().__init__(expr)
        joinString = joinString if joinString is not None else join_string
        # suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself
        if adjacent:
            self.leave_whitespace()
        self.adjacent = adjacent
        self.skipWhitespace = True
        self.joinString = joinString
        self.callPreparse = True

    def ignore(self, other) -> ParserElement:
        if self.adjacent:
            ParserElement.ignore(self, other)
        else:
            super().ignore(other)
        return self

    def postParse(self, instring, loc, tokenlist):
        retToks = tokenlist.copy()
        del retToks[:]
        retToks += ParseResults(
            ["".join(tokenlist._asStringList(self.joinString))], modal=self.modalResults
        )

        if self.resultsName and retToks.haskeys():
            return [retToks]
        else:
            return retToks


class Group(TokenConverter):
    """Converter to return the matched tokens as a list - useful for
    returning tokens of :class:`ZeroOrMore` and :class:`OneOrMore` expressions.

    The optional ``aslist`` argument when set to True will return the
    parsed tokens as a Python list instead of a pyparsing ParseResults.

    Example::

        ident = Word(alphas)
        num = Word(nums)
        term = ident | num
        func = ident + Opt(DelimitedList(term))
        print(func.parse_string("fn a, b, 100"))
        # -> ['fn', 'a', 'b', '100']

        func = ident + Group(Opt(DelimitedList(term)))
        print(func.parse_string("fn a, b, 100"))
        # -> ['fn', ['a', 'b', '100']]
    """

    def __init__(self, expr: ParserElement, aslist: bool = False) -> None:
        super().__init__(expr)
        self.saveAsList = True
        self._asPythonList = aslist

    def postParse(self, instring, loc, tokenlist):
        if self._asPythonList:
            return ParseResults.List(
                tokenlist.asList()
                if isinstance(tokenlist, ParseResults)
                else list(tokenlist)
            )

        return [tokenlist]


class Dict(TokenConverter):
    """Converter to return a repetitive expression as a list, but also
    as a dictionary. Each element can also be referenced using the first
    token in the expression as its key. Useful for tabular report
    scraping when the first column can be used as a item key.

    The optional ``asdict`` argument when set to True will return the
    parsed tokens as a Python dict instead of a pyparsing ParseResults.

    Example::

        data_word = Word(alphas)
        label = data_word + FollowedBy(':')

        text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))

        # print attributes as plain groups
        print(attr_expr[1, ...].parse_string(text).dump())

        # instead of OneOrMore(expr), parse using Dict(Group(expr)[1, ...]) - Dict will auto-assign names
        result = Dict(Group(attr_expr)[1, ...]).parse_string(text)
        print(result.dump())

        # access named fields as dict entries, or output as dict
        print(result['shape'])
        print(result.as_dict())

    prints::

        ['shape', 'SQUARE', 'posn', 'upper left', 'color', 'light blue', 'texture', 'burlap']
        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
        - color: 'light blue'
        - posn: 'upper left'
        - shape: 'SQUARE'
        - texture: 'burlap'
        SQUARE
        {'color': 'light blue', 'posn': 'upper left', 'texture': 'burlap', 'shape': 'SQUARE'}

    See more examples at :class:`ParseResults` of accessing fields by results name.
    """

    def __init__(self, expr: ParserElement, asdict: bool = False) -> None:
        super().__init__(expr)
        self.saveAsList = True
        self._asPythonDict = asdict

    def postParse(self, instring, loc, tokenlist):
        for i, tok in enumerate(tokenlist):
            if len(tok) == 0:
                continue

            ikey = tok[0]
            if isinstance(ikey, int):
                ikey = str(ikey).strip()

            if len(tok) == 1:
                tokenlist[ikey] = _ParseResultsWithOffset("", i)

            elif len(tok) == 2 and not isinstance(tok[1], ParseResults):
                tokenlist[ikey] = _ParseResultsWithOffset(tok[1], i)

            else:
                try:
                    dictvalue = tok.copy()  # ParseResults(i)
                except Exception:
                    exc = TypeError(
                        "could not extract dict values from parsed results"
                        " - Dict expression must contain Grouped expressions"
                    )
                    raise exc from None

                del dictvalue[0]

                if len(dictvalue) != 1 or (
                    isinstance(dictvalue, ParseResults) and dictvalue.haskeys()
                ):
                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue, i)
                else:
                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue[0], i)

        if self._asPythonDict:
            return [tokenlist.as_dict()] if self.resultsName else tokenlist.as_dict()

        return [tokenlist] if self.resultsName else tokenlist


class Suppress(TokenConverter):
    """Converter for ignoring the results of a parsed expression.

    Example::

        source = "a, b, c,d"
        wd = Word(alphas)
        wd_list1 = wd + (',' + wd)[...]
        print(wd_list1.parse_string(source))

        # often, delimiters that are useful during parsing are just in the
        # way afterward - use Suppress to keep them out of the parsed output
        wd_list2 = wd + (Suppress(',') + wd)[...]
        print(wd_list2.parse_string(source))

        # Skipped text (using '...') can be suppressed as well
        source = "lead in START relevant text END trailing text"
        start_marker = Keyword("START")
        end_marker = Keyword("END")
        find_body = Suppress(...) + start_marker + ... + end_marker
        print(find_body.parse_string(source)

    prints::

        ['a', ',', 'b', ',', 'c', ',', 'd']
        ['a', 'b', 'c', 'd']
        ['START', 'relevant text ', 'END']

    (See also :class:`DelimitedList`.)
    """

    def __init__(self, expr: Union[ParserElement, str], savelist: bool = False) -> None:
        if expr is ...:
            expr = _PendingSkip(NoMatch())
        super().__init__(expr)

    def __add__(self, other) -> ParserElement:
        if isinstance(self.expr, _PendingSkip):
            return Suppress(SkipTo(other)) + other

        return super().__add__(other)

    def __sub__(self, other) -> ParserElement:
        if isinstance(self.expr, _PendingSkip):
            return Suppress(SkipTo(other)) - other

        return super().__sub__(other)

    def postParse(self, instring, loc, tokenlist):
        return []

    def suppress(self) -> ParserElement:
        return self


def trace_parse_action(f: ParseAction) -> ParseAction:
    """Decorator for debugging parse actions.

    When the parse action is called, this decorator will print
    ``">> entering method-name(line:<current_source_line>, <parse_location>, <matched_tokens>)"``.
    When the parse action completes, the decorator will print
    ``"<<"`` followed by the returned value, or any exception that the parse action raised.

    Example::

        wd = Word(alphas)

        @trace_parse_action
        def remove_duplicate_chars(tokens):
            return ''.join(sorted(set(''.join(tokens))))

        wds = wd[1, ...].set_parse_action(remove_duplicate_chars)
        print(wds.parse_string("slkdjs sld sldd sdlf sdljf"))

    prints::

        >>entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {}))
        <<leaving remove_duplicate_chars (ret: 'dfjkls')
        ['dfjkls']
    """
    f = _trim_arity(f)

    def z(*paArgs):
        thisFunc = f.__name__
        s, l, t = paArgs[-3:]
        if len(paArgs) > 3:
            thisFunc = f"{type(paArgs[0]).__name__}.{thisFunc}"
        sys.stderr.write(f">>entering {thisFunc}(line: {line(l, s)!r}, {l}, {t!r})\n")
        try:
            ret = f(*paArgs)
        except Exception as exc:
            sys.stderr.write(
                f"<<leaving {thisFunc} (exception: {type(exc).__name__}: {exc})\n"
            )
            raise
        sys.stderr.write(f"<<leaving {thisFunc} (ret: {ret!r})\n")
        return ret

    z.__name__ = f.__name__
    return z


# convenience constants for positional expressions
empty = Empty().set_name("empty")
line_start = LineStart().set_name("line_start")
line_end = LineEnd().set_name("line_end")
string_start = StringStart().set_name("string_start")
string_end = StringEnd().set_name("string_end")

_escapedPunc = Regex(r"\\[\\[\]\/\-\*\.\$\+\^\?()~ ]").set_parse_action(
    lambda s, l, t: t[0][1]
)
_escapedHexChar = Regex(r"\\0?[xX][0-9a-fA-F]+").set_parse_action(
    lambda s, l, t: chr(int(t[0].lstrip(r"\0x"), 16))
)
_escapedOctChar = Regex(r"\\0[0-7]+").set_parse_action(
    lambda s, l, t: chr(int(t[0][1:], 8))
)
_singleChar = (
    _escapedPunc | _escapedHexChar | _escapedOctChar | CharsNotIn(r"\]", exact=1)
)
_charRange = Group(_singleChar + Suppress("-") + _singleChar)
_reBracketExpr = (
    Literal("[")
    + Opt("^").set_results_name("negate")
    + Group(OneOrMore(_charRange | _singleChar)).set_results_name("body")
    + Literal("]")
)


def srange(s: str) -> str:
    r"""Helper to easily define string ranges for use in :class:`Word`
    construction. Borrows syntax from regexp ``'[]'`` string range
    definitions::

        srange("[0-9]")   -> "0123456789"
        srange("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz"
        srange("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_"

    The input string must be enclosed in []'s, and the returned string
    is the expanded character set joined into a single string. The
    values enclosed in the []'s may be:

    - a single character
    - an escaped character with a leading backslash (such as ``\-``
      or ``\]``)
    - an escaped hex character with a leading ``'\x'``
      (``\x21``, which is a ``'!'`` character) (``\0x##``
      is also supported for backwards compatibility)
    - an escaped octal character with a leading ``'\0'``
      (``\041``, which is a ``'!'`` character)
    - a range of any of the above, separated by a dash (``'a-z'``,
      etc.)
    - any combination of the above (``'aeiouy'``,
      ``'a-zA-Z0-9_$'``, etc.)
    """

    def _expanded(p):
        if isinstance(p, ParseResults):
            yield from (chr(c) for c in range(ord(p[0]), ord(p[1]) + 1))
        else:
            yield p

    try:
        return "".join(
            [c for part in _reBracketExpr.parse_string(s).body for c in _expanded(part)]
        )
    except Exception as e:
        return ""


def token_map(func, *args) -> ParseAction:
    """Helper to define a parse action by mapping a function to all
    elements of a :class:`ParseResults` list. If any additional args are passed,
    they are forwarded to the given function as additional arguments
    after the token, as in
    ``hex_integer = Word(hexnums).set_parse_action(token_map(int, 16))``,
    which will convert the parsed data to an integer using base 16.

    Example (compare the last to example in :class:`ParserElement.transform_string`::

        hex_ints = Word(hexnums)[1, ...].set_parse_action(token_map(int, 16))
        hex_ints.run_tests('''
            00 11 22 aa FF 0a 0d 1a
            ''')

        upperword = Word(alphas).set_parse_action(token_map(str.upper))
        upperword[1, ...].run_tests('''
            my kingdom for a horse
            ''')

        wd = Word(alphas).set_parse_action(token_map(str.title))
        wd[1, ...].set_parse_action(' '.join).run_tests('''
            now is the winter of our discontent made glorious summer by this sun of york
            ''')

    prints::

        00 11 22 aa FF 0a 0d 1a
        [0, 17, 34, 170, 255, 10, 13, 26]

        my kingdom for a horse
        ['MY', 'KINGDOM', 'FOR', 'A', 'HORSE']

        now is the winter of our discontent made glorious summer by this sun of york
        ['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York']
    """

    def pa(s, l, t):
        return [func(tokn, *args) for tokn in t]

    func_name = getattr(func, "__name__", getattr(func, "__class__").__name__)
    pa.__name__ = func_name

    return pa


def autoname_elements() -> None:
    """
    Utility to simplify mass-naming of parser elements, for
    generating railroad diagram with named subdiagrams.
    """

    # guard against _getframe not being implemented in the current Python
    getframe_fn = getattr(sys, "_getframe", lambda _: None)
    calling_frame = getframe_fn(1)
    if calling_frame is None:
        return

    # find all locals in the calling frame that are ParserElements
    calling_frame = typing.cast(types.FrameType, calling_frame)
    for name, var in calling_frame.f_locals.items():
        # if no custom name defined, set the name to the var name
        if isinstance(var, ParserElement) and not var.customName:
            var.set_name(name)


dbl_quoted_string = Combine(
    Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*') + '"'
).set_name("string enclosed in double quotes")

sgl_quoted_string = Combine(
    Regex(r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*") + "'"
).set_name("string enclosed in single quotes")

quoted_string = Combine(
    (Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*') + '"').set_name(
        "double quoted string"
    )
    | (Regex(r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*") + "'").set_name(
        "single quoted string"
    )
).set_name("quoted string using single or double quotes")

python_quoted_string = Combine(
    (Regex(r'"""(?:[^"\\]|""(?!")|"(?!"")|\\.)*', flags=re.MULTILINE) + '"""').set_name(
        "multiline double quoted string"
    )
    ^ (
        Regex(r"'''(?:[^'\\]|''(?!')|'(?!'')|\\.)*", flags=re.MULTILINE) + "'''"
    ).set_name("multiline single quoted string")
    ^ (Regex(r'"(?:[^"\n\r\\]|(?:\\")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*') + '"').set_name(
        "double quoted string"
    )
    ^ (Regex(r"'(?:[^'\n\r\\]|(?:\\')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*") + "'").set_name(
        "single quoted string"
    )
).set_name("Python quoted string")

unicode_string = Combine("u" + quoted_string.copy()).set_name("unicode string literal")


alphas8bit = srange(r"[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]")
punc8bit = srange(r"[\0xa1-\0xbf\0xd7\0xf7]")

# build list of built-in expressions, for future reference if a global default value
# gets updated
_builtin_exprs: list[ParserElement] = [
    v for v in vars().values() if isinstance(v, ParserElement)
]

# Compatibility synonyms
# fmt: off
sglQuotedString = sgl_quoted_string
dblQuotedString = dbl_quoted_string
quotedString = quoted_string
unicodeString = unicode_string
lineStart = line_start
lineEnd = line_end
stringStart = string_start
stringEnd = string_end
nullDebugAction = replaced_by_pep8("nullDebugAction", null_debug_action)
traceParseAction = replaced_by_pep8("traceParseAction", trace_parse_action)
conditionAsParseAction = replaced_by_pep8("conditionAsParseAction", condition_as_parse_action)
tokenMap = replaced_by_pep8("tokenMap", token_map)
# fmt: on


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\diagram\__init__.py
# ================================================================================

# mypy: ignore-errors
from __future__ import annotations

import itertools
import railroad
import pyparsing
import dataclasses
import typing
from typing import (
    Generic,
    TypeVar,
    Callable,
    Iterable,
)
from jinja2 import Template
from io import StringIO
import inspect
import re


jinja2_template_source = """\
{% if not embed %}
<!DOCTYPE html>
<html>
<head>
{% endif %}
    {% if not head %}
        <style>
            .railroad-heading {
                font-family: monospace;
            }
        </style>
    {% else %}
        {{ head | safe }}
    {% endif %}
{% if not embed %}
</head>
<body>
{% endif %}
<meta charset="UTF-8"/>
{{ body | safe }}
{% for diagram in diagrams %}
    <div class="railroad-group">
        <h1 class="railroad-heading" id="{{ diagram.bookmark }}">{{ diagram.title }}</h1>
        <div class="railroad-description">{{ diagram.text }}</div>
        <div class="railroad-svg">
            {{ diagram.svg }}
        </div>
    </div>
{% endfor %}
{% if not embed %}
</body>
</html>
{% endif %}
"""

template = Template(jinja2_template_source)


_bookmark_lookup = {}
_bookmark_ids = itertools.count(start=1)

def _make_bookmark(s: str) -> str:
    """
    Converts a string into a valid HTML bookmark (ID or anchor name).
    """
    if s in _bookmark_lookup:
        return _bookmark_lookup[s]

    # Replace invalid characters with hyphens and ensure only valid characters
    bookmark = re.sub(r'[^a-zA-Z0-9-]+', '-', s)

    # Ensure it starts with a letter by adding 'z' if necessary
    if not bookmark[:1].isalpha():
        bookmark = f"z{bookmark}"

    # Convert to lowercase and strip hyphens
    bookmark = bookmark.lower().strip('-')

    _bookmark_lookup[s] = bookmark = f"{bookmark}-{next(_bookmark_ids):04d}"

    return bookmark


def _collapse_verbose_regex(regex_str: str) -> str:
    if "\n" not in regex_str:
        return regex_str
    collapsed = pyparsing.Regex(r"#.*$").suppress().transform_string(regex_str)
    collapsed = re.sub(r"\s*\n\s*", "", collapsed)
    return collapsed


@dataclasses.dataclass
class NamedDiagram:
    """
    A simple structure for associating a name with a railroad diagram
    """

    name: str
    index: int
    diagram: railroad.DiagramItem = None

    @property
    def bookmark(self):
        bookmark = _make_bookmark(self.name)
        return bookmark


T = TypeVar("T")


class EachItem(railroad.Group):
    """
    Custom railroad item to compose a:
    - Group containing a
      - OneOrMore containing a
        - Choice of the elements in the Each
    with the group label indicating that all must be matched
    """

    all_label = "[ALL]"

    def __init__(self, *items) -> None:
        choice_item = railroad.Choice(len(items) - 1, *items)
        one_or_more_item = railroad.OneOrMore(item=choice_item)
        super().__init__(one_or_more_item, label=self.all_label)


class AnnotatedItem(railroad.Group):
    """
    Simple subclass of Group that creates an annotation label
    """

    def __init__(self, label: str, item) -> None:
        super().__init__(item=item, label=f"[{label}]" if label else "")


class EditablePartial(Generic[T]):
    """
    Acts like a functools.partial, but can be edited. In other words, it represents a type that hasn't yet been
    constructed.
    """

    # We need this here because the railroad constructors actually transform the data, so can't be called until the
    # entire tree is assembled

    def __init__(self, func: Callable[..., T], args: list, kwargs: dict) -> None:
        self.func = func
        self.args = args
        self.kwargs = kwargs

    @classmethod
    def from_call(cls, func: Callable[..., T], *args, **kwargs) -> EditablePartial[T]:
        """
        If you call this function in the same way that you would call the constructor, it will store the arguments
        as you expect. For example EditablePartial.from_call(Fraction, 1, 3)() == Fraction(1, 3)
        """
        return EditablePartial(func=func, args=list(args), kwargs=kwargs)

    @property
    def name(self):
        return self.kwargs["name"]

    def __call__(self) -> T:
        """
        Evaluate the partial and return the result
        """
        args = self.args.copy()
        kwargs = self.kwargs.copy()

        # This is a helpful hack to allow you to specify varargs parameters (e.g. *args) as keyword args (e.g.
        # args=['list', 'of', 'things'])
        arg_spec = inspect.getfullargspec(self.func)
        if arg_spec.varargs in self.kwargs:
            args += kwargs.pop(arg_spec.varargs)

        return self.func(*args, **kwargs)


def railroad_to_html(diagrams: list[NamedDiagram], embed=False, **kwargs) -> str:
    """
    Given a list of NamedDiagram, produce a single HTML string that visualises those diagrams
    :params kwargs: kwargs to be passed in to the template
    """
    data = []
    for diagram in diagrams:
        if diagram.diagram is None:
            continue
        io = StringIO()
        try:
            css = kwargs.get("css")
            diagram.diagram.writeStandalone(io.write, css=css)
        except AttributeError:
            diagram.diagram.writeSvg(io.write)
        title = diagram.name
        if diagram.index == 0:
            title += " (root)"
        data.append(
            {
                "title": title, "text": "", "svg": io.getvalue(), "bookmark": diagram.bookmark
            }
        )

    return template.render(diagrams=data, embed=embed, **kwargs)


def resolve_partial(partial: EditablePartial[T]) -> T:
    """
    Recursively resolves a collection of Partials into whatever type they are
    """
    if isinstance(partial, EditablePartial):
        partial.args = resolve_partial(partial.args)
        partial.kwargs = resolve_partial(partial.kwargs)
        return partial()
    elif isinstance(partial, list):
        return [resolve_partial(x) for x in partial]
    elif isinstance(partial, dict):
        return {key: resolve_partial(x) for key, x in partial.items()}
    else:
        return partial


def to_railroad(
    element: pyparsing.ParserElement,
    diagram_kwargs: typing.Optional[dict] = None,
    vertical: int = 3,
    show_results_names: bool = False,
    show_groups: bool = False,
    show_hidden: bool = False,
) -> list[NamedDiagram]:
    """
    Convert a pyparsing element tree into a list of diagrams. This is the recommended entrypoint to diagram
    creation if you want to access the Railroad tree before it is converted to HTML
    :param element: base element of the parser being diagrammed
    :param diagram_kwargs: kwargs to pass to the Diagram() constructor
    :param vertical: (optional) - int - limit at which number of alternatives should be
       shown vertically instead of horizontally
    :param show_results_names - bool to indicate whether results name annotations should be
       included in the diagram
    :param show_groups - bool to indicate whether groups should be highlighted with an unlabeled
       surrounding box
    :param show_hidden - bool to indicate whether internal elements that are typically hidden
       should be shown
    """
    # Convert the whole tree underneath the root
    lookup = ConverterState(diagram_kwargs=diagram_kwargs or {})
    _to_diagram_element(
        element,
        lookup=lookup,
        parent=None,
        vertical=vertical,
        show_results_names=show_results_names,
        show_groups=show_groups,
        show_hidden=show_hidden,
    )

    root_id = id(element)
    # Convert the root if it hasn't been already
    if root_id in lookup:
        if not element.customName:
            lookup[root_id].name = ""
        lookup[root_id].mark_for_extraction(root_id, lookup, force=True)

    # Now that we're finished, we can convert from intermediate structures into Railroad elements
    diags = list(lookup.diagrams.values())
    if len(diags) > 1:
        # collapse out duplicate diags with the same name
        seen = set()
        deduped_diags = []
        for d in diags:
            # don't extract SkipTo elements, they are uninformative as subdiagrams
            if d.name == "...":
                continue
            if d.name is not None and d.name not in seen:
                seen.add(d.name)
                deduped_diags.append(d)
        resolved = [resolve_partial(partial) for partial in deduped_diags]
    else:
        # special case - if just one diagram, always display it, even if
        # it has no name
        resolved = [resolve_partial(partial) for partial in diags]
    return sorted(resolved, key=lambda diag: diag.index)


def _should_vertical(
    specification: int, exprs: Iterable[pyparsing.ParserElement]
) -> bool:
    """
    Returns true if we should return a vertical list of elements
    """
    if specification is None:
        return False
    else:
        return len(_visible_exprs(exprs)) >= specification


@dataclasses.dataclass
class ElementState:
    """
    State recorded for an individual pyparsing Element
    """

    #: The pyparsing element that this represents
    element: pyparsing.ParserElement
    #: The output Railroad element in an unconverted state
    converted: EditablePartial
    #: The parent Railroad element, which we store so that we can extract this if it's duplicated
    parent: EditablePartial
    #: The order in which we found this element, used for sorting diagrams if this is extracted into a diagram
    number: int
    #: The name of the element
    name: str = None
    #: The index of this inside its parent
    parent_index: typing.Optional[int] = None
    #: If true, we should extract this out into a subdiagram
    extract: bool = False
    #: If true, all of this element's children have been filled out
    complete: bool = False

    def mark_for_extraction(
        self, el_id: int, state: ConverterState, name: str = None, force: bool = False
    ):
        """
        Called when this instance has been seen twice, and thus should eventually be extracted into a sub-diagram
        :param el_id: id of the element
        :param state: element/diagram state tracker
        :param name: name to use for this element's text
        :param force: If true, force extraction now, regardless of the state of this. Only useful for extracting the
        root element when we know we're finished
        """
        self.extract = True

        # Set the name
        if not self.name:
            if name:
                # Allow forcing a custom name
                self.name = name
            elif self.element.customName:
                self.name = self.element.customName
            else:
                self.name = ""

        # Just because this is marked for extraction doesn't mean we can do it yet. We may have to wait for children
        # to be added
        # Also, if this is just a string literal etc, don't bother extracting it
        if force or (self.complete and _worth_extracting(self.element)):
            state.extract_into_diagram(el_id)


class ConverterState:
    """
    Stores some state that persists between recursions into the element tree
    """

    def __init__(self, diagram_kwargs: typing.Optional[dict] = None) -> None:
        #: A dictionary mapping ParserElements to state relating to them
        self._element_diagram_states: dict[int, ElementState] = {}
        #: A dictionary mapping ParserElement IDs to subdiagrams generated from them
        self.diagrams: dict[int, EditablePartial[NamedDiagram]] = {}
        #: The index of the next unnamed element
        self.unnamed_index: int = 1
        #: The index of the next element. This is used for sorting
        self.index: int = 0
        #: Shared kwargs that are used to customize the construction of diagrams
        self.diagram_kwargs: dict = diagram_kwargs or {}
        self.extracted_diagram_names: set[str] = set()

    def __setitem__(self, key: int, value: ElementState):
        self._element_diagram_states[key] = value

    def __getitem__(self, key: int) -> ElementState:
        return self._element_diagram_states[key]

    def __delitem__(self, key: int):
        del self._element_diagram_states[key]

    def __contains__(self, key: int):
        return key in self._element_diagram_states

    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            return default

    def generate_unnamed(self) -> int:
        """
        Generate a number used in the name of an otherwise unnamed diagram
        """
        self.unnamed_index += 1
        return self.unnamed_index

    def generate_index(self) -> int:
        """
        Generate a number used to index a diagram
        """
        self.index += 1
        return self.index

    def extract_into_diagram(self, el_id: int):
        """
        Used when we encounter the same token twice in the same tree. When this
        happens, we replace all instances of that token with a terminal, and
        create a new subdiagram for the token
        """
        position = self[el_id]

        # Replace the original definition of this element with a regular block
        if position.parent:
            href = f"#{_make_bookmark(position.name)}"
            ret = EditablePartial.from_call(railroad.NonTerminal, text=position.name, href=href)
            if "item" in position.parent.kwargs:
                position.parent.kwargs["item"] = ret
            elif "items" in position.parent.kwargs:
                position.parent.kwargs["items"][position.parent_index] = ret

        # If the element we're extracting is a group, skip to its content but keep the title
        if position.converted.func == railroad.Group:
            content = position.converted.kwargs["item"]
        else:
            content = position.converted

        self.diagrams[el_id] = EditablePartial.from_call(
            NamedDiagram,
            name=position.name,
            diagram=EditablePartial.from_call(
                railroad.Diagram, content, **self.diagram_kwargs
            ),
            index=position.number,
        )

        del self[el_id]


def _worth_extracting(element: pyparsing.ParserElement) -> bool:
    """
    Returns true if this element is worth having its own sub-diagram. Simply, if any of its children
    themselves have children, then its complex enough to extract
    """
    children = element.recurse()
    return any(child.recurse() for child in children)


def _apply_diagram_item_enhancements(fn):
    """
    decorator to ensure enhancements to a diagram item (such as results name annotations)
    get applied on return from _to_diagram_element (we do this since there are several
    returns in _to_diagram_element)
    """

    def _inner(
        element: pyparsing.ParserElement,
        parent: typing.Optional[EditablePartial],
        lookup: ConverterState = None,
        vertical: int = None,
        index: int = 0,
        name_hint: str = None,
        show_results_names: bool = False,
        show_groups: bool = False,
        show_hidden: bool = False,
    ) -> typing.Optional[EditablePartial]:
        ret = fn(
            element,
            parent,
            lookup,
            vertical,
            index,
            name_hint,
            show_results_names,
            show_groups,
            show_hidden,
        )

        # apply annotation for results name, if present
        if show_results_names and ret is not None:
            element_results_name = element.resultsName
            if element_results_name:
                # add "*" to indicate if this is a "list all results" name
                modal_tag = "" if element.modalResults else "*"
                ret = EditablePartial.from_call(
                    railroad.Group,
                    item=ret,
                    label=f"{repr(element_results_name)}{modal_tag}",
                )

        return ret

    return _inner


def _visible_exprs(exprs: Iterable[pyparsing.ParserElement]):
    non_diagramming_exprs = (
        pyparsing.ParseElementEnhance,
        pyparsing.PositionToken,
        pyparsing.And._ErrorStop,
    )
    return [
        e
        for e in exprs
        if not isinstance(e, non_diagramming_exprs)
    ]


@_apply_diagram_item_enhancements
def _to_diagram_element(
    element: pyparsing.ParserElement,
    parent: typing.Optional[EditablePartial],
    lookup: ConverterState = None,
    vertical: int = None,
    index: int = 0,
    name_hint: str = None,
    show_results_names: bool = False,
    show_groups: bool = False,
    show_hidden: bool = False,
) -> typing.Optional[EditablePartial]:
    """
    Recursively converts a PyParsing Element to a railroad Element
    :param lookup: The shared converter state that keeps track of useful things
    :param index: The index of this element within the parent
    :param parent: The parent of this element in the output tree
    :param vertical: Controls at what point we make a list of elements vertical. If this is an integer (the default),
    it sets the threshold of the number of items before we go vertical. If True, always go vertical, if False, never
    do so
    :param name_hint: If provided, this will override the generated name
    :param show_results_names: bool flag indicating whether to add annotations for results names
    :param show_groups: bool flag indicating whether to show groups using bounding box
    :param show_hidden: bool flag indicating whether to show elements that are typically hidden
    :returns: The converted version of the input element, but as a Partial that hasn't yet been constructed
    """
    exprs = element.recurse()
    name = name_hint or element.customName or type(element).__name__

    # Python's id() is used to provide a unique identifier for elements
    el_id = id(element)

    element_results_name = element.resultsName

    # Here we basically bypass processing certain wrapper elements if they contribute nothing to the diagram
    if not element.customName:
        if isinstance(
            element,
            (
                # pyparsing.TokenConverter,
                pyparsing.Forward,
                pyparsing.Located,
            ),
        ):
            # However, if this element has a useful custom name, and its child does not, we can pass it on to the child
            if exprs:
                if not exprs[0].customName:
                    propagated_name = name
                else:
                    propagated_name = None

                return _to_diagram_element(
                    element.expr,
                    parent=parent,
                    lookup=lookup,
                    vertical=vertical,
                    index=index,
                    name_hint=propagated_name,
                    show_results_names=show_results_names,
                    show_groups=show_groups,
                    show_hidden=show_hidden,
                )

    # If the element isn't worth extracting, we always treat it as the first time we say it
    if _worth_extracting(element):
        looked_up = lookup.get(el_id)
        if looked_up and looked_up.name is not None:
            # If we've seen this element exactly once before, we are only just now finding out that it's a duplicate,
            # so we have to extract it into a new diagram.
            looked_up.mark_for_extraction(el_id, lookup, name=name_hint)
            href = f"#{_make_bookmark(looked_up.name)}"
            ret = EditablePartial.from_call(railroad.NonTerminal, text=looked_up.name, href=href)
            return ret

        elif el_id in lookup.diagrams:
            # If we have seen the element at least twice before, and have already extracted it into a subdiagram, we
            # just put in a marker element that refers to the sub-diagram
            text = lookup.diagrams[el_id].kwargs["name"]
            ret = EditablePartial.from_call(
                railroad.NonTerminal, text=text, href=f"#{_make_bookmark(text)}"
            )
            return ret

    # Recursively convert child elements
    # Here we find the most relevant Railroad element for matching pyparsing Element
    # We use ``items=[]`` here to hold the place for where the child elements will go once created

    # see if this element is normally hidden, and whether hidden elements are desired
    # if not, just return None
    if not element.show_in_diagram and not show_hidden:
        return None

    if isinstance(element, pyparsing.And):
        # detect And's created with ``expr*N`` notation - for these use a OneOrMore with a repeat
        # (all will have the same name, and resultsName)
        if not exprs:
            return None
        if len(set((e.name, e.resultsName) for e in exprs)) == 1 and len(exprs) > 2:
            ret = EditablePartial.from_call(
                railroad.OneOrMore, item="", repeat=str(len(exprs))
            )
        elif _should_vertical(vertical, exprs):
            ret = EditablePartial.from_call(railroad.Stack, items=[])
        else:
            ret = EditablePartial.from_call(railroad.Sequence, items=[])
    elif isinstance(element, (pyparsing.Or, pyparsing.MatchFirst)):
        if not exprs:
            return None
        if _should_vertical(vertical, exprs):
            ret = EditablePartial.from_call(railroad.Choice, 0, items=[])
        else:
            ret = EditablePartial.from_call(railroad.HorizontalChoice, items=[])
    elif isinstance(element, pyparsing.Each):
        if not exprs:
            return None
        ret = EditablePartial.from_call(EachItem, items=[])
    elif isinstance(element, pyparsing.NotAny):
        ret = EditablePartial.from_call(AnnotatedItem, label="NOT", item="")
    elif isinstance(element, pyparsing.FollowedBy):
        ret = EditablePartial.from_call(AnnotatedItem, label="LOOKAHEAD", item="")
    elif isinstance(element, pyparsing.PrecededBy):
        ret = EditablePartial.from_call(AnnotatedItem, label="LOOKBEHIND", item="")
    elif isinstance(element, pyparsing.Group):
        if show_groups:
            ret = EditablePartial.from_call(AnnotatedItem, label="", item="")
        else:
            ret = EditablePartial.from_call(
                railroad.Group, item=None, label=element_results_name
            )
    elif isinstance(element, pyparsing.TokenConverter):
        label = type(element).__name__.lower()
        if label == "tokenconverter":
            ret = EditablePartial.from_call(railroad.Sequence, items=[])
        else:
            ret = EditablePartial.from_call(AnnotatedItem, label=label, item="")
    elif isinstance(element, pyparsing.Opt):
        ret = EditablePartial.from_call(railroad.Optional, item="")
    elif isinstance(element, pyparsing.OneOrMore):
        if element.not_ender is not None:
            args = [
                parent,
                lookup,
                vertical,
                index,
                name_hint,
                show_results_names,
                show_groups,
                show_hidden,
            ]
            return _to_diagram_element(
                (~element.not_ender.expr + element.expr)[1, ...].set_name(element.name),
                *args,
            )
        ret = EditablePartial.from_call(railroad.OneOrMore, item=None)
    elif isinstance(element, pyparsing.ZeroOrMore):
        if element.not_ender is not None:
            args = [
                parent,
                lookup,
                vertical,
                index,
                name_hint,
                show_results_names,
                show_groups,
                show_hidden,
            ]
            return _to_diagram_element(
                (~element.not_ender.expr + element.expr)[...].set_name(element.name),
                *args,
            )
        ret = EditablePartial.from_call(railroad.ZeroOrMore, item="")
    elif isinstance(element, pyparsing.Empty) and not element.customName:
        # Skip unnamed "Empty" elements
        ret = None
    elif isinstance(element, pyparsing.ParseElementEnhance):
        ret = EditablePartial.from_call(railroad.Sequence, items=[])
    elif len(exprs) > 0 and not element_results_name:
        ret = EditablePartial.from_call(railroad.Group, item="", label=name)
    elif isinstance(element, pyparsing.Regex):
        collapsed_patt = _collapse_verbose_regex(element.pattern)
        ret = EditablePartial.from_call(railroad.Terminal, collapsed_patt)
    elif len(exprs) > 0:
        ret = EditablePartial.from_call(railroad.Sequence, items=[])
    else:
        terminal = EditablePartial.from_call(railroad.Terminal, element.defaultName)
        ret = terminal

    if ret is None:
        return

    # Indicate this element's position in the tree so we can extract it if necessary
    lookup[el_id] = ElementState(
        element=element,
        converted=ret,
        parent=parent,
        parent_index=index,
        number=lookup.generate_index(),
    )
    if element.customName:
        lookup[el_id].mark_for_extraction(el_id, lookup, element.customName)

    i = 0
    for expr in exprs:
        # Add a placeholder index in case we have to extract the child before we even add it to the parent
        if "items" in ret.kwargs:
            ret.kwargs["items"].insert(i, None)

        item = _to_diagram_element(
            expr,
            parent=ret,
            lookup=lookup,
            vertical=vertical,
            index=i,
            show_results_names=show_results_names,
            show_groups=show_groups,
            show_hidden=show_hidden,
        )

        # Some elements don't need to be shown in the diagram
        if item is not None:
            if "item" in ret.kwargs:
                ret.kwargs["item"] = item
            elif "items" in ret.kwargs:
                # If we've already extracted the child, don't touch this index, since it's occupied by a nonterminal
                ret.kwargs["items"][i] = item
                i += 1
        elif "items" in ret.kwargs:
            # If we're supposed to skip this element, remove it from the parent
            del ret.kwargs["items"][i]

    # If all this items children are none, skip this item
    if ret and (
        ("items" in ret.kwargs and len(ret.kwargs["items"]) == 0)
        or ("item" in ret.kwargs and ret.kwargs["item"] is None)
    ):
        ret = EditablePartial.from_call(railroad.Terminal, name)

    # Mark this element as "complete", ie it has all of its children
    if el_id in lookup:
        lookup[el_id].complete = True

    if el_id in lookup and lookup[el_id].extract and lookup[el_id].complete:
        lookup.extract_into_diagram(el_id)
        if ret is not None:
            text = lookup.diagrams[el_id].kwargs["name"]
            href = f"#{_make_bookmark(text)}"
            ret = EditablePartial.from_call(
                railroad.NonTerminal, text=text, href=href
            )

    return ret


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\exceptions.py
# ================================================================================

# exceptions.py
from __future__ import annotations

import copy
import re
import sys
import typing
from functools import cached_property

from .unicode import pyparsing_unicode as ppu
from .util import (
    _collapse_string_to_ranges,
    col,
    line,
    lineno,
    replaced_by_pep8,
)


class _ExceptionWordUnicodeSet(
    ppu.Latin1, ppu.LatinA, ppu.LatinB, ppu.Greek, ppu.Cyrillic
):
    pass


_extract_alphanums = _collapse_string_to_ranges(_ExceptionWordUnicodeSet.alphanums)
_exception_word_extractor = re.compile("([" + _extract_alphanums + "]{1,16})|.")


class ParseBaseException(Exception):
    """base exception class for all parsing runtime exceptions"""

    loc: int
    msg: str
    pstr: str
    parser_element: typing.Any  # "ParserElement"
    args: tuple[str, int, typing.Optional[str]]

    __slots__ = (
        "loc",
        "msg",
        "pstr",
        "parser_element",
        "args",
    )

    # Performance tuning: we construct a *lot* of these, so keep this
    # constructor as small and fast as possible
    def __init__(
        self,
        pstr: str,
        loc: int = 0,
        msg: typing.Optional[str] = None,
        elem=None,
    ) -> None:
        if msg is None:
            msg, pstr = pstr, ""

        self.loc = loc
        self.msg = msg
        self.pstr = pstr
        self.parser_element = elem
        self.args = (pstr, loc, msg)

    @staticmethod
    def explain_exception(exc: Exception, depth: int = 16) -> str:
        """
        Method to take an exception and translate the Python internal traceback into a list
        of the pyparsing expressions that caused the exception to be raised.

        Parameters:

        - exc - exception raised during parsing (need not be a ParseException, in support
          of Python exceptions that might be raised in a parse action)
        - depth (default=16) - number of levels back in the stack trace to list expression
          and function names; if None, the full stack trace names will be listed; if 0, only
          the failing input line, marker, and exception string will be shown

        Returns a multi-line string listing the ParserElements and/or function names in the
        exception's stack trace.
        """
        import inspect
        from .core import ParserElement

        if depth is None:
            depth = sys.getrecursionlimit()
        ret: list[str] = []
        if isinstance(exc, ParseBaseException):
            ret.append(exc.line)
            ret.append(f"{'^':>{exc.column}}")
        ret.append(f"{type(exc).__name__}: {exc}")

        if depth <= 0 or exc.__traceback__ is None:
            return "\n".join(ret)

        callers = inspect.getinnerframes(exc.__traceback__, context=depth)
        seen: set[int] = set()
        for ff in callers[-depth:]:
            frm = ff[0]

            f_self = frm.f_locals.get("self", None)
            if isinstance(f_self, ParserElement):
                if not frm.f_code.co_name.startswith(("parseImpl", "_parseNoCache")):
                    continue
                if id(f_self) in seen:
                    continue
                seen.add(id(f_self))

                self_type = type(f_self)
                ret.append(f"{self_type.__module__}.{self_type.__name__} - {f_self}")

            elif f_self is not None:
                self_type = type(f_self)
                ret.append(f"{self_type.__module__}.{self_type.__name__}")

            else:
                code = frm.f_code
                if code.co_name in ("wrapper", "<module>"):
                    continue

                ret.append(code.co_name)

            depth -= 1
            if not depth:
                break

        return "\n".join(ret)

    @classmethod
    def _from_exception(cls, pe) -> ParseBaseException:
        """
        internal factory method to simplify creating one type of ParseException
        from another - avoids having __init__ signature conflicts among subclasses
        """
        return cls(pe.pstr, pe.loc, pe.msg, pe.parser_element)

    @cached_property
    def line(self) -> str:
        """
        Return the line of text where the exception occurred.
        """
        return line(self.loc, self.pstr)

    @cached_property
    def lineno(self) -> int:
        """
        Return the 1-based line number of text where the exception occurred.
        """
        return lineno(self.loc, self.pstr)

    @cached_property
    def col(self) -> int:
        """
        Return the 1-based column on the line of text where the exception occurred.
        """
        return col(self.loc, self.pstr)

    @cached_property
    def column(self) -> int:
        """
        Return the 1-based column on the line of text where the exception occurred.
        """
        return col(self.loc, self.pstr)

    @cached_property
    def found(self) -> str:
        if not self.pstr:
            return ""

        if self.loc >= len(self.pstr):
            return "end of text"

        # pull out next word at error location
        found_match = _exception_word_extractor.match(self.pstr, self.loc)
        if found_match is not None:
            found_text = found_match.group(0)
        else:
            found_text = self.pstr[self.loc : self.loc + 1]

        return repr(found_text).replace(r"\\", "\\")

    # pre-PEP8 compatibility
    @property
    def parserElement(self):
        return self.parser_element

    @parserElement.setter
    def parserElement(self, elem):
        self.parser_element = elem

    def copy(self):
        return copy.copy(self)

    def formatted_message(self) -> str:
        found_phrase = f", found {self.found}" if self.found else ""
        return f"{self.msg}{found_phrase}  (at char {self.loc}), (line:{self.lineno}, col:{self.column})"

    def __str__(self) -> str:
        return self.formatted_message()

    def __repr__(self):
        return str(self)

    def mark_input_line(
        self, marker_string: typing.Optional[str] = None, *, markerString: str = ">!<"
    ) -> str:
        """
        Extracts the exception line from the input string, and marks
        the location of the exception with a special symbol.
        """
        markerString = marker_string if marker_string is not None else markerString
        line_str = self.line
        line_column = self.column - 1
        if markerString:
            line_str = f"{line_str[:line_column]}{markerString}{line_str[line_column:]}"
        return line_str.strip()

    def explain(self, depth: int = 16) -> str:
        """
        Method to translate the Python internal traceback into a list
        of the pyparsing expressions that caused the exception to be raised.

        Parameters:

        - depth (default=16) - number of levels back in the stack trace to list expression
          and function names; if None, the full stack trace names will be listed; if 0, only
          the failing input line, marker, and exception string will be shown

        Returns a multi-line string listing the ParserElements and/or function names in the
        exception's stack trace.

        Example::

            # an expression to parse 3 integers
            expr = pp.Word(pp.nums) * 3
            try:
                # a failing parse - the third integer is prefixed with "A"
                expr.parse_string("123 456 A789")
            except pp.ParseException as pe:
                print(pe.explain(depth=0))

        prints::

            123 456 A789
                    ^
            ParseException: Expected W:(0-9), found 'A'  (at char 8), (line:1, col:9)

        Note: the diagnostic output will include string representations of the expressions
        that failed to parse. These representations will be more helpful if you use `set_name` to
        give identifiable names to your expressions. Otherwise they will use the default string
        forms, which may be cryptic to read.

        Note: pyparsing's default truncation of exception tracebacks may also truncate the
        stack of expressions that are displayed in the ``explain`` output. To get the full listing
        of parser expressions, you may have to set ``ParserElement.verbose_stacktrace = True``
        """
        return self.explain_exception(self, depth)

    # Compatibility synonyms
    # fmt: off
    markInputline = replaced_by_pep8("markInputline", mark_input_line)
    # fmt: on


class ParseException(ParseBaseException):
    """
    Exception thrown when a parse expression doesn't match the input string

    Example::

        integer = Word(nums).set_name("integer")
        try:
            integer.parse_string("ABC")
        except ParseException as pe:
            print(pe, f"column: {pe.column}")

    prints::

       Expected integer, found 'ABC'  (at char 0), (line:1, col:1) column: 1

    """


class ParseFatalException(ParseBaseException):
    """
    User-throwable exception thrown when inconsistent parse content
    is found; stops all parsing immediately
    """


class ParseSyntaxException(ParseFatalException):
    """
    Just like :class:`ParseFatalException`, but thrown internally
    when an :class:`ErrorStop<And._ErrorStop>` ('-' operator) indicates
    that parsing is to stop immediately because an unbacktrackable
    syntax error has been found.
    """


class RecursiveGrammarException(Exception):
    """
    Exception thrown by :class:`ParserElement.validate` if the
    grammar could be left-recursive; parser may need to enable
    left recursion using :class:`ParserElement.enable_left_recursion<ParserElement.enable_left_recursion>`

    Deprecated: only used by deprecated method ParserElement.validate.
    """

    def __init__(self, parseElementList) -> None:
        self.parseElementTrace = parseElementList

    def __str__(self) -> str:
        return f"RecursiveGrammarException: {self.parseElementTrace}"


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\helpers.py
# ================================================================================

# helpers.py
import html.entities
import operator
import re
import sys
import typing

from . import __diag__
from .core import *
from .util import (
    _bslash,
    _flatten,
    _escape_regex_range_chars,
    make_compressed_re,
    replaced_by_pep8,
)


#
# global helpers
#
def counted_array(
    expr: ParserElement,
    int_expr: typing.Optional[ParserElement] = None,
    *,
    intExpr: typing.Optional[ParserElement] = None,
) -> ParserElement:
    """Helper to define a counted list of expressions.

    This helper defines a pattern of the form::

        integer expr expr expr...

    where the leading integer tells how many expr expressions follow.
    The matched tokens returns the array of expr tokens as a list - the
    leading count token is suppressed.

    If ``int_expr`` is specified, it should be a pyparsing expression
    that produces an integer value.

    Example::

        counted_array(Word(alphas)).parse_string('2 ab cd ef')  # -> ['ab', 'cd']

        # in this parser, the leading integer value is given in binary,
        # '10' indicating that 2 values are in the array
        binary_constant = Word('01').set_parse_action(lambda t: int(t[0], 2))
        counted_array(Word(alphas), int_expr=binary_constant).parse_string('10 ab cd ef')  # -> ['ab', 'cd']

        # if other fields must be parsed after the count but before the
        # list items, give the fields results names and they will
        # be preserved in the returned ParseResults:
        count_with_metadata = integer + Word(alphas)("type")
        typed_array = counted_array(Word(alphanums), int_expr=count_with_metadata)("items")
        result = typed_array.parse_string("3 bool True True False")
        print(result.dump())

        # prints
        # ['True', 'True', 'False']
        # - items: ['True', 'True', 'False']
        # - type: 'bool'
    """
    intExpr = intExpr or int_expr
    array_expr = Forward()

    def count_field_parse_action(s, l, t):
        nonlocal array_expr
        n = t[0]
        array_expr <<= (expr * n) if n else Empty()
        # clear list contents, but keep any named results
        del t[:]

    if intExpr is None:
        intExpr = Word(nums).set_parse_action(lambda t: int(t[0]))
    else:
        intExpr = intExpr.copy()
    intExpr.set_name("arrayLen")
    intExpr.add_parse_action(count_field_parse_action, call_during_try=True)
    return (intExpr + array_expr).set_name(f"(len) {expr}...")


def match_previous_literal(expr: ParserElement) -> ParserElement:
    """Helper to define an expression that is indirectly defined from
    the tokens matched in a previous expression, that is, it looks for
    a 'repeat' of a previous expression.  For example::

        first = Word(nums)
        second = match_previous_literal(first)
        match_expr = first + ":" + second

    will match ``"1:1"``, but not ``"1:2"``.  Because this
    matches a previous literal, will also match the leading
    ``"1:1"`` in ``"1:10"``. If this is not desired, use
    :class:`match_previous_expr`. Do *not* use with packrat parsing
    enabled.
    """
    rep = Forward()

    def copy_token_to_repeater(s, l, t):
        if not t:
            rep << Empty()
            return

        if len(t) == 1:
            rep << t[0]
            return

        # flatten t tokens
        tflat = _flatten(t.as_list())
        rep << And(Literal(tt) for tt in tflat)

    expr.add_parse_action(copy_token_to_repeater, callDuringTry=True)
    rep.set_name("(prev) " + str(expr))
    return rep


def match_previous_expr(expr: ParserElement) -> ParserElement:
    """Helper to define an expression that is indirectly defined from
    the tokens matched in a previous expression, that is, it looks for
    a 'repeat' of a previous expression.  For example::

        first = Word(nums)
        second = match_previous_expr(first)
        match_expr = first + ":" + second

    will match ``"1:1"``, but not ``"1:2"``.  Because this
    matches by expressions, will *not* match the leading ``"1:1"``
    in ``"1:10"``; the expressions are evaluated first, and then
    compared, so ``"1"`` is compared with ``"10"``. Do *not* use
    with packrat parsing enabled.
    """
    rep = Forward()
    e2 = expr.copy()
    rep <<= e2

    def copy_token_to_repeater(s, l, t):
        matchTokens = _flatten(t.as_list())

        def must_match_these_tokens(s, l, t):
            theseTokens = _flatten(t.as_list())
            if theseTokens != matchTokens:
                raise ParseException(
                    s, l, f"Expected {matchTokens}, found{theseTokens}"
                )

        rep.set_parse_action(must_match_these_tokens, callDuringTry=True)

    expr.add_parse_action(copy_token_to_repeater, callDuringTry=True)
    rep.set_name("(prev) " + str(expr))
    return rep


def one_of(
    strs: Union[typing.Iterable[str], str],
    caseless: bool = False,
    use_regex: bool = True,
    as_keyword: bool = False,
    *,
    useRegex: bool = True,
    asKeyword: bool = False,
) -> ParserElement:
    """Helper to quickly define a set of alternative :class:`Literal` s,
    and makes sure to do longest-first testing when there is a conflict,
    regardless of the input order, but returns
    a :class:`MatchFirst` for best performance.

    Parameters:

    - ``strs`` - a string of space-delimited literals, or a collection of
      string literals
    - ``caseless`` - treat all literals as caseless - (default= ``False``)
    - ``use_regex`` - as an optimization, will
      generate a :class:`Regex` object; otherwise, will generate
      a :class:`MatchFirst` object (if ``caseless=True`` or ``as_keyword=True``, or if
      creating a :class:`Regex` raises an exception) - (default= ``True``)
    - ``as_keyword`` - enforce :class:`Keyword`-style matching on the
      generated expressions - (default= ``False``)
    - ``asKeyword`` and ``useRegex`` are retained for pre-PEP8 compatibility,
      but will be removed in a future release

    Example::

        comp_oper = one_of("< = > <= >= !=")
        var = Word(alphas)
        number = Word(nums)
        term = var | number
        comparison_expr = term + comp_oper + term
        print(comparison_expr.search_string("B = 12  AA=23 B<=AA AA>12"))

    prints::

        [['B', '=', '12'], ['AA', '=', '23'], ['B', '<=', 'AA'], ['AA', '>', '12']]
    """
    asKeyword = asKeyword or as_keyword
    useRegex = useRegex and use_regex

    if (
        isinstance(caseless, str_type)
        and __diag__.warn_on_multiple_string_args_to_oneof
    ):
        warnings.warn(
            "warn_on_multiple_string_args_to_oneof:"
            " More than one string argument passed to one_of, pass"
            " choices as a list or space-delimited string",
            stacklevel=2,
        )

    if caseless:
        is_equal = lambda a, b: a.upper() == b.upper()
        masks = lambda a, b: b.upper().startswith(a.upper())
    else:
        is_equal = operator.eq
        masks = lambda a, b: b.startswith(a)

    symbols: list[str]
    if isinstance(strs, str_type):
        strs = typing.cast(str, strs)
        symbols = strs.split()
    elif isinstance(strs, Iterable):
        symbols = list(strs)
    else:
        raise TypeError("Invalid argument to one_of, expected string or iterable")
    if not symbols:
        return NoMatch()

    # reorder given symbols to take care to avoid masking longer choices with shorter ones
    # (but only if the given symbols are not just single characters)
    i = 0
    while i < len(symbols) - 1:
        cur = symbols[i]
        for j, other in enumerate(symbols[i + 1 :]):
            if is_equal(other, cur):
                del symbols[i + j + 1]
                break
            if len(other) > len(cur) and masks(cur, other):
                del symbols[i + j + 1]
                symbols.insert(i, other)
                break
        else:
            i += 1

    if useRegex:
        re_flags: int = re.IGNORECASE if caseless else 0

        try:
            if all(len(sym) == 1 for sym in symbols):
                # symbols are just single characters, create range regex pattern
                patt = f"[{''.join(_escape_regex_range_chars(sym) for sym in symbols)}]"
            else:
                patt = "|".join(re.escape(sym) for sym in symbols)

            # wrap with \b word break markers if defining as keywords
            if asKeyword:
                patt = rf"\b(?:{patt})\b"

            ret = Regex(patt, flags=re_flags)
            ret.set_name(" | ".join(re.escape(s) for s in symbols))

            if caseless:
                # add parse action to return symbols as specified, not in random
                # casing as found in input string
                symbol_map = {sym.lower(): sym for sym in symbols}
                ret.add_parse_action(lambda s, l, t: symbol_map[t[0].lower()])

            return ret

        except re.error:
            warnings.warn(
                "Exception creating Regex for one_of, building MatchFirst", stacklevel=2
            )

    # last resort, just use MatchFirst of Token class corresponding to caseless
    # and asKeyword settings
    CASELESS = KEYWORD = True
    parse_element_class = {
        (CASELESS, KEYWORD): CaselessKeyword,
        (CASELESS, not KEYWORD): CaselessLiteral,
        (not CASELESS, KEYWORD): Keyword,
        (not CASELESS, not KEYWORD): Literal,
    }[(caseless, asKeyword)]
    return MatchFirst(parse_element_class(sym) for sym in symbols).set_name(
        " | ".join(symbols)
    )


def dict_of(key: ParserElement, value: ParserElement) -> Dict:
    """Helper to easily and clearly define a dictionary by specifying
    the respective patterns for the key and value.  Takes care of
    defining the :class:`Dict`, :class:`ZeroOrMore`, and
    :class:`Group` tokens in the proper order.  The key pattern
    can include delimiting markers or punctuation, as long as they are
    suppressed, thereby leaving the significant key text.  The value
    pattern can include named results, so that the :class:`Dict` results
    can include named token fields.

    Example::

        text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))
        print(attr_expr[1, ...].parse_string(text).dump())

        attr_label = label
        attr_value = Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join)

        # similar to Dict, but simpler call format
        result = dict_of(attr_label, attr_value).parse_string(text)
        print(result.dump())
        print(result['shape'])
        print(result.shape)  # object attribute access works too
        print(result.as_dict())

    prints::

        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
        - color: 'light blue'
        - posn: 'upper left'
        - shape: 'SQUARE'
        - texture: 'burlap'
        SQUARE
        SQUARE
        {'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'}
    """
    return Dict(OneOrMore(Group(key + value)))


def original_text_for(
    expr: ParserElement, as_string: bool = True, *, asString: bool = True
) -> ParserElement:
    """Helper to return the original, untokenized text for a given
    expression.  Useful to restore the parsed fields of an HTML start
    tag into the raw tag text itself, or to revert separate tokens with
    intervening whitespace back to the original matching input text. By
    default, returns a string containing the original parsed text.

    If the optional ``as_string`` argument is passed as
    ``False``, then the return value is
    a :class:`ParseResults` containing any results names that
    were originally matched, and a single token containing the original
    matched text from the input string.  So if the expression passed to
    :class:`original_text_for` contains expressions with defined
    results names, you must set ``as_string`` to ``False`` if you
    want to preserve those results name values.

    The ``asString`` pre-PEP8 argument is retained for compatibility,
    but will be removed in a future release.

    Example::

        src = "this is test <b> bold <i>text</i> </b> normal text "
        for tag in ("b", "i"):
            opener, closer = make_html_tags(tag)
            patt = original_text_for(opener + ... + closer)
            print(patt.search_string(src)[0])

    prints::

        ['<b> bold <i>text</i> </b>']
        ['<i>text</i>']
    """
    asString = asString and as_string

    locMarker = Empty().set_parse_action(lambda s, loc, t: loc)
    endlocMarker = locMarker.copy()
    endlocMarker.callPreparse = False
    matchExpr = locMarker("_original_start") + expr + endlocMarker("_original_end")
    if asString:
        extractText = lambda s, l, t: s[t._original_start : t._original_end]
    else:

        def extractText(s, l, t):
            t[:] = [s[t.pop("_original_start") : t.pop("_original_end")]]

    matchExpr.set_parse_action(extractText)
    matchExpr.ignoreExprs = expr.ignoreExprs
    matchExpr.suppress_warning(Diagnostics.warn_ungrouped_named_tokens_in_collection)
    return matchExpr


def ungroup(expr: ParserElement) -> ParserElement:
    """Helper to undo pyparsing's default grouping of And expressions,
    even if all but one are non-empty.
    """
    return TokenConverter(expr).add_parse_action(lambda t: t[0])


def locatedExpr(expr: ParserElement) -> ParserElement:
    """
    (DEPRECATED - future code should use the :class:`Located` class)
    Helper to decorate a returned token with its starting and ending
    locations in the input string.

    This helper adds the following results names:

    - ``locn_start`` - location where matched expression begins
    - ``locn_end`` - location where matched expression ends
    - ``value`` - the actual parsed results

    Be careful if the input text contains ``<TAB>`` characters, you
    may want to call :class:`ParserElement.parse_with_tabs`

    Example::

        wd = Word(alphas)
        for match in locatedExpr(wd).search_string("ljsdf123lksdjjf123lkkjj1222"):
            print(match)

    prints::

        [[0, 'ljsdf', 5]]
        [[8, 'lksdjjf', 15]]
        [[18, 'lkkjj', 23]]
    """
    locator = Empty().set_parse_action(lambda ss, ll, tt: ll)
    return Group(
        locator("locn_start")
        + expr("value")
        + locator.copy().leaveWhitespace()("locn_end")
    )


# define special default value to permit None as a significant value for
# ignore_expr
_NO_IGNORE_EXPR_GIVEN = NoMatch()


def nested_expr(
    opener: Union[str, ParserElement] = "(",
    closer: Union[str, ParserElement] = ")",
    content: typing.Optional[ParserElement] = None,
    ignore_expr: ParserElement = _NO_IGNORE_EXPR_GIVEN,
    *,
    ignoreExpr: ParserElement = _NO_IGNORE_EXPR_GIVEN,
) -> ParserElement:
    """Helper method for defining nested lists enclosed in opening and
    closing delimiters (``"("`` and ``")"`` are the default).

    Parameters:

    - ``opener`` - opening character for a nested list
      (default= ``"("``); can also be a pyparsing expression
    - ``closer`` - closing character for a nested list
      (default= ``")"``); can also be a pyparsing expression
    - ``content`` - expression for items within the nested lists
      (default= ``None``)
    - ``ignore_expr`` - expression for ignoring opening and closing delimiters
      (default= :class:`quoted_string`)
    - ``ignoreExpr`` - this pre-PEP8 argument is retained for compatibility
      but will be removed in a future release

    If an expression is not provided for the content argument, the
    nested expression will capture all whitespace-delimited content
    between delimiters as a list of separate values.

    Use the ``ignore_expr`` argument to define expressions that may
    contain opening or closing characters that should not be treated as
    opening or closing characters for nesting, such as quoted_string or
    a comment expression.  Specify multiple expressions using an
    :class:`Or` or :class:`MatchFirst`. The default is
    :class:`quoted_string`, but if no expressions are to be ignored, then
    pass ``None`` for this argument.

    Example::

        data_type = one_of("void int short long char float double")
        decl_data_type = Combine(data_type + Opt(Word('*')))
        ident = Word(alphas+'_', alphanums+'_')
        number = pyparsing_common.number
        arg = Group(decl_data_type + ident)
        LPAR, RPAR = map(Suppress, "()")

        code_body = nested_expr('{', '}', ignore_expr=(quoted_string | c_style_comment))

        c_function = (decl_data_type("type")
                      + ident("name")
                      + LPAR + Opt(DelimitedList(arg), [])("args") + RPAR
                      + code_body("body"))
        c_function.ignore(c_style_comment)

        source_code = '''
            int is_odd(int x) {
                return (x%2);
            }

            int dec_to_hex(char hchar) {
                if (hchar >= '0' && hchar <= '9') {
                    return (ord(hchar)-ord('0'));
                } else {
                    return (10+ord(hchar)-ord('A'));
                }
            }
        '''
        for func in c_function.search_string(source_code):
            print("%(name)s (%(type)s) args: %(args)s" % func)


    prints::

        is_odd (int) args: [['int', 'x']]
        dec_to_hex (int) args: [['char', 'hchar']]
    """
    if ignoreExpr != ignore_expr:
        ignoreExpr = ignore_expr if ignoreExpr is _NO_IGNORE_EXPR_GIVEN else ignoreExpr

    if ignoreExpr is _NO_IGNORE_EXPR_GIVEN:
        ignoreExpr = quoted_string()

    if opener == closer:
        raise ValueError("opening and closing strings cannot be the same")

    if content is None:
        if isinstance(opener, str_type) and isinstance(closer, str_type):
            opener = typing.cast(str, opener)
            closer = typing.cast(str, closer)
            if len(opener) == 1 and len(closer) == 1:
                if ignoreExpr is not None:
                    content = Combine(
                        OneOrMore(
                            ~ignoreExpr
                            + CharsNotIn(
                                opener + closer + ParserElement.DEFAULT_WHITE_CHARS,
                                exact=1,
                            )
                        )
                    )
                else:
                    content = Combine(
                        Empty()
                        + CharsNotIn(
                            opener + closer + ParserElement.DEFAULT_WHITE_CHARS
                        )
                    )
            else:
                if ignoreExpr is not None:
                    content = Combine(
                        OneOrMore(
                            ~ignoreExpr
                            + ~Literal(opener)
                            + ~Literal(closer)
                            + CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS, exact=1)
                        )
                    )
                else:
                    content = Combine(
                        OneOrMore(
                            ~Literal(opener)
                            + ~Literal(closer)
                            + CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS, exact=1)
                        )
                    )
        else:
            raise ValueError(
                "opening and closing arguments must be strings if no content expression is given"
            )

        # for these internally-created context expressions, simulate whitespace-skipping
        if ParserElement.DEFAULT_WHITE_CHARS:
            content.set_parse_action(
                lambda t: t[0].strip(ParserElement.DEFAULT_WHITE_CHARS)
            )

    ret = Forward()
    if ignoreExpr is not None:
        ret <<= Group(
            Suppress(opener) + ZeroOrMore(ignoreExpr | ret | content) + Suppress(closer)
        )
    else:
        ret <<= Group(Suppress(opener) + ZeroOrMore(ret | content) + Suppress(closer))

    ret.set_name(f"nested {opener}{closer} expression")

    # don't override error message from content expressions
    ret.errmsg = None
    return ret


def _makeTags(tagStr, xml, suppress_LT=Suppress("<"), suppress_GT=Suppress(">")):
    """Internal helper to construct opening and closing tag expressions, given a tag name"""
    if isinstance(tagStr, str_type):
        resname = tagStr
        tagStr = Keyword(tagStr, caseless=not xml)
    else:
        resname = tagStr.name

    tagAttrName = Word(alphas, alphanums + "_-:")
    if xml:
        tagAttrValue = dbl_quoted_string.copy().set_parse_action(remove_quotes)
        openTag = (
            suppress_LT
            + tagStr("tag")
            + Dict(ZeroOrMore(Group(tagAttrName + Suppress("=") + tagAttrValue)))
            + Opt("/", default=[False])("empty").set_parse_action(
                lambda s, l, t: t[0] == "/"
            )
            + suppress_GT
        )
    else:
        tagAttrValue = quoted_string.copy().set_parse_action(remove_quotes) | Word(
            printables, exclude_chars=">"
        )
        openTag = (
            suppress_LT
            + tagStr("tag")
            + Dict(
                ZeroOrMore(
                    Group(
                        tagAttrName.set_parse_action(lambda t: t[0].lower())
                        + Opt(Suppress("=") + tagAttrValue)
                    )
                )
            )
            + Opt("/", default=[False])("empty").set_parse_action(
                lambda s, l, t: t[0] == "/"
            )
            + suppress_GT
        )
    closeTag = Combine(Literal("</") + tagStr + ">", adjacent=False)

    openTag.set_name(f"<{resname}>")
    # add start<tagname> results name in parse action now that ungrouped names are not reported at two levels
    openTag.add_parse_action(
        lambda t: t.__setitem__(
            "start" + "".join(resname.replace(":", " ").title().split()), t.copy()
        )
    )
    closeTag = closeTag(
        "end" + "".join(resname.replace(":", " ").title().split())
    ).set_name(f"</{resname}>")
    openTag.tag = resname
    closeTag.tag = resname
    openTag.tag_body = SkipTo(closeTag())
    return openTag, closeTag


def make_html_tags(
    tag_str: Union[str, ParserElement],
) -> tuple[ParserElement, ParserElement]:
    """Helper to construct opening and closing tag expressions for HTML,
    given a tag name. Matches tags in either upper or lower case,
    attributes with namespaces and with quoted or unquoted values.

    Example::

        text = '<td>More info at the <a href="https://github.com/pyparsing/pyparsing/wiki">pyparsing</a> wiki page</td>'
        # make_html_tags returns pyparsing expressions for the opening and
        # closing tags as a 2-tuple
        a, a_end = make_html_tags("A")
        link_expr = a + SkipTo(a_end)("link_text") + a_end

        for link in link_expr.search_string(text):
            # attributes in the <A> tag (like "href" shown here) are
            # also accessible as named results
            print(link.link_text, '->', link.href)

    prints::

        pyparsing -> https://github.com/pyparsing/pyparsing/wiki
    """
    return _makeTags(tag_str, False)


def make_xml_tags(
    tag_str: Union[str, ParserElement],
) -> tuple[ParserElement, ParserElement]:
    """Helper to construct opening and closing tag expressions for XML,
    given a tag name. Matches tags only in the given upper/lower case.

    Example: similar to :class:`make_html_tags`
    """
    return _makeTags(tag_str, True)


any_open_tag: ParserElement
any_close_tag: ParserElement
any_open_tag, any_close_tag = make_html_tags(
    Word(alphas, alphanums + "_:").set_name("any tag")
)

_htmlEntityMap = {k.rstrip(";"): v for k, v in html.entities.html5.items()}
_most_common_entities = "nbsp lt gt amp quot apos cent pound euro copy".replace(
    " ", "|"
)
common_html_entity = Regex(
    lambda: f"&(?P<entity>{_most_common_entities}|{make_compressed_re(_htmlEntityMap)});"
).set_name("common HTML entity")


def replace_html_entity(s, l, t):
    """Helper parser action to replace common HTML entities with their special characters"""
    return _htmlEntityMap.get(t.entity)


class OpAssoc(Enum):
    """Enumeration of operator associativity
    - used in constructing InfixNotationOperatorSpec for :class:`infix_notation`"""

    LEFT = 1
    RIGHT = 2


InfixNotationOperatorArgType = Union[
    ParserElement, str, tuple[Union[ParserElement, str], Union[ParserElement, str]]
]
InfixNotationOperatorSpec = Union[
    tuple[
        InfixNotationOperatorArgType,
        int,
        OpAssoc,
        typing.Optional[ParseAction],
    ],
    tuple[
        InfixNotationOperatorArgType,
        int,
        OpAssoc,
    ],
]


def infix_notation(
    base_expr: ParserElement,
    op_list: list[InfixNotationOperatorSpec],
    lpar: Union[str, ParserElement] = Suppress("("),
    rpar: Union[str, ParserElement] = Suppress(")"),
) -> Forward:
    """Helper method for constructing grammars of expressions made up of
    operators working in a precedence hierarchy.  Operators may be unary
    or binary, left- or right-associative.  Parse actions can also be
    attached to operator expressions. The generated parser will also
    recognize the use of parentheses to override operator precedences
    (see example below).

    Note: if you define a deep operator list, you may see performance
    issues when using infix_notation. See
    :class:`ParserElement.enable_packrat` for a mechanism to potentially
    improve your parser performance.

    Parameters:

    - ``base_expr`` - expression representing the most basic operand to
      be used in the expression
    - ``op_list`` - list of tuples, one for each operator precedence level
      in the expression grammar; each tuple is of the form ``(op_expr,
      num_operands, right_left_assoc, (optional)parse_action)``, where:

      - ``op_expr`` is the pyparsing expression for the operator; may also
        be a string, which will be converted to a Literal; if ``num_operands``
        is 3, ``op_expr`` is a tuple of two expressions, for the two
        operators separating the 3 terms
      - ``num_operands`` is the number of terms for this operator (must be 1,
        2, or 3)
      - ``right_left_assoc`` is the indicator whether the operator is right
        or left associative, using the pyparsing-defined constants
        ``OpAssoc.RIGHT`` and ``OpAssoc.LEFT``.
      - ``parse_action`` is the parse action to be associated with
        expressions matching this operator expression (the parse action
        tuple member may be omitted); if the parse action is passed
        a tuple or list of functions, this is equivalent to calling
        ``set_parse_action(*fn)``
        (:class:`ParserElement.set_parse_action`)
    - ``lpar`` - expression for matching left-parentheses; if passed as a
      str, then will be parsed as ``Suppress(lpar)``. If lpar is passed as
      an expression (such as ``Literal('(')``), then it will be kept in
      the parsed results, and grouped with them. (default= ``Suppress('(')``)
    - ``rpar`` - expression for matching right-parentheses; if passed as a
      str, then will be parsed as ``Suppress(rpar)``. If rpar is passed as
      an expression (such as ``Literal(')')``), then it will be kept in
      the parsed results, and grouped with them. (default= ``Suppress(')')``)

    Example::

        # simple example of four-function arithmetic with ints and
        # variable names
        integer = pyparsing_common.signed_integer
        varname = pyparsing_common.identifier

        arith_expr = infix_notation(integer | varname,
            [
            ('-', 1, OpAssoc.RIGHT),
            (one_of('* /'), 2, OpAssoc.LEFT),
            (one_of('+ -'), 2, OpAssoc.LEFT),
            ])

        arith_expr.run_tests('''
            5+3*6
            (5+3)*6
            -2--11
            ''', full_dump=False)

    prints::

        5+3*6
        [[5, '+', [3, '*', 6]]]

        (5+3)*6
        [[[5, '+', 3], '*', 6]]

        (5+x)*y
        [[[5, '+', 'x'], '*', 'y']]

        -2--11
        [[['-', 2], '-', ['-', 11]]]
    """

    # captive version of FollowedBy that does not do parse actions or capture results names
    class _FB(FollowedBy):
        def parseImpl(self, instring, loc, doActions=True):
            self.expr.try_parse(instring, loc)
            return loc, []

    _FB.__name__ = "FollowedBy>"

    ret = Forward()
    ret.set_name(f"{base_expr.name}_expression")
    if isinstance(lpar, str):
        lpar = Suppress(lpar)
    if isinstance(rpar, str):
        rpar = Suppress(rpar)

    nested_expr = (lpar + ret + rpar).set_name(f"nested_{base_expr.name}")

    # if lpar and rpar are not suppressed, wrap in group
    if not (isinstance(lpar, Suppress) and isinstance(rpar, Suppress)):
        lastExpr = base_expr | Group(nested_expr)
    else:
        lastExpr = base_expr | nested_expr

    arity: int
    rightLeftAssoc: opAssoc
    pa: typing.Optional[ParseAction]
    opExpr1: ParserElement
    opExpr2: ParserElement
    matchExpr: ParserElement
    match_lookahead: ParserElement
    for operDef in op_list:
        opExpr, arity, rightLeftAssoc, pa = (operDef + (None,))[:4]  # type: ignore[assignment]
        if isinstance(opExpr, str_type):
            opExpr = ParserElement._literalStringClass(opExpr)
        opExpr = typing.cast(ParserElement, opExpr)
        if arity == 3:
            if not isinstance(opExpr, (tuple, list)) or len(opExpr) != 2:
                raise ValueError(
                    "if numterms=3, opExpr must be a tuple or list of two expressions"
                )
            opExpr1, opExpr2 = opExpr
            term_name = f"{opExpr1}{opExpr2} operations"
        else:
            term_name = f"{opExpr} operations"

        if not 1 <= arity <= 3:
            raise ValueError("operator must be unary (1), binary (2), or ternary (3)")

        if rightLeftAssoc not in (OpAssoc.LEFT, OpAssoc.RIGHT):
            raise ValueError("operator must indicate right or left associativity")

        thisExpr: ParserElement = Forward().set_name(term_name)
        thisExpr = typing.cast(Forward, thisExpr)
        match_lookahead = And([])
        if rightLeftAssoc is OpAssoc.LEFT:
            if arity == 1:
                match_lookahead = _FB(lastExpr + opExpr)
                matchExpr = Group(lastExpr + opExpr[1, ...])
            elif arity == 2:
                if opExpr is not None:
                    match_lookahead = _FB(lastExpr + opExpr + lastExpr)
                    matchExpr = Group(lastExpr + (opExpr + lastExpr)[1, ...])
                else:
                    match_lookahead = _FB(lastExpr + lastExpr)
                    matchExpr = Group(lastExpr[2, ...])
            elif arity == 3:
                match_lookahead = _FB(
                    lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr
                )
                matchExpr = Group(
                    lastExpr + (opExpr1 + lastExpr + opExpr2 + lastExpr)[1, ...]
                )
        elif rightLeftAssoc is OpAssoc.RIGHT:
            if arity == 1:
                # try to avoid LR with this extra test
                if not isinstance(opExpr, Opt):
                    opExpr = Opt(opExpr)
                match_lookahead = _FB(opExpr.expr + thisExpr)
                matchExpr = Group(opExpr + thisExpr)
            elif arity == 2:
                if opExpr is not None:
                    match_lookahead = _FB(lastExpr + opExpr + thisExpr)
                    matchExpr = Group(lastExpr + (opExpr + thisExpr)[1, ...])
                else:
                    match_lookahead = _FB(lastExpr + thisExpr)
                    matchExpr = Group(lastExpr + thisExpr[1, ...])
            elif arity == 3:
                match_lookahead = _FB(
                    lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr
                )
                matchExpr = Group(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr)

        # suppress lookahead expr from railroad diagrams
        match_lookahead.show_in_diagram = False

        # TODO - determine why this statement can't be included in the following
        #  if pa block
        matchExpr = match_lookahead + matchExpr

        if pa:
            if isinstance(pa, (tuple, list)):
                matchExpr.set_parse_action(*pa)
            else:
                matchExpr.set_parse_action(pa)

        thisExpr <<= (matchExpr | lastExpr).setName(term_name)
        lastExpr = thisExpr

    ret <<= lastExpr
    return ret


def indentedBlock(blockStatementExpr, indentStack, indent=True, backup_stacks=[]):
    """
    (DEPRECATED - use :class:`IndentedBlock` class instead)
    Helper method for defining space-delimited indentation blocks,
    such as those used to define block statements in Python source code.

    Parameters:

    - ``blockStatementExpr`` - expression defining syntax of statement that
      is repeated within the indented block
    - ``indentStack`` - list created by caller to manage indentation stack
      (multiple ``statementWithIndentedBlock`` expressions within a single
      grammar should share a common ``indentStack``)
    - ``indent`` - boolean indicating whether block must be indented beyond
      the current level; set to ``False`` for block of left-most statements
      (default= ``True``)

    A valid block must contain at least one ``blockStatement``.

    (Note that indentedBlock uses internal parse actions which make it
    incompatible with packrat parsing.)

    Example::

        data = '''
        def A(z):
          A1
          B = 100
          G = A2
          A2
          A3
        B
        def BB(a,b,c):
          BB1
          def BBA():
            bba1
            bba2
            bba3
        C
        D
        def spam(x,y):
             def eggs(z):
                 pass
        '''


        indentStack = [1]
        stmt = Forward()

        identifier = Word(alphas, alphanums)
        funcDecl = ("def" + identifier + Group("(" + Opt(delimitedList(identifier)) + ")") + ":")
        func_body = indentedBlock(stmt, indentStack)
        funcDef = Group(funcDecl + func_body)

        rvalue = Forward()
        funcCall = Group(identifier + "(" + Opt(delimitedList(rvalue)) + ")")
        rvalue << (funcCall | identifier | Word(nums))
        assignment = Group(identifier + "=" + rvalue)
        stmt << (funcDef | assignment | identifier)

        module_body = stmt[1, ...]

        parseTree = module_body.parseString(data)
        parseTree.pprint()

    prints::

        [['def',
          'A',
          ['(', 'z', ')'],
          ':',
          [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]],
         'B',
         ['def',
          'BB',
          ['(', 'a', 'b', 'c', ')'],
          ':',
          [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]],
         'C',
         'D',
         ['def',
          'spam',
          ['(', 'x', 'y', ')'],
          ':',
          [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]]
    """
    backup_stacks.append(indentStack[:])

    def reset_stack():
        indentStack[:] = backup_stacks[-1]

    def checkPeerIndent(s, l, t):
        if l >= len(s):
            return
        curCol = col(l, s)
        if curCol != indentStack[-1]:
            if curCol > indentStack[-1]:
                raise ParseException(s, l, "illegal nesting")
            raise ParseException(s, l, "not a peer entry")

    def checkSubIndent(s, l, t):
        curCol = col(l, s)
        if curCol > indentStack[-1]:
            indentStack.append(curCol)
        else:
            raise ParseException(s, l, "not a subentry")

    def checkUnindent(s, l, t):
        if l >= len(s):
            return
        curCol = col(l, s)
        if not (indentStack and curCol in indentStack):
            raise ParseException(s, l, "not an unindent")
        if curCol < indentStack[-1]:
            indentStack.pop()

    NL = OneOrMore(LineEnd().set_whitespace_chars("\t ").suppress())
    INDENT = (Empty() + Empty().set_parse_action(checkSubIndent)).set_name("INDENT")
    PEER = Empty().set_parse_action(checkPeerIndent).set_name("")
    UNDENT = Empty().set_parse_action(checkUnindent).set_name("UNINDENT")
    if indent:
        smExpr = Group(
            Opt(NL)
            + INDENT
            + OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))
            + UNDENT
        )
    else:
        smExpr = Group(
            Opt(NL)
            + OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))
            + Opt(UNDENT)
        )

    # add a parse action to remove backup_stack from list of backups
    smExpr.add_parse_action(
        lambda: backup_stacks.pop(-1) and None if backup_stacks else None
    )
    smExpr.set_fail_action(lambda a, b, c, d: reset_stack())
    blockStatementExpr.ignore(_bslash + LineEnd())
    return smExpr.set_name("indented block")


# it's easy to get these comment structures wrong - they're very common,
# so may as well make them available
c_style_comment = Regex(r"/\*(?:[^*]|\*(?!/))*\*\/").set_name("C style comment")
"Comment of the form ``/* ... */``"

html_comment = Regex(r"<!--[\s\S]*?-->").set_name("HTML comment")
"Comment of the form ``<!-- ... -->``"

rest_of_line = Regex(r".*").leave_whitespace().set_name("rest of line")
dbl_slash_comment = Regex(r"//(?:\\\n|[^\n])*").set_name("// comment")
"Comment of the form ``// ... (to end of line)``"

cpp_style_comment = Regex(
    r"(?:/\*(?:[^*]|\*(?!/))*\*\/)|(?://(?:\\\n|[^\n])*)"
).set_name("C++ style comment")
"Comment of either form :class:`c_style_comment` or :class:`dbl_slash_comment`"

java_style_comment = cpp_style_comment
"Same as :class:`cpp_style_comment`"

python_style_comment = Regex(r"#.*").set_name("Python style comment")
"Comment of the form ``# ... (to end of line)``"


# build list of built-in expressions, for future reference if a global default value
# gets updated
_builtin_exprs: list[ParserElement] = [
    v for v in vars().values() if isinstance(v, ParserElement)
]


# compatibility function, superseded by DelimitedList class
def delimited_list(
    expr: Union[str, ParserElement],
    delim: Union[str, ParserElement] = ",",
    combine: bool = False,
    min: typing.Optional[int] = None,
    max: typing.Optional[int] = None,
    *,
    allow_trailing_delim: bool = False,
) -> ParserElement:
    """(DEPRECATED - use :class:`DelimitedList` class)"""
    return DelimitedList(
        expr, delim, combine, min, max, allow_trailing_delim=allow_trailing_delim
    )


# Compatibility synonyms
# fmt: off
opAssoc = OpAssoc
anyOpenTag = any_open_tag
anyCloseTag = any_close_tag
commonHTMLEntity = common_html_entity
cStyleComment = c_style_comment
htmlComment = html_comment
restOfLine = rest_of_line
dblSlashComment = dbl_slash_comment
cppStyleComment = cpp_style_comment
javaStyleComment = java_style_comment
pythonStyleComment = python_style_comment
delimitedList = replaced_by_pep8("delimitedList", DelimitedList)
delimited_list = replaced_by_pep8("delimited_list", DelimitedList)
countedArray = replaced_by_pep8("countedArray", counted_array)
matchPreviousLiteral = replaced_by_pep8("matchPreviousLiteral", match_previous_literal)
matchPreviousExpr = replaced_by_pep8("matchPreviousExpr", match_previous_expr)
oneOf = replaced_by_pep8("oneOf", one_of)
dictOf = replaced_by_pep8("dictOf", dict_of)
originalTextFor = replaced_by_pep8("originalTextFor", original_text_for)
nestedExpr = replaced_by_pep8("nestedExpr", nested_expr)
makeHTMLTags = replaced_by_pep8("makeHTMLTags", make_html_tags)
makeXMLTags = replaced_by_pep8("makeXMLTags", make_xml_tags)
replaceHTMLEntity = replaced_by_pep8("replaceHTMLEntity", replace_html_entity)
infixNotation = replaced_by_pep8("infixNotation", infix_notation)
# fmt: on


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\results.py
# ================================================================================

# results.py
from __future__ import annotations

import collections
from collections.abc import (
    MutableMapping,
    Mapping,
    MutableSequence,
    Iterator,
    Iterable,
)
import pprint
from typing import Any

from .util import replaced_by_pep8


str_type: tuple[type, ...] = (str, bytes)
_generator_type = type((_ for _ in ()))


class _ParseResultsWithOffset:
    tup: tuple[ParseResults, int]
    __slots__ = ["tup"]

    def __init__(self, p1: ParseResults, p2: int) -> None:
        self.tup: tuple[ParseResults, int] = (p1, p2)

    def __getitem__(self, i):
        return self.tup[i]

    def __getstate__(self):
        return self.tup

    def __setstate__(self, *args):
        self.tup = args[0]


class ParseResults:
    """Structured parse results, to provide multiple means of access to
    the parsed data:

    - as a list (``len(results)``)
    - by list index (``results[0], results[1]``, etc.)
    - by attribute (``results.<results_name>`` - see :class:`ParserElement.set_results_name`)

    Example::

        integer = Word(nums)
        date_str = (integer.set_results_name("year") + '/'
                    + integer.set_results_name("month") + '/'
                    + integer.set_results_name("day"))
        # equivalent form:
        # date_str = (integer("year") + '/'
        #             + integer("month") + '/'
        #             + integer("day"))

        # parse_string returns a ParseResults object
        result = date_str.parse_string("1999/12/31")

        def test(s, fn=repr):
            print(f"{s} -> {fn(eval(s))}")
        test("list(result)")
        test("result[0]")
        test("result['month']")
        test("result.day")
        test("'month' in result")
        test("'minutes' in result")
        test("result.dump()", str)

    prints::

        list(result) -> ['1999', '/', '12', '/', '31']
        result[0] -> '1999'
        result['month'] -> '12'
        result.day -> '31'
        'month' in result -> True
        'minutes' in result -> False
        result.dump() -> ['1999', '/', '12', '/', '31']
        - day: '31'
        - month: '12'
        - year: '1999'
    """

    _null_values: tuple[Any, ...] = (None, [], ())

    _name: str
    _parent: ParseResults
    _all_names: set[str]
    _modal: bool
    _toklist: list[Any]
    _tokdict: dict[str, Any]

    __slots__ = (
        "_name",
        "_parent",
        "_all_names",
        "_modal",
        "_toklist",
        "_tokdict",
    )

    class List(list):
        """
        Simple wrapper class to distinguish parsed list results that should be preserved
        as actual Python lists, instead of being converted to :class:`ParseResults`::

            LBRACK, RBRACK = map(pp.Suppress, "[]")
            element = pp.Forward()
            item = ppc.integer
            element_list = LBRACK + pp.DelimitedList(element) + RBRACK

            # add parse actions to convert from ParseResults to actual Python collection types
            def as_python_list(t):
                return pp.ParseResults.List(t.as_list())
            element_list.add_parse_action(as_python_list)

            element <<= item | element_list

            element.run_tests('''
                100
                [2,3,4]
                [[2, 1],3,4]
                [(2, 1),3,4]
                (2,3,4)
                ''', post_parse=lambda s, r: (r[0], type(r[0])))

        prints::

            100
            (100, <class 'int'>)

            [2,3,4]
            ([2, 3, 4], <class 'list'>)

            [[2, 1],3,4]
            ([[2, 1], 3, 4], <class 'list'>)

        (Used internally by :class:`Group` when `aslist=True`.)
        """

        def __new__(cls, contained=None):
            if contained is None:
                contained = []

            if not isinstance(contained, list):
                raise TypeError(
                    f"{cls.__name__} may only be constructed with a list, not {type(contained).__name__}"
                )

            return list.__new__(cls)

    def __new__(cls, toklist=None, name=None, **kwargs):
        if isinstance(toklist, ParseResults):
            return toklist
        self = object.__new__(cls)
        self._name = None
        self._parent = None
        self._all_names = set()

        if toklist is None:
            self._toklist = []
        elif isinstance(toklist, (list, _generator_type)):
            self._toklist = (
                [toklist[:]]
                if isinstance(toklist, ParseResults.List)
                else list(toklist)
            )
        else:
            self._toklist = [toklist]
        self._tokdict = dict()
        return self

    # Performance tuning: we construct a *lot* of these, so keep this
    # constructor as small and fast as possible
    def __init__(
        self, toklist=None, name=None, asList=True, modal=True, isinstance=isinstance
    ) -> None:
        self._tokdict: dict[str, _ParseResultsWithOffset]
        self._modal = modal

        if name is None or name == "":
            return

        if isinstance(name, int):
            name = str(name)

        if not modal:
            self._all_names = {name}

        self._name = name

        if toklist in self._null_values:
            return

        if isinstance(toklist, (str_type, type)):
            toklist = [toklist]

        if asList:
            if isinstance(toklist, ParseResults):
                self[name] = _ParseResultsWithOffset(ParseResults(toklist._toklist), 0)
            else:
                self[name] = _ParseResultsWithOffset(ParseResults(toklist[0]), 0)
            self[name]._name = name
            return

        try:
            self[name] = toklist[0]
        except (KeyError, TypeError, IndexError):
            if toklist is not self:
                self[name] = toklist
            else:
                self._name = name

    def __getitem__(self, i):
        if isinstance(i, (int, slice)):
            return self._toklist[i]

        if i not in self._all_names:
            return self._tokdict[i][-1][0]

        return ParseResults([v[0] for v in self._tokdict[i]])

    def __setitem__(self, k, v, isinstance=isinstance):
        if isinstance(v, _ParseResultsWithOffset):
            self._tokdict[k] = self._tokdict.get(k, list()) + [v]
            sub = v[0]
        elif isinstance(k, (int, slice)):
            self._toklist[k] = v
            sub = v
        else:
            self._tokdict[k] = self._tokdict.get(k, []) + [
                _ParseResultsWithOffset(v, 0)
            ]
            sub = v
        if isinstance(sub, ParseResults):
            sub._parent = self

    def __delitem__(self, i):
        if not isinstance(i, (int, slice)):
            del self._tokdict[i]
            return

        mylen = len(self._toklist)
        del self._toklist[i]

        # convert int to slice
        if isinstance(i, int):
            if i < 0:
                i += mylen
            i = slice(i, i + 1)
        # get removed indices
        removed = list(range(*i.indices(mylen)))
        removed.reverse()
        # fixup indices in token dictionary
        for occurrences in self._tokdict.values():
            for j in removed:
                for k, (value, position) in enumerate(occurrences):
                    occurrences[k] = _ParseResultsWithOffset(
                        value, position - (position > j)
                    )

    def __contains__(self, k) -> bool:
        return k in self._tokdict

    def __len__(self) -> int:
        return len(self._toklist)

    def __bool__(self) -> bool:
        return not not (self._toklist or self._tokdict)

    def __iter__(self) -> Iterator:
        return iter(self._toklist)

    def __reversed__(self) -> Iterator:
        return iter(self._toklist[::-1])

    def keys(self):
        return iter(self._tokdict)

    def values(self):
        return (self[k] for k in self.keys())

    def items(self):
        return ((k, self[k]) for k in self.keys())

    def haskeys(self) -> bool:
        """
        Since ``keys()`` returns an iterator, this method is helpful in bypassing
        code that looks for the existence of any defined results names."""
        return not not self._tokdict

    def pop(self, *args, **kwargs):
        """
        Removes and returns item at specified index (default= ``last``).
        Supports both ``list`` and ``dict`` semantics for ``pop()``. If
        passed no argument or an integer argument, it will use ``list``
        semantics and pop tokens from the list of parsed tokens. If passed
        a non-integer argument (most likely a string), it will use ``dict``
        semantics and pop the corresponding value from any defined results
        names. A second default return value argument is supported, just as in
        ``dict.pop()``.

        Example::

            numlist = Word(nums)[...]
            print(numlist.parse_string("0 123 321")) # -> ['0', '123', '321']

            def remove_first(tokens):
                tokens.pop(0)
            numlist.add_parse_action(remove_first)
            print(numlist.parse_string("0 123 321")) # -> ['123', '321']

            label = Word(alphas)
            patt = label("LABEL") + Word(nums)[1, ...]
            print(patt.parse_string("AAB 123 321").dump())

            # Use pop() in a parse action to remove named result (note that corresponding value is not
            # removed from list form of results)
            def remove_LABEL(tokens):
                tokens.pop("LABEL")
                return tokens
            patt.add_parse_action(remove_LABEL)
            print(patt.parse_string("AAB 123 321").dump())

        prints::

            ['AAB', '123', '321']
            - LABEL: 'AAB'

            ['AAB', '123', '321']
        """
        if not args:
            args = [-1]
        for k, v in kwargs.items():
            if k == "default":
                args = (args[0], v)
            else:
                raise TypeError(f"pop() got an unexpected keyword argument {k!r}")
        if isinstance(args[0], int) or len(args) == 1 or args[0] in self:
            index = args[0]
            ret = self[index]
            del self[index]
            return ret
        else:
            defaultvalue = args[1]
            return defaultvalue

    def get(self, key, default_value=None):
        """
        Returns named result matching the given key, or if there is no
        such name, then returns the given ``default_value`` or ``None`` if no
        ``default_value`` is specified.

        Similar to ``dict.get()``.

        Example::

            integer = Word(nums)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")

            result = date_str.parse_string("1999/12/31")
            print(result.get("year")) # -> '1999'
            print(result.get("hour", "not specified")) # -> 'not specified'
            print(result.get("hour")) # -> None
        """
        if key in self:
            return self[key]
        else:
            return default_value

    def insert(self, index, ins_string):
        """
        Inserts new element at location index in the list of parsed tokens.

        Similar to ``list.insert()``.

        Example::

            numlist = Word(nums)[...]
            print(numlist.parse_string("0 123 321")) # -> ['0', '123', '321']

            # use a parse action to insert the parse location in the front of the parsed results
            def insert_locn(locn, tokens):
                tokens.insert(0, locn)
            numlist.add_parse_action(insert_locn)
            print(numlist.parse_string("0 123 321")) # -> [0, '0', '123', '321']
        """
        self._toklist.insert(index, ins_string)
        # fixup indices in token dictionary
        for occurrences in self._tokdict.values():
            for k, (value, position) in enumerate(occurrences):
                occurrences[k] = _ParseResultsWithOffset(
                    value, position + (position > index)
                )

    def append(self, item):
        """
        Add single element to end of ``ParseResults`` list of elements.

        Example::

            numlist = Word(nums)[...]
            print(numlist.parse_string("0 123 321")) # -> ['0', '123', '321']

            # use a parse action to compute the sum of the parsed integers, and add it to the end
            def append_sum(tokens):
                tokens.append(sum(map(int, tokens)))
            numlist.add_parse_action(append_sum)
            print(numlist.parse_string("0 123 321")) # -> ['0', '123', '321', 444]
        """
        self._toklist.append(item)

    def extend(self, itemseq):
        """
        Add sequence of elements to end of ``ParseResults`` list of elements.

        Example::

            patt = Word(alphas)[1, ...]

            # use a parse action to append the reverse of the matched strings, to make a palindrome
            def make_palindrome(tokens):
                tokens.extend(reversed([t[::-1] for t in tokens]))
                return ''.join(tokens)
            patt.add_parse_action(make_palindrome)
            print(patt.parse_string("lskdj sdlkjf lksd")) # -> 'lskdjsdlkjflksddsklfjkldsjdksl'
        """
        if isinstance(itemseq, ParseResults):
            self.__iadd__(itemseq)
        else:
            self._toklist.extend(itemseq)

    def clear(self):
        """
        Clear all elements and results names.
        """
        del self._toklist[:]
        self._tokdict.clear()

    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            if name.startswith("__"):
                raise AttributeError(name)
            return ""

    def __add__(self, other: ParseResults) -> ParseResults:
        ret = self.copy()
        ret += other
        return ret

    def __iadd__(self, other: ParseResults) -> ParseResults:
        if not other:
            return self

        if other._tokdict:
            offset = len(self._toklist)
            addoffset = lambda a: offset if a < 0 else a + offset
            otheritems = other._tokdict.items()
            otherdictitems = [
                (k, _ParseResultsWithOffset(v[0], addoffset(v[1])))
                for k, vlist in otheritems
                for v in vlist
            ]
            for k, v in otherdictitems:
                self[k] = v
                if isinstance(v[0], ParseResults):
                    v[0]._parent = self

        self._toklist += other._toklist
        self._all_names |= other._all_names
        return self

    def __radd__(self, other) -> ParseResults:
        if isinstance(other, int) and other == 0:
            # useful for merging many ParseResults using sum() builtin
            return self.copy()
        else:
            # this may raise a TypeError - so be it
            return other + self

    def __repr__(self) -> str:
        return f"{type(self).__name__}({self._toklist!r}, {self.as_dict()})"

    def __str__(self) -> str:
        return (
            "["
            + ", ".join(
                [
                    str(i) if isinstance(i, ParseResults) else repr(i)
                    for i in self._toklist
                ]
            )
            + "]"
        )

    def _asStringList(self, sep=""):
        out = []
        for item in self._toklist:
            if out and sep:
                out.append(sep)
            if isinstance(item, ParseResults):
                out += item._asStringList()
            else:
                out.append(str(item))
        return out

    def as_list(self, *, flatten: bool = False) -> list:
        """
        Returns the parse results as a nested list of matching tokens, all converted to strings.
        If flatten is True, all the nesting levels in the returned list are collapsed.

        Example::

            patt = Word(alphas)[1, ...]
            result = patt.parse_string("sldkj lsdkj sldkj")
            # even though the result prints in string-like form, it is actually a pyparsing ParseResults
            print(type(result), result) # -> <class 'pyparsing.ParseResults'> ['sldkj', 'lsdkj', 'sldkj']

            # Use as_list() to create an actual list
            result_list = result.as_list()
            print(type(result_list), result_list) # -> <class 'list'> ['sldkj', 'lsdkj', 'sldkj']
        """

        def flattened(pr):
            to_visit = collections.deque([*self])
            while to_visit:
                to_do = to_visit.popleft()
                if isinstance(to_do, ParseResults):
                    to_visit.extendleft(to_do[::-1])
                else:
                    yield to_do

        if flatten:
            return [*flattened(self)]
        else:
            return [
                res.as_list() if isinstance(res, ParseResults) else res
                for res in self._toklist
            ]

    def as_dict(self) -> dict:
        """
        Returns the named parse results as a nested dictionary.

        Example::

            integer = Word(nums)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")

            result = date_str.parse_string('12/31/1999')
            print(type(result), repr(result)) # -> <class 'pyparsing.ParseResults'> (['12', '/', '31', '/', '1999'], {'day': [('1999', 4)], 'year': [('12', 0)], 'month': [('31', 2)]})

            result_dict = result.as_dict()
            print(type(result_dict), repr(result_dict)) # -> <class 'dict'> {'day': '1999', 'year': '12', 'month': '31'}

            # even though a ParseResults supports dict-like access, sometime you just need to have a dict
            import json
            print(json.dumps(result)) # -> Exception: TypeError: ... is not JSON serializable
            print(json.dumps(result.as_dict())) # -> {"month": "31", "day": "1999", "year": "12"}
        """

        def to_item(obj):
            if isinstance(obj, ParseResults):
                return obj.as_dict() if obj.haskeys() else [to_item(v) for v in obj]
            else:
                return obj

        return dict((k, to_item(v)) for k, v in self.items())

    def copy(self) -> ParseResults:
        """
        Returns a new shallow copy of a :class:`ParseResults` object. `ParseResults`
        items contained within the source are shared with the copy. Use
        :class:`ParseResults.deepcopy()` to create a copy with its own separate
        content values.
        """
        ret = ParseResults(self._toklist)
        ret._tokdict = self._tokdict.copy()
        ret._parent = self._parent
        ret._all_names |= self._all_names
        ret._name = self._name
        return ret

    def deepcopy(self) -> ParseResults:
        """
        Returns a new deep copy of a :class:`ParseResults` object.
        """
        ret = self.copy()
        # replace values with copies if they are of known mutable types
        for i, obj in enumerate(self._toklist):
            if isinstance(obj, ParseResults):
                ret._toklist[i] = obj.deepcopy()
            elif isinstance(obj, (str, bytes)):
                pass
            elif isinstance(obj, MutableMapping):
                ret._toklist[i] = dest = type(obj)()
                for k, v in obj.items():
                    dest[k] = v.deepcopy() if isinstance(v, ParseResults) else v
            elif isinstance(obj, Iterable):
                ret._toklist[i] = type(obj)(
                    v.deepcopy() if isinstance(v, ParseResults) else v for v in obj  # type: ignore[call-arg]
                )
        return ret

    def get_name(self) -> str | None:
        r"""
        Returns the results name for this token expression. Useful when several
        different expressions might match at a particular location.

        Example::

            integer = Word(nums)
            ssn_expr = Regex(r"\d\d\d-\d\d-\d\d\d\d")
            house_number_expr = Suppress('#') + Word(nums, alphanums)
            user_data = (Group(house_number_expr)("house_number")
                        | Group(ssn_expr)("ssn")
                        | Group(integer)("age"))
            user_info = user_data[1, ...]

            result = user_info.parse_string("22 111-22-3333 #221B")
            for item in result:
                print(item.get_name(), ':', item[0])

        prints::

            age : 22
            ssn : 111-22-3333
            house_number : 221B
        """
        if self._name:
            return self._name
        elif self._parent:
            par: ParseResults = self._parent
            parent_tokdict_items = par._tokdict.items()
            return next(
                (
                    k
                    for k, vlist in parent_tokdict_items
                    for v, loc in vlist
                    if v is self
                ),
                None,
            )
        elif (
            len(self) == 1
            and len(self._tokdict) == 1
            and next(iter(self._tokdict.values()))[0][1] in (0, -1)
        ):
            return next(iter(self._tokdict.keys()))
        else:
            return None

    def dump(self, indent="", full=True, include_list=True, _depth=0) -> str:
        """
        Diagnostic method for listing out the contents of
        a :class:`ParseResults`. Accepts an optional ``indent`` argument so
        that this string can be embedded in a nested display of other data.

        Example::

            integer = Word(nums)
            date_str = integer("year") + '/' + integer("month") + '/' + integer("day")

            result = date_str.parse_string('1999/12/31')
            print(result.dump())

        prints::

            ['1999', '/', '12', '/', '31']
            - day: '31'
            - month: '12'
            - year: '1999'
        """
        out = []
        NL = "\n"
        out.append(indent + str(self.as_list()) if include_list else "")

        if not full:
            return "".join(out)

        if self.haskeys():
            items = sorted((str(k), v) for k, v in self.items())
            for k, v in items:
                if out:
                    out.append(NL)
                out.append(f"{indent}{('  ' * _depth)}- {k}: ")
                if not isinstance(v, ParseResults):
                    out.append(repr(v))
                    continue

                if not v:
                    out.append(str(v))
                    continue

                out.append(
                    v.dump(
                        indent=indent,
                        full=full,
                        include_list=include_list,
                        _depth=_depth + 1,
                    )
                )
        if not any(isinstance(vv, ParseResults) for vv in self):
            return "".join(out)

        v = self
        incr = "  "
        nl = "\n"
        for i, vv in enumerate(v):
            if isinstance(vv, ParseResults):
                vv_dump = vv.dump(
                    indent=indent,
                    full=full,
                    include_list=include_list,
                    _depth=_depth + 1,
                )
                out.append(
                    f"{nl}{indent}{incr * _depth}[{i}]:{nl}{indent}{incr * (_depth + 1)}{vv_dump}"
                )
            else:
                out.append(
                    f"{nl}{indent}{incr * _depth}[{i}]:{nl}{indent}{incr * (_depth + 1)}{vv}"
                )

        return "".join(out)

    def pprint(self, *args, **kwargs):
        """
        Pretty-printer for parsed results as a list, using the
        `pprint <https://docs.python.org/3/library/pprint.html>`_ module.
        Accepts additional positional or keyword args as defined for
        `pprint.pprint <https://docs.python.org/3/library/pprint.html#pprint.pprint>`_ .

        Example::

            ident = Word(alphas, alphanums)
            num = Word(nums)
            func = Forward()
            term = ident | num | Group('(' + func + ')')
            func <<= ident + Group(Optional(DelimitedList(term)))
            result = func.parse_string("fna a,b,(fnb c,d,200),100")
            result.pprint(width=40)

        prints::

            ['fna',
             ['a',
              'b',
              ['(', 'fnb', ['c', 'd', '200'], ')'],
              '100']]
        """
        pprint.pprint(self.as_list(), *args, **kwargs)

    # add support for pickle protocol
    def __getstate__(self):
        return (
            self._toklist,
            (
                self._tokdict.copy(),
                None,
                self._all_names,
                self._name,
            ),
        )

    def __setstate__(self, state):
        self._toklist, (self._tokdict, par, inAccumNames, self._name) = state
        self._all_names = set(inAccumNames)
        self._parent = None

    def __getnewargs__(self):
        return self._toklist, self._name

    def __dir__(self):
        return dir(type(self)) + list(self.keys())

    @classmethod
    def from_dict(cls, other, name=None) -> ParseResults:
        """
        Helper classmethod to construct a ``ParseResults`` from a ``dict``, preserving the
        name-value relations as results names. If an optional ``name`` argument is
        given, a nested ``ParseResults`` will be returned.
        """

        def is_iterable(obj):
            try:
                iter(obj)
            except Exception:
                return False
            # str's are iterable, but in pyparsing, we don't want to iterate over them
            else:
                return not isinstance(obj, str_type)

        ret = cls([])
        for k, v in other.items():
            if isinstance(v, Mapping):
                ret += cls.from_dict(v, name=k)
            else:
                ret += cls([v], name=k, asList=is_iterable(v))
        if name is not None:
            ret = cls([ret], name=name)
        return ret

    asList = as_list
    """Deprecated - use :class:`as_list`"""
    asDict = as_dict
    """Deprecated - use :class:`as_dict`"""
    getName = get_name
    """Deprecated - use :class:`get_name`"""


MutableMapping.register(ParseResults)
MutableSequence.register(ParseResults)


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\testing.py
# ================================================================================

# testing.py

from contextlib import contextmanager
import re
import typing


from .core import (
    ParserElement,
    ParseException,
    Keyword,
    __diag__,
    __compat__,
)


class pyparsing_test:
    """
    namespace class for classes useful in writing unit tests
    """

    class reset_pyparsing_context:
        """
        Context manager to be used when writing unit tests that modify pyparsing config values:
        - packrat parsing
        - bounded recursion parsing
        - default whitespace characters.
        - default keyword characters
        - literal string auto-conversion class
        - __diag__ settings

        Example::

            with reset_pyparsing_context():
                # test that literals used to construct a grammar are automatically suppressed
                ParserElement.inlineLiteralsUsing(Suppress)

                term = Word(alphas) | Word(nums)
                group = Group('(' + term[...] + ')')

                # assert that the '()' characters are not included in the parsed tokens
                self.assertParseAndCheckList(group, "(abc 123 def)", ['abc', '123', 'def'])

            # after exiting context manager, literals are converted to Literal expressions again
        """

        def __init__(self):
            self._save_context = {}

        def save(self):
            self._save_context["default_whitespace"] = ParserElement.DEFAULT_WHITE_CHARS
            self._save_context["default_keyword_chars"] = Keyword.DEFAULT_KEYWORD_CHARS

            self._save_context["literal_string_class"] = (
                ParserElement._literalStringClass
            )

            self._save_context["verbose_stacktrace"] = ParserElement.verbose_stacktrace

            self._save_context["packrat_enabled"] = ParserElement._packratEnabled
            if ParserElement._packratEnabled:
                self._save_context["packrat_cache_size"] = (
                    ParserElement.packrat_cache.size
                )
            else:
                self._save_context["packrat_cache_size"] = None
            self._save_context["packrat_parse"] = ParserElement._parse
            self._save_context["recursion_enabled"] = (
                ParserElement._left_recursion_enabled
            )

            self._save_context["__diag__"] = {
                name: getattr(__diag__, name) for name in __diag__._all_names
            }

            self._save_context["__compat__"] = {
                "collect_all_And_tokens": __compat__.collect_all_And_tokens
            }

            return self

        def restore(self):
            # reset pyparsing global state
            if (
                ParserElement.DEFAULT_WHITE_CHARS
                != self._save_context["default_whitespace"]
            ):
                ParserElement.set_default_whitespace_chars(
                    self._save_context["default_whitespace"]
                )

            ParserElement.verbose_stacktrace = self._save_context["verbose_stacktrace"]

            Keyword.DEFAULT_KEYWORD_CHARS = self._save_context["default_keyword_chars"]
            ParserElement.inlineLiteralsUsing(
                self._save_context["literal_string_class"]
            )

            for name, value in self._save_context["__diag__"].items():
                (__diag__.enable if value else __diag__.disable)(name)

            ParserElement._packratEnabled = False
            if self._save_context["packrat_enabled"]:
                ParserElement.enable_packrat(self._save_context["packrat_cache_size"])
            else:
                ParserElement._parse = self._save_context["packrat_parse"]
            ParserElement._left_recursion_enabled = self._save_context[
                "recursion_enabled"
            ]

            __compat__.collect_all_And_tokens = self._save_context["__compat__"]

            return self

        def copy(self):
            ret = type(self)()
            ret._save_context.update(self._save_context)
            return ret

        def __enter__(self):
            return self.save()

        def __exit__(self, *args):
            self.restore()

    class TestParseResultsAsserts:
        """
        A mixin class to add parse results assertion methods to normal unittest.TestCase classes.
        """

        def assertParseResultsEquals(
            self, result, expected_list=None, expected_dict=None, msg=None
        ):
            """
            Unit test assertion to compare a :class:`ParseResults` object with an optional ``expected_list``,
            and compare any defined results names with an optional ``expected_dict``.
            """
            if expected_list is not None:
                self.assertEqual(expected_list, result.as_list(), msg=msg)
            if expected_dict is not None:
                self.assertEqual(expected_dict, result.as_dict(), msg=msg)

        def assertParseAndCheckList(
            self, expr, test_string, expected_list, msg=None, verbose=True
        ):
            """
            Convenience wrapper assert to test a parser element and input string, and assert that
            the resulting ``ParseResults.asList()`` is equal to the ``expected_list``.
            """
            result = expr.parse_string(test_string, parse_all=True)
            if verbose:
                print(result.dump())
            else:
                print(result.as_list())
            self.assertParseResultsEquals(result, expected_list=expected_list, msg=msg)

        def assertParseAndCheckDict(
            self, expr, test_string, expected_dict, msg=None, verbose=True
        ):
            """
            Convenience wrapper assert to test a parser element and input string, and assert that
            the resulting ``ParseResults.asDict()`` is equal to the ``expected_dict``.
            """
            result = expr.parse_string(test_string, parseAll=True)
            if verbose:
                print(result.dump())
            else:
                print(result.as_list())
            self.assertParseResultsEquals(result, expected_dict=expected_dict, msg=msg)

        def assertRunTestResults(
            self, run_tests_report, expected_parse_results=None, msg=None
        ):
            """
            Unit test assertion to evaluate output of ``ParserElement.runTests()``. If a list of
            list-dict tuples is given as the ``expected_parse_results`` argument, then these are zipped
            with the report tuples returned by ``runTests`` and evaluated using ``assertParseResultsEquals``.
            Finally, asserts that the overall ``runTests()`` success value is ``True``.

            :param run_tests_report: tuple(bool, [tuple(str, ParseResults or Exception)]) returned from runTests
            :param expected_parse_results (optional): [tuple(str, list, dict, Exception)]
            """
            run_test_success, run_test_results = run_tests_report

            if expected_parse_results is None:
                self.assertTrue(
                    run_test_success, msg=msg if msg is not None else "failed runTests"
                )
                return

            merged = [
                (*rpt, expected)
                for rpt, expected in zip(run_test_results, expected_parse_results)
            ]
            for test_string, result, expected in merged:
                # expected should be a tuple containing a list and/or a dict or an exception,
                # and optional failure message string
                # an empty tuple will skip any result validation
                fail_msg = next((exp for exp in expected if isinstance(exp, str)), None)
                expected_exception = next(
                    (
                        exp
                        for exp in expected
                        if isinstance(exp, type) and issubclass(exp, Exception)
                    ),
                    None,
                )
                if expected_exception is not None:
                    with self.assertRaises(
                        expected_exception=expected_exception, msg=fail_msg or msg
                    ):
                        if isinstance(result, Exception):
                            raise result
                else:
                    expected_list = next(
                        (exp for exp in expected if isinstance(exp, list)), None
                    )
                    expected_dict = next(
                        (exp for exp in expected if isinstance(exp, dict)), None
                    )
                    if (expected_list, expected_dict) != (None, None):
                        self.assertParseResultsEquals(
                            result,
                            expected_list=expected_list,
                            expected_dict=expected_dict,
                            msg=fail_msg or msg,
                        )
                    else:
                        # warning here maybe?
                        print(f"no validation for {test_string!r}")

            # do this last, in case some specific test results can be reported instead
            self.assertTrue(
                run_test_success, msg=msg if msg is not None else "failed runTests"
            )

        @contextmanager
        def assertRaisesParseException(
            self, exc_type=ParseException, expected_msg=None, msg=None
        ):
            if expected_msg is not None:
                if isinstance(expected_msg, str):
                    expected_msg = re.escape(expected_msg)
                with self.assertRaisesRegex(exc_type, expected_msg, msg=msg) as ctx:
                    yield ctx

            else:
                with self.assertRaises(exc_type, msg=msg) as ctx:
                    yield ctx

    @staticmethod
    def with_line_numbers(
        s: str,
        start_line: typing.Optional[int] = None,
        end_line: typing.Optional[int] = None,
        expand_tabs: bool = True,
        eol_mark: str = "|",
        mark_spaces: typing.Optional[str] = None,
        mark_control: typing.Optional[str] = None,
        *,
        indent: typing.Union[str, int] = "",
        base_1: bool = True,
    ) -> str:
        """
        Helpful method for debugging a parser - prints a string with line and column numbers.
        (Line and column numbers are 1-based by default - if debugging a parse action,
        pass base_1=False, to correspond to the loc value passed to the parse action.)

        :param s: tuple(bool, str - string to be printed with line and column numbers
        :param start_line: int - (optional) starting line number in s to print (default=1)
        :param end_line: int - (optional) ending line number in s to print (default=len(s))
        :param expand_tabs: bool - (optional) expand tabs to spaces, to match the pyparsing default
        :param eol_mark: str - (optional) string to mark the end of lines, helps visualize trailing spaces (default="|")
        :param mark_spaces: str - (optional) special character to display in place of spaces
        :param mark_control: str - (optional) convert non-printing control characters to a placeholding
                                 character; valid values:
                                 - "unicode" - replaces control chars with Unicode symbols, such as "␍" and "␊"
                                 - any single character string - replace control characters with given string
                                 - None (default) - string is displayed as-is
        :param indent: str | int - (optional) string to indent with line and column numbers; if an int
                                   is passed, converted to " " * indent
        :param base_1: bool - (optional) whether to label string using base 1; if False, string will be
                              labeled based at 0 (default=True)

        :return: str - input string with leading line numbers and column number headers
        """
        if expand_tabs:
            s = s.expandtabs()
        if isinstance(indent, int):
            indent = " " * indent
        indent = indent.expandtabs()
        if mark_control is not None:
            mark_control = typing.cast(str, mark_control)
            if mark_control == "unicode":
                transtable_map = {
                    c: u for c, u in zip(range(0, 33), range(0x2400, 0x2433))
                }
                transtable_map[127] = 0x2421
                tbl = str.maketrans(transtable_map)
                eol_mark = ""
            else:
                ord_mark_control = ord(mark_control)
                tbl = str.maketrans(
                    {c: ord_mark_control for c in list(range(0, 32)) + [127]}
                )
            s = s.translate(tbl)
        if mark_spaces is not None and mark_spaces != " ":
            if mark_spaces == "unicode":
                tbl = str.maketrans({9: 0x2409, 32: 0x2423})
                s = s.translate(tbl)
            else:
                s = s.replace(" ", mark_spaces)
        if start_line is None:
            start_line = 0
        if end_line is None:
            end_line = len(s)
        end_line = min(end_line, len(s))
        start_line = min(max(0, start_line), end_line)

        if mark_control != "unicode":
            s_lines = s.splitlines()[start_line - base_1 : end_line]
        else:
            s_lines = [
                line + "␊" for line in s.split("␊")[start_line - base_1 : end_line]
            ]
        if not s_lines:
            return ""

        lineno_width = len(str(end_line))
        max_line_len = max(len(line) for line in s_lines)
        lead = indent + " " * (lineno_width + 1)
        if max_line_len >= 99:
            header0 = (
                lead
                + ("" if base_1 else " ")
                + "".join(
                    f"{' ' * 99}{(i + 1) % 100}"
                    for i in range(1 if base_1 else 0, max(max_line_len // 100, 1))
                )
                + "\n"
            )
        else:
            header0 = ""
        header1 = (
            ("" if base_1 else " ")
            + lead
            + "".join(f"         {(i + 1) % 10}" for i in range(-(-max_line_len // 10)))
            + "\n"
        )
        digits = "1234567890"
        header2 = (
            lead + ("" if base_1 else "0") + digits * (-(-max_line_len // 10)) + "\n"
        )
        return (
            header1
            + header2
            + "\n".join(
                f"{indent}{i:{lineno_width}d}:{line}{eol_mark}"
                for i, line in enumerate(s_lines, start=start_line + base_1)
            )
            + "\n"
        )


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\tools\__init__.py
# ================================================================================



# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\tools\cvt_pyparsing_pep8_names.py
# ================================================================================

from functools import lru_cache
import pyparsing as pp


@lru_cache(maxsize=None)
def camel_to_snake(s: str) -> str:
    """
    Convert CamelCase to snake_case.
    """
    return "".join("_" + c.lower() if c.isupper() else c for c in s).lstrip("_")


pre_pep8_method_names = """
addCondition addParseAction anyCloseTag anyOpenTag asDict asList cStyleComment canParseNext conditionAsParseAction 
convertToDate convertToDatetime convertToFloat convertToInteger countedArray cppStyleComment dblQuotedString 
dblSlashComment defaultName dictOf disableMemoization downcaseTokens enableLeftRecursion enablePackrat getName 
htmlComment ignoreWhitespace indentedBlock infixNotation inlineLiteralsUsing javaStyleComment leaveWhitespace 
lineEnd lineStart locatedExpr matchOnlyAtCol matchPreviousExpr matchPreviousLiteral nestedExpr nullDebugAction oneOf 
originalTextFor parseFile parseString parseWithTabs pythonStyleComment quotedString removeQuotes replaceWith 
resetCache restOfLine runTests scanString searchString setBreak setDebug setDebugActions setDefaultWhitespaceChars 
setFailAction setName setParseAction setResultsName setWhitespaceChars sglQuotedString stringEnd stringStart tokenMap 
traceParseAction transformString tryParse unicodeString upcaseTokens withAttribute withClass
""".split()

special_changes = {
    "opAssoc": "OpAssoc",
    "delimitedList": "DelimitedList",
    "delimited_list": "DelimitedList",
    "replaceHTMLEntity": "replace_html_entity",
    "makeHTMLTags": "make_html_tags",
    "makeXMLTags": "make_xml_tags",
    "commonHTMLEntity": "common_html_entity",
    "stripHTMLTags": "strip_html_tags",
}

pre_pep8_arg_names = """parseAll maxMatches listAllMatches callDuringTry includeSeparators fullDump printResults 
failureTests postParse matchString identChars maxMismatches initChars bodyChars asKeyword excludeChars asGroupList 
asMatch quoteChar escChar escQuote unquoteResults endQuoteChar convertWhitespaceEscapes notChars wordChars stopOn 
failOn joinString markerString intExpr useRegex asString ignoreExpr""".split()

pre_pep8_method_name = pp.one_of(pre_pep8_method_names, as_keyword=True)
pre_pep8_method_name.set_parse_action(lambda t: camel_to_snake(t[0]))
special_pre_pep8_name = pp.one_of(special_changes, as_keyword=True)
special_pre_pep8_name.set_parse_action(lambda t: special_changes[t[0]])
# only replace arg names if part of an arg list
pre_pep8_arg_name = pp.Regex(
    rf"{pp.util.make_compressed_re(pre_pep8_arg_names)}\s*="
)
pre_pep8_arg_name.set_parse_action(lambda t: camel_to_snake(t[0]))

pep8_converter = pre_pep8_method_name | special_pre_pep8_name | pre_pep8_arg_name

if __name__ == "__main__":
    import argparse
    from pathlib import Path
    import sys

    argparser = argparse.ArgumentParser(
        description = (
            "Utility to convert Python pyparsing scripts using legacy"
            " camelCase names to use PEP8 snake_case names."
            "\nBy default, this script will only show whether this script would make any changes."
        )
    )
    argparser.add_argument("--verbose", "-v", action="store_true", help="Show unified diff for each source file")
    argparser.add_argument("-vv", action="store_true", dest="verbose2", help="Show unified diff for each source file, plus names of scanned files with no changes")
    argparser.add_argument("--update", "-u", action="store_true", help="Update source files in-place")
    argparser.add_argument("--encoding", type=str, default="utf-8", help="Encoding of source files (default: utf-8)")
    argparser.add_argument("--exit-zero-even-if-changed", "-exit0", action="store_true", help="Exit with status code 0 even if changes were made")
    argparser.add_argument("source_filename", nargs="+", help="Source filenames or filename patterns of Python files to be converted")
    args = argparser.parse_args()


    def show_diffs(original, modified):
        import difflib

        diff = difflib.unified_diff(
            original.splitlines(), modified.splitlines(), lineterm=""
        )
        sys.stdout.writelines(f"{diff_line}\n" for diff_line in diff)

    exit_status = 0

    for filename_pattern in args.source_filename:

        for filename in Path().glob(filename_pattern):
            if not Path(filename).is_file():
                continue

            try:
                original_contents = Path(filename).read_text(encoding=args.encoding)
                modified_contents = pep8_converter.transform_string(
                    original_contents
                )

                if modified_contents != original_contents:
                    if args.update:
                        Path(filename).write_text(modified_contents, encoding=args.encoding)
                        print(f"Converted {filename}")
                    else:
                        print(f"Found required changes in {filename}")

                    if args.verbose:
                        show_diffs(original_contents, modified_contents)
                        print()

                    exit_status = 1

                else:
                    if args.verbose2:
                        print(f"No required changes in {filename}")

            except Exception as e:
                print(f"Failed to convert {filename}: {type(e).__name__}: {e}")

    sys.exit(exit_status if not args.exit_zero_even_if_changed else 0)


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\unicode.py
# ================================================================================

# unicode.py

import sys
from itertools import filterfalse
from typing import Union


class _lazyclassproperty:
    def __init__(self, fn):
        self.fn = fn
        self.__doc__ = fn.__doc__
        self.__name__ = fn.__name__

    def __get__(self, obj, cls):
        if cls is None:
            cls = type(obj)
        if not hasattr(cls, "_intern") or any(
            cls._intern is getattr(superclass, "_intern", [])
            for superclass in cls.__mro__[1:]
        ):
            cls._intern = {}
        attrname = self.fn.__name__
        if attrname not in cls._intern:
            cls._intern[attrname] = self.fn(cls)
        return cls._intern[attrname]


UnicodeRangeList = list[Union[tuple[int, int], tuple[int]]]


class unicode_set:
    """
    A set of Unicode characters, for language-specific strings for
    ``alphas``, ``nums``, ``alphanums``, and ``printables``.
    A unicode_set is defined by a list of ranges in the Unicode character
    set, in a class attribute ``_ranges``. Ranges can be specified using
    2-tuples or a 1-tuple, such as::

        _ranges = [
            (0x0020, 0x007e),
            (0x00a0, 0x00ff),
            (0x0100,),
            ]

    Ranges are left- and right-inclusive. A 1-tuple of (x,) is treated as (x, x).

    A unicode set can also be defined using multiple inheritance of other unicode sets::

        class CJK(Chinese, Japanese, Korean):
            pass
    """

    _ranges: UnicodeRangeList = []

    @_lazyclassproperty
    def _chars_for_ranges(cls) -> list[str]:
        ret: list[int] = []
        for cc in cls.__mro__:  # type: ignore[attr-defined]
            if cc is unicode_set:
                break
            for rr in getattr(cc, "_ranges", ()):
                ret.extend(range(rr[0], rr[-1] + 1))
        return sorted(chr(c) for c in set(ret))

    @_lazyclassproperty
    def printables(cls) -> str:
        """all non-whitespace characters in this range"""
        return "".join(filterfalse(str.isspace, cls._chars_for_ranges))

    @_lazyclassproperty
    def alphas(cls) -> str:
        """all alphabetic characters in this range"""
        return "".join(filter(str.isalpha, cls._chars_for_ranges))

    @_lazyclassproperty
    def nums(cls) -> str:
        """all numeric digit characters in this range"""
        return "".join(filter(str.isdigit, cls._chars_for_ranges))

    @_lazyclassproperty
    def alphanums(cls) -> str:
        """all alphanumeric characters in this range"""
        return cls.alphas + cls.nums

    @_lazyclassproperty
    def identchars(cls) -> str:
        """all characters in this range that are valid identifier characters, plus underscore '_'"""
        return "".join(
            sorted(
                set(filter(str.isidentifier, cls._chars_for_ranges))
                | set(
                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzªµº"
                    "ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ"
                    "_"
                )
            )
        )

    @_lazyclassproperty
    def identbodychars(cls) -> str:
        """
        all characters in this range that are valid identifier body characters,
        plus the digits 0-9, and · (Unicode MIDDLE DOT)
        """
        identifier_chars = set(
            c for c in cls._chars_for_ranges if ("_" + c).isidentifier()
        )
        return "".join(
            sorted(identifier_chars | set(cls.identchars) | set("0123456789·"))
        )

    @_lazyclassproperty
    def identifier(cls):
        """
        a pyparsing Word expression for an identifier using this range's definitions for
        identchars and identbodychars
        """
        from pyparsing import Word

        return Word(cls.identchars, cls.identbodychars)


class pyparsing_unicode(unicode_set):
    """
    A namespace class for defining common language unicode_sets.
    """

    # fmt: off

    # define ranges in language character sets
    _ranges: UnicodeRangeList = [
        (0x0020, sys.maxunicode),
    ]

    class BasicMultilingualPlane(unicode_set):
        """Unicode set for the Basic Multilingual Plane"""
        _ranges: UnicodeRangeList = [
            (0x0020, 0xFFFF),
        ]

    class Latin1(unicode_set):
        """Unicode set for Latin-1 Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x0020, 0x007E),
            (0x00A0, 0x00FF),
        ]

    class LatinA(unicode_set):
        """Unicode set for Latin-A Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x0100, 0x017F),
        ]

    class LatinB(unicode_set):
        """Unicode set for Latin-B Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x0180, 0x024F),
        ]

    class Greek(unicode_set):
        """Unicode set for Greek Unicode Character Ranges"""
        _ranges: UnicodeRangeList = [
            (0x0342, 0x0345),
            (0x0370, 0x0377),
            (0x037A, 0x037F),
            (0x0384, 0x038A),
            (0x038C,),
            (0x038E, 0x03A1),
            (0x03A3, 0x03E1),
            (0x03F0, 0x03FF),
            (0x1D26, 0x1D2A),
            (0x1D5E,),
            (0x1D60,),
            (0x1D66, 0x1D6A),
            (0x1F00, 0x1F15),
            (0x1F18, 0x1F1D),
            (0x1F20, 0x1F45),
            (0x1F48, 0x1F4D),
            (0x1F50, 0x1F57),
            (0x1F59,),
            (0x1F5B,),
            (0x1F5D,),
            (0x1F5F, 0x1F7D),
            (0x1F80, 0x1FB4),
            (0x1FB6, 0x1FC4),
            (0x1FC6, 0x1FD3),
            (0x1FD6, 0x1FDB),
            (0x1FDD, 0x1FEF),
            (0x1FF2, 0x1FF4),
            (0x1FF6, 0x1FFE),
            (0x2129,),
            (0x2719, 0x271A),
            (0xAB65,),
            (0x10140, 0x1018D),
            (0x101A0,),
            (0x1D200, 0x1D245),
            (0x1F7A1, 0x1F7A7),
        ]

    class Cyrillic(unicode_set):
        """Unicode set for Cyrillic Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x0400, 0x052F),
            (0x1C80, 0x1C88),
            (0x1D2B,),
            (0x1D78,),
            (0x2DE0, 0x2DFF),
            (0xA640, 0xA672),
            (0xA674, 0xA69F),
            (0xFE2E, 0xFE2F),
        ]

    class Chinese(unicode_set):
        """Unicode set for Chinese Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x2E80, 0x2E99),
            (0x2E9B, 0x2EF3),
            (0x31C0, 0x31E3),
            (0x3400, 0x4DB5),
            (0x4E00, 0x9FEF),
            (0xA700, 0xA707),
            (0xF900, 0xFA6D),
            (0xFA70, 0xFAD9),
            (0x16FE2, 0x16FE3),
            (0x1F210, 0x1F212),
            (0x1F214, 0x1F23B),
            (0x1F240, 0x1F248),
            (0x20000, 0x2A6D6),
            (0x2A700, 0x2B734),
            (0x2B740, 0x2B81D),
            (0x2B820, 0x2CEA1),
            (0x2CEB0, 0x2EBE0),
            (0x2F800, 0x2FA1D),
        ]

    class Japanese(unicode_set):
        """Unicode set for Japanese Unicode Character Range, combining Kanji, Hiragana, and Katakana ranges"""

        class Kanji(unicode_set):
            "Unicode set for Kanji Unicode Character Range"
            _ranges: UnicodeRangeList = [
                (0x4E00, 0x9FBF),
                (0x3000, 0x303F),
            ]

        class Hiragana(unicode_set):
            """Unicode set for Hiragana Unicode Character Range"""
            _ranges: UnicodeRangeList = [
                (0x3041, 0x3096),
                (0x3099, 0x30A0),
                (0x30FC,),
                (0xFF70,),
                (0x1B001,),
                (0x1B150, 0x1B152),
                (0x1F200,),
            ]

        class Katakana(unicode_set):
            """Unicode set for Katakana  Unicode Character Range"""
            _ranges: UnicodeRangeList = [
                (0x3099, 0x309C),
                (0x30A0, 0x30FF),
                (0x31F0, 0x31FF),
                (0x32D0, 0x32FE),
                (0xFF65, 0xFF9F),
                (0x1B000,),
                (0x1B164, 0x1B167),
                (0x1F201, 0x1F202),
                (0x1F213,),
            ]

        漢字 = Kanji
        カタカナ = Katakana
        ひらがな = Hiragana

        _ranges = (
            Kanji._ranges
            + Hiragana._ranges
            + Katakana._ranges
        )

    class Hangul(unicode_set):
        """Unicode set for Hangul (Korean) Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x1100, 0x11FF),
            (0x302E, 0x302F),
            (0x3131, 0x318E),
            (0x3200, 0x321C),
            (0x3260, 0x327B),
            (0x327E,),
            (0xA960, 0xA97C),
            (0xAC00, 0xD7A3),
            (0xD7B0, 0xD7C6),
            (0xD7CB, 0xD7FB),
            (0xFFA0, 0xFFBE),
            (0xFFC2, 0xFFC7),
            (0xFFCA, 0xFFCF),
            (0xFFD2, 0xFFD7),
            (0xFFDA, 0xFFDC),
        ]

    Korean = Hangul

    class CJK(Chinese, Japanese, Hangul):
        """Unicode set for combined Chinese, Japanese, and Korean (CJK) Unicode Character Range"""

    class Thai(unicode_set):
        """Unicode set for Thai Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x0E01, 0x0E3A),
            (0x0E3F, 0x0E5B)
        ]

    class Arabic(unicode_set):
        """Unicode set for Arabic Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x0600, 0x061B),
            (0x061E, 0x06FF),
            (0x0700, 0x077F),
        ]

    class Hebrew(unicode_set):
        """Unicode set for Hebrew Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x0591, 0x05C7),
            (0x05D0, 0x05EA),
            (0x05EF, 0x05F4),
            (0xFB1D, 0xFB36),
            (0xFB38, 0xFB3C),
            (0xFB3E,),
            (0xFB40, 0xFB41),
            (0xFB43, 0xFB44),
            (0xFB46, 0xFB4F),
        ]

    class Devanagari(unicode_set):
        """Unicode set for Devanagari Unicode Character Range"""
        _ranges: UnicodeRangeList = [
            (0x0900, 0x097F),
            (0xA8E0, 0xA8FF)
        ]

    BMP = BasicMultilingualPlane

    # add language identifiers using language Unicode
    العربية = Arabic
    中文 = Chinese
    кириллица = Cyrillic
    Ελληνικά = Greek
    עִברִית = Hebrew
    日本語 = Japanese
    한국어 = Korean
    ไทย = Thai
    देवनागरी = Devanagari

    # fmt: on


# ================================================================================
# Datei: venv\Lib\site-packages\pyparsing\util.py
# ================================================================================

# util.py
import contextlib
import re
from functools import lru_cache, wraps
import inspect
import itertools
import types
from typing import Callable, Union, Iterable, TypeVar, cast
import warnings

_bslash = chr(92)
C = TypeVar("C", bound=Callable)


class __config_flags:
    """Internal class for defining compatibility and debugging flags"""

    _all_names: list[str] = []
    _fixed_names: list[str] = []
    _type_desc = "configuration"

    @classmethod
    def _set(cls, dname, value):
        if dname in cls._fixed_names:
            warnings.warn(
                f"{cls.__name__}.{dname} {cls._type_desc} is {str(getattr(cls, dname)).upper()}"
                f" and cannot be overridden",
                stacklevel=3,
            )
            return
        if dname in cls._all_names:
            setattr(cls, dname, value)
        else:
            raise ValueError(f"no such {cls._type_desc} {dname!r}")

    enable = classmethod(lambda cls, name: cls._set(name, True))
    disable = classmethod(lambda cls, name: cls._set(name, False))


@lru_cache(maxsize=128)
def col(loc: int, strg: str) -> int:
    """
    Returns current column within a string, counting newlines as line separators.
    The first column is number 1.

    Note: the default parsing behavior is to expand tabs in the input string
    before starting the parsing process.  See
    :class:`ParserElement.parse_string` for more
    information on parsing strings containing ``<TAB>`` s, and suggested
    methods to maintain a consistent view of the parsed string, the parse
    location, and line and column positions within the parsed string.
    """
    s = strg
    return 1 if 0 < loc < len(s) and s[loc - 1] == "\n" else loc - s.rfind("\n", 0, loc)


@lru_cache(maxsize=128)
def lineno(loc: int, strg: str) -> int:
    """Returns current line number within a string, counting newlines as line separators.
    The first line is number 1.

    Note - the default parsing behavior is to expand tabs in the input string
    before starting the parsing process.  See :class:`ParserElement.parse_string`
    for more information on parsing strings containing ``<TAB>`` s, and
    suggested methods to maintain a consistent view of the parsed string, the
    parse location, and line and column positions within the parsed string.
    """
    return strg.count("\n", 0, loc) + 1


@lru_cache(maxsize=128)
def line(loc: int, strg: str) -> str:
    """
    Returns the line of text containing loc within a string, counting newlines as line separators.
    """
    last_cr = strg.rfind("\n", 0, loc)
    next_cr = strg.find("\n", loc)
    return strg[last_cr + 1 : next_cr] if next_cr >= 0 else strg[last_cr + 1 :]


class _UnboundedCache:
    def __init__(self):
        cache = {}
        cache_get = cache.get
        self.not_in_cache = not_in_cache = object()

        def get(_, key):
            return cache_get(key, not_in_cache)

        def set_(_, key, value):
            cache[key] = value

        def clear(_):
            cache.clear()

        self.size = None
        self.get = types.MethodType(get, self)
        self.set = types.MethodType(set_, self)
        self.clear = types.MethodType(clear, self)


class _FifoCache:
    def __init__(self, size):
        cache = {}
        self.size = size
        self.not_in_cache = not_in_cache = object()
        cache_get = cache.get
        cache_pop = cache.pop

        def get(_, key):
            return cache_get(key, not_in_cache)

        def set_(_, key, value):
            cache[key] = value
            while len(cache) > size:
                # pop oldest element in cache by getting the first key
                cache_pop(next(iter(cache)))

        def clear(_):
            cache.clear()

        self.get = types.MethodType(get, self)
        self.set = types.MethodType(set_, self)
        self.clear = types.MethodType(clear, self)


class LRUMemo:
    """
    A memoizing mapping that retains `capacity` deleted items

    The memo tracks retained items by their access order; once `capacity` items
    are retained, the least recently used item is discarded.
    """

    def __init__(self, capacity):
        self._capacity = capacity
        self._active = {}
        self._memory = {}

    def __getitem__(self, key):
        try:
            return self._active[key]
        except KeyError:
            self._memory[key] = self._memory.pop(key)
            return self._memory[key]

    def __setitem__(self, key, value):
        self._memory.pop(key, None)
        self._active[key] = value

    def __delitem__(self, key):
        try:
            value = self._active.pop(key)
        except KeyError:
            pass
        else:
            oldest_keys = list(self._memory)[: -(self._capacity + 1)]
            for key_to_delete in oldest_keys:
                self._memory.pop(key_to_delete)
            self._memory[key] = value

    def clear(self):
        self._active.clear()
        self._memory.clear()


class UnboundedMemo(dict):
    """
    A memoizing mapping that retains all deleted items
    """

    def __delitem__(self, key):
        pass


def _escape_regex_range_chars(s: str) -> str:
    # escape these chars: ^-[]
    for c in r"\^-[]":
        s = s.replace(c, _bslash + c)
    s = s.replace("\n", r"\n")
    s = s.replace("\t", r"\t")
    return str(s)


class _GroupConsecutive:
    """
    Used as a callable `key` for itertools.groupby to group
    characters that are consecutive:
        itertools.groupby("abcdejkmpqrs", key=IsConsecutive())
        yields:
            (0, iter(['a', 'b', 'c', 'd', 'e']))
            (1, iter(['j', 'k']))
            (2, iter(['m']))
            (3, iter(['p', 'q', 'r', 's']))
    """

    def __init__(self) -> None:
        self.prev = 0
        self.counter = itertools.count()
        self.value = -1

    def __call__(self, char: str) -> int:
        c_int = ord(char)
        self.prev, prev = c_int, self.prev
        if c_int - prev > 1:
            self.value = next(self.counter)
        return self.value


def _collapse_string_to_ranges(
    s: Union[str, Iterable[str]], re_escape: bool = True
) -> str:
    r"""
    Take a string or list of single-character strings, and return
    a string of the consecutive characters in that string collapsed
    into groups, as might be used in a regular expression '[a-z]'
    character set:
        'a' -> 'a' -> '[a]'
        'bc' -> 'bc' -> '[bc]'
        'defgh' -> 'd-h' -> '[d-h]'
        'fdgeh' -> 'd-h' -> '[d-h]'
        'jklnpqrtu' -> 'j-lnp-rtu' -> '[j-lnp-rtu]'
    Duplicates get collapsed out:
        'aaa' -> 'a' -> '[a]'
        'bcbccb' -> 'bc' -> '[bc]'
        'defghhgf' -> 'd-h' -> '[d-h]'
        'jklnpqrjjjtu' -> 'j-lnp-rtu' -> '[j-lnp-rtu]'
    Spaces are preserved:
        'ab c' -> ' a-c' -> '[ a-c]'
    Characters that are significant when defining regex ranges
    get escaped:
        'acde[]-' -> r'\-\[\]ac-e' -> r'[\-\[\]ac-e]'
    """

    # Developer notes:
    # - Do not optimize this code assuming that the given input string
    #   or internal lists will be short (such as in loading generators into
    #   lists to make it easier to find the last element); this method is also
    #   used to generate regex ranges for character sets in the pyparsing.unicode
    #   classes, and these can be _very_ long lists of strings

    def escape_re_range_char(c: str) -> str:
        return "\\" + c if c in r"\^-][" else c

    def no_escape_re_range_char(c: str) -> str:
        return c

    if not re_escape:
        escape_re_range_char = no_escape_re_range_char

    ret = []

    # reduce input string to remove duplicates, and put in sorted order
    s_chars: list[str] = sorted(set(s))

    if len(s_chars) > 2:
        # find groups of characters that are consecutive (can be collapsed
        # down to "<first>-<last>")
        for _, chars in itertools.groupby(s_chars, key=_GroupConsecutive()):
            # _ is unimportant, is just used to identify groups
            # chars is an iterator of one or more consecutive characters
            # that comprise the current group
            first = last = next(chars)
            with contextlib.suppress(ValueError):
                *_, last = chars

            if first == last:
                # there was only a single char in this group
                ret.append(escape_re_range_char(first))

            elif last == chr(ord(first) + 1):
                # there were only 2 characters in this group
                #   'a','b' -> 'ab'
                ret.append(f"{escape_re_range_char(first)}{escape_re_range_char(last)}")

            else:
                # there were > 2 characters in this group, make into a range
                #   'c','d','e' -> 'c-e'
                ret.append(
                    f"{escape_re_range_char(first)}-{escape_re_range_char(last)}"
                )
    else:
        # only 1 or 2 chars were given to form into groups
        #   'a' -> ['a']
        #   'bc' -> ['b', 'c']
        #   'dg' -> ['d', 'g']
        # no need to list them with "-", just return as a list
        # (after escaping)
        ret = [escape_re_range_char(c) for c in s_chars]

    return "".join(ret)


def _flatten(ll: Iterable) -> list:
    ret = []
    to_visit = [*ll]
    while to_visit:
        i = to_visit.pop(0)
        if isinstance(i, Iterable) and not isinstance(i, str):
            to_visit[:0] = i
        else:
            ret.append(i)
    return ret


def make_compressed_re(
    word_list: Iterable[str],
    max_level: int = 2,
    *,
    non_capturing_groups: bool = True,
    _level: int = 1,
) -> str:
    """
    Create a regular expression string from a list of words, collapsing by common
    prefixes and optional suffixes.

    Calls itself recursively to build nested sublists for each group of suffixes
    that have a shared prefix.
    """

    def get_suffixes_from_common_prefixes(namelist: list[str]):
        if len(namelist) > 1:
            for prefix, suffixes in itertools.groupby(namelist, key=lambda s: s[:1]):
                yield prefix, sorted([s[1:] for s in suffixes], key=len, reverse=True)
        else:
            yield namelist[0][0], [namelist[0][1:]]

    if _level == 1:
        if not word_list:
            raise ValueError("no words given to make_compressed_re()")

        if "" in word_list:
            raise ValueError("word list cannot contain empty string")
    else:
        # internal recursive call, just return empty string if no words
        if not word_list:
            return ""

    # dedupe the word list
    word_list = list({}.fromkeys(word_list))

    if max_level == 0:
        if any(len(wd) > 1 for wd in word_list):
            return "|".join(
                sorted([re.escape(wd) for wd in word_list], key=len, reverse=True)
            )
        else:
            return f"[{''.join(_escape_regex_range_chars(wd) for wd in word_list)}]"

    ret = []
    sep = ""
    ncgroup = "?:" if non_capturing_groups else ""

    for initial, suffixes in get_suffixes_from_common_prefixes(sorted(word_list)):
        ret.append(sep)
        sep = "|"

        initial = re.escape(initial)

        trailing = ""
        if "" in suffixes:
            trailing = "?"
            suffixes.remove("")

        if len(suffixes) > 1:
            if all(len(s) == 1 for s in suffixes):
                ret.append(
                    f"{initial}[{''.join(_escape_regex_range_chars(s) for s in suffixes)}]{trailing}"
                )
            else:
                if _level < max_level:
                    suffix_re = make_compressed_re(
                        sorted(suffixes),
                        max_level,
                        non_capturing_groups=non_capturing_groups,
                        _level=_level + 1,
                    )
                    ret.append(f"{initial}({ncgroup}{suffix_re}){trailing}")
                else:
                    if all(len(s) == 1 for s in suffixes):
                        ret.append(
                            f"{initial}[{''.join(_escape_regex_range_chars(s) for s in suffixes)}]{trailing}"
                        )
                    else:
                        suffixes.sort(key=len, reverse=True)
                        ret.append(
                            f"{initial}({ncgroup}{'|'.join(re.escape(s) for s in suffixes)}){trailing}"
                        )
        else:
            if suffixes:
                suffix = re.escape(suffixes[0])
                if len(suffix) > 1 and trailing:
                    ret.append(f"{initial}({ncgroup}{suffix}){trailing}")
                else:
                    ret.append(f"{initial}{suffix}{trailing}")
            else:
                ret.append(initial)
    return "".join(ret)


def replaced_by_pep8(compat_name: str, fn: C) -> C:
    # In a future version, uncomment the code in the internal _inner() functions
    # to begin emitting DeprecationWarnings.

    # Unwrap staticmethod/classmethod
    fn = getattr(fn, "__func__", fn)

    # (Presence of 'self' arg in signature is used by explain_exception() methods, so we take
    # some extra steps to add it if present in decorated function.)
    if ["self"] == list(inspect.signature(fn).parameters)[:1]:

        @wraps(fn)
        def _inner(self, *args, **kwargs):
            # warnings.warn(
            #     f"Deprecated - use {fn.__name__}", DeprecationWarning, stacklevel=2
            # )
            return fn(self, *args, **kwargs)

    else:

        @wraps(fn)
        def _inner(*args, **kwargs):
            # warnings.warn(
            #     f"Deprecated - use {fn.__name__}", DeprecationWarning, stacklevel=2
            # )
            return fn(*args, **kwargs)

    _inner.__doc__ = f"""Deprecated - use :class:`{fn.__name__}`"""
    _inner.__name__ = compat_name
    _inner.__annotations__ = fn.__annotations__
    if isinstance(fn, types.FunctionType):
        _inner.__kwdefaults__ = fn.__kwdefaults__  # type: ignore [attr-defined]
    elif isinstance(fn, type) and hasattr(fn, "__init__"):
        _inner.__kwdefaults__ = fn.__init__.__kwdefaults__  # type: ignore [misc,attr-defined]
    else:
        _inner.__kwdefaults__ = None  # type: ignore [attr-defined]
    _inner.__qualname__ = fn.__qualname__
    return cast(C, _inner)


# ================================================================================
# Datei: venv\Lib\site-packages\sniffio\__init__.py
# ================================================================================

"""Top-level package for sniffio."""

__all__ = [
    "current_async_library",
    "AsyncLibraryNotFoundError",
    "current_async_library_cvar",
    "thread_local",
]

from ._version import __version__

from ._impl import (
    current_async_library,
    AsyncLibraryNotFoundError,
    current_async_library_cvar,
    thread_local,
)


# ================================================================================
# Datei: venv\Lib\site-packages\sniffio\_impl.py
# ================================================================================

from contextvars import ContextVar
from typing import Optional
import sys
import threading

current_async_library_cvar = ContextVar(
    "current_async_library_cvar", default=None
)  # type: ContextVar[Optional[str]]


class _ThreadLocal(threading.local):
    # Since threading.local provides no explicit mechanism is for setting
    # a default for a value, a custom class with a class attribute is used
    # instead.
    name = None  # type: Optional[str]


thread_local = _ThreadLocal()


class AsyncLibraryNotFoundError(RuntimeError):
    pass


def current_async_library() -> str:
    """Detect which async library is currently running.

    The following libraries are currently supported:

    ================   ===========  ============================
    Library             Requires     Magic string
    ================   ===========  ============================
    **Trio**            Trio v0.6+   ``"trio"``
    **Curio**           -            ``"curio"``
    **asyncio**                      ``"asyncio"``
    **Trio-asyncio**    v0.8.2+     ``"trio"`` or ``"asyncio"``,
                                    depending on current mode
    ================   ===========  ============================

    Returns:
      A string like ``"trio"``.

    Raises:
      AsyncLibraryNotFoundError: if called from synchronous context,
        or if the current async library was not recognized.

    Examples:

        .. code-block:: python3

           from sniffio import current_async_library

           async def generic_sleep(seconds):
               library = current_async_library()
               if library == "trio":
                   import trio
                   await trio.sleep(seconds)
               elif library == "asyncio":
                   import asyncio
                   await asyncio.sleep(seconds)
               # ... and so on ...
               else:
                   raise RuntimeError(f"Unsupported library {library!r}")

    """
    value = thread_local.name
    if value is not None:
        return value

    value = current_async_library_cvar.get()
    if value is not None:
        return value

    # Need to sniff for asyncio
    if "asyncio" in sys.modules:
        import asyncio
        try:
            current_task = asyncio.current_task  # type: ignore[attr-defined]
        except AttributeError:
            current_task = asyncio.Task.current_task  # type: ignore[attr-defined]
        try:
            if current_task() is not None:
                return "asyncio"
        except RuntimeError:
            pass

    # Sniff for curio (for now)
    if 'curio' in sys.modules:
        from curio.meta import curio_running
        if curio_running():
            return 'curio'

    raise AsyncLibraryNotFoundError(
        "unknown async library, or not in async context"
    )


# ================================================================================
# Datei: venv\Lib\site-packages\sniffio\_tests\__init__.py
# ================================================================================



# ================================================================================
# Datei: venv\Lib\site-packages\sniffio\_tests\test_sniffio.py
# ================================================================================

import os
import sys

import pytest

from .. import (
    current_async_library, AsyncLibraryNotFoundError,
    current_async_library_cvar, thread_local
)


def test_basics_cvar():
    with pytest.raises(AsyncLibraryNotFoundError):
        current_async_library()

    token = current_async_library_cvar.set("generic-lib")
    try:
        assert current_async_library() == "generic-lib"
    finally:
        current_async_library_cvar.reset(token)

    with pytest.raises(AsyncLibraryNotFoundError):
        current_async_library()


def test_basics_tlocal():
    with pytest.raises(AsyncLibraryNotFoundError):
        current_async_library()

    old_name, thread_local.name = thread_local.name, "generic-lib"
    try:
        assert current_async_library() == "generic-lib"
    finally:
        thread_local.name = old_name

    with pytest.raises(AsyncLibraryNotFoundError):
        current_async_library()


def test_asyncio():
    import asyncio

    with pytest.raises(AsyncLibraryNotFoundError):
        current_async_library()

    ran = []

    async def this_is_asyncio():
        assert current_async_library() == "asyncio"
        # Call it a second time to exercise the caching logic
        assert current_async_library() == "asyncio"
        ran.append(True)

    asyncio.run(this_is_asyncio())
    assert ran == [True]

    with pytest.raises(AsyncLibraryNotFoundError):
        current_async_library()


@pytest.mark.skipif(
    sys.version_info >= (3, 12),
    reason=
    "curio broken on 3.12 (https://github.com/python-trio/sniffio/pull/42)",
)
def test_curio():
    import curio

    with pytest.raises(AsyncLibraryNotFoundError):
        current_async_library()

    ran = []

    async def this_is_curio():
        assert current_async_library() == "curio"
        # Call it a second time to exercise the caching logic
        assert current_async_library() == "curio"
        ran.append(True)

    curio.run(this_is_curio)
    assert ran == [True]

    with pytest.raises(AsyncLibraryNotFoundError):
        current_async_library()


# ================================================================================
# Datei: venv\Lib\site-packages\sniffio\_version.py
# ================================================================================

# This file is imported from __init__.py and exec'd from setup.py

__version__ = "1.3.1"


# ================================================================================
# Datei: venv\Lib\site-packages\tkinterdnd2\TkinterDnD.py
# ================================================================================

'''Python wrapper for the tkdnd tk extension.

The tkdnd extension provides an interface to native, platform specific
drag and drop mechanisms. Under Unix the drag & drop protocol in use is
the XDND protocol version 5 (also used by the Qt toolkit, and the KDE and
GNOME desktops). Under Windows, the OLE2 drag & drop interfaces are used.
Under Macintosh, the Cocoa drag and drop interfaces are used.

Once the TkinterDnD2 package is installed, it is safe to do:

from TkinterDnD2 import *

This will add the classes TkinterDnD.Tk to the global
namespace, plus the following constants:
PRIVATE, NONE, ASK, COPY, MOVE, LINK, REFUSE_DROP,
DND_TEXT, DND_FILES, DND_ALL, CF_UNICODETEXT, CF_TEXT, CF_HDROP,
FileGroupDescriptor, FileGroupDescriptorW

Drag and drop for the application can then be enabled by using one of the
classes TkinterDnD.Tk() as application main window instead of a regular
tkinter.Tk() window. This will add the drag-and-drop specific methods to the
Tk window and all its descendants.
'''

import tkinter

TkdndVersion = None

def _require(tkroot):
    '''Internal function.'''
    global TkdndVersion
    try:
        import os
        import platform

        # On Windows, platform.machine() returns the identifier of the
        # *host* architecture, which does not necessarily match the
        # architecture of the running python process. For example, when
        # running x86 python under x64 Windows, the return value is AMD64;
        # when running either x86 or x64 python under arm64 Windows, the
        # return value is ARM64. The architecture of the running process
        # can be obtained from the PROCESSOR_ARCHITECTURE environment variable,
        # which is automatically set by Windows / WOW subsystem.
        system = platform.system()
        if system=="Windows":
            machine = os.environ.get('PROCESSOR_ARCHITECTURE', platform.machine())
        else:
            machine = platform.machine()

        if system=="Darwin" and machine=="arm64":
            tkdnd_platform_rep = "osx-arm64"
        elif system=="Darwin" and machine=="x86_64":
            tkdnd_platform_rep = "osx-x64"
        elif system=="Linux" and machine=="aarch64":
            tkdnd_platform_rep = "linux-arm64"
        elif system=="Linux" and machine=="x86_64":
            tkdnd_platform_rep = "linux-x64"
        elif system=="Windows" and machine=="ARM64":
            tkdnd_platform_rep = "win-arm64"
        elif system=="Windows" and machine=="AMD64":
            tkdnd_platform_rep = "win-x64"
        elif system=="Windows" and machine=="x86":
            tkdnd_platform_rep = "win-x86"
        else:
            raise RuntimeError('Plaform not supported.')

        module_path = os.path.join(os.path.dirname(__file__), 'tkdnd', tkdnd_platform_rep)
        tkroot.tk.call('lappend', 'auto_path', module_path)
        TkdndVersion = tkroot.tk.call('package', 'require', 'tkdnd')
    except tkinter.TclError:
        raise RuntimeError('Unable to load tkdnd library.')
    return TkdndVersion

class DnDEvent:
    """Internal class.
    Container for the properties of a drag-and-drop event, similar to a
    normal tkinter.Event.
    An instance of the DnDEvent class has the following attributes:
        action (string)
        actions (tuple)
        button (int)
        code (string)
        codes (tuple)
        commonsourcetypes (tuple)
        commontargettypes (tuple)
        data (string)
        name (string)
        types (tuple)
        modifiers (tuple)
        supportedsourcetypes (tuple)
        sourcetypes (tuple)
        type (string)
        supportedtargettypes (tuple)
        widget (widget instance)
        x_root (int)
        y_root (int)
    Depending on the type of DnD event however, not all attributes may be set.
    """
    pass

class DnDWrapper:
    '''Internal class.'''
    # some of the percent substitutions need to be enclosed in braces
    # so we can use splitlist() to convert them into tuples
    _subst_format_dnd = ('%A', '%a', '%b', '%C', '%c', '{%CST}',
                         '{%CTT}', '%D', '%e', '{%L}', '{%m}', '{%ST}',
                         '%T', '{%t}', '{%TT}', '%W', '%X', '%Y')
    _subst_format_str_dnd = " ".join(_subst_format_dnd)
    tkinter.BaseWidget._subst_format_dnd = _subst_format_dnd
    tkinter.BaseWidget._subst_format_str_dnd = _subst_format_str_dnd

    def _substitute_dnd(self, *args):
        """Internal function."""
        if len(args) != len(self._subst_format_dnd):
            return args
        def getint_event(s):
            try:
                return int(s)
            except ValueError:
                return s
        def splitlist_event(s):
            try:
                return self.tk.splitlist(s)
            except ValueError:
                return s
        # valid percent substitutions for DnD event types
        # (tested with tkdnd-2.8 on debian jessie):
        # <<DragInitCmd>> : %W, %X, %Y %e, %t
        # <<DragEndCmd>> : %A, %W, %e
        # <<DropEnter>> : all except : %D (always empty)
        # <<DropLeave>> : all except %D (always empty)
        # <<DropPosition>> :all except %D (always empty)
        # <<Drop>> : all
        A, a, b, C, c, CST, CTT, D, e, L, m, ST, T, t, TT, W, X, Y = args
        ev = DnDEvent()
        ev.action = A
        ev.actions = splitlist_event(a)
        ev.button = getint_event(b)
        ev.code = C
        ev.codes = splitlist_event(c)
        ev.commonsourcetypes = splitlist_event(CST)
        ev.commontargettypes = splitlist_event(CTT)
        ev.data = D
        ev.name = e
        ev.types = splitlist_event(L)
        ev.modifiers = splitlist_event(m)
        ev.supportedsourcetypes = splitlist_event(ST)
        ev.sourcetypes = splitlist_event(t)
        ev.type = T
        ev.supportedtargettypes = splitlist_event(TT)
        try:
            ev.widget = self.nametowidget(W)
        except KeyError:
            ev.widget = W
        ev.x_root = getint_event(X)
        ev.y_root = getint_event(Y)
        return (ev,)
    tkinter.BaseWidget._substitute_dnd = _substitute_dnd

    def _dnd_bind(self, what, sequence, func, add, needcleanup=True):
        """Internal function."""
        if isinstance(func, str):
            self.tk.call(what + (sequence, func))
        elif func:
            funcid = self._register(func, self._substitute_dnd, needcleanup)
            # FIXME: why doesn't the "return 'break'" mechanism work here??
            #cmd = ('%sif {"[%s %s]" == "break"} break\n' % (add and '+' or '',
            #                              funcid, self._subst_format_str_dnd))
            cmd = '%s%s %s' %(add and '+' or '', funcid,
                                    self._subst_format_str_dnd)
            self.tk.call(what + (sequence, cmd))
            return funcid
        elif sequence:
            return self.tk.call(what + (sequence,))
        else:
            return self.tk.splitlist(self.tk.call(what))
    tkinter.BaseWidget._dnd_bind = _dnd_bind

    def dnd_bind(self, sequence=None, func=None, add=None):
        '''Bind to this widget at drag and drop event SEQUENCE a call
        to function FUNC.
        SEQUENCE may be one of the following:
        <<DropEnter>>, <<DropPosition>>, <<DropLeave>>, <<Drop>>,
        <<Drop:type>>, <<DragInitCmd>>, <<DragEndCmd>> .
        The callbacks for the <Drop*>> events, with the exception of
        <<DropLeave>>, should always return an action (i.e. one of COPY,
        MOVE, LINK, ASK or PRIVATE).
        The callback for the <<DragInitCmd>> event must return a tuple
        containing three elements: the drop action(s) supported by the
        drag source, the format type(s) that the data can be dropped as and
        finally the data that shall be dropped. Each of these three elements
        may be a tuple of strings or a single string.'''
        return self._dnd_bind(('bind', self._w), sequence, func, add)
    tkinter.BaseWidget.dnd_bind = dnd_bind

    def drag_source_register(self, button=None, *dndtypes):
        '''This command will register SELF as a drag source.
        A drag source is a widget than can start a drag action. This command
        can be executed multiple times on a widget.
        When SELF is registered as a drag source, optional DNDTYPES can be
        provided. These DNDTYPES will be provided during a drag action, and
        it can contain platform independent or platform specific types.
        Platform independent are DND_Text for dropping text portions and
        DND_Files for dropping a list of files (which can contain one or
        multiple files) on SELF. However, these types are
        indicative/informative. SELF can initiate a drag action with even a
        different type list. Finally, button is the mouse button that will be
        used for starting the drag action. It can have any of the values 1
        (left mouse button), 2 (middle mouse button - wheel) and 3
        (right mouse button). If button is not specified, it defaults to 1.'''
        # hack to fix a design bug from the first version
        if button is None:
            button = 1
        else:
            try:
                button = int(button)
            except ValueError:
                # no button defined, button is actually
                # something like DND_TEXT
                dndtypes = (button,) + dndtypes
                button = 1
        self.tk.call(
                'tkdnd::drag_source', 'register', self._w, dndtypes, button)
    tkinter.BaseWidget.drag_source_register = drag_source_register

    def drag_source_unregister(self):
        '''This command will stop SELF from being a drag source. Thus, window
        will stop receiving events related to drag operations. It is an error
        to use this command for a window that has not been registered as a
        drag source with drag_source_register().'''
        self.tk.call('tkdnd::drag_source', 'unregister', self._w)
    tkinter.BaseWidget.drag_source_unregister = drag_source_unregister

    def drop_target_register(self, *dndtypes):
        '''This command will register SELF as a drop target. A drop target is
        a widget than can accept a drop action. This command can be executed
        multiple times on a widget. When SELF is registered as a drop target,
        optional DNDTYPES can be provided. These types list can contain one or
        more types that SELF will accept during a drop action, and it can
        contain platform independent or platform specific types. Platform
        independent are DND_Text for dropping text portions and DND_Files for
        dropping a list of files (which can contain one or multiple files) on
        SELF.'''
        self.tk.call('tkdnd::drop_target', 'register', self._w, dndtypes)
    tkinter.BaseWidget.drop_target_register = drop_target_register

    def drop_target_unregister(self):
        '''This command will stop SELF from being a drop target. Thus, SELF
        will stop receiving events related to drop operations. It is an error
        to use this command for a window that has not been registered as a
        drop target with drop_target_register().'''
        self.tk.call('tkdnd::drop_target', 'unregister', self._w)
    tkinter.BaseWidget.drop_target_unregister = drop_target_unregister

    def platform_independent_types(self, *dndtypes):
        '''This command will accept a list of types that can contain platform
        independnent or platform specific types. A new list will be returned,
        where each platform specific type in DNDTYPES will be substituted by
        one or more platform independent types. Thus, the returned list may
        have more elements than DNDTYPES.'''
        return self.tk.split(self.tk.call(
                            'tkdnd::platform_independent_types', dndtypes))
    tkinter.BaseWidget.platform_independent_types = platform_independent_types

    def platform_specific_types(self, *dndtypes):
        '''This command will accept a list of types that can contain platform
        independnent or platform specific types. A new list will be returned,
        where each platform independent type in DNDTYPES will be substituted
        by one or more platform specific types. Thus, the returned list may
        have more elements than DNDTYPES.'''
        return self.tk.split(self.tk.call(
                            'tkdnd::platform_specific_types', dndtypes))
    tkinter.BaseWidget.platform_specific_types = platform_specific_types

    def get_dropfile_tempdir(self):
        '''This command will return the temporary directory used by TkDND for
        storing temporary files. When the package is loaded, this temporary
        directory will be initialised to a proper directory according to the
        operating system. This default initial value can be changed to be the
        value of the following environmental variables:
        TKDND_TEMP_DIR, TEMP, TMP.'''
        return self.tk.call('tkdnd::GetDropFileTempDirectory')
    tkinter.BaseWidget.get_dropfile_tempdir = get_dropfile_tempdir

    def set_dropfile_tempdir(self, tempdir):
        '''This command will change the temporary directory used by TkDND for
        storing temporary files to TEMPDIR.'''
        self.tk.call('tkdnd::SetDropFileTempDirectory', tempdir)
    tkinter.BaseWidget.set_dropfile_tempdir = set_dropfile_tempdir

#######################################################################
####      The main window classes that enable Drag & Drop for      ####
####      themselves and all their descendant widgets:             ####
#######################################################################

class Tk(tkinter.Tk, DnDWrapper):
    '''Creates a new instance of a tkinter.Tk() window; all methods of the
    DnDWrapper class apply to this window and all its descendants.'''
    def __init__(self, *args, **kw):
        tkinter.Tk.__init__(self, *args, **kw)
        self.TkdndVersion = _require(self)



# ================================================================================
# Datei: venv\Lib\site-packages\tkinterdnd2\__init__.py
# ================================================================================

# dnd actions
PRIVATE = 'private'
NONE = 'none'
ASK = 'ask'
COPY = 'copy'
MOVE = 'move'
LINK = 'link'
REFUSE_DROP = 'refuse_drop'

# dnd types
DND_TEXT = 'DND_Text'
DND_FILES = 'DND_Files'
DND_ALL = '*'
CF_UNICODETEXT = 'CF_UNICODETEXT'
CF_TEXT = 'CF_TEXT'
CF_HDROP = 'CF_HDROP'

FileGroupDescriptor = 'FileGroupDescriptor - FileContents'# ??
FileGroupDescriptorW = 'FileGroupDescriptorW - FileContents'# ??

from . import TkinterDnD
from .TkinterDnD import Tk




# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\__init__.py
# ================================================================================

from ._monitor import TMonitor, TqdmSynchronisationWarning
from ._tqdm_pandas import tqdm_pandas
from .cli import main  # TODO: remove in v5.0.0
from .gui import tqdm as tqdm_gui  # TODO: remove in v5.0.0
from .gui import trange as tgrange  # TODO: remove in v5.0.0
from .std import (
    TqdmDeprecationWarning, TqdmExperimentalWarning, TqdmKeyError, TqdmMonitorWarning,
    TqdmTypeError, TqdmWarning, tqdm, trange)
from .version import __version__

__all__ = ['tqdm', 'tqdm_gui', 'trange', 'tgrange', 'tqdm_pandas',
           'tqdm_notebook', 'tnrange', 'main', 'TMonitor',
           'TqdmTypeError', 'TqdmKeyError',
           'TqdmWarning', 'TqdmDeprecationWarning',
           'TqdmExperimentalWarning',
           'TqdmMonitorWarning', 'TqdmSynchronisationWarning',
           '__version__']


def tqdm_notebook(*args, **kwargs):  # pragma: no cover
    """See tqdm.notebook.tqdm for full documentation"""
    from warnings import warn

    from .notebook import tqdm as _tqdm_notebook
    warn("This function will be removed in tqdm==5.0.0\n"
         "Please use `tqdm.notebook.tqdm` instead of `tqdm.tqdm_notebook`",
         TqdmDeprecationWarning, stacklevel=2)
    return _tqdm_notebook(*args, **kwargs)


def tnrange(*args, **kwargs):  # pragma: no cover
    """Shortcut for `tqdm.notebook.tqdm(range(*args), **kwargs)`."""
    from warnings import warn

    from .notebook import trange as _tnrange
    warn("Please use `tqdm.notebook.trange` instead of `tqdm.tnrange`",
         TqdmDeprecationWarning, stacklevel=2)
    return _tnrange(*args, **kwargs)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\__main__.py
# ================================================================================

from .cli import main

main()


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\_dist_ver.py
# ================================================================================

__version__ = '4.67.1'


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\_main.py
# ================================================================================

from warnings import warn

from .cli import *  # NOQA
from .cli import __all__  # NOQA
from .std import TqdmDeprecationWarning

warn("This function will be removed in tqdm==5.0.0\n"
     "Please use `tqdm.cli.*` instead of `tqdm._main.*`",
     TqdmDeprecationWarning, stacklevel=2)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\_monitor.py
# ================================================================================

import atexit
from threading import Event, Thread, current_thread
from time import time
from warnings import warn

__all__ = ["TMonitor", "TqdmSynchronisationWarning"]


class TqdmSynchronisationWarning(RuntimeWarning):
    """tqdm multi-thread/-process errors which may cause incorrect nesting
    but otherwise no adverse effects"""
    pass


class TMonitor(Thread):
    """
    Monitoring thread for tqdm bars.
    Monitors if tqdm bars are taking too much time to display
    and readjusts miniters automatically if necessary.

    Parameters
    ----------
    tqdm_cls  : class
        tqdm class to use (can be core tqdm or a submodule).
    sleep_interval  : float
        Time to sleep between monitoring checks.
    """
    _test = {}  # internal vars for unit testing

    def __init__(self, tqdm_cls, sleep_interval):
        Thread.__init__(self)
        self.daemon = True  # kill thread when main killed (KeyboardInterrupt)
        self.woken = 0  # last time woken up, to sync with monitor
        self.tqdm_cls = tqdm_cls
        self.sleep_interval = sleep_interval
        self._time = self._test.get("time", time)
        self.was_killed = self._test.get("Event", Event)()
        atexit.register(self.exit)
        self.start()

    def exit(self):
        self.was_killed.set()
        if self is not current_thread():
            self.join()
        return self.report()

    def get_instances(self):
        # returns a copy of started `tqdm_cls` instances
        return [i for i in self.tqdm_cls._instances.copy()
                # Avoid race by checking that the instance started
                if hasattr(i, 'start_t')]

    def run(self):
        cur_t = self._time()
        while True:
            # After processing and before sleeping, notify that we woke
            # Need to be done just before sleeping
            self.woken = cur_t
            # Sleep some time...
            self.was_killed.wait(self.sleep_interval)
            # Quit if killed
            if self.was_killed.is_set():
                return
            # Then monitor!
            # Acquire lock (to access _instances)
            with self.tqdm_cls.get_lock():
                cur_t = self._time()
                # Check tqdm instances are waiting too long to print
                instances = self.get_instances()
                for instance in instances:
                    # Check event in loop to reduce blocking time on exit
                    if self.was_killed.is_set():
                        return
                    # Only if mininterval > 1 (else iterations are just slow)
                    # and last refresh exceeded maxinterval
                    if (
                        instance.miniters > 1
                        and (cur_t - instance.last_print_t) >= instance.maxinterval
                    ):
                        # force bypassing miniters on next iteration
                        # (dynamic_miniters adjusts mininterval automatically)
                        instance.miniters = 1
                        # Refresh now! (works only for manual tqdm)
                        instance.refresh(nolock=True)
                    # Remove accidental long-lived strong reference
                    del instance
                if instances != self.get_instances():  # pragma: nocover
                    warn("Set changed size during iteration" +
                         " (see https://github.com/tqdm/tqdm/issues/481)",
                         TqdmSynchronisationWarning, stacklevel=2)
                # Remove accidental long-lived strong references
                del instances

    def report(self):
        return not self.was_killed.is_set()


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\_tqdm.py
# ================================================================================

from warnings import warn

from .std import *  # NOQA
from .std import __all__  # NOQA
from .std import TqdmDeprecationWarning

warn("This function will be removed in tqdm==5.0.0\n"
     "Please use `tqdm.std.*` instead of `tqdm._tqdm.*`",
     TqdmDeprecationWarning, stacklevel=2)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\_tqdm_gui.py
# ================================================================================

from warnings import warn

from .gui import *  # NOQA
from .gui import __all__  # NOQA
from .std import TqdmDeprecationWarning

warn("This function will be removed in tqdm==5.0.0\n"
     "Please use `tqdm.gui.*` instead of `tqdm._tqdm_gui.*`",
     TqdmDeprecationWarning, stacklevel=2)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\_tqdm_notebook.py
# ================================================================================

from warnings import warn

from .notebook import *  # NOQA
from .notebook import __all__  # NOQA
from .std import TqdmDeprecationWarning

warn("This function will be removed in tqdm==5.0.0\n"
     "Please use `tqdm.notebook.*` instead of `tqdm._tqdm_notebook.*`",
     TqdmDeprecationWarning, stacklevel=2)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\_tqdm_pandas.py
# ================================================================================

import sys

__author__ = "github.com/casperdcl"
__all__ = ['tqdm_pandas']


def tqdm_pandas(tclass, **tqdm_kwargs):
    """
    Registers the given `tqdm` instance with
    `pandas.core.groupby.DataFrameGroupBy.progress_apply`.
    """
    from tqdm import TqdmDeprecationWarning

    if isinstance(tclass, type) or (getattr(tclass, '__name__', '').startswith(
            'tqdm_')):  # delayed adapter case
        TqdmDeprecationWarning(
            "Please use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm, ...)`.",
            fp_write=getattr(tqdm_kwargs.get('file', None), 'write', sys.stderr.write))
        tclass.pandas(**tqdm_kwargs)
    else:
        TqdmDeprecationWarning(
            "Please use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm(...))`.",
            fp_write=getattr(tclass.fp, 'write', sys.stderr.write))
        type(tclass).pandas(deprecated_t=tclass)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\_utils.py
# ================================================================================

from warnings import warn

from .std import TqdmDeprecationWarning
from .utils import (  # NOQA, pylint: disable=unused-import
    CUR_OS, IS_NIX, IS_WIN, RE_ANSI, Comparable, FormatReplace, SimpleTextIOWrapper,
    _environ_cols_wrapper, _is_ascii, _is_utf, _screen_shape_linux, _screen_shape_tput,
    _screen_shape_windows, _screen_shape_wrapper, _supports_unicode, _term_move_up, colorama)

warn("This function will be removed in tqdm==5.0.0\n"
     "Please use `tqdm.utils.*` instead of `tqdm._utils.*`",
     TqdmDeprecationWarning, stacklevel=2)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\asyncio.py
# ================================================================================

"""
Asynchronous progressbar decorator for iterators.
Includes a default `range` iterator printing to `stderr`.

Usage:
>>> from tqdm.asyncio import trange, tqdm
>>> async for i in trange(10):
...     ...
"""
import asyncio
from sys import version_info

from .std import tqdm as std_tqdm

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ['tqdm_asyncio', 'tarange', 'tqdm', 'trange']


class tqdm_asyncio(std_tqdm):
    """
    Asynchronous-friendly version of tqdm.
    """
    def __init__(self, iterable=None, *args, **kwargs):
        super().__init__(iterable, *args, **kwargs)
        self.iterable_awaitable = False
        if iterable is not None:
            if hasattr(iterable, "__anext__"):
                self.iterable_next = iterable.__anext__
                self.iterable_awaitable = True
            elif hasattr(iterable, "__next__"):
                self.iterable_next = iterable.__next__
            else:
                self.iterable_iterator = iter(iterable)
                self.iterable_next = self.iterable_iterator.__next__

    def __aiter__(self):
        return self

    async def __anext__(self):
        try:
            if self.iterable_awaitable:
                res = await self.iterable_next()
            else:
                res = self.iterable_next()
            self.update()
            return res
        except StopIteration:
            self.close()
            raise StopAsyncIteration
        except BaseException:
            self.close()
            raise

    def send(self, *args, **kwargs):
        return self.iterable.send(*args, **kwargs)

    @classmethod
    def as_completed(cls, fs, *, loop=None, timeout=None, total=None, **tqdm_kwargs):
        """
        Wrapper for `asyncio.as_completed`.
        """
        if total is None:
            total = len(fs)
        kwargs = {}
        if version_info[:2] < (3, 10):
            kwargs['loop'] = loop
        yield from cls(asyncio.as_completed(fs, timeout=timeout, **kwargs),
                       total=total, **tqdm_kwargs)

    @classmethod
    async def gather(cls, *fs, loop=None, timeout=None, total=None, **tqdm_kwargs):
        """
        Wrapper for `asyncio.gather`.
        """
        async def wrap_awaitable(i, f):
            return i, await f

        ifs = [wrap_awaitable(i, f) for i, f in enumerate(fs)]
        res = [await f for f in cls.as_completed(ifs, loop=loop, timeout=timeout,
                                                 total=total, **tqdm_kwargs)]
        return [i for _, i in sorted(res)]


def tarange(*args, **kwargs):
    """
    A shortcut for `tqdm.asyncio.tqdm(range(*args), **kwargs)`.
    """
    return tqdm_asyncio(range(*args), **kwargs)


# Aliases
tqdm = tqdm_asyncio
trange = tarange


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\auto.py
# ================================================================================

"""
Enables multiple commonly used features.

Method resolution order:

- `tqdm.autonotebook` without import warnings
- `tqdm.asyncio`
- `tqdm.std` base class

Usage:
>>> from tqdm.auto import trange, tqdm
>>> for i in trange(10):
...     ...
"""
import warnings

from .std import TqdmExperimentalWarning

with warnings.catch_warnings():
    warnings.simplefilter("ignore", category=TqdmExperimentalWarning)
    from .autonotebook import tqdm as notebook_tqdm

from .asyncio import tqdm as asyncio_tqdm
from .std import tqdm as std_tqdm

if notebook_tqdm != std_tqdm:
    class tqdm(notebook_tqdm, asyncio_tqdm):  # pylint: disable=inconsistent-mro
        pass
else:
    tqdm = asyncio_tqdm


def trange(*args, **kwargs):
    """
    A shortcut for `tqdm.auto.tqdm(range(*args), **kwargs)`.
    """
    return tqdm(range(*args), **kwargs)


__all__ = ["tqdm", "trange"]


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\autonotebook.py
# ================================================================================

"""
Automatically choose between `tqdm.notebook` and `tqdm.std`.

Usage:
>>> from tqdm.autonotebook import trange, tqdm
>>> for i in trange(10):
...     ...
"""
import sys
from warnings import warn

try:
    get_ipython = sys.modules['IPython'].get_ipython
    if 'IPKernelApp' not in get_ipython().config:  # pragma: no cover
        raise ImportError("console")
    from .notebook import WARN_NOIPYW, IProgress
    if IProgress is None:
        from .std import TqdmWarning
        warn(WARN_NOIPYW, TqdmWarning, stacklevel=2)
        raise ImportError('ipywidgets')
except Exception:
    from .std import tqdm, trange
else:  # pragma: no cover
    from .notebook import tqdm, trange
    from .std import TqdmExperimentalWarning
    warn("Using `tqdm.autonotebook.tqdm` in notebook mode."
         " Use `tqdm.tqdm` instead to force console mode"
         " (e.g. in jupyter console)", TqdmExperimentalWarning, stacklevel=2)
__all__ = ["tqdm", "trange"]


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\cli.py
# ================================================================================

"""
Module version for monitoring CLI pipes (`... | python -m tqdm | ...`).
"""
import logging
import re
import sys
from ast import literal_eval as numeric
from textwrap import indent

from .std import TqdmKeyError, TqdmTypeError, tqdm
from .version import __version__

__all__ = ["main"]
log = logging.getLogger(__name__)


def cast(val, typ):
    log.debug((val, typ))
    if " or " in typ:
        for t in typ.split(" or "):
            try:
                return cast(val, t)
            except TqdmTypeError:
                pass
        raise TqdmTypeError(f"{val} : {typ}")

    # sys.stderr.write('\ndebug | `val:type`: `' + val + ':' + typ + '`.\n')
    if typ == 'bool':
        if (val == 'True') or (val == ''):
            return True
        if val == 'False':
            return False
        raise TqdmTypeError(val + ' : ' + typ)
    if typ == 'chr':
        if len(val) == 1:
            return val.encode()
        if re.match(r"^\\\w+$", val):
            return eval(f'"{val}"').encode()
        raise TqdmTypeError(f"{val} : {typ}")
    if typ == 'str':
        return val
    if typ == 'int':
        try:
            return int(val)
        except ValueError as exc:
            raise TqdmTypeError(f"{val} : {typ}") from exc
    if typ == 'float':
        try:
            return float(val)
        except ValueError as exc:
            raise TqdmTypeError(f"{val} : {typ}") from exc
    raise TqdmTypeError(f"{val} : {typ}")


def posix_pipe(fin, fout, delim=b'\\n', buf_size=256,
               callback=lambda float: None, callback_len=True):
    """
    Params
    ------
    fin  : binary file with `read(buf_size : int)` method
    fout  : binary file with `write` (and optionally `flush`) methods.
    callback  : function(float), e.g.: `tqdm.update`
    callback_len  : If (default: True) do `callback(len(buffer))`.
      Otherwise, do `callback(data) for data in buffer.split(delim)`.
    """
    fp_write = fout.write

    if not delim:
        while True:
            tmp = fin.read(buf_size)

            # flush at EOF
            if not tmp:
                getattr(fout, 'flush', lambda: None)()
                return

            fp_write(tmp)
            callback(len(tmp))
        # return

    buf = b''
    len_delim = len(delim)
    # n = 0
    while True:
        tmp = fin.read(buf_size)

        # flush at EOF
        if not tmp:
            if buf:
                fp_write(buf)
                if callback_len:
                    # n += 1 + buf.count(delim)
                    callback(1 + buf.count(delim))
                else:
                    for i in buf.split(delim):
                        callback(i)
            getattr(fout, 'flush', lambda: None)()
            return  # n

        while True:
            i = tmp.find(delim)
            if i < 0:
                buf += tmp
                break
            fp_write(buf + tmp[:i + len(delim)])
            # n += 1
            callback(1 if callback_len else (buf + tmp[:i]))
            buf = b''
            tmp = tmp[i + len_delim:]


# ((opt, type), ... )
RE_OPTS = re.compile(r'\n {4}(\S+)\s{2,}:\s*([^,]+)')
# better split method assuming no positional args
RE_SHLEX = re.compile(r'\s*(?<!\S)--?([^\s=]+)(\s+|=|$)')

# TODO: add custom support for some of the following?
UNSUPPORTED_OPTS = ('iterable', 'gui', 'out', 'file')

# The 8 leading spaces are required for consistency
CLI_EXTRA_DOC = r"""
    Extra CLI Options
    -----------------
    name  : type, optional
        TODO: find out why this is needed.
    delim  : chr, optional
        Delimiting character [default: '\n']. Use '\0' for null.
        N.B.: on Windows systems, Python converts '\n' to '\r\n'.
    buf_size  : int, optional
        String buffer size in bytes [default: 256]
        used when `delim` is specified.
    bytes  : bool, optional
        If true, will count bytes, ignore `delim`, and default
        `unit_scale` to True, `unit_divisor` to 1024, and `unit` to 'B'.
    tee  : bool, optional
        If true, passes `stdin` to both `stderr` and `stdout`.
    update  : bool, optional
        If true, will treat input as newly elapsed iterations,
        i.e. numbers to pass to `update()`. Note that this is slow
        (~2e5 it/s) since every input must be decoded as a number.
    update_to  : bool, optional
        If true, will treat input as total elapsed iterations,
        i.e. numbers to assign to `self.n`. Note that this is slow
        (~2e5 it/s) since every input must be decoded as a number.
    null  : bool, optional
        If true, will discard input (no stdout).
    manpath  : str, optional
        Directory in which to install tqdm man pages.
    comppath  : str, optional
        Directory in which to place tqdm completion.
    log  : str, optional
        CRITICAL|FATAL|ERROR|WARN(ING)|[default: 'INFO']|DEBUG|NOTSET.
"""


def main(fp=sys.stderr, argv=None):
    """
    Parameters (internal use only)
    ---------
    fp  : file-like object for tqdm
    argv  : list (default: sys.argv[1:])
    """
    if argv is None:
        argv = sys.argv[1:]
    try:
        log_idx = argv.index('--log')
    except ValueError:
        for i in argv:
            if i.startswith('--log='):
                logLevel = i[len('--log='):]
                break
        else:
            logLevel = 'INFO'
    else:
        # argv.pop(log_idx)
        # logLevel = argv.pop(log_idx)
        logLevel = argv[log_idx + 1]
    logging.basicConfig(level=getattr(logging, logLevel),
                        format="%(levelname)s:%(module)s:%(lineno)d:%(message)s")

    # py<3.13 doesn't dedent docstrings
    d = (tqdm.__doc__ if sys.version_info < (3, 13)
         else indent(tqdm.__doc__, "    ")) + CLI_EXTRA_DOC

    opt_types = dict(RE_OPTS.findall(d))
    # opt_types['delim'] = 'chr'

    for o in UNSUPPORTED_OPTS:
        opt_types.pop(o)

    log.debug(sorted(opt_types.items()))

    # d = RE_OPTS.sub(r'  --\1=<\1>  : \2', d)
    split = RE_OPTS.split(d)
    opt_types_desc = zip(split[1::3], split[2::3], split[3::3])
    d = ''.join(('\n  --{0}  : {2}{3}' if otd[1] == 'bool' else
                 '\n  --{0}=<{1}>  : {2}{3}').format(
                     otd[0].replace('_', '-'), otd[0], *otd[1:])
                for otd in opt_types_desc if otd[0] not in UNSUPPORTED_OPTS)

    help_short = "Usage:\n  tqdm [--help | options]\n"
    d = help_short + """
Options:
  -h, --help     Print this help and exit.
  -v, --version  Print version and exit.
""" + d.strip('\n') + '\n'

    # opts = docopt(d, version=__version__)
    if any(v in argv for v in ('-v', '--version')):
        sys.stdout.write(__version__ + '\n')
        sys.exit(0)
    elif any(v in argv for v in ('-h', '--help')):
        sys.stdout.write(d + '\n')
        sys.exit(0)
    elif argv and argv[0][:2] != '--':
        sys.stderr.write(f"Error:Unknown argument:{argv[0]}\n{help_short}")

    argv = RE_SHLEX.split(' '.join(["tqdm"] + argv))
    opts = dict(zip(argv[1::3], argv[3::3]))

    log.debug(opts)
    opts.pop('log', True)

    tqdm_args = {'file': fp}
    try:
        for (o, v) in opts.items():
            o = o.replace('-', '_')
            try:
                tqdm_args[o] = cast(v, opt_types[o])
            except KeyError as e:
                raise TqdmKeyError(str(e))
        log.debug('args:' + str(tqdm_args))

        delim_per_char = tqdm_args.pop('bytes', False)
        update = tqdm_args.pop('update', False)
        update_to = tqdm_args.pop('update_to', False)
        if sum((delim_per_char, update, update_to)) > 1:
            raise TqdmKeyError("Can only have one of --bytes --update --update_to")
    except Exception:
        fp.write("\nError:\n" + help_short)
        stdin, stdout_write = sys.stdin, sys.stdout.write
        for i in stdin:
            stdout_write(i)
        raise
    else:
        buf_size = tqdm_args.pop('buf_size', 256)
        delim = tqdm_args.pop('delim', b'\\n')
        tee = tqdm_args.pop('tee', False)
        manpath = tqdm_args.pop('manpath', None)
        comppath = tqdm_args.pop('comppath', None)
        if tqdm_args.pop('null', False):
            class stdout(object):
                @staticmethod
                def write(_):
                    pass
        else:
            stdout = sys.stdout
            stdout = getattr(stdout, 'buffer', stdout)
        stdin = getattr(sys.stdin, 'buffer', sys.stdin)
        if manpath or comppath:
            try:  # py<3.9
                import importlib_resources as resources
            except ImportError:
                from importlib import resources
            from pathlib import Path

            def cp(name, dst):
                """copy resource `name` to `dst`"""
                fi = resources.files('tqdm') / name
                dst.write_bytes(fi.read_bytes())
                log.info("written:%s", dst)
            if manpath is not None:
                cp('tqdm.1', Path(manpath) / 'tqdm.1')
            if comppath is not None:
                cp('completion.sh', Path(comppath) / 'tqdm_completion.sh')
            sys.exit(0)
        if tee:
            stdout_write = stdout.write
            fp_write = getattr(fp, 'buffer', fp).write

            class stdout(object):  # pylint: disable=function-redefined
                @staticmethod
                def write(x):
                    with tqdm.external_write_mode(file=fp):
                        fp_write(x)
                    stdout_write(x)
        if delim_per_char:
            tqdm_args.setdefault('unit', 'B')
            tqdm_args.setdefault('unit_scale', True)
            tqdm_args.setdefault('unit_divisor', 1024)
            log.debug(tqdm_args)
            with tqdm(**tqdm_args) as t:
                posix_pipe(stdin, stdout, '', buf_size, t.update)
        elif delim == b'\\n':
            log.debug(tqdm_args)
            write = stdout.write
            if update or update_to:
                with tqdm(**tqdm_args) as t:
                    if update:
                        def callback(i):
                            t.update(numeric(i.decode()))
                    else:  # update_to
                        def callback(i):
                            t.update(numeric(i.decode()) - t.n)
                    for i in stdin:
                        write(i)
                        callback(i)
            else:
                for i in tqdm(stdin, **tqdm_args):
                    write(i)
        else:
            log.debug(tqdm_args)
            with tqdm(**tqdm_args) as t:
                callback_len = False
                if update:
                    def callback(i):
                        t.update(numeric(i.decode()))
                elif update_to:
                    def callback(i):
                        t.update(numeric(i.decode()) - t.n)
                else:
                    callback = t.update
                    callback_len = True
                posix_pipe(stdin, stdout, delim, buf_size, callback, callback_len)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\contrib\__init__.py
# ================================================================================

"""
Thin wrappers around common functions.

Subpackages contain potentially unstable extensions.
"""
from warnings import warn

from ..auto import tqdm as tqdm_auto
from ..std import TqdmDeprecationWarning, tqdm
from ..utils import ObjectWrapper

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ['tenumerate', 'tzip', 'tmap']


class DummyTqdmFile(ObjectWrapper):
    """Dummy file-like that will write to tqdm"""

    def __init__(self, wrapped):
        super().__init__(wrapped)
        self._buf = []

    def write(self, x, nolock=False):
        nl = b"\n" if isinstance(x, bytes) else "\n"
        pre, sep, post = x.rpartition(nl)
        if sep:
            blank = type(nl)()
            tqdm.write(blank.join(self._buf + [pre, sep]),
                       end=blank, file=self._wrapped, nolock=nolock)
            self._buf = [post]
        else:
            self._buf.append(x)

    def __del__(self):
        if self._buf:
            blank = type(self._buf[0])()
            try:
                tqdm.write(blank.join(self._buf), end=blank, file=self._wrapped)
            except (OSError, ValueError):
                pass


def builtin_iterable(func):
    """Returns `func`"""
    warn("This function has no effect, and will be removed in tqdm==5.0.0",
         TqdmDeprecationWarning, stacklevel=2)
    return func


def tenumerate(iterable, start=0, total=None, tqdm_class=tqdm_auto, **tqdm_kwargs):
    """
    Equivalent of `numpy.ndenumerate` or builtin `enumerate`.

    Parameters
    ----------
    tqdm_class  : [default: tqdm.auto.tqdm].
    """
    try:
        import numpy as np
    except ImportError:
        pass
    else:
        if isinstance(iterable, np.ndarray):
            return tqdm_class(np.ndenumerate(iterable), total=total or iterable.size,
                              **tqdm_kwargs)
    return enumerate(tqdm_class(iterable, total=total, **tqdm_kwargs), start)


def tzip(iter1, *iter2plus, **tqdm_kwargs):
    """
    Equivalent of builtin `zip`.

    Parameters
    ----------
    tqdm_class  : [default: tqdm.auto.tqdm].
    """
    kwargs = tqdm_kwargs.copy()
    tqdm_class = kwargs.pop("tqdm_class", tqdm_auto)
    for i in zip(tqdm_class(iter1, **kwargs), *iter2plus):
        yield i


def tmap(function, *sequences, **tqdm_kwargs):
    """
    Equivalent of builtin `map`.

    Parameters
    ----------
    tqdm_class  : [default: tqdm.auto.tqdm].
    """
    for i in tzip(*sequences, **tqdm_kwargs):
        yield function(*i)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\contrib\bells.py
# ================================================================================

"""
Even more features than `tqdm.auto` (all the bells & whistles):

- `tqdm.auto`
- `tqdm.tqdm.pandas`
- `tqdm.contrib.telegram`
    + uses `${TQDM_TELEGRAM_TOKEN}` and `${TQDM_TELEGRAM_CHAT_ID}`
- `tqdm.contrib.discord`
    + uses `${TQDM_DISCORD_TOKEN}` and `${TQDM_DISCORD_CHANNEL_ID}`
"""
__all__ = ['tqdm', 'trange']
import warnings
from os import getenv

if getenv("TQDM_SLACK_TOKEN") and getenv("TQDM_SLACK_CHANNEL"):
    from .slack import tqdm, trange
elif getenv("TQDM_TELEGRAM_TOKEN") and getenv("TQDM_TELEGRAM_CHAT_ID"):
    from .telegram import tqdm, trange
elif getenv("TQDM_DISCORD_TOKEN") and getenv("TQDM_DISCORD_CHANNEL_ID"):
    from .discord import tqdm, trange
else:
    from ..auto import tqdm, trange

with warnings.catch_warnings():
    warnings.simplefilter("ignore", category=FutureWarning)
    tqdm.pandas()


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\contrib\concurrent.py
# ================================================================================

"""
Thin wrappers around `concurrent.futures`.
"""
from contextlib import contextmanager
from operator import length_hint
from os import cpu_count

from ..auto import tqdm as tqdm_auto
from ..std import TqdmWarning

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ['thread_map', 'process_map']


@contextmanager
def ensure_lock(tqdm_class, lock_name=""):
    """get (create if necessary) and then restore `tqdm_class`'s lock"""
    old_lock = getattr(tqdm_class, '_lock', None)  # don't create a new lock
    lock = old_lock or tqdm_class.get_lock()  # maybe create a new lock
    lock = getattr(lock, lock_name, lock)  # maybe subtype
    tqdm_class.set_lock(lock)
    yield lock
    if old_lock is None:
        del tqdm_class._lock
    else:
        tqdm_class.set_lock(old_lock)


def _executor_map(PoolExecutor, fn, *iterables, **tqdm_kwargs):
    """
    Implementation of `thread_map` and `process_map`.

    Parameters
    ----------
    tqdm_class  : [default: tqdm.auto.tqdm].
    max_workers  : [default: min(32, cpu_count() + 4)].
    chunksize  : [default: 1].
    lock_name  : [default: "":str].
    """
    kwargs = tqdm_kwargs.copy()
    if "total" not in kwargs:
        kwargs["total"] = length_hint(iterables[0])
    tqdm_class = kwargs.pop("tqdm_class", tqdm_auto)
    max_workers = kwargs.pop("max_workers", min(32, cpu_count() + 4))
    chunksize = kwargs.pop("chunksize", 1)
    lock_name = kwargs.pop("lock_name", "")
    with ensure_lock(tqdm_class, lock_name=lock_name) as lk:
        # share lock in case workers are already using `tqdm`
        with PoolExecutor(max_workers=max_workers, initializer=tqdm_class.set_lock,
                          initargs=(lk,)) as ex:
            return list(tqdm_class(ex.map(fn, *iterables, chunksize=chunksize), **kwargs))


def thread_map(fn, *iterables, **tqdm_kwargs):
    """
    Equivalent of `list(map(fn, *iterables))`
    driven by `concurrent.futures.ThreadPoolExecutor`.

    Parameters
    ----------
    tqdm_class  : optional
        `tqdm` class to use for bars [default: tqdm.auto.tqdm].
    max_workers  : int, optional
        Maximum number of workers to spawn; passed to
        `concurrent.futures.ThreadPoolExecutor.__init__`.
        [default: max(32, cpu_count() + 4)].
    """
    from concurrent.futures import ThreadPoolExecutor
    return _executor_map(ThreadPoolExecutor, fn, *iterables, **tqdm_kwargs)


def process_map(fn, *iterables, **tqdm_kwargs):
    """
    Equivalent of `list(map(fn, *iterables))`
    driven by `concurrent.futures.ProcessPoolExecutor`.

    Parameters
    ----------
    tqdm_class  : optional
        `tqdm` class to use for bars [default: tqdm.auto.tqdm].
    max_workers  : int, optional
        Maximum number of workers to spawn; passed to
        `concurrent.futures.ProcessPoolExecutor.__init__`.
        [default: min(32, cpu_count() + 4)].
    chunksize  : int, optional
        Size of chunks sent to worker processes; passed to
        `concurrent.futures.ProcessPoolExecutor.map`. [default: 1].
    lock_name  : str, optional
        Member of `tqdm_class.get_lock()` to use [default: mp_lock].
    """
    from concurrent.futures import ProcessPoolExecutor
    if iterables and "chunksize" not in tqdm_kwargs:
        # default `chunksize=1` has poor performance for large iterables
        # (most time spent dispatching items to workers).
        longest_iterable_len = max(map(length_hint, iterables))
        if longest_iterable_len > 1000:
            from warnings import warn
            warn("Iterable length %d > 1000 but `chunksize` is not set."
                 " This may seriously degrade multiprocess performance."
                 " Set `chunksize=1` or more." % longest_iterable_len,
                 TqdmWarning, stacklevel=2)
    if "lock_name" not in tqdm_kwargs:
        tqdm_kwargs = tqdm_kwargs.copy()
        tqdm_kwargs["lock_name"] = "mp_lock"
    return _executor_map(ProcessPoolExecutor, fn, *iterables, **tqdm_kwargs)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\contrib\discord.py
# ================================================================================

"""
Sends updates to a Discord bot.

Usage:
>>> from tqdm.contrib.discord import tqdm, trange
>>> for i in trange(10, token='{token}', channel_id='{channel_id}'):
...     ...

![screenshot](https://tqdm.github.io/img/screenshot-discord.png)
"""
from os import getenv
from warnings import warn

from requests import Session
from requests.utils import default_user_agent

from ..auto import tqdm as tqdm_auto
from ..std import TqdmWarning
from ..version import __version__
from .utils_worker import MonoWorker

__author__ = {"github.com/": ["casperdcl", "guigoruiz1"]}
__all__ = ['DiscordIO', 'tqdm_discord', 'tdrange', 'tqdm', 'trange']


class DiscordIO(MonoWorker):
    """Non-blocking file-like IO using a Discord Bot."""
    API = "https://discord.com/api/v10"
    UA = f"tqdm (https://tqdm.github.io, {__version__}) {default_user_agent()}"

    def __init__(self, token, channel_id):
        """Creates a new message in the given `channel_id`."""
        super().__init__()
        self.token = token
        self.channel_id = channel_id
        self.session = Session()
        self.text = self.__class__.__name__
        self.message_id

    @property
    def message_id(self):
        if hasattr(self, '_message_id'):
            return self._message_id
        try:
            res = self.session.post(
                f'{self.API}/channels/{self.channel_id}/messages',
                headers={'Authorization': f'Bot {self.token}', 'User-Agent': self.UA},
                json={'content': f"`{self.text}`"}).json()
        except Exception as e:
            tqdm_auto.write(str(e))
        else:
            if res.get('error_code') == 429:
                warn("Creation rate limit: try increasing `mininterval`.",
                     TqdmWarning, stacklevel=2)
            else:
                self._message_id = res['id']
                return self._message_id

    def write(self, s):
        """Replaces internal `message_id`'s text with `s`."""
        if not s:
            s = "..."
        s = s.replace('\r', '').strip()
        if s == self.text:
            return  # avoid duplicate message Bot error
        message_id = self.message_id
        if message_id is None:
            return
        self.text = s
        try:
            future = self.submit(
                self.session.patch,
                f'{self.API}/channels/{self.channel_id}/messages/{message_id}',
                headers={'Authorization': f'Bot {self.token}', 'User-Agent': self.UA},
                json={'content': f"`{self.text}`"})
        except Exception as e:
            tqdm_auto.write(str(e))
        else:
            return future

    def delete(self):
        """Deletes internal `message_id`."""
        try:
            future = self.submit(
                self.session.delete,
                f'{self.API}/channels/{self.channel_id}/messages/{self.message_id}',
                headers={'Authorization': f'Bot {self.token}', 'User-Agent': self.UA})
        except Exception as e:
            tqdm_auto.write(str(e))
        else:
            return future


class tqdm_discord(tqdm_auto):
    """
    Standard `tqdm.auto.tqdm` but also sends updates to a Discord Bot.
    May take a few seconds to create (`__init__`).

    - create a discord bot (not public, no requirement of OAuth2 code
      grant, only send message permissions) & invite it to a channel:
      <https://discordpy.readthedocs.io/en/latest/discord.html>
    - copy the bot `{token}` & `{channel_id}` and paste below

    >>> from tqdm.contrib.discord import tqdm, trange
    >>> for i in tqdm(iterable, token='{token}', channel_id='{channel_id}'):
    ...     ...
    """
    def __init__(self, *args, **kwargs):
        """
        Parameters
        ----------
        token  : str, required. Discord bot token
            [default: ${TQDM_DISCORD_TOKEN}].
        channel_id  : int, required. Discord channel ID
            [default: ${TQDM_DISCORD_CHANNEL_ID}].

        See `tqdm.auto.tqdm.__init__` for other parameters.
        """
        if not kwargs.get('disable'):
            kwargs = kwargs.copy()
            self.dio = DiscordIO(
                kwargs.pop('token', getenv('TQDM_DISCORD_TOKEN')),
                kwargs.pop('channel_id', getenv('TQDM_DISCORD_CHANNEL_ID')))
        super().__init__(*args, **kwargs)

    def display(self, **kwargs):
        super().display(**kwargs)
        fmt = self.format_dict
        if fmt.get('bar_format', None):
            fmt['bar_format'] = fmt['bar_format'].replace(
                '<bar/>', '{bar:10u}').replace('{bar}', '{bar:10u}')
        else:
            fmt['bar_format'] = '{l_bar}{bar:10u}{r_bar}'
        self.dio.write(self.format_meter(**fmt))

    def clear(self, *args, **kwargs):
        super().clear(*args, **kwargs)
        if not self.disable:
            self.dio.write("")

    def close(self):
        if self.disable:
            return
        super().close()
        if not (self.leave or (self.leave is None and self.pos == 0)):
            self.dio.delete()


def tdrange(*args, **kwargs):
    """Shortcut for `tqdm.contrib.discord.tqdm(range(*args), **kwargs)`."""
    return tqdm_discord(range(*args), **kwargs)


# Aliases
tqdm = tqdm_discord
trange = tdrange


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\contrib\itertools.py
# ================================================================================

"""
Thin wrappers around `itertools`.
"""
import itertools

from ..auto import tqdm as tqdm_auto

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ['product']


def product(*iterables, **tqdm_kwargs):
    """
    Equivalent of `itertools.product`.

    Parameters
    ----------
    tqdm_class  : [default: tqdm.auto.tqdm].
    """
    kwargs = tqdm_kwargs.copy()
    tqdm_class = kwargs.pop("tqdm_class", tqdm_auto)
    try:
        lens = list(map(len, iterables))
    except TypeError:
        total = None
    else:
        total = 1
        for i in lens:
            total *= i
        kwargs.setdefault("total", total)
    with tqdm_class(**kwargs) as t:
        it = itertools.product(*iterables)
        for i in it:
            yield i
            t.update()


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\contrib\logging.py
# ================================================================================

"""
Helper functionality for interoperability with stdlib `logging`.
"""
import logging
import sys
from contextlib import contextmanager

try:
    from typing import Iterator, List, Optional, Type  # noqa: F401
except ImportError:
    pass

from ..std import tqdm as std_tqdm


class _TqdmLoggingHandler(logging.StreamHandler):
    def __init__(
        self,
        tqdm_class=std_tqdm  # type: Type[std_tqdm]
    ):
        super().__init__()
        self.tqdm_class = tqdm_class

    def emit(self, record):
        try:
            msg = self.format(record)
            self.tqdm_class.write(msg, file=self.stream)
            self.flush()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:  # noqa pylint: disable=bare-except
            self.handleError(record)


def _is_console_logging_handler(handler):
    return (isinstance(handler, logging.StreamHandler)
            and handler.stream in {sys.stdout, sys.stderr})


def _get_first_found_console_logging_handler(handlers):
    for handler in handlers:
        if _is_console_logging_handler(handler):
            return handler


@contextmanager
def logging_redirect_tqdm(
    loggers=None,  # type: Optional[List[logging.Logger]],
    tqdm_class=std_tqdm  # type: Type[std_tqdm]
):
    # type: (...) -> Iterator[None]
    """
    Context manager redirecting console logging to `tqdm.write()`, leaving
    other logging handlers (e.g. log files) unaffected.

    Parameters
    ----------
    loggers  : list, optional
      Which handlers to redirect (default: [logging.root]).
    tqdm_class  : optional

    Example
    -------
    ```python
    import logging
    from tqdm import trange
    from tqdm.contrib.logging import logging_redirect_tqdm

    LOG = logging.getLogger(__name__)

    if __name__ == '__main__':
        logging.basicConfig(level=logging.INFO)
        with logging_redirect_tqdm():
            for i in trange(9):
                if i == 4:
                    LOG.info("console logging redirected to `tqdm.write()`")
        # logging restored
    ```
    """
    if loggers is None:
        loggers = [logging.root]
    original_handlers_list = [logger.handlers for logger in loggers]
    try:
        for logger in loggers:
            tqdm_handler = _TqdmLoggingHandler(tqdm_class)
            orig_handler = _get_first_found_console_logging_handler(logger.handlers)
            if orig_handler is not None:
                tqdm_handler.setFormatter(orig_handler.formatter)
                tqdm_handler.stream = orig_handler.stream
            logger.handlers = [
                handler for handler in logger.handlers
                if not _is_console_logging_handler(handler)] + [tqdm_handler]
        yield
    finally:
        for logger, original_handlers in zip(loggers, original_handlers_list):
            logger.handlers = original_handlers


@contextmanager
def tqdm_logging_redirect(
    *args,
    # loggers=None,  # type: Optional[List[logging.Logger]]
    # tqdm=None,  # type: Optional[Type[tqdm.tqdm]]
    **kwargs
):
    # type: (...) -> Iterator[None]
    """
    Convenience shortcut for:
    ```python
    with tqdm_class(*args, **tqdm_kwargs) as pbar:
        with logging_redirect_tqdm(loggers=loggers, tqdm_class=tqdm_class):
            yield pbar
    ```

    Parameters
    ----------
    tqdm_class  : optional, (default: tqdm.std.tqdm).
    loggers  : optional, list.
    **tqdm_kwargs  : passed to `tqdm_class`.
    """
    tqdm_kwargs = kwargs.copy()
    loggers = tqdm_kwargs.pop('loggers', None)
    tqdm_class = tqdm_kwargs.pop('tqdm_class', std_tqdm)
    with tqdm_class(*args, **tqdm_kwargs) as pbar:
        with logging_redirect_tqdm(loggers=loggers, tqdm_class=tqdm_class):
            yield pbar


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\contrib\slack.py
# ================================================================================

"""
Sends updates to a Slack app.

Usage:
>>> from tqdm.contrib.slack import tqdm, trange
>>> for i in trange(10, token='{token}', channel='{channel}'):
...     ...

![screenshot](https://tqdm.github.io/img/screenshot-slack.png)
"""
import logging
from os import getenv

try:
    from slack_sdk import WebClient
except ImportError:
    raise ImportError("Please `pip install slack-sdk`")

from ..auto import tqdm as tqdm_auto
from .utils_worker import MonoWorker

__author__ = {"github.com/": ["0x2b3bfa0", "casperdcl"]}
__all__ = ['SlackIO', 'tqdm_slack', 'tsrange', 'tqdm', 'trange']


class SlackIO(MonoWorker):
    """Non-blocking file-like IO using a Slack app."""
    def __init__(self, token, channel):
        """Creates a new message in the given `channel`."""
        super().__init__()
        self.client = WebClient(token=token)
        self.text = self.__class__.__name__
        try:
            self.message = self.client.chat_postMessage(channel=channel, text=self.text)
        except Exception as e:
            tqdm_auto.write(str(e))
            self.message = None

    def write(self, s):
        """Replaces internal `message`'s text with `s`."""
        if not s:
            s = "..."
        s = s.replace('\r', '').strip()
        if s == self.text:
            return  # skip duplicate message
        message = self.message
        if message is None:
            return
        self.text = s
        try:
            future = self.submit(self.client.chat_update, channel=message['channel'],
                                 ts=message['ts'], text='`' + s + '`')
        except Exception as e:
            tqdm_auto.write(str(e))
        else:
            return future


class tqdm_slack(tqdm_auto):
    """
    Standard `tqdm.auto.tqdm` but also sends updates to a Slack app.
    May take a few seconds to create (`__init__`).

    - create a Slack app with the `chat:write` scope & invite it to a
      channel: <https://api.slack.com/authentication/basics>
    - copy the bot `{token}` & `{channel}` and paste below
    >>> from tqdm.contrib.slack import tqdm, trange
    >>> for i in tqdm(iterable, token='{token}', channel='{channel}'):
    ...     ...
    """
    def __init__(self, *args, **kwargs):
        """
        Parameters
        ----------
        token  : str, required. Slack token
            [default: ${TQDM_SLACK_TOKEN}].
        channel  : int, required. Slack channel
            [default: ${TQDM_SLACK_CHANNEL}].
        mininterval  : float, optional.
          Minimum of [default: 1.5] to avoid rate limit.

        See `tqdm.auto.tqdm.__init__` for other parameters.
        """
        if not kwargs.get('disable'):
            kwargs = kwargs.copy()
            logging.getLogger("HTTPClient").setLevel(logging.WARNING)
            self.sio = SlackIO(
                kwargs.pop('token', getenv("TQDM_SLACK_TOKEN")),
                kwargs.pop('channel', getenv("TQDM_SLACK_CHANNEL")))
            kwargs['mininterval'] = max(1.5, kwargs.get('mininterval', 1.5))
        super().__init__(*args, **kwargs)

    def display(self, **kwargs):
        super().display(**kwargs)
        fmt = self.format_dict
        if fmt.get('bar_format', None):
            fmt['bar_format'] = fmt['bar_format'].replace(
                '<bar/>', '`{bar:10}`').replace('{bar}', '`{bar:10u}`')
        else:
            fmt['bar_format'] = '{l_bar}`{bar:10}`{r_bar}'
        if fmt['ascii'] is False:
            fmt['ascii'] = [":black_square:", ":small_blue_diamond:", ":large_blue_diamond:",
                            ":large_blue_square:"]
            fmt['ncols'] = 336
        self.sio.write(self.format_meter(**fmt))

    def clear(self, *args, **kwargs):
        super().clear(*args, **kwargs)
        if not self.disable:
            self.sio.write("")


def tsrange(*args, **kwargs):
    """Shortcut for `tqdm.contrib.slack.tqdm(range(*args), **kwargs)`."""
    return tqdm_slack(range(*args), **kwargs)


# Aliases
tqdm = tqdm_slack
trange = tsrange


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\contrib\telegram.py
# ================================================================================

"""
Sends updates to a Telegram bot.

Usage:
>>> from tqdm.contrib.telegram import tqdm, trange
>>> for i in trange(10, token='{token}', chat_id='{chat_id}'):
...     ...

![screenshot](https://tqdm.github.io/img/screenshot-telegram.gif)
"""
from os import getenv
from warnings import warn

from requests import Session

from ..auto import tqdm as tqdm_auto
from ..std import TqdmWarning
from .utils_worker import MonoWorker

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ['TelegramIO', 'tqdm_telegram', 'ttgrange', 'tqdm', 'trange']


class TelegramIO(MonoWorker):
    """Non-blocking file-like IO using a Telegram Bot."""
    API = 'https://api.telegram.org/bot'

    def __init__(self, token, chat_id):
        """Creates a new message in the given `chat_id`."""
        super().__init__()
        self.token = token
        self.chat_id = chat_id
        self.session = Session()
        self.text = self.__class__.__name__
        self.message_id

    @property
    def message_id(self):
        if hasattr(self, '_message_id'):
            return self._message_id
        try:
            res = self.session.post(
                self.API + '%s/sendMessage' % self.token,
                data={'text': '`' + self.text + '`', 'chat_id': self.chat_id,
                      'parse_mode': 'MarkdownV2'}).json()
        except Exception as e:
            tqdm_auto.write(str(e))
        else:
            if res.get('error_code') == 429:
                warn("Creation rate limit: try increasing `mininterval`.",
                     TqdmWarning, stacklevel=2)
            else:
                self._message_id = res['result']['message_id']
                return self._message_id

    def write(self, s):
        """Replaces internal `message_id`'s text with `s`."""
        if not s:
            s = "..."
        s = s.replace('\r', '').strip()
        if s == self.text:
            return  # avoid duplicate message Bot error
        message_id = self.message_id
        if message_id is None:
            return
        self.text = s
        try:
            future = self.submit(
                self.session.post, self.API + '%s/editMessageText' % self.token,
                data={'text': '`' + s + '`', 'chat_id': self.chat_id,
                      'message_id': message_id, 'parse_mode': 'MarkdownV2'})
        except Exception as e:
            tqdm_auto.write(str(e))
        else:
            return future

    def delete(self):
        """Deletes internal `message_id`."""
        try:
            future = self.submit(
                self.session.post, self.API + '%s/deleteMessage' % self.token,
                data={'chat_id': self.chat_id, 'message_id': self.message_id})
        except Exception as e:
            tqdm_auto.write(str(e))
        else:
            return future


class tqdm_telegram(tqdm_auto):
    """
    Standard `tqdm.auto.tqdm` but also sends updates to a Telegram Bot.
    May take a few seconds to create (`__init__`).

    - create a bot <https://core.telegram.org/bots#6-botfather>
    - copy its `{token}`
    - add the bot to a chat and send it a message such as `/start`
    - go to <https://api.telegram.org/bot`{token}`/getUpdates> to find out
      the `{chat_id}`
    - paste the `{token}` & `{chat_id}` below

    >>> from tqdm.contrib.telegram import tqdm, trange
    >>> for i in tqdm(iterable, token='{token}', chat_id='{chat_id}'):
    ...     ...
    """
    def __init__(self, *args, **kwargs):
        """
        Parameters
        ----------
        token  : str, required. Telegram token
            [default: ${TQDM_TELEGRAM_TOKEN}].
        chat_id  : str, required. Telegram chat ID
            [default: ${TQDM_TELEGRAM_CHAT_ID}].

        See `tqdm.auto.tqdm.__init__` for other parameters.
        """
        if not kwargs.get('disable'):
            kwargs = kwargs.copy()
            self.tgio = TelegramIO(
                kwargs.pop('token', getenv('TQDM_TELEGRAM_TOKEN')),
                kwargs.pop('chat_id', getenv('TQDM_TELEGRAM_CHAT_ID')))
        super().__init__(*args, **kwargs)

    def display(self, **kwargs):
        super().display(**kwargs)
        fmt = self.format_dict
        if fmt.get('bar_format', None):
            fmt['bar_format'] = fmt['bar_format'].replace(
                '<bar/>', '{bar:10u}').replace('{bar}', '{bar:10u}')
        else:
            fmt['bar_format'] = '{l_bar}{bar:10u}{r_bar}'
        self.tgio.write(self.format_meter(**fmt))

    def clear(self, *args, **kwargs):
        super().clear(*args, **kwargs)
        if not self.disable:
            self.tgio.write("")

    def close(self):
        if self.disable:
            return
        super().close()
        if not (self.leave or (self.leave is None and self.pos == 0)):
            self.tgio.delete()


def ttgrange(*args, **kwargs):
    """Shortcut for `tqdm.contrib.telegram.tqdm(range(*args), **kwargs)`."""
    return tqdm_telegram(range(*args), **kwargs)


# Aliases
tqdm = tqdm_telegram
trange = ttgrange


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\contrib\utils_worker.py
# ================================================================================

"""
IO/concurrency helpers for `tqdm.contrib`.
"""
from collections import deque
from concurrent.futures import ThreadPoolExecutor

from ..auto import tqdm as tqdm_auto

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ['MonoWorker']


class MonoWorker(object):
    """
    Supports one running task and one waiting task.
    The waiting task is the most recent submitted (others are discarded).
    """
    def __init__(self):
        self.pool = ThreadPoolExecutor(max_workers=1)
        self.futures = deque([], 2)

    def submit(self, func, *args, **kwargs):
        """`func(*args, **kwargs)` may replace currently waiting task."""
        futures = self.futures
        if len(futures) == futures.maxlen:
            running = futures.popleft()
            if not running.done():
                if len(futures):  # clear waiting
                    waiting = futures.pop()
                    waiting.cancel()
                futures.appendleft(running)  # re-insert running
        try:
            waiting = self.pool.submit(func, *args, **kwargs)
        except Exception as e:
            tqdm_auto.write(str(e))
        else:
            futures.append(waiting)
            return waiting


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\dask.py
# ================================================================================

from functools import partial

from dask.callbacks import Callback

from .auto import tqdm as tqdm_auto

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ['TqdmCallback']


class TqdmCallback(Callback):
    """Dask callback for task progress."""
    def __init__(self, start=None, pretask=None, tqdm_class=tqdm_auto,
                 **tqdm_kwargs):
        """
        Parameters
        ----------
        tqdm_class  : optional
            `tqdm` class to use for bars [default: `tqdm.auto.tqdm`].
        tqdm_kwargs  : optional
            Any other arguments used for all bars.
        """
        super().__init__(start=start, pretask=pretask)
        if tqdm_kwargs:
            tqdm_class = partial(tqdm_class, **tqdm_kwargs)
        self.tqdm_class = tqdm_class

    def _start_state(self, _, state):
        self.pbar = self.tqdm_class(total=sum(
            len(state[k]) for k in ['ready', 'waiting', 'running', 'finished']))

    def _posttask(self, *_, **__):
        self.pbar.update()

    def _finish(self, *_, **__):
        self.pbar.close()

    def display(self):
        """Displays in the current cell in Notebooks."""
        container = getattr(self.bar, 'container', None)
        if container is None:
            return
        from .notebook import display
        display(container)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\gui.py
# ================================================================================

"""
Matplotlib GUI progressbar decorator for iterators.

Usage:
>>> from tqdm.gui import trange, tqdm
>>> for i in trange(10):
...     ...
"""
# future division is important to divide integers and get as
# a result precise floating numbers (instead of truncated int)
import re
from warnings import warn

# to inherit from the tqdm class
from .std import TqdmExperimentalWarning
from .std import tqdm as std_tqdm

# import compatibility functions and utilities

__author__ = {"github.com/": ["casperdcl", "lrq3000"]}
__all__ = ['tqdm_gui', 'tgrange', 'tqdm', 'trange']


class tqdm_gui(std_tqdm):  # pragma: no cover
    """Experimental Matplotlib GUI version of tqdm!"""
    # TODO: @classmethod: write() on GUI?
    def __init__(self, *args, **kwargs):
        from collections import deque

        import matplotlib as mpl
        import matplotlib.pyplot as plt
        kwargs = kwargs.copy()
        kwargs['gui'] = True
        colour = kwargs.pop('colour', 'g')
        super().__init__(*args, **kwargs)

        if self.disable:
            return

        warn("GUI is experimental/alpha", TqdmExperimentalWarning, stacklevel=2)
        self.mpl = mpl
        self.plt = plt

        # Remember if external environment uses toolbars
        self.toolbar = self.mpl.rcParams['toolbar']
        self.mpl.rcParams['toolbar'] = 'None'

        self.mininterval = max(self.mininterval, 0.5)
        self.fig, ax = plt.subplots(figsize=(9, 2.2))
        # self.fig.subplots_adjust(bottom=0.2)
        total = self.__len__()  # avoids TypeError on None #971
        if total is not None:
            self.xdata = []
            self.ydata = []
            self.zdata = []
        else:
            self.xdata = deque([])
            self.ydata = deque([])
            self.zdata = deque([])
        self.line1, = ax.plot(self.xdata, self.ydata, color='b')
        self.line2, = ax.plot(self.xdata, self.zdata, color='k')
        ax.set_ylim(0, 0.001)
        if total is not None:
            ax.set_xlim(0, 100)
            ax.set_xlabel("percent")
            self.fig.legend((self.line1, self.line2), ("cur", "est"),
                            loc='center right')
            # progressbar
            self.hspan = plt.axhspan(0, 0.001, xmin=0, xmax=0, color=colour)
        else:
            # ax.set_xlim(-60, 0)
            ax.set_xlim(0, 60)
            ax.invert_xaxis()
            ax.set_xlabel("seconds")
            ax.legend(("cur", "est"), loc='lower left')
        ax.grid()
        # ax.set_xlabel('seconds')
        ax.set_ylabel((self.unit if self.unit else "it") + "/s")
        if self.unit_scale:
            plt.ticklabel_format(style='sci', axis='y', scilimits=(0, 0))
            ax.yaxis.get_offset_text().set_x(-0.15)

        # Remember if external environment is interactive
        self.wasion = plt.isinteractive()
        plt.ion()
        self.ax = ax

    def close(self):
        if self.disable:
            return

        self.disable = True

        with self.get_lock():
            self._instances.remove(self)

        # Restore toolbars
        self.mpl.rcParams['toolbar'] = self.toolbar
        # Return to non-interactive mode
        if not self.wasion:
            self.plt.ioff()
        if self.leave:
            self.display()
        else:
            self.plt.close(self.fig)

    def clear(self, *_, **__):
        pass

    def display(self, *_, **__):
        n = self.n
        cur_t = self._time()
        elapsed = cur_t - self.start_t
        delta_it = n - self.last_print_n
        delta_t = cur_t - self.last_print_t

        # Inline due to multiple calls
        total = self.total
        xdata = self.xdata
        ydata = self.ydata
        zdata = self.zdata
        ax = self.ax
        line1 = self.line1
        line2 = self.line2
        hspan = getattr(self, 'hspan', None)
        # instantaneous rate
        y = delta_it / delta_t
        # overall rate
        z = n / elapsed
        # update line data
        xdata.append(n * 100.0 / total if total else cur_t)
        ydata.append(y)
        zdata.append(z)

        # Discard old values
        # xmin, xmax = ax.get_xlim()
        # if (not total) and elapsed > xmin * 1.1:
        if (not total) and elapsed > 66:
            xdata.popleft()
            ydata.popleft()
            zdata.popleft()

        ymin, ymax = ax.get_ylim()
        if y > ymax or z > ymax:
            ymax = 1.1 * y
            ax.set_ylim(ymin, ymax)
            ax.figure.canvas.draw()

        if total:
            line1.set_data(xdata, ydata)
            line2.set_data(xdata, zdata)
            if hspan:
                hspan.set_xy((0, ymin))
                hspan.set_height(ymax - ymin)
                hspan.set_width(n / total)
        else:
            t_ago = [cur_t - i for i in xdata]
            line1.set_data(t_ago, ydata)
            line2.set_data(t_ago, zdata)

        d = self.format_dict
        # remove {bar}
        d['bar_format'] = (d['bar_format'] or "{l_bar}<bar/>{r_bar}").replace(
            "{bar}", "<bar/>")
        msg = self.format_meter(**d)
        if '<bar/>' in msg:
            msg = "".join(re.split(r'\|?<bar/>\|?', msg, maxsplit=1))
        ax.set_title(msg, fontname="DejaVu Sans Mono", fontsize=11)
        self.plt.pause(1e-9)


def tgrange(*args, **kwargs):
    """Shortcut for `tqdm.gui.tqdm(range(*args), **kwargs)`."""
    return tqdm_gui(range(*args), **kwargs)


# Aliases
tqdm = tqdm_gui
trange = tgrange


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\keras.py
# ================================================================================

from copy import copy
from functools import partial

from .auto import tqdm as tqdm_auto

try:
    import keras
except (ImportError, AttributeError) as e:
    try:
        from tensorflow import keras
    except ImportError:
        raise e
__author__ = {"github.com/": ["casperdcl"]}
__all__ = ['TqdmCallback']


class TqdmCallback(keras.callbacks.Callback):
    """Keras callback for epoch and batch progress."""
    @staticmethod
    def bar2callback(bar, pop=None, delta=(lambda logs: 1)):
        def callback(_, logs=None):
            n = delta(logs)
            if logs:
                if pop:
                    logs = copy(logs)
                    [logs.pop(i, 0) for i in pop]
                bar.set_postfix(logs, refresh=False)
            bar.update(n)

        return callback

    def __init__(self, epochs=None, data_size=None, batch_size=None, verbose=1,
                 tqdm_class=tqdm_auto, **tqdm_kwargs):
        """
        Parameters
        ----------
        epochs  : int, optional
        data_size  : int, optional
            Number of training pairs.
        batch_size  : int, optional
            Number of training pairs per batch.
        verbose  : int
            0: epoch, 1: batch (transient), 2: batch. [default: 1].
            Will be set to `0` unless both `data_size` and `batch_size`
            are given.
        tqdm_class  : optional
            `tqdm` class to use for bars [default: `tqdm.auto.tqdm`].
        tqdm_kwargs  : optional
            Any other arguments used for all bars.
        """
        if tqdm_kwargs:
            tqdm_class = partial(tqdm_class, **tqdm_kwargs)
        self.tqdm_class = tqdm_class
        self.epoch_bar = tqdm_class(total=epochs, unit='epoch')
        self.on_epoch_end = self.bar2callback(self.epoch_bar)
        if data_size and batch_size:
            self.batches = batches = (data_size + batch_size - 1) // batch_size
        else:
            self.batches = batches = None
        self.verbose = verbose
        if verbose == 1:
            self.batch_bar = tqdm_class(total=batches, unit='batch', leave=False)
            self.on_batch_end = self.bar2callback(
                self.batch_bar, pop=['batch', 'size'],
                delta=lambda logs: logs.get('size', 1))

    def on_train_begin(self, *_, **__):
        params = self.params.get
        auto_total = params('epochs', params('nb_epoch', None))
        if auto_total is not None and auto_total != self.epoch_bar.total:
            self.epoch_bar.reset(total=auto_total)

    def on_epoch_begin(self, epoch, *_, **__):
        if self.epoch_bar.n < epoch:
            ebar = self.epoch_bar
            ebar.n = ebar.last_print_n = ebar.initial = epoch
        if self.verbose:
            params = self.params.get
            total = params('samples', params(
                'nb_sample', params('steps', None))) or self.batches
            if self.verbose == 2:
                if hasattr(self, 'batch_bar'):
                    self.batch_bar.close()
                self.batch_bar = self.tqdm_class(
                    total=total, unit='batch', leave=True,
                    unit_scale=1 / (params('batch_size', 1) or 1))
                self.on_batch_end = self.bar2callback(
                    self.batch_bar, pop=['batch', 'size'],
                    delta=lambda logs: logs.get('size', 1))
            elif self.verbose == 1:
                self.batch_bar.unit_scale = 1 / (params('batch_size', 1) or 1)
                self.batch_bar.reset(total=total)
            else:
                raise KeyError('Unknown verbosity')

    def on_train_end(self, *_, **__):
        if hasattr(self, 'batch_bar'):
            self.batch_bar.close()
        self.epoch_bar.close()

    def display(self):
        """Displays in the current cell in Notebooks."""
        container = getattr(self.epoch_bar, 'container', None)
        if container is None:
            return
        from .notebook import display
        display(container)
        batch_bar = getattr(self, 'batch_bar', None)
        if batch_bar is not None:
            display(batch_bar.container)

    @staticmethod
    def _implements_train_batch_hooks():
        return True

    @staticmethod
    def _implements_test_batch_hooks():
        return True

    @staticmethod
    def _implements_predict_batch_hooks():
        return True


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\notebook.py
# ================================================================================

"""
IPython/Jupyter Notebook progressbar decorator for iterators.
Includes a default `range` iterator printing to `stderr`.

Usage:
>>> from tqdm.notebook import trange, tqdm
>>> for i in trange(10):
...     ...
"""
# import compatibility functions and utilities
import re
import sys
from html import escape
from weakref import proxy

# to inherit from the tqdm class
from .std import tqdm as std_tqdm

if True:  # pragma: no cover
    # import IPython/Jupyter base widget and display utilities
    IPY = 0
    try:  # IPython 4.x
        import ipywidgets
        IPY = 4
    except ImportError:  # IPython 3.x / 2.x
        IPY = 32
        import warnings
        with warnings.catch_warnings():
            warnings.filterwarnings(
                'ignore', message=".*The `IPython.html` package has been deprecated.*")
            try:
                import IPython.html.widgets as ipywidgets  # NOQA: F401
            except ImportError:
                pass

    try:  # IPython 4.x / 3.x
        if IPY == 32:
            from IPython.html.widgets import HTML
            from IPython.html.widgets import FloatProgress as IProgress
            from IPython.html.widgets import HBox
            IPY = 3
        else:
            from ipywidgets import HTML
            from ipywidgets import FloatProgress as IProgress
            from ipywidgets import HBox
    except ImportError:
        try:  # IPython 2.x
            from IPython.html.widgets import HTML
            from IPython.html.widgets import ContainerWidget as HBox
            from IPython.html.widgets import FloatProgressWidget as IProgress
            IPY = 2
        except ImportError:
            IPY = 0
            IProgress = None
            HBox = object

    try:
        from IPython.display import display  # , clear_output
    except ImportError:
        pass

__author__ = {"github.com/": ["lrq3000", "casperdcl", "alexanderkuk"]}
__all__ = ['tqdm_notebook', 'tnrange', 'tqdm', 'trange']
WARN_NOIPYW = ("IProgress not found. Please update jupyter and ipywidgets."
               " See https://ipywidgets.readthedocs.io/en/stable"
               "/user_install.html")


class TqdmHBox(HBox):
    """`ipywidgets.HBox` with a pretty representation"""
    def _json_(self, pretty=None):
        pbar = getattr(self, 'pbar', None)
        if pbar is None:
            return {}
        d = pbar.format_dict
        if pretty is not None:
            d["ascii"] = not pretty
        return d

    def __repr__(self, pretty=False):
        pbar = getattr(self, 'pbar', None)
        if pbar is None:
            return super().__repr__()
        return pbar.format_meter(**self._json_(pretty))

    def _repr_pretty_(self, pp, *_, **__):
        pp.text(self.__repr__(True))


class tqdm_notebook(std_tqdm):
    """
    Experimental IPython/Jupyter Notebook widget using tqdm!
    """
    @staticmethod
    def status_printer(_, total=None, desc=None, ncols=None):
        """
        Manage the printing of an IPython/Jupyter Notebook progress bar widget.
        """
        # Fallback to text bar if there's no total
        # DEPRECATED: replaced with an 'info' style bar
        # if not total:
        #    return super(tqdm_notebook, tqdm_notebook).status_printer(file)

        # fp = file

        # Prepare IPython progress bar
        if IProgress is None:  # #187 #451 #558 #872
            raise ImportError(WARN_NOIPYW)
        if total:
            pbar = IProgress(min=0, max=total)
        else:  # No total? Show info style bar with no progress tqdm status
            pbar = IProgress(min=0, max=1)
            pbar.value = 1
            pbar.bar_style = 'info'
            if ncols is None:
                pbar.layout.width = "20px"

        ltext = HTML()
        rtext = HTML()
        if desc:
            ltext.value = desc
        container = TqdmHBox(children=[ltext, pbar, rtext])
        # Prepare layout
        if ncols is not None:  # use default style of ipywidgets
            # ncols could be 100, "100px", "100%"
            ncols = str(ncols)  # ipywidgets only accepts string
            try:
                if int(ncols) > 0:  # isnumeric and positive
                    ncols += 'px'
            except ValueError:
                pass
            pbar.layout.flex = '2'
            container.layout.width = ncols
            container.layout.display = 'inline-flex'
            container.layout.flex_flow = 'row wrap'

        return container

    def display(self, msg=None, pos=None,
                # additional signals
                close=False, bar_style=None, check_delay=True):
        # Note: contrary to native tqdm, msg='' does NOT clear bar
        # goal is to keep all infos if error happens so user knows
        # at which iteration the loop failed.

        # Clear previous output (really necessary?)
        # clear_output(wait=1)

        if not msg and not close:
            d = self.format_dict
            # remove {bar}
            d['bar_format'] = (d['bar_format'] or "{l_bar}<bar/>{r_bar}").replace(
                "{bar}", "<bar/>")
            msg = self.format_meter(**d)

        ltext, pbar, rtext = self.container.children
        pbar.value = self.n

        if msg:
            msg = msg.replace(' ', u'\u2007')  # fix html space padding
            # html escape special characters (like '&')
            if '<bar/>' in msg:
                left, right = map(escape, re.split(r'\|?<bar/>\|?', msg, maxsplit=1))
            else:
                left, right = '', escape(msg)

            # Update description
            ltext.value = left
            # never clear the bar (signal: msg='')
            if right:
                rtext.value = right

        # Change bar style
        if bar_style:
            # Hack-ish way to avoid the danger bar_style being overridden by
            # success because the bar gets closed after the error...
            if pbar.bar_style != 'danger' or bar_style != 'success':
                pbar.bar_style = bar_style

        # Special signal to close the bar
        if close and pbar.bar_style != 'danger':  # hide only if no error
            try:
                self.container.close()
            except AttributeError:
                self.container.visible = False
            self.container.layout.visibility = 'hidden'  # IPYW>=8

        if check_delay and self.delay > 0 and not self.displayed:
            display(self.container)
            self.displayed = True

    @property
    def colour(self):
        if hasattr(self, 'container'):
            return self.container.children[-2].style.bar_color

    @colour.setter
    def colour(self, bar_color):
        if hasattr(self, 'container'):
            self.container.children[-2].style.bar_color = bar_color

    def __init__(self, *args, **kwargs):
        """
        Supports the usual `tqdm.tqdm` parameters as well as those listed below.

        Parameters
        ----------
        display  : Whether to call `display(self.container)` immediately
            [default: True].
        """
        kwargs = kwargs.copy()
        # Setup default output
        file_kwarg = kwargs.get('file', sys.stderr)
        if file_kwarg is sys.stderr or file_kwarg is None:
            kwargs['file'] = sys.stdout  # avoid the red block in IPython

        # Initialize parent class + avoid printing by using gui=True
        kwargs['gui'] = True
        # convert disable = None to False
        kwargs['disable'] = bool(kwargs.get('disable', False))
        colour = kwargs.pop('colour', None)
        display_here = kwargs.pop('display', True)
        super().__init__(*args, **kwargs)
        if self.disable or not kwargs['gui']:
            self.disp = lambda *_, **__: None
            return

        # Get bar width
        self.ncols = '100%' if self.dynamic_ncols else kwargs.get("ncols", None)

        # Replace with IPython progress bar display (with correct total)
        unit_scale = 1 if self.unit_scale is True else self.unit_scale or 1
        total = self.total * unit_scale if self.total else self.total
        self.container = self.status_printer(self.fp, total, self.desc, self.ncols)
        self.container.pbar = proxy(self)
        self.displayed = False
        if display_here and self.delay <= 0:
            display(self.container)
            self.displayed = True
        self.disp = self.display
        self.colour = colour

        # Print initial bar state
        if not self.disable:
            self.display(check_delay=False)

    def __iter__(self):
        try:
            it = super().__iter__()
            for obj in it:
                # return super(tqdm...) will not catch exception
                yield obj
        # NB: except ... [ as ...] breaks IPython async KeyboardInterrupt
        except:  # NOQA
            self.disp(bar_style='danger')
            raise
        # NB: don't `finally: close()`
        # since this could be a shared bar which the user will `reset()`

    def update(self, n=1):
        try:
            return super().update(n=n)
        # NB: except ... [ as ...] breaks IPython async KeyboardInterrupt
        except:  # NOQA
            # cannot catch KeyboardInterrupt when using manual tqdm
            # as the interrupt will most likely happen on another statement
            self.disp(bar_style='danger')
            raise
        # NB: don't `finally: close()`
        # since this could be a shared bar which the user will `reset()`

    def close(self):
        if self.disable:
            return
        super().close()
        # Try to detect if there was an error or KeyboardInterrupt
        # in manual mode: if n < total, things probably got wrong
        if self.total and self.n < self.total:
            self.disp(bar_style='danger', check_delay=False)
        else:
            if self.leave:
                self.disp(bar_style='success', check_delay=False)
            else:
                self.disp(close=True, check_delay=False)

    def clear(self, *_, **__):
        pass

    def reset(self, total=None):
        """
        Resets to 0 iterations for repeated use.

        Consider combining with `leave=True`.

        Parameters
        ----------
        total  : int or float, optional. Total to use for the new bar.
        """
        if self.disable:
            return super().reset(total=total)
        _, pbar, _ = self.container.children
        pbar.bar_style = ''
        if total is not None:
            pbar.max = total
            if not self.total and self.ncols is None:  # no longer unknown total
                pbar.layout.width = None  # reset width
        return super().reset(total=total)


def tnrange(*args, **kwargs):
    """Shortcut for `tqdm.notebook.tqdm(range(*args), **kwargs)`."""
    return tqdm_notebook(range(*args), **kwargs)


# Aliases
tqdm = tqdm_notebook
trange = tnrange


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\rich.py
# ================================================================================

"""
`rich.progress` decorator for iterators.

Usage:
>>> from tqdm.rich import trange, tqdm
>>> for i in trange(10):
...     ...
"""
from warnings import warn

from rich.progress import (
    BarColumn, Progress, ProgressColumn, Text, TimeElapsedColumn, TimeRemainingColumn, filesize)

from .std import TqdmExperimentalWarning
from .std import tqdm as std_tqdm

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ['tqdm_rich', 'trrange', 'tqdm', 'trange']


class FractionColumn(ProgressColumn):
    """Renders completed/total, e.g. '0.5/2.3 G'."""
    def __init__(self, unit_scale=False, unit_divisor=1000):
        self.unit_scale = unit_scale
        self.unit_divisor = unit_divisor
        super().__init__()

    def render(self, task):
        """Calculate common unit for completed and total."""
        completed = int(task.completed)
        total = int(task.total)
        if self.unit_scale:
            unit, suffix = filesize.pick_unit_and_suffix(
                total,
                ["", "K", "M", "G", "T", "P", "E", "Z", "Y"],
                self.unit_divisor,
            )
        else:
            unit, suffix = filesize.pick_unit_and_suffix(total, [""], 1)
        precision = 0 if unit == 1 else 1
        return Text(
            f"{completed/unit:,.{precision}f}/{total/unit:,.{precision}f} {suffix}",
            style="progress.download")


class RateColumn(ProgressColumn):
    """Renders human readable transfer speed."""
    def __init__(self, unit="", unit_scale=False, unit_divisor=1000):
        self.unit = unit
        self.unit_scale = unit_scale
        self.unit_divisor = unit_divisor
        super().__init__()

    def render(self, task):
        """Show data transfer speed."""
        speed = task.speed
        if speed is None:
            return Text(f"? {self.unit}/s", style="progress.data.speed")
        if self.unit_scale:
            unit, suffix = filesize.pick_unit_and_suffix(
                speed,
                ["", "K", "M", "G", "T", "P", "E", "Z", "Y"],
                self.unit_divisor,
            )
        else:
            unit, suffix = filesize.pick_unit_and_suffix(speed, [""], 1)
        precision = 0 if unit == 1 else 1
        return Text(f"{speed/unit:,.{precision}f} {suffix}{self.unit}/s",
                    style="progress.data.speed")


class tqdm_rich(std_tqdm):  # pragma: no cover
    """Experimental rich.progress GUI version of tqdm!"""
    # TODO: @classmethod: write()?
    def __init__(self, *args, **kwargs):
        """
        This class accepts the following parameters *in addition* to
        the parameters accepted by `tqdm`.

        Parameters
        ----------
        progress  : tuple, optional
            arguments for `rich.progress.Progress()`.
        options  : dict, optional
            keyword arguments for `rich.progress.Progress()`.
        """
        kwargs = kwargs.copy()
        kwargs['gui'] = True
        # convert disable = None to False
        kwargs['disable'] = bool(kwargs.get('disable', False))
        progress = kwargs.pop('progress', None)
        options = kwargs.pop('options', {}).copy()
        super().__init__(*args, **kwargs)

        if self.disable:
            return

        warn("rich is experimental/alpha", TqdmExperimentalWarning, stacklevel=2)
        d = self.format_dict
        if progress is None:
            progress = (
                "[progress.description]{task.description}"
                "[progress.percentage]{task.percentage:>4.0f}%",
                BarColumn(bar_width=None),
                FractionColumn(
                    unit_scale=d['unit_scale'], unit_divisor=d['unit_divisor']),
                "[", TimeElapsedColumn(), "<", TimeRemainingColumn(),
                ",", RateColumn(unit=d['unit'], unit_scale=d['unit_scale'],
                                unit_divisor=d['unit_divisor']), "]"
            )
        options.setdefault('transient', not self.leave)
        self._prog = Progress(*progress, **options)
        self._prog.__enter__()
        self._task_id = self._prog.add_task(self.desc or "", **d)

    def close(self):
        if self.disable:
            return
        self.display()  # print 100%, vis #1306
        super().close()
        self._prog.__exit__(None, None, None)

    def clear(self, *_, **__):
        pass

    def display(self, *_, **__):
        if not hasattr(self, '_prog'):
            return
        self._prog.update(self._task_id, completed=self.n, description=self.desc)

    def reset(self, total=None):
        """
        Resets to 0 iterations for repeated use.

        Parameters
        ----------
        total  : int or float, optional. Total to use for the new bar.
        """
        if hasattr(self, '_prog'):
            self._prog.reset(total=total)
        super().reset(total=total)


def trrange(*args, **kwargs):
    """Shortcut for `tqdm.rich.tqdm(range(*args), **kwargs)`."""
    return tqdm_rich(range(*args), **kwargs)


# Aliases
tqdm = tqdm_rich
trange = trrange


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\std.py
# ================================================================================

"""
Customisable progressbar decorator for iterators.
Includes a default `range` iterator printing to `stderr`.

Usage:
>>> from tqdm import trange, tqdm
>>> for i in trange(10):
...     ...
"""
import sys
from collections import OrderedDict, defaultdict
from contextlib import contextmanager
from datetime import datetime, timedelta, timezone
from numbers import Number
from time import time
from warnings import warn
from weakref import WeakSet

from ._monitor import TMonitor
from .utils import (
    CallbackIOWrapper, Comparable, DisableOnWriteError, FormatReplace, SimpleTextIOWrapper,
    _is_ascii, _screen_shape_wrapper, _supports_unicode, _term_move_up, disp_len, disp_trim,
    envwrap)

__author__ = "https://github.com/tqdm/tqdm#contributions"
__all__ = ['tqdm', 'trange',
           'TqdmTypeError', 'TqdmKeyError', 'TqdmWarning',
           'TqdmExperimentalWarning', 'TqdmDeprecationWarning',
           'TqdmMonitorWarning']


class TqdmTypeError(TypeError):
    pass


class TqdmKeyError(KeyError):
    pass


class TqdmWarning(Warning):
    """base class for all tqdm warnings.

    Used for non-external-code-breaking errors, such as garbled printing.
    """
    def __init__(self, msg, fp_write=None, *a, **k):
        if fp_write is not None:
            fp_write("\n" + self.__class__.__name__ + ": " + str(msg).rstrip() + '\n')
        else:
            super().__init__(msg, *a, **k)


class TqdmExperimentalWarning(TqdmWarning, FutureWarning):
    """beta feature, unstable API and behaviour"""
    pass


class TqdmDeprecationWarning(TqdmWarning, DeprecationWarning):
    # not suppressed if raised
    pass


class TqdmMonitorWarning(TqdmWarning, RuntimeWarning):
    """tqdm monitor errors which do not affect external functionality"""
    pass


def TRLock(*args, **kwargs):
    """threading RLock"""
    try:
        from threading import RLock
        return RLock(*args, **kwargs)
    except (ImportError, OSError):  # pragma: no cover
        pass


class TqdmDefaultWriteLock(object):
    """
    Provide a default write lock for thread and multiprocessing safety.
    Works only on platforms supporting `fork` (so Windows is excluded).
    You must initialise a `tqdm` or `TqdmDefaultWriteLock` instance
    before forking in order for the write lock to work.
    On Windows, you need to supply the lock from the parent to the children as
    an argument to joblib or the parallelism lib you use.
    """
    # global thread lock so no setup required for multithreading.
    # NB: Do not create multiprocessing lock as it sets the multiprocessing
    # context, disallowing `spawn()`/`forkserver()`
    th_lock = TRLock()

    def __init__(self):
        # Create global parallelism locks to avoid racing issues with parallel
        # bars works only if fork available (Linux/MacOSX, but not Windows)
        cls = type(self)
        root_lock = cls.th_lock
        if root_lock is not None:
            root_lock.acquire()
        cls.create_mp_lock()
        self.locks = [lk for lk in [cls.mp_lock, cls.th_lock] if lk is not None]
        if root_lock is not None:
            root_lock.release()

    def acquire(self, *a, **k):
        for lock in self.locks:
            lock.acquire(*a, **k)

    def release(self):
        for lock in self.locks[::-1]:  # Release in inverse order of acquisition
            lock.release()

    def __enter__(self):
        self.acquire()

    def __exit__(self, *exc):
        self.release()

    @classmethod
    def create_mp_lock(cls):
        if not hasattr(cls, 'mp_lock'):
            try:
                from multiprocessing import RLock
                cls.mp_lock = RLock()
            except (ImportError, OSError):  # pragma: no cover
                cls.mp_lock = None

    @classmethod
    def create_th_lock(cls):
        assert hasattr(cls, 'th_lock')
        warn("create_th_lock not needed anymore", TqdmDeprecationWarning, stacklevel=2)


class Bar(object):
    """
    `str.format`-able bar with format specifiers: `[width][type]`

    - `width`
      + unspecified (default): use `self.default_len`
      + `int >= 0`: overrides `self.default_len`
      + `int < 0`: subtract from `self.default_len`
    - `type`
      + `a`: ascii (`charset=self.ASCII` override)
      + `u`: unicode (`charset=self.UTF` override)
      + `b`: blank (`charset="  "` override)
    """
    ASCII = " 123456789#"
    UTF = u" " + u''.join(map(chr, range(0x258F, 0x2587, -1)))
    BLANK = "  "
    COLOUR_RESET = '\x1b[0m'
    COLOUR_RGB = '\x1b[38;2;%d;%d;%dm'
    COLOURS = {'BLACK': '\x1b[30m', 'RED': '\x1b[31m', 'GREEN': '\x1b[32m',
               'YELLOW': '\x1b[33m', 'BLUE': '\x1b[34m', 'MAGENTA': '\x1b[35m',
               'CYAN': '\x1b[36m', 'WHITE': '\x1b[37m'}

    def __init__(self, frac, default_len=10, charset=UTF, colour=None):
        if not 0 <= frac <= 1:
            warn("clamping frac to range [0, 1]", TqdmWarning, stacklevel=2)
            frac = max(0, min(1, frac))
        assert default_len > 0
        self.frac = frac
        self.default_len = default_len
        self.charset = charset
        self.colour = colour

    @property
    def colour(self):
        return self._colour

    @colour.setter
    def colour(self, value):
        if not value:
            self._colour = None
            return
        try:
            if value.upper() in self.COLOURS:
                self._colour = self.COLOURS[value.upper()]
            elif value[0] == '#' and len(value) == 7:
                self._colour = self.COLOUR_RGB % tuple(
                    int(i, 16) for i in (value[1:3], value[3:5], value[5:7]))
            else:
                raise KeyError
        except (KeyError, AttributeError):
            warn("Unknown colour (%s); valid choices: [hex (#00ff00), %s]" % (
                 value, ", ".join(self.COLOURS)),
                 TqdmWarning, stacklevel=2)
            self._colour = None

    def __format__(self, format_spec):
        if format_spec:
            _type = format_spec[-1].lower()
            try:
                charset = {'a': self.ASCII, 'u': self.UTF, 'b': self.BLANK}[_type]
            except KeyError:
                charset = self.charset
            else:
                format_spec = format_spec[:-1]
            if format_spec:
                N_BARS = int(format_spec)
                if N_BARS < 0:
                    N_BARS += self.default_len
            else:
                N_BARS = self.default_len
        else:
            charset = self.charset
            N_BARS = self.default_len

        nsyms = len(charset) - 1
        bar_length, frac_bar_length = divmod(int(self.frac * N_BARS * nsyms), nsyms)

        res = charset[-1] * bar_length
        if bar_length < N_BARS:  # whitespace padding
            res = res + charset[frac_bar_length] + charset[0] * (N_BARS - bar_length - 1)
        return self.colour + res + self.COLOUR_RESET if self.colour else res


class EMA(object):
    """
    Exponential moving average: smoothing to give progressively lower
    weights to older values.

    Parameters
    ----------
    smoothing  : float, optional
        Smoothing factor in range [0, 1], [default: 0.3].
        Increase to give more weight to recent values.
        Ranges from 0 (yields old value) to 1 (yields new value).
    """
    def __init__(self, smoothing=0.3):
        self.alpha = smoothing
        self.last = 0
        self.calls = 0

    def __call__(self, x=None):
        """
        Parameters
        ----------
        x  : float
            New value to include in EMA.
        """
        beta = 1 - self.alpha
        if x is not None:
            self.last = self.alpha * x + beta * self.last
            self.calls += 1
        return self.last / (1 - beta ** self.calls) if self.calls else self.last


class tqdm(Comparable):
    """
    Decorate an iterable object, returning an iterator which acts exactly
    like the original iterable, but prints a dynamically updating
    progressbar every time a value is requested.

    Parameters
    ----------
    iterable  : iterable, optional
        Iterable to decorate with a progressbar.
        Leave blank to manually manage the updates.
    desc  : str, optional
        Prefix for the progressbar.
    total  : int or float, optional
        The number of expected iterations. If unspecified,
        len(iterable) is used if possible. If float("inf") or as a last
        resort, only basic progress statistics are displayed
        (no ETA, no progressbar).
        If `gui` is True and this parameter needs subsequent updating,
        specify an initial arbitrary large positive number,
        e.g. 9e9.
    leave  : bool, optional
        If [default: True], keeps all traces of the progressbar
        upon termination of iteration.
        If `None`, will leave only if `position` is `0`.
    file  : `io.TextIOWrapper` or `io.StringIO`, optional
        Specifies where to output the progress messages
        (default: sys.stderr). Uses `file.write(str)` and `file.flush()`
        methods.  For encoding, see `write_bytes`.
    ncols  : int, optional
        The width of the entire output message. If specified,
        dynamically resizes the progressbar to stay within this bound.
        If unspecified, attempts to use environment width. The
        fallback is a meter width of 10 and no limit for the counter and
        statistics. If 0, will not print any meter (only stats).
    mininterval  : float, optional
        Minimum progress display update interval [default: 0.1] seconds.
    maxinterval  : float, optional
        Maximum progress display update interval [default: 10] seconds.
        Automatically adjusts `miniters` to correspond to `mininterval`
        after long display update lag. Only works if `dynamic_miniters`
        or monitor thread is enabled.
    miniters  : int or float, optional
        Minimum progress display update interval, in iterations.
        If 0 and `dynamic_miniters`, will automatically adjust to equal
        `mininterval` (more CPU efficient, good for tight loops).
        If > 0, will skip display of specified number of iterations.
        Tweak this and `mininterval` to get very efficient loops.
        If your progress is erratic with both fast and slow iterations
        (network, skipping items, etc) you should set miniters=1.
    ascii  : bool or str, optional
        If unspecified or False, use unicode (smooth blocks) to fill
        the meter. The fallback is to use ASCII characters " 123456789#".
    disable  : bool, optional
        Whether to disable the entire progressbar wrapper
        [default: False]. If set to None, disable on non-TTY.
    unit  : str, optional
        String that will be used to define the unit of each iteration
        [default: it].
    unit_scale  : bool or int or float, optional
        If 1 or True, the number of iterations will be reduced/scaled
        automatically and a metric prefix following the
        International System of Units standard will be added
        (kilo, mega, etc.) [default: False]. If any other non-zero
        number, will scale `total` and `n`.
    dynamic_ncols  : bool, optional
        If set, constantly alters `ncols` and `nrows` to the
        environment (allowing for window resizes) [default: False].
    smoothing  : float, optional
        Exponential moving average smoothing factor for speed estimates
        (ignored in GUI mode). Ranges from 0 (average speed) to 1
        (current/instantaneous speed) [default: 0.3].
    bar_format  : str, optional
        Specify a custom bar string formatting. May impact performance.
        [default: '{l_bar}{bar}{r_bar}'], where
        l_bar='{desc}: {percentage:3.0f}%|' and
        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '
            '{rate_fmt}{postfix}]'
        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,
            percentage, elapsed, elapsed_s, ncols, nrows, desc, unit,
            rate, rate_fmt, rate_noinv, rate_noinv_fmt,
            rate_inv, rate_inv_fmt, postfix, unit_divisor,
            remaining, remaining_s, eta.
        Note that a trailing ": " is automatically removed after {desc}
        if the latter is empty.
    initial  : int or float, optional
        The initial counter value. Useful when restarting a progress
        bar [default: 0]. If using float, consider specifying `{n:.3f}`
        or similar in `bar_format`, or specifying `unit_scale`.
    position  : int, optional
        Specify the line offset to print this bar (starting from 0)
        Automatic if unspecified.
        Useful to manage multiple bars at once (eg, from threads).
    postfix  : dict or *, optional
        Specify additional stats to display at the end of the bar.
        Calls `set_postfix(**postfix)` if possible (dict).
    unit_divisor  : float, optional
        [default: 1000], ignored unless `unit_scale` is True.
    write_bytes  : bool, optional
        Whether to write bytes. If (default: False) will write unicode.
    lock_args  : tuple, optional
        Passed to `refresh` for intermediate output
        (initialisation, iterating, and updating).
    nrows  : int, optional
        The screen height. If specified, hides nested bars outside this
        bound. If unspecified, attempts to use environment height.
        The fallback is 20.
    colour  : str, optional
        Bar colour (e.g. 'green', '#00ff00').
    delay  : float, optional
        Don't display until [default: 0] seconds have elapsed.
    gui  : bool, optional
        WARNING: internal parameter - do not use.
        Use tqdm.gui.tqdm(...) instead. If set, will attempt to use
        matplotlib animations for a graphical output [default: False].

    Returns
    -------
    out  : decorated iterator.
    """

    monitor_interval = 10  # set to 0 to disable the thread
    monitor = None
    _instances = WeakSet()

    @staticmethod
    def format_sizeof(num, suffix='', divisor=1000):
        """
        Formats a number (greater than unity) with SI Order of Magnitude
        prefixes.

        Parameters
        ----------
        num  : float
            Number ( >= 1) to format.
        suffix  : str, optional
            Post-postfix [default: ''].
        divisor  : float, optional
            Divisor between prefixes [default: 1000].

        Returns
        -------
        out  : str
            Number with Order of Magnitude SI unit postfix.
        """
        for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:
            if abs(num) < 999.5:
                if abs(num) < 99.95:
                    if abs(num) < 9.995:
                        return f'{num:1.2f}{unit}{suffix}'
                    return f'{num:2.1f}{unit}{suffix}'
                return f'{num:3.0f}{unit}{suffix}'
            num /= divisor
        return f'{num:3.1f}Y{suffix}'

    @staticmethod
    def format_interval(t):
        """
        Formats a number of seconds as a clock time, [H:]MM:SS

        Parameters
        ----------
        t  : int
            Number of seconds.

        Returns
        -------
        out  : str
            [H:]MM:SS
        """
        mins, s = divmod(int(t), 60)
        h, m = divmod(mins, 60)
        return f'{h:d}:{m:02d}:{s:02d}' if h else f'{m:02d}:{s:02d}'

    @staticmethod
    def format_num(n):
        """
        Intelligent scientific notation (.3g).

        Parameters
        ----------
        n  : int or float or Numeric
            A Number.

        Returns
        -------
        out  : str
            Formatted number.
        """
        f = f'{n:.3g}'.replace('e+0', 'e+').replace('e-0', 'e-')
        n = str(n)
        return f if len(f) < len(n) else n

    @staticmethod
    def status_printer(file):
        """
        Manage the printing and in-place updating of a line of characters.
        Note that if the string is longer than a line, then in-place
        updating may not work (it will print a new line at each refresh).
        """
        fp = file
        fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover
        if fp in (sys.stderr, sys.stdout):
            getattr(sys.stderr, 'flush', lambda: None)()
            getattr(sys.stdout, 'flush', lambda: None)()

        def fp_write(s):
            fp.write(str(s))
            fp_flush()

        last_len = [0]

        def print_status(s):
            len_s = disp_len(s)
            fp_write('\r' + s + (' ' * max(last_len[0] - len_s, 0)))
            last_len[0] = len_s

        return print_status

    @staticmethod
    def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it',
                     unit_scale=False, rate=None, bar_format=None, postfix=None,
                     unit_divisor=1000, initial=0, colour=None, **extra_kwargs):
        """
        Return a string-based progress bar given some parameters

        Parameters
        ----------
        n  : int or float
            Number of finished iterations.
        total  : int or float
            The expected total number of iterations. If meaningless (None),
            only basic progress statistics are displayed (no ETA).
        elapsed  : float
            Number of seconds passed since start.
        ncols  : int, optional
            The width of the entire output message. If specified,
            dynamically resizes `{bar}` to stay within this bound
            [default: None]. If `0`, will not print any bar (only stats).
            The fallback is `{bar:10}`.
        prefix  : str, optional
            Prefix message (included in total width) [default: ''].
            Use as {desc} in bar_format string.
        ascii  : bool, optional or str, optional
            If not set, use unicode (smooth blocks) to fill the meter
            [default: False]. The fallback is to use ASCII characters
            " 123456789#".
        unit  : str, optional
            The iteration unit [default: 'it'].
        unit_scale  : bool or int or float, optional
            If 1 or True, the number of iterations will be printed with an
            appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)
            [default: False]. If any other non-zero number, will scale
            `total` and `n`.
        rate  : float, optional
            Manual override for iteration rate.
            If [default: None], uses n/elapsed.
        bar_format  : str, optional
            Specify a custom bar string formatting. May impact performance.
            [default: '{l_bar}{bar}{r_bar}'], where
            l_bar='{desc}: {percentage:3.0f}%|' and
            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '
              '{rate_fmt}{postfix}]'
            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,
              percentage, elapsed, elapsed_s, ncols, nrows, desc, unit,
              rate, rate_fmt, rate_noinv, rate_noinv_fmt,
              rate_inv, rate_inv_fmt, postfix, unit_divisor,
              remaining, remaining_s, eta.
            Note that a trailing ": " is automatically removed after {desc}
            if the latter is empty.
        postfix  : *, optional
            Similar to `prefix`, but placed at the end
            (e.g. for additional stats).
            Note: postfix is usually a string (not a dict) for this method,
            and will if possible be set to postfix = ', ' + postfix.
            However other types are supported (#382).
        unit_divisor  : float, optional
            [default: 1000], ignored unless `unit_scale` is True.
        initial  : int or float, optional
            The initial counter value [default: 0].
        colour  : str, optional
            Bar colour (e.g. 'green', '#00ff00').

        Returns
        -------
        out  : Formatted meter and stats, ready to display.
        """

        # sanity check: total
        if total and n >= (total + 0.5):  # allow float imprecision (#849)
            total = None

        # apply custom scale if necessary
        if unit_scale and unit_scale not in (True, 1):
            if total:
                total *= unit_scale
            n *= unit_scale
            if rate:
                rate *= unit_scale  # by default rate = self.avg_dn / self.avg_dt
            unit_scale = False

        elapsed_str = tqdm.format_interval(elapsed)

        # if unspecified, attempt to use rate = average speed
        # (we allow manual override since predicting time is an arcane art)
        if rate is None and elapsed:
            rate = (n - initial) / elapsed
        inv_rate = 1 / rate if rate else None
        format_sizeof = tqdm.format_sizeof
        rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else f'{rate:5.2f}')
                          if rate else '?') + unit + '/s'
        rate_inv_fmt = (
            (format_sizeof(inv_rate) if unit_scale else f'{inv_rate:5.2f}')
            if inv_rate else '?') + 's/' + unit
        rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt

        if unit_scale:
            n_fmt = format_sizeof(n, divisor=unit_divisor)
            total_fmt = format_sizeof(total, divisor=unit_divisor) if total is not None else '?'
        else:
            n_fmt = str(n)
            total_fmt = str(total) if total is not None else '?'

        try:
            postfix = ', ' + postfix if postfix else ''
        except TypeError:
            pass

        remaining = (total - n) / rate if rate and total else 0
        remaining_str = tqdm.format_interval(remaining) if rate else '?'
        try:
            eta_dt = (datetime.now() + timedelta(seconds=remaining)
                      if rate and total else datetime.fromtimestamp(0, timezone.utc))
        except OverflowError:
            eta_dt = datetime.max

        # format the stats displayed to the left and right sides of the bar
        if prefix:
            # old prefix setup work around
            bool_prefix_colon_already = (prefix[-2:] == ": ")
            l_bar = prefix if bool_prefix_colon_already else prefix + ": "
        else:
            l_bar = ''

        r_bar = f'| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}{postfix}]'

        # Custom bar formatting
        # Populate a dict with all available progress indicators
        format_dict = {
            # slight extension of self.format_dict
            'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt,
            'elapsed': elapsed_str, 'elapsed_s': elapsed,
            'ncols': ncols, 'desc': prefix or '', 'unit': unit,
            'rate': inv_rate if inv_rate and inv_rate > 1 else rate,
            'rate_fmt': rate_fmt, 'rate_noinv': rate,
            'rate_noinv_fmt': rate_noinv_fmt, 'rate_inv': inv_rate,
            'rate_inv_fmt': rate_inv_fmt,
            'postfix': postfix, 'unit_divisor': unit_divisor,
            'colour': colour,
            # plus more useful definitions
            'remaining': remaining_str, 'remaining_s': remaining,
            'l_bar': l_bar, 'r_bar': r_bar, 'eta': eta_dt,
            **extra_kwargs}

        # total is known: we can predict some stats
        if total:
            # fractional and percentage progress
            frac = n / total
            percentage = frac * 100

            l_bar += f'{percentage:3.0f}%|'

            if ncols == 0:
                return l_bar[:-1] + r_bar[1:]

            format_dict.update(l_bar=l_bar)
            if bar_format:
                format_dict.update(percentage=percentage)

                # auto-remove colon for empty `{desc}`
                if not prefix:
                    bar_format = bar_format.replace("{desc}: ", '')
            else:
                bar_format = "{l_bar}{bar}{r_bar}"

            full_bar = FormatReplace()
            nobar = bar_format.format(bar=full_bar, **format_dict)
            if not full_bar.format_called:
                return nobar  # no `{bar}`; nothing else to do

            # Formatting progress bar space available for bar's display
            full_bar = Bar(frac,
                           max(1, ncols - disp_len(nobar)) if ncols else 10,
                           charset=Bar.ASCII if ascii is True else ascii or Bar.UTF,
                           colour=colour)
            if not _is_ascii(full_bar.charset) and _is_ascii(bar_format):
                bar_format = str(bar_format)
            res = bar_format.format(bar=full_bar, **format_dict)
            return disp_trim(res, ncols) if ncols else res

        elif bar_format:
            # user-specified bar_format but no total
            l_bar += '|'
            format_dict.update(l_bar=l_bar, percentage=0)
            full_bar = FormatReplace()
            nobar = bar_format.format(bar=full_bar, **format_dict)
            if not full_bar.format_called:
                return nobar
            full_bar = Bar(0,
                           max(1, ncols - disp_len(nobar)) if ncols else 10,
                           charset=Bar.BLANK, colour=colour)
            res = bar_format.format(bar=full_bar, **format_dict)
            return disp_trim(res, ncols) if ncols else res
        else:
            # no total: no progressbar, ETA, just progress stats
            return (f'{(prefix + ": ") if prefix else ""}'
                    f'{n_fmt}{unit} [{elapsed_str}, {rate_fmt}{postfix}]')

    def __new__(cls, *_, **__):
        instance = object.__new__(cls)
        with cls.get_lock():  # also constructs lock if non-existent
            cls._instances.add(instance)
            # create monitoring thread
            if cls.monitor_interval and (cls.monitor is None
                                         or not cls.monitor.report()):
                try:
                    cls.monitor = TMonitor(cls, cls.monitor_interval)
                except Exception as e:  # pragma: nocover
                    warn("tqdm:disabling monitor support"
                         " (monitor_interval = 0) due to:\n" + str(e),
                         TqdmMonitorWarning, stacklevel=2)
                    cls.monitor_interval = 0
        return instance

    @classmethod
    def _get_free_pos(cls, instance=None):
        """Skips specified instance."""
        positions = {abs(inst.pos) for inst in cls._instances
                     if inst is not instance and hasattr(inst, "pos")}
        return min(set(range(len(positions) + 1)).difference(positions))

    @classmethod
    def _decr_instances(cls, instance):
        """
        Remove from list and reposition another unfixed bar
        to fill the new gap.

        This means that by default (where all nested bars are unfixed),
        order is not maintained but screen flicker/blank space is minimised.
        (tqdm<=4.44.1 moved ALL subsequent unfixed bars up.)
        """
        with cls._lock:
            try:
                cls._instances.remove(instance)
            except KeyError:
                # if not instance.gui:  # pragma: no cover
                #     raise
                pass  # py2: maybe magically removed already
            # else:
            if not instance.gui:
                last = (instance.nrows or 20) - 1
                # find unfixed (`pos >= 0`) overflow (`pos >= nrows - 1`)
                instances = list(filter(
                    lambda i: hasattr(i, "pos") and last <= i.pos,
                    cls._instances))
                # set first found to current `pos`
                if instances:
                    inst = min(instances, key=lambda i: i.pos)
                    inst.clear(nolock=True)
                    inst.pos = abs(instance.pos)

    @classmethod
    def write(cls, s, file=None, end="\n", nolock=False):
        """Print a message via tqdm (without overlap with bars)."""
        fp = file if file is not None else sys.stdout
        with cls.external_write_mode(file=file, nolock=nolock):
            # Write the message
            fp.write(s)
            fp.write(end)

    @classmethod
    @contextmanager
    def external_write_mode(cls, file=None, nolock=False):
        """
        Disable tqdm within context and refresh tqdm when exits.
        Useful when writing to standard output stream
        """
        fp = file if file is not None else sys.stdout

        try:
            if not nolock:
                cls.get_lock().acquire()
            # Clear all bars
            inst_cleared = []
            for inst in getattr(cls, '_instances', []):
                # Clear instance if in the target output file
                # or if write output + tqdm output are both either
                # sys.stdout or sys.stderr (because both are mixed in terminal)
                if hasattr(inst, "start_t") and (inst.fp == fp or all(
                        f in (sys.stdout, sys.stderr) for f in (fp, inst.fp))):
                    inst.clear(nolock=True)
                    inst_cleared.append(inst)
            yield
            # Force refresh display of bars we cleared
            for inst in inst_cleared:
                inst.refresh(nolock=True)
        finally:
            if not nolock:
                cls._lock.release()

    @classmethod
    def set_lock(cls, lock):
        """Set the global lock."""
        cls._lock = lock

    @classmethod
    def get_lock(cls):
        """Get the global lock. Construct it if it does not exist."""
        if not hasattr(cls, '_lock'):
            cls._lock = TqdmDefaultWriteLock()
        return cls._lock

    @classmethod
    def pandas(cls, **tqdm_kwargs):
        """
        Registers the current `tqdm` class with
            pandas.core.
            ( frame.DataFrame
            | series.Series
            | groupby.(generic.)DataFrameGroupBy
            | groupby.(generic.)SeriesGroupBy
            ).progress_apply

        A new instance will be created every time `progress_apply` is called,
        and each instance will automatically `close()` upon completion.

        Parameters
        ----------
        tqdm_kwargs  : arguments for the tqdm instance

        Examples
        --------
        >>> import pandas as pd
        >>> import numpy as np
        >>> from tqdm import tqdm
        >>> from tqdm.gui import tqdm as tqdm_gui
        >>>
        >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))
        >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc
        >>> # Now you can use `progress_apply` instead of `apply`
        >>> df.groupby(0).progress_apply(lambda x: x**2)

        References
        ----------
        <https://stackoverflow.com/questions/18603270/\
        progress-indicator-during-pandas-operations-python>
        """
        from warnings import catch_warnings, simplefilter

        from pandas.core.frame import DataFrame
        from pandas.core.series import Series
        try:
            with catch_warnings():
                simplefilter("ignore", category=FutureWarning)
                from pandas import Panel
        except ImportError:  # pandas>=1.2.0
            Panel = None
        Rolling, Expanding = None, None
        try:  # pandas>=1.0.0
            from pandas.core.window.rolling import _Rolling_and_Expanding
        except ImportError:
            try:  # pandas>=0.18.0
                from pandas.core.window import _Rolling_and_Expanding
            except ImportError:  # pandas>=1.2.0
                try:  # pandas>=1.2.0
                    from pandas.core.window.expanding import Expanding
                    from pandas.core.window.rolling import Rolling
                    _Rolling_and_Expanding = Rolling, Expanding
                except ImportError:  # pragma: no cover
                    _Rolling_and_Expanding = None
        try:  # pandas>=0.25.0
            from pandas.core.groupby.generic import SeriesGroupBy  # , NDFrameGroupBy
            from pandas.core.groupby.generic import DataFrameGroupBy
        except ImportError:  # pragma: no cover
            try:  # pandas>=0.23.0
                from pandas.core.groupby.groupby import DataFrameGroupBy, SeriesGroupBy
            except ImportError:
                from pandas.core.groupby import DataFrameGroupBy, SeriesGroupBy
        try:  # pandas>=0.23.0
            from pandas.core.groupby.groupby import GroupBy
        except ImportError:  # pragma: no cover
            from pandas.core.groupby import GroupBy

        try:  # pandas>=0.23.0
            from pandas.core.groupby.groupby import PanelGroupBy
        except ImportError:
            try:
                from pandas.core.groupby import PanelGroupBy
            except ImportError:  # pandas>=0.25.0
                PanelGroupBy = None

        tqdm_kwargs = tqdm_kwargs.copy()
        deprecated_t = [tqdm_kwargs.pop('deprecated_t', None)]

        def inner_generator(df_function='apply'):
            def inner(df, func, *args, **kwargs):
                """
                Parameters
                ----------
                df  : (DataFrame|Series)[GroupBy]
                    Data (may be grouped).
                func  : function
                    To be applied on the (grouped) data.
                **kwargs  : optional
                    Transmitted to `df.apply()`.
                """

                # Precompute total iterations
                total = tqdm_kwargs.pop("total", getattr(df, 'ngroups', None))
                if total is None:  # not grouped
                    if df_function == 'applymap':
                        total = df.size
                    elif isinstance(df, Series):
                        total = len(df)
                    elif (_Rolling_and_Expanding is None or
                          not isinstance(df, _Rolling_and_Expanding)):
                        # DataFrame or Panel
                        axis = kwargs.get('axis', 0)
                        if axis == 'index':
                            axis = 0
                        elif axis == 'columns':
                            axis = 1
                        # when axis=0, total is shape[axis1]
                        total = df.size // df.shape[axis]

                # Init bar
                if deprecated_t[0] is not None:
                    t = deprecated_t[0]
                    deprecated_t[0] = None
                else:
                    t = cls(total=total, **tqdm_kwargs)

                if len(args) > 0:
                    # *args intentionally not supported (see #244, #299)
                    TqdmDeprecationWarning(
                        "Except func, normal arguments are intentionally" +
                        " not supported by" +
                        " `(DataFrame|Series|GroupBy).progress_apply`." +
                        " Use keyword arguments instead.",
                        fp_write=getattr(t.fp, 'write', sys.stderr.write))

                try:  # pandas>=1.3.0
                    from pandas.core.common import is_builtin_func
                except ImportError:
                    is_builtin_func = df._is_builtin_func
                try:
                    func = is_builtin_func(func)
                except TypeError:
                    pass

                # Define bar updating wrapper
                def wrapper(*args, **kwargs):
                    # update tbar correctly
                    # it seems `pandas apply` calls `func` twice
                    # on the first column/row to decide whether it can
                    # take a fast or slow code path; so stop when t.total==t.n
                    t.update(n=1 if not t.total or t.n < t.total else 0)
                    return func(*args, **kwargs)

                # Apply the provided function (in **kwargs)
                # on the df using our wrapper (which provides bar updating)
                try:
                    return getattr(df, df_function)(wrapper, **kwargs)
                finally:
                    t.close()

            return inner

        # Monkeypatch pandas to provide easy methods
        # Enable custom tqdm progress in pandas!
        Series.progress_apply = inner_generator()
        SeriesGroupBy.progress_apply = inner_generator()
        Series.progress_map = inner_generator('map')
        SeriesGroupBy.progress_map = inner_generator('map')

        DataFrame.progress_apply = inner_generator()
        DataFrameGroupBy.progress_apply = inner_generator()
        DataFrame.progress_applymap = inner_generator('applymap')
        DataFrame.progress_map = inner_generator('map')
        DataFrameGroupBy.progress_map = inner_generator('map')

        if Panel is not None:
            Panel.progress_apply = inner_generator()
        if PanelGroupBy is not None:
            PanelGroupBy.progress_apply = inner_generator()

        GroupBy.progress_apply = inner_generator()
        GroupBy.progress_aggregate = inner_generator('aggregate')
        GroupBy.progress_transform = inner_generator('transform')

        if Rolling is not None and Expanding is not None:
            Rolling.progress_apply = inner_generator()
            Expanding.progress_apply = inner_generator()
        elif _Rolling_and_Expanding is not None:
            _Rolling_and_Expanding.progress_apply = inner_generator()

    # override defaults via env vars
    @envwrap("TQDM_", is_method=True, types={'total': float, 'ncols': int, 'miniters': float,
                                             'position': int, 'nrows': int})
    def __init__(self, iterable=None, desc=None, total=None, leave=True, file=None,
                 ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None,
                 ascii=None, disable=False, unit='it', unit_scale=False,
                 dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0,
                 position=None, postfix=None, unit_divisor=1000, write_bytes=False,
                 lock_args=None, nrows=None, colour=None, delay=0.0, gui=False,
                 **kwargs):
        """see tqdm.tqdm for arguments"""
        if file is None:
            file = sys.stderr

        if write_bytes:
            # Despite coercing unicode into bytes, py2 sys.std* streams
            # should have bytes written to them.
            file = SimpleTextIOWrapper(
                file, encoding=getattr(file, 'encoding', None) or 'utf-8')

        file = DisableOnWriteError(file, tqdm_instance=self)

        if disable is None and hasattr(file, "isatty") and not file.isatty():
            disable = True

        if total is None and iterable is not None:
            try:
                total = len(iterable)
            except (TypeError, AttributeError):
                total = None
        if total == float("inf"):
            # Infinite iterations, behave same as unknown
            total = None

        if disable:
            self.iterable = iterable
            self.disable = disable
            with self._lock:
                self.pos = self._get_free_pos(self)
                self._instances.remove(self)
            self.n = initial
            self.total = total
            self.leave = leave
            return

        if kwargs:
            self.disable = True
            with self._lock:
                self.pos = self._get_free_pos(self)
                self._instances.remove(self)
            raise (
                TqdmDeprecationWarning(
                    "`nested` is deprecated and automated.\n"
                    "Use `position` instead for manual control.\n",
                    fp_write=getattr(file, 'write', sys.stderr.write))
                if "nested" in kwargs else
                TqdmKeyError("Unknown argument(s): " + str(kwargs)))

        # Preprocess the arguments
        if (
            (ncols is None or nrows is None) and (file in (sys.stderr, sys.stdout))
        ) or dynamic_ncols:  # pragma: no cover
            if dynamic_ncols:
                dynamic_ncols = _screen_shape_wrapper()
                if dynamic_ncols:
                    ncols, nrows = dynamic_ncols(file)
            else:
                _dynamic_ncols = _screen_shape_wrapper()
                if _dynamic_ncols:
                    _ncols, _nrows = _dynamic_ncols(file)
                    if ncols is None:
                        ncols = _ncols
                    if nrows is None:
                        nrows = _nrows

        if miniters is None:
            miniters = 0
            dynamic_miniters = True
        else:
            dynamic_miniters = False

        if mininterval is None:
            mininterval = 0

        if maxinterval is None:
            maxinterval = 0

        if ascii is None:
            ascii = not _supports_unicode(file)

        if bar_format and ascii is not True and not _is_ascii(ascii):
            # Convert bar format into unicode since terminal uses unicode
            bar_format = str(bar_format)

        if smoothing is None:
            smoothing = 0

        # Store the arguments
        self.iterable = iterable
        self.desc = desc or ''
        self.total = total
        self.leave = leave
        self.fp = file
        self.ncols = ncols
        self.nrows = nrows
        self.mininterval = mininterval
        self.maxinterval = maxinterval
        self.miniters = miniters
        self.dynamic_miniters = dynamic_miniters
        self.ascii = ascii
        self.disable = disable
        self.unit = unit
        self.unit_scale = unit_scale
        self.unit_divisor = unit_divisor
        self.initial = initial
        self.lock_args = lock_args
        self.delay = delay
        self.gui = gui
        self.dynamic_ncols = dynamic_ncols
        self.smoothing = smoothing
        self._ema_dn = EMA(smoothing)
        self._ema_dt = EMA(smoothing)
        self._ema_miniters = EMA(smoothing)
        self.bar_format = bar_format
        self.postfix = None
        self.colour = colour
        self._time = time
        if postfix:
            try:
                self.set_postfix(refresh=False, **postfix)
            except TypeError:
                self.postfix = postfix

        # Init the iterations counters
        self.last_print_n = initial
        self.n = initial

        # if nested, at initial sp() call we replace '\r' by '\n' to
        # not overwrite the outer progress bar
        with self._lock:
            # mark fixed positions as negative
            self.pos = self._get_free_pos(self) if position is None else -position

        if not gui:
            # Initialize the screen printer
            self.sp = self.status_printer(self.fp)
            if delay <= 0:
                self.refresh(lock_args=self.lock_args)

        # Init the time counter
        self.last_print_t = self._time()
        # NB: Avoid race conditions by setting start_t at the very end of init
        self.start_t = self.last_print_t

    def __bool__(self):
        if self.total is not None:
            return self.total > 0
        if self.iterable is None:
            raise TypeError('bool() undefined when iterable == total == None')
        return bool(self.iterable)

    def __len__(self):
        return (
            self.total if self.iterable is None
            else self.iterable.shape[0] if hasattr(self.iterable, "shape")
            else len(self.iterable) if hasattr(self.iterable, "__len__")
            else self.iterable.__length_hint__() if hasattr(self.iterable, "__length_hint__")
            else getattr(self, "total", None))

    def __reversed__(self):
        try:
            orig = self.iterable
        except AttributeError:
            raise TypeError("'tqdm' object is not reversible")
        else:
            self.iterable = reversed(self.iterable)
            return self.__iter__()
        finally:
            self.iterable = orig

    def __contains__(self, item):
        contains = getattr(self.iterable, '__contains__', None)
        return contains(item) if contains is not None else item in self.__iter__()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        try:
            self.close()
        except AttributeError:
            # maybe eager thread cleanup upon external error
            if (exc_type, exc_value, traceback) == (None, None, None):
                raise
            warn("AttributeError ignored", TqdmWarning, stacklevel=2)

    def __del__(self):
        self.close()

    def __str__(self):
        return self.format_meter(**self.format_dict)

    @property
    def _comparable(self):
        return abs(getattr(self, "pos", 1 << 31))

    def __hash__(self):
        return id(self)

    def __iter__(self):
        """Backward-compatibility to use: for x in tqdm(iterable)"""

        # Inlining instance variables as locals (speed optimisation)
        iterable = self.iterable

        # If the bar is disabled, then just walk the iterable
        # (note: keep this check outside the loop for performance)
        if self.disable:
            for obj in iterable:
                yield obj
            return

        mininterval = self.mininterval
        last_print_t = self.last_print_t
        last_print_n = self.last_print_n
        min_start_t = self.start_t + self.delay
        n = self.n
        time = self._time

        try:
            for obj in iterable:
                yield obj
                # Update and possibly print the progressbar.
                # Note: does not call self.update(1) for speed optimisation.
                n += 1

                if n - last_print_n >= self.miniters:
                    cur_t = time()
                    dt = cur_t - last_print_t
                    if dt >= mininterval and cur_t >= min_start_t:
                        self.update(n - last_print_n)
                        last_print_n = self.last_print_n
                        last_print_t = self.last_print_t
        finally:
            self.n = n
            self.close()

    def update(self, n=1):
        """
        Manually update the progress bar, useful for streams
        such as reading files.
        E.g.:
        >>> t = tqdm(total=filesize) # Initialise
        >>> for current_buffer in stream:
        ...    ...
        ...    t.update(len(current_buffer))
        >>> t.close()
        The last line is highly recommended, but possibly not necessary if
        `t.update()` will be called in such a way that `filesize` will be
        exactly reached and printed.

        Parameters
        ----------
        n  : int or float, optional
            Increment to add to the internal counter of iterations
            [default: 1]. If using float, consider specifying `{n:.3f}`
            or similar in `bar_format`, or specifying `unit_scale`.

        Returns
        -------
        out  : bool or None
            True if a `display()` was triggered.
        """
        if self.disable:
            return

        if n < 0:
            self.last_print_n += n  # for auto-refresh logic to work
        self.n += n

        # check counter first to reduce calls to time()
        if self.n - self.last_print_n >= self.miniters:
            cur_t = self._time()
            dt = cur_t - self.last_print_t
            if dt >= self.mininterval and cur_t >= self.start_t + self.delay:
                cur_t = self._time()
                dn = self.n - self.last_print_n  # >= n
                if self.smoothing and dt and dn:
                    # EMA (not just overall average)
                    self._ema_dn(dn)
                    self._ema_dt(dt)
                self.refresh(lock_args=self.lock_args)
                if self.dynamic_miniters:
                    # If no `miniters` was specified, adjust automatically to the
                    # maximum iteration rate seen so far between two prints.
                    # e.g.: After running `tqdm.update(5)`, subsequent
                    # calls to `tqdm.update()` will only cause an update after
                    # at least 5 more iterations.
                    if self.maxinterval and dt >= self.maxinterval:
                        self.miniters = dn * (self.mininterval or self.maxinterval) / dt
                    elif self.smoothing:
                        # EMA miniters update
                        self.miniters = self._ema_miniters(
                            dn * (self.mininterval / dt if self.mininterval and dt
                                  else 1))
                    else:
                        # max iters between two prints
                        self.miniters = max(self.miniters, dn)

                # Store old values for next call
                self.last_print_n = self.n
                self.last_print_t = cur_t
                return True

    def close(self):
        """Cleanup and (if leave=False) close the progressbar."""
        if self.disable:
            return

        # Prevent multiple closures
        self.disable = True

        # decrement instance pos and remove from internal set
        pos = abs(self.pos)
        self._decr_instances(self)

        if self.last_print_t < self.start_t + self.delay:
            # haven't ever displayed; nothing to clear
            return

        # GUI mode
        if getattr(self, 'sp', None) is None:
            return

        # annoyingly, _supports_unicode isn't good enough
        def fp_write(s):
            self.fp.write(str(s))

        try:
            fp_write('')
        except ValueError as e:
            if 'closed' in str(e):
                return
            raise  # pragma: no cover

        leave = pos == 0 if self.leave is None else self.leave

        with self._lock:
            if leave:
                # stats for overall rate (no weighted average)
                self._ema_dt = lambda: None
                self.display(pos=0)
                fp_write('\n')
            else:
                # clear previous display
                if self.display(msg='', pos=pos) and not pos:
                    fp_write('\r')

    def clear(self, nolock=False):
        """Clear current bar display."""
        if self.disable:
            return

        if not nolock:
            self._lock.acquire()
        pos = abs(self.pos)
        if pos < (self.nrows or 20):
            self.moveto(pos)
            self.sp('')
            self.fp.write('\r')  # place cursor back at the beginning of line
            self.moveto(-pos)
        if not nolock:
            self._lock.release()

    def refresh(self, nolock=False, lock_args=None):
        """
        Force refresh the display of this bar.

        Parameters
        ----------
        nolock  : bool, optional
            If `True`, does not lock.
            If [default: `False`]: calls `acquire()` on internal lock.
        lock_args  : tuple, optional
            Passed to internal lock's `acquire()`.
            If specified, will only `display()` if `acquire()` returns `True`.
        """
        if self.disable:
            return

        if not nolock:
            if lock_args:
                if not self._lock.acquire(*lock_args):
                    return False
            else:
                self._lock.acquire()
        self.display()
        if not nolock:
            self._lock.release()
        return True

    def unpause(self):
        """Restart tqdm timer from last print time."""
        if self.disable:
            return
        cur_t = self._time()
        self.start_t += cur_t - self.last_print_t
        self.last_print_t = cur_t

    def reset(self, total=None):
        """
        Resets to 0 iterations for repeated use.

        Consider combining with `leave=True`.

        Parameters
        ----------
        total  : int or float, optional. Total to use for the new bar.
        """
        self.n = 0
        if total is not None:
            self.total = total
        if self.disable:
            return
        self.last_print_n = 0
        self.last_print_t = self.start_t = self._time()
        self._ema_dn = EMA(self.smoothing)
        self._ema_dt = EMA(self.smoothing)
        self._ema_miniters = EMA(self.smoothing)
        self.refresh()

    def set_description(self, desc=None, refresh=True):
        """
        Set/modify description of the progress bar.

        Parameters
        ----------
        desc  : str, optional
        refresh  : bool, optional
            Forces refresh [default: True].
        """
        self.desc = desc + ': ' if desc else ''
        if refresh:
            self.refresh()

    def set_description_str(self, desc=None, refresh=True):
        """Set/modify description without ': ' appended."""
        self.desc = desc or ''
        if refresh:
            self.refresh()

    def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):
        """
        Set/modify postfix (additional stats)
        with automatic formatting based on datatype.

        Parameters
        ----------
        ordered_dict  : dict or OrderedDict, optional
        refresh  : bool, optional
            Forces refresh [default: True].
        kwargs  : dict, optional
        """
        # Sort in alphabetical order to be more deterministic
        postfix = OrderedDict([] if ordered_dict is None else ordered_dict)
        for key in sorted(kwargs.keys()):
            postfix[key] = kwargs[key]
        # Preprocess stats according to datatype
        for key in postfix.keys():
            # Number: limit the length of the string
            if isinstance(postfix[key], Number):
                postfix[key] = self.format_num(postfix[key])
            # Else for any other type, try to get the string conversion
            elif not isinstance(postfix[key], str):
                postfix[key] = str(postfix[key])
            # Else if it's a string, don't need to preprocess anything
        # Stitch together to get the final postfix
        self.postfix = ', '.join(key + '=' + postfix[key].strip()
                                 for key in postfix.keys())
        if refresh:
            self.refresh()

    def set_postfix_str(self, s='', refresh=True):
        """
        Postfix without dictionary expansion, similar to prefix handling.
        """
        self.postfix = str(s)
        if refresh:
            self.refresh()

    def moveto(self, n):
        # TODO: private method
        self.fp.write('\n' * n + _term_move_up() * -n)
        getattr(self.fp, 'flush', lambda: None)()

    @property
    def format_dict(self):
        """Public API for read-only member access."""
        if self.disable and not hasattr(self, 'unit'):
            return defaultdict(lambda: None, {
                'n': self.n, 'total': self.total, 'elapsed': 0, 'unit': 'it'})
        if self.dynamic_ncols:
            self.ncols, self.nrows = self.dynamic_ncols(self.fp)
        return {
            'n': self.n, 'total': self.total,
            'elapsed': self._time() - self.start_t if hasattr(self, 'start_t') else 0,
            'ncols': self.ncols, 'nrows': self.nrows, 'prefix': self.desc,
            'ascii': self.ascii, 'unit': self.unit, 'unit_scale': self.unit_scale,
            'rate': self._ema_dn() / self._ema_dt() if self._ema_dt() else None,
            'bar_format': self.bar_format, 'postfix': self.postfix,
            'unit_divisor': self.unit_divisor, 'initial': self.initial,
            'colour': self.colour}

    def display(self, msg=None, pos=None):
        """
        Use `self.sp` to display `msg` in the specified `pos`.

        Consider overloading this function when inheriting to use e.g.:
        `self.some_frontend(**self.format_dict)` instead of `self.sp`.

        Parameters
        ----------
        msg  : str, optional. What to display (default: `repr(self)`).
        pos  : int, optional. Position to `moveto`
          (default: `abs(self.pos)`).
        """
        if pos is None:
            pos = abs(self.pos)

        nrows = self.nrows or 20
        if pos >= nrows - 1:
            if pos >= nrows:
                return False
            if msg or msg is None:  # override at `nrows - 1`
                msg = " ... (more hidden) ..."

        if not hasattr(self, "sp"):
            raise TqdmDeprecationWarning(
                "Please use `tqdm.gui.tqdm(...)`"
                " instead of `tqdm(..., gui=True)`\n",
                fp_write=getattr(self.fp, 'write', sys.stderr.write))

        if pos:
            self.moveto(pos)
        self.sp(self.__str__() if msg is None else msg)
        if pos:
            self.moveto(-pos)
        return True

    @classmethod
    @contextmanager
    def wrapattr(cls, stream, method, total=None, bytes=True, **tqdm_kwargs):
        """
        stream  : file-like object.
        method  : str, "read" or "write". The result of `read()` and
            the first argument of `write()` should have a `len()`.

        >>> with tqdm.wrapattr(file_obj, "read", total=file_obj.size) as fobj:
        ...     while True:
        ...         chunk = fobj.read(chunk_size)
        ...         if not chunk:
        ...             break
        """
        with cls(total=total, **tqdm_kwargs) as t:
            if bytes:
                t.unit = "B"
                t.unit_scale = True
                t.unit_divisor = 1024
            yield CallbackIOWrapper(t.update, stream, method)


def trange(*args, **kwargs):
    """Shortcut for tqdm(range(*args), **kwargs)."""
    return tqdm(range(*args), **kwargs)


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\tk.py
# ================================================================================

"""
Tkinter GUI progressbar decorator for iterators.

Usage:
>>> from tqdm.tk import trange, tqdm
>>> for i in trange(10):
...     ...
"""
import re
import sys
import tkinter
import tkinter.ttk as ttk
from warnings import warn

from .std import TqdmExperimentalWarning, TqdmWarning
from .std import tqdm as std_tqdm

__author__ = {"github.com/": ["richardsheridan", "casperdcl"]}
__all__ = ['tqdm_tk', 'ttkrange', 'tqdm', 'trange']


class tqdm_tk(std_tqdm):  # pragma: no cover
    """
    Experimental Tkinter GUI version of tqdm!

    Note: Window interactivity suffers if `tqdm_tk` is not running within
    a Tkinter mainloop and values are generated infrequently. In this case,
    consider calling `tqdm_tk.refresh()` frequently in the Tk thread.
    """

    # TODO: @classmethod: write()?

    def __init__(self, *args, **kwargs):
        """
        This class accepts the following parameters *in addition* to
        the parameters accepted by `tqdm`.

        Parameters
        ----------
        grab  : bool, optional
            Grab the input across all windows of the process.
        tk_parent  : `tkinter.Wm`, optional
            Parent Tk window.
        cancel_callback  : Callable, optional
            Create a cancel button and set `cancel_callback` to be called
            when the cancel or window close button is clicked.
        """
        kwargs = kwargs.copy()
        kwargs['gui'] = True
        # convert disable = None to False
        kwargs['disable'] = bool(kwargs.get('disable', False))
        self._warn_leave = 'leave' in kwargs
        grab = kwargs.pop('grab', False)
        tk_parent = kwargs.pop('tk_parent', None)
        self._cancel_callback = kwargs.pop('cancel_callback', None)
        super().__init__(*args, **kwargs)

        if self.disable:
            return

        if tk_parent is None:  # Discover parent widget
            try:
                tk_parent = tkinter._default_root
            except AttributeError:
                raise AttributeError(
                    "`tk_parent` required when using `tkinter.NoDefaultRoot()`")
            if tk_parent is None:  # use new default root window as display
                self._tk_window = tkinter.Tk()
            else:  # some other windows already exist
                self._tk_window = tkinter.Toplevel()
        else:
            self._tk_window = tkinter.Toplevel(tk_parent)

        warn("GUI is experimental/alpha", TqdmExperimentalWarning, stacklevel=2)
        self._tk_dispatching = self._tk_dispatching_helper()

        self._tk_window.protocol("WM_DELETE_WINDOW", self.cancel)
        self._tk_window.wm_title(self.desc)
        self._tk_window.wm_attributes("-topmost", 1)
        self._tk_window.after(0, lambda: self._tk_window.wm_attributes("-topmost", 0))
        self._tk_n_var = tkinter.DoubleVar(self._tk_window, value=0)
        self._tk_text_var = tkinter.StringVar(self._tk_window)
        pbar_frame = ttk.Frame(self._tk_window, padding=5)
        pbar_frame.pack()
        _tk_label = ttk.Label(pbar_frame, textvariable=self._tk_text_var,
                              wraplength=600, anchor="center", justify="center")
        _tk_label.pack()
        self._tk_pbar = ttk.Progressbar(
            pbar_frame, variable=self._tk_n_var, length=450)
        if self.total is not None:
            self._tk_pbar.configure(maximum=self.total)
        else:
            self._tk_pbar.configure(mode="indeterminate")
        self._tk_pbar.pack()
        if self._cancel_callback is not None:
            _tk_button = ttk.Button(pbar_frame, text="Cancel", command=self.cancel)
            _tk_button.pack()
        if grab:
            self._tk_window.grab_set()

    def close(self):
        if self.disable:
            return

        self.disable = True

        with self.get_lock():
            self._instances.remove(self)

        def _close():
            self._tk_window.after('idle', self._tk_window.destroy)
            if not self._tk_dispatching:
                self._tk_window.update()

        self._tk_window.protocol("WM_DELETE_WINDOW", _close)

        # if leave is set but we are self-dispatching, the left window is
        # totally unresponsive unless the user manually dispatches
        if not self.leave:
            _close()
        elif not self._tk_dispatching:
            if self._warn_leave:
                warn("leave flag ignored if not in tkinter mainloop",
                     TqdmWarning, stacklevel=2)
            _close()

    def clear(self, *_, **__):
        pass

    def display(self, *_, **__):
        self._tk_n_var.set(self.n)
        d = self.format_dict
        # remove {bar}
        d['bar_format'] = (d['bar_format'] or "{l_bar}<bar/>{r_bar}").replace(
            "{bar}", "<bar/>")
        msg = self.format_meter(**d)
        if '<bar/>' in msg:
            msg = "".join(re.split(r'\|?<bar/>\|?', msg, maxsplit=1))
        self._tk_text_var.set(msg)
        if not self._tk_dispatching:
            self._tk_window.update()

    def set_description(self, desc=None, refresh=True):
        self.set_description_str(desc, refresh)

    def set_description_str(self, desc=None, refresh=True):
        self.desc = desc
        if not self.disable:
            self._tk_window.wm_title(desc)
            if refresh and not self._tk_dispatching:
                self._tk_window.update()

    def cancel(self):
        """
        `cancel_callback()` followed by `close()`
        when close/cancel buttons clicked.
        """
        if self._cancel_callback is not None:
            self._cancel_callback()
        self.close()

    def reset(self, total=None):
        """
        Resets to 0 iterations for repeated use.

        Parameters
        ----------
        total  : int or float, optional. Total to use for the new bar.
        """
        if hasattr(self, '_tk_pbar'):
            if total is None:
                self._tk_pbar.configure(maximum=100, mode="indeterminate")
            else:
                self._tk_pbar.configure(maximum=total, mode="determinate")
        super().reset(total=total)

    @staticmethod
    def _tk_dispatching_helper():
        """determine if Tkinter mainloop is dispatching events"""
        codes = {tkinter.mainloop.__code__, tkinter.Misc.mainloop.__code__}
        for frame in sys._current_frames().values():
            while frame:
                if frame.f_code in codes:
                    return True
                frame = frame.f_back
        return False


def ttkrange(*args, **kwargs):
    """Shortcut for `tqdm.tk.tqdm(range(*args), **kwargs)`."""
    return tqdm_tk(range(*args), **kwargs)


# Aliases
tqdm = tqdm_tk
trange = ttkrange


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\utils.py
# ================================================================================

"""
General helpers required for `tqdm.std`.
"""
import os
import re
import sys
from functools import partial, partialmethod, wraps
from inspect import signature
# TODO consider using wcswidth third-party package for 0-width characters
from unicodedata import east_asian_width
from warnings import warn
from weakref import proxy

_range, _unich, _unicode, _basestring = range, chr, str, str
CUR_OS = sys.platform
IS_WIN = any(CUR_OS.startswith(i) for i in ['win32', 'cygwin'])
IS_NIX = any(CUR_OS.startswith(i) for i in ['aix', 'linux', 'darwin', 'freebsd'])
RE_ANSI = re.compile(r"\x1b\[[;\d]*[A-Za-z]")

try:
    if IS_WIN:
        import colorama
    else:
        raise ImportError
except ImportError:
    colorama = None
else:
    try:
        colorama.init(strip=False)
    except TypeError:
        colorama.init()


def envwrap(prefix, types=None, is_method=False):
    """
    Override parameter defaults via `os.environ[prefix + param_name]`.
    Maps UPPER_CASE env vars map to lower_case param names.
    camelCase isn't supported (because Windows ignores case).

    Precedence (highest first):

    - call (`foo(a=3)`)
    - environ (`FOO_A=2`)
    - signature (`def foo(a=1)`)

    Parameters
    ----------
    prefix  : str
        Env var prefix, e.g. "FOO_"
    types  : dict, optional
        Fallback mappings `{'param_name': type, ...}` if types cannot be
        inferred from function signature.
        Consider using `types=collections.defaultdict(lambda: ast.literal_eval)`.
    is_method  : bool, optional
        Whether to use `functools.partialmethod`. If (default: False) use `functools.partial`.

    Examples
    --------
    ```
    $ cat foo.py
    from tqdm.utils import envwrap
    @envwrap("FOO_")
    def test(a=1, b=2, c=3):
        print(f"received: a={a}, b={b}, c={c}")

    $ FOO_A=42 FOO_C=1337 python -c 'import foo; foo.test(c=99)'
    received: a=42, b=2, c=99
    ```
    """
    if types is None:
        types = {}
    i = len(prefix)
    env_overrides = {k[i:].lower(): v for k, v in os.environ.items() if k.startswith(prefix)}
    part = partialmethod if is_method else partial

    def wrap(func):
        params = signature(func).parameters
        # ignore unknown env vars
        overrides = {k: v for k, v in env_overrides.items() if k in params}
        # infer overrides' `type`s
        for k in overrides:
            param = params[k]
            if param.annotation is not param.empty:  # typehints
                for typ in getattr(param.annotation, '__args__', (param.annotation,)):
                    try:
                        overrides[k] = typ(overrides[k])
                    except Exception:
                        pass
                    else:
                        break
            elif param.default is not None:  # type of default value
                overrides[k] = type(param.default)(overrides[k])
            else:
                try:  # `types` fallback
                    overrides[k] = types[k](overrides[k])
                except KeyError:  # keep unconverted (`str`)
                    pass
        return part(func, **overrides)
    return wrap


class FormatReplace(object):
    """
    >>> a = FormatReplace('something')
    >>> f"{a:5d}"
    'something'
    """  # NOQA: P102
    def __init__(self, replace=''):
        self.replace = replace
        self.format_called = 0

    def __format__(self, _):
        self.format_called += 1
        return self.replace


class Comparable(object):
    """Assumes child has self._comparable attr/@property"""
    def __lt__(self, other):
        return self._comparable < other._comparable

    def __le__(self, other):
        return (self < other) or (self == other)

    def __eq__(self, other):
        return self._comparable == other._comparable

    def __ne__(self, other):
        return not self == other

    def __gt__(self, other):
        return not self <= other

    def __ge__(self, other):
        return not self < other


class ObjectWrapper(object):
    def __getattr__(self, name):
        return getattr(self._wrapped, name)

    def __setattr__(self, name, value):
        return setattr(self._wrapped, name, value)

    def wrapper_getattr(self, name):
        """Actual `self.getattr` rather than self._wrapped.getattr"""
        try:
            return object.__getattr__(self, name)
        except AttributeError:  # py2
            return getattr(self, name)

    def wrapper_setattr(self, name, value):
        """Actual `self.setattr` rather than self._wrapped.setattr"""
        return object.__setattr__(self, name, value)

    def __init__(self, wrapped):
        """
        Thin wrapper around a given object
        """
        self.wrapper_setattr('_wrapped', wrapped)


class SimpleTextIOWrapper(ObjectWrapper):
    """
    Change only `.write()` of the wrapped object by encoding the passed
    value and passing the result to the wrapped object's `.write()` method.
    """
    # pylint: disable=too-few-public-methods
    def __init__(self, wrapped, encoding):
        super().__init__(wrapped)
        self.wrapper_setattr('encoding', encoding)

    def write(self, s):
        """
        Encode `s` and pass to the wrapped object's `.write()` method.
        """
        return self._wrapped.write(s.encode(self.wrapper_getattr('encoding')))

    def __eq__(self, other):
        return self._wrapped == getattr(other, '_wrapped', other)


class DisableOnWriteError(ObjectWrapper):
    """
    Disable the given `tqdm_instance` upon `write()` or `flush()` errors.
    """
    @staticmethod
    def disable_on_exception(tqdm_instance, func):
        """
        Quietly set `tqdm_instance.miniters=inf` if `func` raises `errno=5`.
        """
        tqdm_instance = proxy(tqdm_instance)

        def inner(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except OSError as e:
                if e.errno != 5:
                    raise
                try:
                    tqdm_instance.miniters = float('inf')
                except ReferenceError:
                    pass
            except ValueError as e:
                if 'closed' not in str(e):
                    raise
                try:
                    tqdm_instance.miniters = float('inf')
                except ReferenceError:
                    pass
        return inner

    def __init__(self, wrapped, tqdm_instance):
        super().__init__(wrapped)
        if hasattr(wrapped, 'write'):
            self.wrapper_setattr(
                'write', self.disable_on_exception(tqdm_instance, wrapped.write))
        if hasattr(wrapped, 'flush'):
            self.wrapper_setattr(
                'flush', self.disable_on_exception(tqdm_instance, wrapped.flush))

    def __eq__(self, other):
        return self._wrapped == getattr(other, '_wrapped', other)


class CallbackIOWrapper(ObjectWrapper):
    def __init__(self, callback, stream, method="read"):
        """
        Wrap a given `file`-like object's `read()` or `write()` to report
        lengths to the given `callback`
        """
        super().__init__(stream)
        func = getattr(stream, method)
        if method == "write":
            @wraps(func)
            def write(data, *args, **kwargs):
                res = func(data, *args, **kwargs)
                callback(len(data))
                return res
            self.wrapper_setattr('write', write)
        elif method == "read":
            @wraps(func)
            def read(*args, **kwargs):
                data = func(*args, **kwargs)
                callback(len(data))
                return data
            self.wrapper_setattr('read', read)
        else:
            raise KeyError("Can only wrap read/write methods")


def _is_utf(encoding):
    try:
        u'\u2588\u2589'.encode(encoding)
    except UnicodeEncodeError:
        return False
    except Exception:
        try:
            return encoding.lower().startswith('utf-') or ('U8' == encoding)
        except Exception:
            return False
    else:
        return True


def _supports_unicode(fp):
    try:
        return _is_utf(fp.encoding)
    except AttributeError:
        return False


def _is_ascii(s):
    if isinstance(s, str):
        for c in s:
            if ord(c) > 255:
                return False
        return True
    return _supports_unicode(s)


def _screen_shape_wrapper():  # pragma: no cover
    """
    Return a function which returns console dimensions (width, height).
    Supported: linux, osx, windows, cygwin.
    """
    _screen_shape = None
    if IS_WIN:
        _screen_shape = _screen_shape_windows
        if _screen_shape is None:
            _screen_shape = _screen_shape_tput
    if IS_NIX:
        _screen_shape = _screen_shape_linux
    return _screen_shape


def _screen_shape_windows(fp):  # pragma: no cover
    try:
        import struct
        from ctypes import create_string_buffer, windll
        from sys import stdin, stdout

        io_handle = -12  # assume stderr
        if fp == stdin:
            io_handle = -10
        elif fp == stdout:
            io_handle = -11

        h = windll.kernel32.GetStdHandle(io_handle)
        csbi = create_string_buffer(22)
        res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)
        if res:
            (_bufx, _bufy, _curx, _cury, _wattr, left, top, right, bottom,
             _maxx, _maxy) = struct.unpack("hhhhHhhhhhh", csbi.raw)
            return right - left, bottom - top  # +1
    except Exception:  # nosec
        pass
    return None, None


def _screen_shape_tput(*_):  # pragma: no cover
    """cygwin xterm (windows)"""
    try:
        import shlex
        from subprocess import check_call  # nosec
        return [int(check_call(shlex.split('tput ' + i))) - 1
                for i in ('cols', 'lines')]
    except Exception:  # nosec
        pass
    return None, None


def _screen_shape_linux(fp):  # pragma: no cover

    try:
        from array import array
        from fcntl import ioctl
        from termios import TIOCGWINSZ
    except ImportError:
        return None, None
    else:
        try:
            rows, cols = array('h', ioctl(fp, TIOCGWINSZ, '\0' * 8))[:2]
            return cols, rows
        except Exception:
            try:
                return [int(os.environ[i]) - 1 for i in ("COLUMNS", "LINES")]
            except (KeyError, ValueError):
                return None, None


def _environ_cols_wrapper():  # pragma: no cover
    """
    Return a function which returns console width.
    Supported: linux, osx, windows, cygwin.
    """
    warn("Use `_screen_shape_wrapper()(file)[0]` instead of"
         " `_environ_cols_wrapper()(file)`", DeprecationWarning, stacklevel=2)
    shape = _screen_shape_wrapper()
    if not shape:
        return None

    @wraps(shape)
    def inner(fp):
        return shape(fp)[0]

    return inner


def _term_move_up():  # pragma: no cover
    return '' if (os.name == 'nt') and (colorama is None) else '\x1b[A'


def _text_width(s):
    return sum(2 if east_asian_width(ch) in 'FW' else 1 for ch in str(s))


def disp_len(data):
    """
    Returns the real on-screen length of a string which may contain
    ANSI control codes and wide chars.
    """
    return _text_width(RE_ANSI.sub('', data))


def disp_trim(data, length):
    """
    Trim a string which may contain ANSI control characters.
    """
    if len(data) == disp_len(data):
        return data[:length]

    ansi_present = bool(RE_ANSI.search(data))
    while disp_len(data) > length:  # carefully delete one char at a time
        data = data[:-1]
    if ansi_present and bool(RE_ANSI.search(data)):
        # assume ANSI reset is required
        return data if data.endswith("\033[0m") else data + "\033[0m"
    return data


# ================================================================================
# Datei: venv\Lib\site-packages\tqdm\version.py
# ================================================================================

"""`tqdm` version detector. Precedence: installed dist, git, 'UNKNOWN'."""
try:
    from ._dist_ver import __version__
except ImportError:
    try:
        from setuptools_scm import get_version
        __version__ = get_version(root='..', relative_to=__file__)
    except (ImportError, LookupError):
        __version__ = "UNKNOWN"


# ================================================================================
# Datei: venv\Lib\site-packages\typing_extensions.py
# ================================================================================

import abc
import builtins
import collections
import collections.abc
import contextlib
import enum
import functools
import inspect
import keyword
import operator
import sys
import types as _types
import typing
import warnings

__all__ = [
    # Super-special typing primitives.
    'Any',
    'ClassVar',
    'Concatenate',
    'Final',
    'LiteralString',
    'ParamSpec',
    'ParamSpecArgs',
    'ParamSpecKwargs',
    'Self',
    'Type',
    'TypeVar',
    'TypeVarTuple',
    'Unpack',

    # ABCs (from collections.abc).
    'Awaitable',
    'AsyncIterator',
    'AsyncIterable',
    'Coroutine',
    'AsyncGenerator',
    'AsyncContextManager',
    'Buffer',
    'ChainMap',

    # Concrete collection types.
    'ContextManager',
    'Counter',
    'Deque',
    'DefaultDict',
    'NamedTuple',
    'OrderedDict',
    'TypedDict',

    # Structural checks, a.k.a. protocols.
    'SupportsAbs',
    'SupportsBytes',
    'SupportsComplex',
    'SupportsFloat',
    'SupportsIndex',
    'SupportsInt',
    'SupportsRound',

    # One-off things.
    'Annotated',
    'assert_never',
    'assert_type',
    'clear_overloads',
    'dataclass_transform',
    'deprecated',
    'Doc',
    'evaluate_forward_ref',
    'get_overloads',
    'final',
    'Format',
    'get_annotations',
    'get_args',
    'get_origin',
    'get_original_bases',
    'get_protocol_members',
    'get_type_hints',
    'IntVar',
    'is_protocol',
    'is_typeddict',
    'Literal',
    'NewType',
    'overload',
    'override',
    'Protocol',
    'reveal_type',
    'runtime',
    'runtime_checkable',
    'Text',
    'TypeAlias',
    'TypeAliasType',
    'TypeForm',
    'TypeGuard',
    'TypeIs',
    'TYPE_CHECKING',
    'Never',
    'NoReturn',
    'ReadOnly',
    'Required',
    'NotRequired',
    'NoDefault',
    'NoExtraItems',

    # Pure aliases, have always been in typing
    'AbstractSet',
    'AnyStr',
    'BinaryIO',
    'Callable',
    'Collection',
    'Container',
    'Dict',
    'ForwardRef',
    'FrozenSet',
    'Generator',
    'Generic',
    'Hashable',
    'IO',
    'ItemsView',
    'Iterable',
    'Iterator',
    'KeysView',
    'List',
    'Mapping',
    'MappingView',
    'Match',
    'MutableMapping',
    'MutableSequence',
    'MutableSet',
    'Optional',
    'Pattern',
    'Reversible',
    'Sequence',
    'Set',
    'Sized',
    'TextIO',
    'Tuple',
    'Union',
    'ValuesView',
    'cast',
    'no_type_check',
    'no_type_check_decorator',
]

# for backward compatibility
PEP_560 = True
GenericMeta = type
_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, "beta")

# Added with bpo-45166 to 3.10.1+ and some 3.9 versions
_FORWARD_REF_HAS_CLASS = "__forward_is_class__" in typing.ForwardRef.__slots__

# The functions below are modified copies of typing internal helpers.
# They are needed by _ProtocolMeta and they provide support for PEP 646.


class _Sentinel:
    def __repr__(self):
        return "<sentinel>"


_marker = _Sentinel()


if sys.version_info >= (3, 10):
    def _should_collect_from_parameters(t):
        return isinstance(
            t, (typing._GenericAlias, _types.GenericAlias, _types.UnionType)
        )
elif sys.version_info >= (3, 9):
    def _should_collect_from_parameters(t):
        return isinstance(t, (typing._GenericAlias, _types.GenericAlias))
else:
    def _should_collect_from_parameters(t):
        return isinstance(t, typing._GenericAlias) and not t._special


NoReturn = typing.NoReturn

# Some unconstrained type variables.  These are used by the container types.
# (These are not for export.)
T = typing.TypeVar('T')  # Any type.
KT = typing.TypeVar('KT')  # Key type.
VT = typing.TypeVar('VT')  # Value type.
T_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.
T_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.


if sys.version_info >= (3, 11):
    from typing import Any
else:

    class _AnyMeta(type):
        def __instancecheck__(self, obj):
            if self is Any:
                raise TypeError("typing_extensions.Any cannot be used with isinstance()")
            return super().__instancecheck__(obj)

        def __repr__(self):
            if self is Any:
                return "typing_extensions.Any"
            return super().__repr__()

    class Any(metaclass=_AnyMeta):
        """Special type indicating an unconstrained type.
        - Any is compatible with every type.
        - Any assumed to have all methods.
        - All values assumed to be instances of Any.
        Note that all the above statements are true from the point of view of
        static type checkers. At runtime, Any should not be used with instance
        checks.
        """
        def __new__(cls, *args, **kwargs):
            if cls is Any:
                raise TypeError("Any cannot be instantiated")
            return super().__new__(cls, *args, **kwargs)


ClassVar = typing.ClassVar


class _ExtensionsSpecialForm(typing._SpecialForm, _root=True):
    def __repr__(self):
        return 'typing_extensions.' + self._name


Final = typing.Final

if sys.version_info >= (3, 11):
    final = typing.final
else:
    # @final exists in 3.8+, but we backport it for all versions
    # before 3.11 to keep support for the __final__ attribute.
    # See https://bugs.python.org/issue46342
    def final(f):
        """This decorator can be used to indicate to type checkers that
        the decorated method cannot be overridden, and decorated class
        cannot be subclassed. For example:

            class Base:
                @final
                def done(self) -> None:
                    ...
            class Sub(Base):
                def done(self) -> None:  # Error reported by type checker
                    ...
            @final
            class Leaf:
                ...
            class Other(Leaf):  # Error reported by type checker
                ...

        There is no runtime checking of these properties. The decorator
        sets the ``__final__`` attribute to ``True`` on the decorated object
        to allow runtime introspection.
        """
        try:
            f.__final__ = True
        except (AttributeError, TypeError):
            # Skip the attribute silently if it is not writable.
            # AttributeError happens if the object has __slots__ or a
            # read-only property, TypeError if it's a builtin class.
            pass
        return f


def IntVar(name):
    return typing.TypeVar(name)


# A Literal bug was fixed in 3.11.0, 3.10.1 and 3.9.8
if sys.version_info >= (3, 10, 1):
    Literal = typing.Literal
else:
    def _flatten_literal_params(parameters):
        """An internal helper for Literal creation: flatten Literals among parameters"""
        params = []
        for p in parameters:
            if isinstance(p, _LiteralGenericAlias):
                params.extend(p.__args__)
            else:
                params.append(p)
        return tuple(params)

    def _value_and_type_iter(params):
        for p in params:
            yield p, type(p)

    class _LiteralGenericAlias(typing._GenericAlias, _root=True):
        def __eq__(self, other):
            if not isinstance(other, _LiteralGenericAlias):
                return NotImplemented
            these_args_deduped = set(_value_and_type_iter(self.__args__))
            other_args_deduped = set(_value_and_type_iter(other.__args__))
            return these_args_deduped == other_args_deduped

        def __hash__(self):
            return hash(frozenset(_value_and_type_iter(self.__args__)))

    class _LiteralForm(_ExtensionsSpecialForm, _root=True):
        def __init__(self, doc: str):
            self._name = 'Literal'
            self._doc = self.__doc__ = doc

        def __getitem__(self, parameters):
            if not isinstance(parameters, tuple):
                parameters = (parameters,)

            parameters = _flatten_literal_params(parameters)

            val_type_pairs = list(_value_and_type_iter(parameters))
            try:
                deduped_pairs = set(val_type_pairs)
            except TypeError:
                # unhashable parameters
                pass
            else:
                # similar logic to typing._deduplicate on Python 3.9+
                if len(deduped_pairs) < len(val_type_pairs):
                    new_parameters = []
                    for pair in val_type_pairs:
                        if pair in deduped_pairs:
                            new_parameters.append(pair[0])
                            deduped_pairs.remove(pair)
                    assert not deduped_pairs, deduped_pairs
                    parameters = tuple(new_parameters)

            return _LiteralGenericAlias(self, parameters)

    Literal = _LiteralForm(doc="""\
                           A type that can be used to indicate to type checkers
                           that the corresponding value has a value literally equivalent
                           to the provided parameter. For example:

                               var: Literal[4] = 4

                           The type checker understands that 'var' is literally equal to
                           the value 4 and no other value.

                           Literal[...] cannot be subclassed. There is no runtime
                           checking verifying that the parameter is actually a value
                           instead of a type.""")


_overload_dummy = typing._overload_dummy


if hasattr(typing, "get_overloads"):  # 3.11+
    overload = typing.overload
    get_overloads = typing.get_overloads
    clear_overloads = typing.clear_overloads
else:
    # {module: {qualname: {firstlineno: func}}}
    _overload_registry = collections.defaultdict(
        functools.partial(collections.defaultdict, dict)
    )

    def overload(func):
        """Decorator for overloaded functions/methods.

        In a stub file, place two or more stub definitions for the same
        function in a row, each decorated with @overload.  For example:

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...

        In a non-stub file (i.e. a regular .py file), do the same but
        follow it with an implementation.  The implementation should *not*
        be decorated with @overload.  For example:

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...
        def utf8(value):
            # implementation goes here

        The overloads for a function can be retrieved at runtime using the
        get_overloads() function.
        """
        # classmethod and staticmethod
        f = getattr(func, "__func__", func)
        try:
            _overload_registry[f.__module__][f.__qualname__][
                f.__code__.co_firstlineno
            ] = func
        except AttributeError:
            # Not a normal function; ignore.
            pass
        return _overload_dummy

    def get_overloads(func):
        """Return all defined overloads for *func* as a sequence."""
        # classmethod and staticmethod
        f = getattr(func, "__func__", func)
        if f.__module__ not in _overload_registry:
            return []
        mod_dict = _overload_registry[f.__module__]
        if f.__qualname__ not in mod_dict:
            return []
        return list(mod_dict[f.__qualname__].values())

    def clear_overloads():
        """Clear all overloads in the registry."""
        _overload_registry.clear()


# This is not a real generic class.  Don't use outside annotations.
Type = typing.Type

# Various ABCs mimicking those in collections.abc.
# A few are simply re-exported for completeness.
Awaitable = typing.Awaitable
Coroutine = typing.Coroutine
AsyncIterable = typing.AsyncIterable
AsyncIterator = typing.AsyncIterator
Deque = typing.Deque
DefaultDict = typing.DefaultDict
OrderedDict = typing.OrderedDict
Counter = typing.Counter
ChainMap = typing.ChainMap
Text = typing.Text
TYPE_CHECKING = typing.TYPE_CHECKING


if sys.version_info >= (3, 13, 0, "beta"):
    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator
else:
    def _is_dunder(attr):
        return attr.startswith('__') and attr.endswith('__')

    # Python <3.9 doesn't have typing._SpecialGenericAlias
    _special_generic_alias_base = getattr(
        typing, "_SpecialGenericAlias", typing._GenericAlias
    )

    class _SpecialGenericAlias(_special_generic_alias_base, _root=True):
        def __init__(self, origin, nparams, *, inst=True, name=None, defaults=()):
            if _special_generic_alias_base is typing._GenericAlias:
                # Python <3.9
                self.__origin__ = origin
                self._nparams = nparams
                super().__init__(origin, nparams, special=True, inst=inst, name=name)
            else:
                # Python >= 3.9
                super().__init__(origin, nparams, inst=inst, name=name)
            self._defaults = defaults

        def __setattr__(self, attr, val):
            allowed_attrs = {'_name', '_inst', '_nparams', '_defaults'}
            if _special_generic_alias_base is typing._GenericAlias:
                # Python <3.9
                allowed_attrs.add("__origin__")
            if _is_dunder(attr) or attr in allowed_attrs:
                object.__setattr__(self, attr, val)
            else:
                setattr(self.__origin__, attr, val)

        @typing._tp_cache
        def __getitem__(self, params):
            if not isinstance(params, tuple):
                params = (params,)
            msg = "Parameters to generic types must be types."
            params = tuple(typing._type_check(p, msg) for p in params)
            if (
                self._defaults
                and len(params) < self._nparams
                and len(params) + len(self._defaults) >= self._nparams
            ):
                params = (*params, *self._defaults[len(params) - self._nparams:])
            actual_len = len(params)

            if actual_len != self._nparams:
                if self._defaults:
                    expected = f"at least {self._nparams - len(self._defaults)}"
                else:
                    expected = str(self._nparams)
                if not self._nparams:
                    raise TypeError(f"{self} is not a generic class")
                raise TypeError(
                    f"Too {'many' if actual_len > self._nparams else 'few'}"
                    f" arguments for {self};"
                    f" actual {actual_len}, expected {expected}"
                )
            return self.copy_with(params)

    _NoneType = type(None)
    Generator = _SpecialGenericAlias(
        collections.abc.Generator, 3, defaults=(_NoneType, _NoneType)
    )
    AsyncGenerator = _SpecialGenericAlias(
        collections.abc.AsyncGenerator, 2, defaults=(_NoneType,)
    )
    ContextManager = _SpecialGenericAlias(
        contextlib.AbstractContextManager,
        2,
        name="ContextManager",
        defaults=(typing.Optional[bool],)
    )
    AsyncContextManager = _SpecialGenericAlias(
        contextlib.AbstractAsyncContextManager,
        2,
        name="AsyncContextManager",
        defaults=(typing.Optional[bool],)
    )


_PROTO_ALLOWLIST = {
    'collections.abc': [
        'Callable', 'Awaitable', 'Iterable', 'Iterator', 'AsyncIterable',
        'Hashable', 'Sized', 'Container', 'Collection', 'Reversible', 'Buffer',
    ],
    'contextlib': ['AbstractContextManager', 'AbstractAsyncContextManager'],
    'typing_extensions': ['Buffer'],
}


_EXCLUDED_ATTRS = frozenset(typing.EXCLUDED_ATTRIBUTES) | {
    "__match_args__", "__protocol_attrs__", "__non_callable_proto_members__",
    "__final__",
}


def _get_protocol_attrs(cls):
    attrs = set()
    for base in cls.__mro__[:-1]:  # without object
        if base.__name__ in {'Protocol', 'Generic'}:
            continue
        annotations = getattr(base, '__annotations__', {})
        for attr in (*base.__dict__, *annotations):
            if (not attr.startswith('_abc_') and attr not in _EXCLUDED_ATTRS):
                attrs.add(attr)
    return attrs


def _caller(depth=2):
    try:
        return sys._getframe(depth).f_globals.get('__name__', '__main__')
    except (AttributeError, ValueError):  # For platforms without _getframe()
        return None


# `__match_args__` attribute was removed from protocol members in 3.13,
# we want to backport this change to older Python versions.
if sys.version_info >= (3, 13):
    Protocol = typing.Protocol
else:
    def _allow_reckless_class_checks(depth=3):
        """Allow instance and class checks for special stdlib modules.
        The abc and functools modules indiscriminately call isinstance() and
        issubclass() on the whole MRO of a user class, which may contain protocols.
        """
        return _caller(depth) in {'abc', 'functools', None}

    def _no_init(self, *args, **kwargs):
        if type(self)._is_protocol:
            raise TypeError('Protocols cannot be instantiated')

    def _type_check_issubclass_arg_1(arg):
        """Raise TypeError if `arg` is not an instance of `type`
        in `issubclass(arg, <protocol>)`.

        In most cases, this is verified by type.__subclasscheck__.
        Checking it again unnecessarily would slow down issubclass() checks,
        so, we don't perform this check unless we absolutely have to.

        For various error paths, however,
        we want to ensure that *this* error message is shown to the user
        where relevant, rather than a typing.py-specific error message.
        """
        if not isinstance(arg, type):
            # Same error message as for issubclass(1, int).
            raise TypeError('issubclass() arg 1 must be a class')

    # Inheriting from typing._ProtocolMeta isn't actually desirable,
    # but is necessary to allow typing.Protocol and typing_extensions.Protocol
    # to mix without getting TypeErrors about "metaclass conflict"
    class _ProtocolMeta(type(typing.Protocol)):
        # This metaclass is somewhat unfortunate,
        # but is necessary for several reasons...
        #
        # NOTE: DO NOT call super() in any methods in this class
        # That would call the methods on typing._ProtocolMeta on Python 3.8-3.11
        # and those are slow
        def __new__(mcls, name, bases, namespace, **kwargs):
            if name == "Protocol" and len(bases) < 2:
                pass
            elif {Protocol, typing.Protocol} & set(bases):
                for base in bases:
                    if not (
                        base in {object, typing.Generic, Protocol, typing.Protocol}
                        or base.__name__ in _PROTO_ALLOWLIST.get(base.__module__, [])
                        or is_protocol(base)
                    ):
                        raise TypeError(
                            f"Protocols can only inherit from other protocols, "
                            f"got {base!r}"
                        )
            return abc.ABCMeta.__new__(mcls, name, bases, namespace, **kwargs)

        def __init__(cls, *args, **kwargs):
            abc.ABCMeta.__init__(cls, *args, **kwargs)
            if getattr(cls, "_is_protocol", False):
                cls.__protocol_attrs__ = _get_protocol_attrs(cls)

        def __subclasscheck__(cls, other):
            if cls is Protocol:
                return type.__subclasscheck__(cls, other)
            if (
                getattr(cls, '_is_protocol', False)
                and not _allow_reckless_class_checks()
            ):
                if not getattr(cls, '_is_runtime_protocol', False):
                    _type_check_issubclass_arg_1(other)
                    raise TypeError(
                        "Instance and class checks can only be used with "
                        "@runtime_checkable protocols"
                    )
                if (
                    # this attribute is set by @runtime_checkable:
                    cls.__non_callable_proto_members__
                    and cls.__dict__.get("__subclasshook__") is _proto_hook
                ):
                    _type_check_issubclass_arg_1(other)
                    non_method_attrs = sorted(cls.__non_callable_proto_members__)
                    raise TypeError(
                        "Protocols with non-method members don't support issubclass()."
                        f" Non-method members: {str(non_method_attrs)[1:-1]}."
                    )
            return abc.ABCMeta.__subclasscheck__(cls, other)

        def __instancecheck__(cls, instance):
            # We need this method for situations where attributes are
            # assigned in __init__.
            if cls is Protocol:
                return type.__instancecheck__(cls, instance)
            if not getattr(cls, "_is_protocol", False):
                # i.e., it's a concrete subclass of a protocol
                return abc.ABCMeta.__instancecheck__(cls, instance)

            if (
                not getattr(cls, '_is_runtime_protocol', False) and
                not _allow_reckless_class_checks()
            ):
                raise TypeError("Instance and class checks can only be used with"
                                " @runtime_checkable protocols")

            if abc.ABCMeta.__instancecheck__(cls, instance):
                return True

            for attr in cls.__protocol_attrs__:
                try:
                    val = inspect.getattr_static(instance, attr)
                except AttributeError:
                    break
                # this attribute is set by @runtime_checkable:
                if val is None and attr not in cls.__non_callable_proto_members__:
                    break
            else:
                return True

            return False

        def __eq__(cls, other):
            # Hack so that typing.Generic.__class_getitem__
            # treats typing_extensions.Protocol
            # as equivalent to typing.Protocol
            if abc.ABCMeta.__eq__(cls, other) is True:
                return True
            return cls is Protocol and other is typing.Protocol

        # This has to be defined, or the abc-module cache
        # complains about classes with this metaclass being unhashable,
        # if we define only __eq__!
        def __hash__(cls) -> int:
            return type.__hash__(cls)

    @classmethod
    def _proto_hook(cls, other):
        if not cls.__dict__.get('_is_protocol', False):
            return NotImplemented

        for attr in cls.__protocol_attrs__:
            for base in other.__mro__:
                # Check if the members appears in the class dictionary...
                if attr in base.__dict__:
                    if base.__dict__[attr] is None:
                        return NotImplemented
                    break

                # ...or in annotations, if it is a sub-protocol.
                annotations = getattr(base, '__annotations__', {})
                if (
                    isinstance(annotations, collections.abc.Mapping)
                    and attr in annotations
                    and is_protocol(other)
                ):
                    break
            else:
                return NotImplemented
        return True

    class Protocol(typing.Generic, metaclass=_ProtocolMeta):
        __doc__ = typing.Protocol.__doc__
        __slots__ = ()
        _is_protocol = True
        _is_runtime_protocol = False

        def __init_subclass__(cls, *args, **kwargs):
            super().__init_subclass__(*args, **kwargs)

            # Determine if this is a protocol or a concrete subclass.
            if not cls.__dict__.get('_is_protocol', False):
                cls._is_protocol = any(b is Protocol for b in cls.__bases__)

            # Set (or override) the protocol subclass hook.
            if '__subclasshook__' not in cls.__dict__:
                cls.__subclasshook__ = _proto_hook

            # Prohibit instantiation for protocol classes
            if cls._is_protocol and cls.__init__ is Protocol.__init__:
                cls.__init__ = _no_init


if sys.version_info >= (3, 13):
    runtime_checkable = typing.runtime_checkable
else:
    def runtime_checkable(cls):
        """Mark a protocol class as a runtime protocol.

        Such protocol can be used with isinstance() and issubclass().
        Raise TypeError if applied to a non-protocol class.
        This allows a simple-minded structural check very similar to
        one trick ponies in collections.abc such as Iterable.

        For example::

            @runtime_checkable
            class Closable(Protocol):
                def close(self): ...

            assert isinstance(open('/some/file'), Closable)

        Warning: this will check only the presence of the required methods,
        not their type signatures!
        """
        if not issubclass(cls, typing.Generic) or not getattr(cls, '_is_protocol', False):
            raise TypeError(f'@runtime_checkable can be only applied to protocol classes,'
                            f' got {cls!r}')
        cls._is_runtime_protocol = True

        # typing.Protocol classes on <=3.11 break if we execute this block,
        # because typing.Protocol classes on <=3.11 don't have a
        # `__protocol_attrs__` attribute, and this block relies on the
        # `__protocol_attrs__` attribute. Meanwhile, typing.Protocol classes on 3.12.2+
        # break if we *don't* execute this block, because *they* assume that all
        # protocol classes have a `__non_callable_proto_members__` attribute
        # (which this block sets)
        if isinstance(cls, _ProtocolMeta) or sys.version_info >= (3, 12, 2):
            # PEP 544 prohibits using issubclass()
            # with protocols that have non-method members.
            # See gh-113320 for why we compute this attribute here,
            # rather than in `_ProtocolMeta.__init__`
            cls.__non_callable_proto_members__ = set()
            for attr in cls.__protocol_attrs__:
                try:
                    is_callable = callable(getattr(cls, attr, None))
                except Exception as e:
                    raise TypeError(
                        f"Failed to determine whether protocol member {attr!r} "
                        "is a method member"
                    ) from e
                else:
                    if not is_callable:
                        cls.__non_callable_proto_members__.add(attr)

        return cls


# The "runtime" alias exists for backwards compatibility.
runtime = runtime_checkable


# Our version of runtime-checkable protocols is faster on Python 3.8-3.11
if sys.version_info >= (3, 12):
    SupportsInt = typing.SupportsInt
    SupportsFloat = typing.SupportsFloat
    SupportsComplex = typing.SupportsComplex
    SupportsBytes = typing.SupportsBytes
    SupportsIndex = typing.SupportsIndex
    SupportsAbs = typing.SupportsAbs
    SupportsRound = typing.SupportsRound
else:
    @runtime_checkable
    class SupportsInt(Protocol):
        """An ABC with one abstract method __int__."""
        __slots__ = ()

        @abc.abstractmethod
        def __int__(self) -> int:
            pass

    @runtime_checkable
    class SupportsFloat(Protocol):
        """An ABC with one abstract method __float__."""
        __slots__ = ()

        @abc.abstractmethod
        def __float__(self) -> float:
            pass

    @runtime_checkable
    class SupportsComplex(Protocol):
        """An ABC with one abstract method __complex__."""
        __slots__ = ()

        @abc.abstractmethod
        def __complex__(self) -> complex:
            pass

    @runtime_checkable
    class SupportsBytes(Protocol):
        """An ABC with one abstract method __bytes__."""
        __slots__ = ()

        @abc.abstractmethod
        def __bytes__(self) -> bytes:
            pass

    @runtime_checkable
    class SupportsIndex(Protocol):
        __slots__ = ()

        @abc.abstractmethod
        def __index__(self) -> int:
            pass

    @runtime_checkable
    class SupportsAbs(Protocol[T_co]):
        """
        An ABC with one abstract method __abs__ that is covariant in its return type.
        """
        __slots__ = ()

        @abc.abstractmethod
        def __abs__(self) -> T_co:
            pass

    @runtime_checkable
    class SupportsRound(Protocol[T_co]):
        """
        An ABC with one abstract method __round__ that is covariant in its return type.
        """
        __slots__ = ()

        @abc.abstractmethod
        def __round__(self, ndigits: int = 0) -> T_co:
            pass


def _ensure_subclassable(mro_entries):
    def inner(func):
        if sys.implementation.name == "pypy" and sys.version_info < (3, 9):
            cls_dict = {
                "__call__": staticmethod(func),
                "__mro_entries__": staticmethod(mro_entries)
            }
            t = type(func.__name__, (), cls_dict)
            return functools.update_wrapper(t(), func)
        else:
            func.__mro_entries__ = mro_entries
            return func
    return inner


_NEEDS_SINGLETONMETA = (
    not hasattr(typing, "NoDefault") or not hasattr(typing, "NoExtraItems")
)

if _NEEDS_SINGLETONMETA:
    class SingletonMeta(type):
        def __setattr__(cls, attr, value):
            # TypeError is consistent with the behavior of NoneType
            raise TypeError(
                f"cannot set {attr!r} attribute of immutable type {cls.__name__!r}"
            )


if hasattr(typing, "NoDefault"):
    NoDefault = typing.NoDefault
else:
    class NoDefaultType(metaclass=SingletonMeta):
        """The type of the NoDefault singleton."""

        __slots__ = ()

        def __new__(cls):
            return globals().get("NoDefault") or object.__new__(cls)

        def __repr__(self):
            return "typing_extensions.NoDefault"

        def __reduce__(self):
            return "NoDefault"

    NoDefault = NoDefaultType()
    del NoDefaultType

if hasattr(typing, "NoExtraItems"):
    NoExtraItems = typing.NoExtraItems
else:
    class NoExtraItemsType(metaclass=SingletonMeta):
        """The type of the NoExtraItems singleton."""

        __slots__ = ()

        def __new__(cls):
            return globals().get("NoExtraItems") or object.__new__(cls)

        def __repr__(self):
            return "typing_extensions.NoExtraItems"

        def __reduce__(self):
            return "NoExtraItems"

    NoExtraItems = NoExtraItemsType()
    del NoExtraItemsType

if _NEEDS_SINGLETONMETA:
    del SingletonMeta


# Update this to something like >=3.13.0b1 if and when
# PEP 728 is implemented in CPython
_PEP_728_IMPLEMENTED = False

if _PEP_728_IMPLEMENTED:
    # The standard library TypedDict in Python 3.8 does not store runtime information
    # about which (if any) keys are optional.  See https://bugs.python.org/issue38834
    # The standard library TypedDict in Python 3.9.0/1 does not honour the "total"
    # keyword with old-style TypedDict().  See https://bugs.python.org/issue42059
    # The standard library TypedDict below Python 3.11 does not store runtime
    # information about optional and required keys when using Required or NotRequired.
    # Generic TypedDicts are also impossible using typing.TypedDict on Python <3.11.
    # Aaaand on 3.12 we add __orig_bases__ to TypedDict
    # to enable better runtime introspection.
    # On 3.13 we deprecate some odd ways of creating TypedDicts.
    # Also on 3.13, PEP 705 adds the ReadOnly[] qualifier.
    # PEP 728 (still pending) makes more changes.
    TypedDict = typing.TypedDict
    _TypedDictMeta = typing._TypedDictMeta
    is_typeddict = typing.is_typeddict
else:
    # 3.10.0 and later
    _TAKES_MODULE = "module" in inspect.signature(typing._type_check).parameters

    def _get_typeddict_qualifiers(annotation_type):
        while True:
            annotation_origin = get_origin(annotation_type)
            if annotation_origin is Annotated:
                annotation_args = get_args(annotation_type)
                if annotation_args:
                    annotation_type = annotation_args[0]
                else:
                    break
            elif annotation_origin is Required:
                yield Required
                annotation_type, = get_args(annotation_type)
            elif annotation_origin is NotRequired:
                yield NotRequired
                annotation_type, = get_args(annotation_type)
            elif annotation_origin is ReadOnly:
                yield ReadOnly
                annotation_type, = get_args(annotation_type)
            else:
                break

    class _TypedDictMeta(type):

        def __new__(cls, name, bases, ns, *, total=True, closed=None,
                    extra_items=NoExtraItems):
            """Create new typed dict class object.

            This method is called when TypedDict is subclassed,
            or when TypedDict is instantiated. This way
            TypedDict supports all three syntax forms described in its docstring.
            Subclasses and instances of TypedDict return actual dictionaries.
            """
            for base in bases:
                if type(base) is not _TypedDictMeta and base is not typing.Generic:
                    raise TypeError('cannot inherit from both a TypedDict type '
                                    'and a non-TypedDict base class')
            if closed is not None and extra_items is not NoExtraItems:
                raise TypeError(f"Cannot combine closed={closed!r} and extra_items")

            if any(issubclass(b, typing.Generic) for b in bases):
                generic_base = (typing.Generic,)
            else:
                generic_base = ()

            # typing.py generally doesn't let you inherit from plain Generic, unless
            # the name of the class happens to be "Protocol"
            tp_dict = type.__new__(_TypedDictMeta, "Protocol", (*generic_base, dict), ns)
            tp_dict.__name__ = name
            if tp_dict.__qualname__ == "Protocol":
                tp_dict.__qualname__ = name

            if not hasattr(tp_dict, '__orig_bases__'):
                tp_dict.__orig_bases__ = bases

            annotations = {}
            if "__annotations__" in ns:
                own_annotations = ns["__annotations__"]
            elif "__annotate__" in ns:
                # TODO: Use inspect.VALUE here, and make the annotations lazily evaluated
                own_annotations = ns["__annotate__"](1)
            else:
                own_annotations = {}
            msg = "TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type"
            if _TAKES_MODULE:
                own_annotations = {
                    n: typing._type_check(tp, msg, module=tp_dict.__module__)
                    for n, tp in own_annotations.items()
                }
            else:
                own_annotations = {
                    n: typing._type_check(tp, msg)
                    for n, tp in own_annotations.items()
                }
            required_keys = set()
            optional_keys = set()
            readonly_keys = set()
            mutable_keys = set()
            extra_items_type = extra_items

            for base in bases:
                base_dict = base.__dict__

                annotations.update(base_dict.get('__annotations__', {}))
                required_keys.update(base_dict.get('__required_keys__', ()))
                optional_keys.update(base_dict.get('__optional_keys__', ()))
                readonly_keys.update(base_dict.get('__readonly_keys__', ()))
                mutable_keys.update(base_dict.get('__mutable_keys__', ()))

            # This was specified in an earlier version of PEP 728. Support
            # is retained for backwards compatibility, but only for Python
            # 3.13 and lower.
            if (closed and sys.version_info < (3, 14)
                       and "__extra_items__" in own_annotations):
                annotation_type = own_annotations.pop("__extra_items__")
                qualifiers = set(_get_typeddict_qualifiers(annotation_type))
                if Required in qualifiers:
                    raise TypeError(
                        "Special key __extra_items__ does not support "
                        "Required"
                    )
                if NotRequired in qualifiers:
                    raise TypeError(
                        "Special key __extra_items__ does not support "
                        "NotRequired"
                    )
                extra_items_type = annotation_type

            annotations.update(own_annotations)
            for annotation_key, annotation_type in own_annotations.items():
                qualifiers = set(_get_typeddict_qualifiers(annotation_type))

                if Required in qualifiers:
                    required_keys.add(annotation_key)
                elif NotRequired in qualifiers:
                    optional_keys.add(annotation_key)
                elif total:
                    required_keys.add(annotation_key)
                else:
                    optional_keys.add(annotation_key)
                if ReadOnly in qualifiers:
                    mutable_keys.discard(annotation_key)
                    readonly_keys.add(annotation_key)
                else:
                    mutable_keys.add(annotation_key)
                    readonly_keys.discard(annotation_key)

            tp_dict.__annotations__ = annotations
            tp_dict.__required_keys__ = frozenset(required_keys)
            tp_dict.__optional_keys__ = frozenset(optional_keys)
            tp_dict.__readonly_keys__ = frozenset(readonly_keys)
            tp_dict.__mutable_keys__ = frozenset(mutable_keys)
            tp_dict.__total__ = total
            tp_dict.__closed__ = closed
            tp_dict.__extra_items__ = extra_items_type
            return tp_dict

        __call__ = dict  # static method

        def __subclasscheck__(cls, other):
            # Typed dicts are only for static structural subtyping.
            raise TypeError('TypedDict does not support instance and class checks')

        __instancecheck__ = __subclasscheck__

    _TypedDict = type.__new__(_TypedDictMeta, 'TypedDict', (), {})

    @_ensure_subclassable(lambda bases: (_TypedDict,))
    def TypedDict(
        typename,
        fields=_marker,
        /,
        *,
        total=True,
        closed=None,
        extra_items=NoExtraItems,
        **kwargs
    ):
        """A simple typed namespace. At runtime it is equivalent to a plain dict.

        TypedDict creates a dictionary type such that a type checker will expect all
        instances to have a certain set of keys, where each key is
        associated with a value of a consistent type. This expectation
        is not checked at runtime.

        Usage::

            class Point2D(TypedDict):
                x: int
                y: int
                label: str

            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK
            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check

            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')

        The type info can be accessed via the Point2D.__annotations__ dict, and
        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.
        TypedDict supports an additional equivalent form::

            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})

        By default, all keys must be present in a TypedDict. It is possible
        to override this by specifying totality::

            class Point2D(TypedDict, total=False):
                x: int
                y: int

        This means that a Point2D TypedDict can have any of the keys omitted. A type
        checker is only expected to support a literal False or True as the value of
        the total argument. True is the default, and makes all items defined in the
        class body be required.

        The Required and NotRequired special forms can also be used to mark
        individual keys as being required or not required::

            class Point2D(TypedDict):
                x: int  # the "x" key must always be present (Required is the default)
                y: NotRequired[int]  # the "y" key can be omitted

        See PEP 655 for more details on Required and NotRequired.
        """
        if fields is _marker or fields is None:
            if fields is _marker:
                deprecated_thing = "Failing to pass a value for the 'fields' parameter"
            else:
                deprecated_thing = "Passing `None` as the 'fields' parameter"

            example = f"`{typename} = TypedDict({typename!r}, {{}})`"
            deprecation_msg = (
                f"{deprecated_thing} is deprecated and will be disallowed in "
                "Python 3.15. To create a TypedDict class with 0 fields "
                "using the functional syntax, pass an empty dictionary, e.g. "
            ) + example + "."
            warnings.warn(deprecation_msg, DeprecationWarning, stacklevel=2)
            # Support a field called "closed"
            if closed is not False and closed is not True and closed is not None:
                kwargs["closed"] = closed
                closed = None
            # Or "extra_items"
            if extra_items is not NoExtraItems:
                kwargs["extra_items"] = extra_items
                extra_items = NoExtraItems
            fields = kwargs
        elif kwargs:
            raise TypeError("TypedDict takes either a dict or keyword arguments,"
                            " but not both")
        if kwargs:
            if sys.version_info >= (3, 13):
                raise TypeError("TypedDict takes no keyword arguments")
            warnings.warn(
                "The kwargs-based syntax for TypedDict definitions is deprecated "
                "in Python 3.11, will be removed in Python 3.13, and may not be "
                "understood by third-party type checkers.",
                DeprecationWarning,
                stacklevel=2,
            )

        ns = {'__annotations__': dict(fields)}
        module = _caller()
        if module is not None:
            # Setting correct module is necessary to make typed dict classes pickleable.
            ns['__module__'] = module

        td = _TypedDictMeta(typename, (), ns, total=total, closed=closed,
                            extra_items=extra_items)
        td.__orig_bases__ = (TypedDict,)
        return td

    if hasattr(typing, "_TypedDictMeta"):
        _TYPEDDICT_TYPES = (typing._TypedDictMeta, _TypedDictMeta)
    else:
        _TYPEDDICT_TYPES = (_TypedDictMeta,)

    def is_typeddict(tp):
        """Check if an annotation is a TypedDict class

        For example::
            class Film(TypedDict):
                title: str
                year: int

            is_typeddict(Film)  # => True
            is_typeddict(Union[list, str])  # => False
        """
        # On 3.8, this would otherwise return True
        if hasattr(typing, "TypedDict") and tp is typing.TypedDict:
            return False
        return isinstance(tp, _TYPEDDICT_TYPES)


if hasattr(typing, "assert_type"):
    assert_type = typing.assert_type

else:
    def assert_type(val, typ, /):
        """Assert (to the type checker) that the value is of the given type.

        When the type checker encounters a call to assert_type(), it
        emits an error if the value is not of the specified type::

            def greet(name: str) -> None:
                assert_type(name, str)  # ok
                assert_type(name, int)  # type checker error

        At runtime this returns the first argument unchanged and otherwise
        does nothing.
        """
        return val


if hasattr(typing, "ReadOnly"):  # 3.13+
    get_type_hints = typing.get_type_hints
else:  # <=3.13
    # replaces _strip_annotations()
    def _strip_extras(t):
        """Strips Annotated, Required and NotRequired from a given type."""
        if isinstance(t, _AnnotatedAlias):
            return _strip_extras(t.__origin__)
        if hasattr(t, "__origin__") and t.__origin__ in (Required, NotRequired, ReadOnly):
            return _strip_extras(t.__args__[0])
        if isinstance(t, typing._GenericAlias):
            stripped_args = tuple(_strip_extras(a) for a in t.__args__)
            if stripped_args == t.__args__:
                return t
            return t.copy_with(stripped_args)
        if hasattr(_types, "GenericAlias") and isinstance(t, _types.GenericAlias):
            stripped_args = tuple(_strip_extras(a) for a in t.__args__)
            if stripped_args == t.__args__:
                return t
            return _types.GenericAlias(t.__origin__, stripped_args)
        if hasattr(_types, "UnionType") and isinstance(t, _types.UnionType):
            stripped_args = tuple(_strip_extras(a) for a in t.__args__)
            if stripped_args == t.__args__:
                return t
            return functools.reduce(operator.or_, stripped_args)

        return t

    def get_type_hints(obj, globalns=None, localns=None, include_extras=False):
        """Return type hints for an object.

        This is often the same as obj.__annotations__, but it handles
        forward references encoded as string literals, adds Optional[t] if a
        default value equal to None is set and recursively replaces all
        'Annotated[T, ...]', 'Required[T]' or 'NotRequired[T]' with 'T'
        (unless 'include_extras=True').

        The argument may be a module, class, method, or function. The annotations
        are returned as a dictionary. For classes, annotations include also
        inherited members.

        TypeError is raised if the argument is not of a type that can contain
        annotations, and an empty dictionary is returned if no annotations are
        present.

        BEWARE -- the behavior of globalns and localns is counterintuitive
        (unless you are familiar with how eval() and exec() work).  The
        search order is locals first, then globals.

        - If no dict arguments are passed, an attempt is made to use the
          globals from obj (or the respective module's globals for classes),
          and these are also used as the locals.  If the object does not appear
          to have globals, an empty dictionary is used.

        - If one dict argument is passed, it is used for both globals and
          locals.

        - If two dict arguments are passed, they specify globals and
          locals, respectively.
        """
        if hasattr(typing, "Annotated"):  # 3.9+
            hint = typing.get_type_hints(
                obj, globalns=globalns, localns=localns, include_extras=True
            )
        else:  # 3.8
            hint = typing.get_type_hints(obj, globalns=globalns, localns=localns)
        if sys.version_info < (3, 11):
            _clean_optional(obj, hint, globalns, localns)
        if sys.version_info < (3, 9):
            # In 3.8 eval_type does not flatten Optional[ForwardRef] correctly
            # This will recreate and and cache Unions.
            hint = {
                k: (t
                    if get_origin(t) != Union
                    else Union[t.__args__])
                for k, t in hint.items()
            }
        if include_extras:
            return hint
        return {k: _strip_extras(t) for k, t in hint.items()}

    _NoneType = type(None)

    def _could_be_inserted_optional(t):
        """detects Union[..., None] pattern"""
        # 3.8+ compatible checking before _UnionGenericAlias
        if get_origin(t) is not Union:
            return False
        # Assume if last argument is not None they are user defined
        if t.__args__[-1] is not _NoneType:
            return False
        return True

    # < 3.11
    def _clean_optional(obj, hints, globalns=None, localns=None):
        # reverts injected Union[..., None] cases from typing.get_type_hints
        # when a None default value is used.
        # see https://github.com/python/typing_extensions/issues/310
        if not hints or isinstance(obj, type):
            return
        defaults = typing._get_defaults(obj)  # avoid accessing __annotations___
        if not defaults:
            return
        original_hints = obj.__annotations__
        for name, value in hints.items():
            # Not a Union[..., None] or replacement conditions not fullfilled
            if (not _could_be_inserted_optional(value)
                or name not in defaults
                or defaults[name] is not None
            ):
                continue
            original_value = original_hints[name]
            # value=NoneType should have caused a skip above but check for safety
            if original_value is None:
                original_value = _NoneType
            # Forward reference
            if isinstance(original_value, str):
                if globalns is None:
                    if isinstance(obj, _types.ModuleType):
                        globalns = obj.__dict__
                    else:
                        nsobj = obj
                        # Find globalns for the unwrapped object.
                        while hasattr(nsobj, '__wrapped__'):
                            nsobj = nsobj.__wrapped__
                        globalns = getattr(nsobj, '__globals__', {})
                    if localns is None:
                        localns = globalns
                elif localns is None:
                    localns = globalns
                if sys.version_info < (3, 9):
                    original_value = ForwardRef(original_value)
                else:
                    original_value = ForwardRef(
                        original_value,
                        is_argument=not isinstance(obj, _types.ModuleType)
                    )
            original_evaluated = typing._eval_type(original_value, globalns, localns)
            if sys.version_info < (3, 9) and get_origin(original_evaluated) is Union:
                # Union[str, None, "str"] is not reduced to Union[str, None]
                original_evaluated = Union[original_evaluated.__args__]
            # Compare if values differ. Note that even if equal
            # value might be cached by typing._tp_cache contrary to original_evaluated
            if original_evaluated != value or (
                # 3.10: ForwardRefs of UnionType might be turned into _UnionGenericAlias
                hasattr(_types, "UnionType")
                and isinstance(original_evaluated, _types.UnionType)
                and not isinstance(value, _types.UnionType)
            ):
                hints[name] = original_evaluated

# Python 3.9+ has PEP 593 (Annotated)
if hasattr(typing, 'Annotated'):
    Annotated = typing.Annotated
    # Not exported and not a public API, but needed for get_origin() and get_args()
    # to work.
    _AnnotatedAlias = typing._AnnotatedAlias
# 3.8
else:
    class _AnnotatedAlias(typing._GenericAlias, _root=True):
        """Runtime representation of an annotated type.

        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
        with extra annotations. The alias behaves like a normal typing alias,
        instantiating is the same as instantiating the underlying type, binding
        it to types is also the same.
        """
        def __init__(self, origin, metadata):
            if isinstance(origin, _AnnotatedAlias):
                metadata = origin.__metadata__ + metadata
                origin = origin.__origin__
            super().__init__(origin, origin)
            self.__metadata__ = metadata

        def copy_with(self, params):
            assert len(params) == 1
            new_type = params[0]
            return _AnnotatedAlias(new_type, self.__metadata__)

        def __repr__(self):
            return (f"typing_extensions.Annotated[{typing._type_repr(self.__origin__)}, "
                    f"{', '.join(repr(a) for a in self.__metadata__)}]")

        def __reduce__(self):
            return operator.getitem, (
                Annotated, (self.__origin__, *self.__metadata__)
            )

        def __eq__(self, other):
            if not isinstance(other, _AnnotatedAlias):
                return NotImplemented
            if self.__origin__ != other.__origin__:
                return False
            return self.__metadata__ == other.__metadata__

        def __hash__(self):
            return hash((self.__origin__, self.__metadata__))

    class Annotated:
        """Add context specific metadata to a type.

        Example: Annotated[int, runtime_check.Unsigned] indicates to the
        hypothetical runtime_check module that this type is an unsigned int.
        Every other consumer of this type can ignore this metadata and treat
        this type as int.

        The first argument to Annotated must be a valid type (and will be in
        the __origin__ field), the remaining arguments are kept as a tuple in
        the __extra__ field.

        Details:

        - It's an error to call `Annotated` with less than two arguments.
        - Nested Annotated are flattened::

            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]

        - Instantiating an annotated type is equivalent to instantiating the
        underlying type::

            Annotated[C, Ann1](5) == C(5)

        - Annotated can be used as a generic type alias::

            Optimized = Annotated[T, runtime.Optimize()]
            Optimized[int] == Annotated[int, runtime.Optimize()]

            OptimizedList = Annotated[List[T], runtime.Optimize()]
            OptimizedList[int] == Annotated[List[int], runtime.Optimize()]
        """

        __slots__ = ()

        def __new__(cls, *args, **kwargs):
            raise TypeError("Type Annotated cannot be instantiated.")

        @typing._tp_cache
        def __class_getitem__(cls, params):
            if not isinstance(params, tuple) or len(params) < 2:
                raise TypeError("Annotated[...] should be used "
                                "with at least two arguments (a type and an "
                                "annotation).")
            allowed_special_forms = (ClassVar, Final)
            if get_origin(params[0]) in allowed_special_forms:
                origin = params[0]
            else:
                msg = "Annotated[t, ...]: t must be a type."
                origin = typing._type_check(params[0], msg)
            metadata = tuple(params[1:])
            return _AnnotatedAlias(origin, metadata)

        def __init_subclass__(cls, *args, **kwargs):
            raise TypeError(
                f"Cannot subclass {cls.__module__}.Annotated"
            )

# Python 3.8 has get_origin() and get_args() but those implementations aren't
# Annotated-aware, so we can't use those. Python 3.9's versions don't support
# ParamSpecArgs and ParamSpecKwargs, so only Python 3.10's versions will do.
if sys.version_info[:2] >= (3, 10):
    get_origin = typing.get_origin
    get_args = typing.get_args
# 3.8-3.9
else:
    try:
        # 3.9+
        from typing import _BaseGenericAlias
    except ImportError:
        _BaseGenericAlias = typing._GenericAlias
    try:
        # 3.9+
        from typing import GenericAlias as _typing_GenericAlias
    except ImportError:
        _typing_GenericAlias = typing._GenericAlias

    def get_origin(tp):
        """Get the unsubscripted version of a type.

        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar
        and Annotated. Return None for unsupported types. Examples::

            get_origin(Literal[42]) is Literal
            get_origin(int) is None
            get_origin(ClassVar[int]) is ClassVar
            get_origin(Generic) is Generic
            get_origin(Generic[T]) is Generic
            get_origin(Union[T, int]) is Union
            get_origin(List[Tuple[T, T]][int]) == list
            get_origin(P.args) is P
        """
        if isinstance(tp, _AnnotatedAlias):
            return Annotated
        if isinstance(tp, (typing._GenericAlias, _typing_GenericAlias, _BaseGenericAlias,
                           ParamSpecArgs, ParamSpecKwargs)):
            return tp.__origin__
        if tp is typing.Generic:
            return typing.Generic
        return None

    def get_args(tp):
        """Get type arguments with all substitutions performed.

        For unions, basic simplifications used by Union constructor are performed.
        Examples::
            get_args(Dict[str, int]) == (str, int)
            get_args(int) == ()
            get_args(Union[int, Union[T, int], str][int]) == (int, str)
            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
            get_args(Callable[[], T][int]) == ([], int)
        """
        if isinstance(tp, _AnnotatedAlias):
            return (tp.__origin__, *tp.__metadata__)
        if isinstance(tp, (typing._GenericAlias, _typing_GenericAlias)):
            if getattr(tp, "_special", False):
                return ()
            res = tp.__args__
            if get_origin(tp) is collections.abc.Callable and res[0] is not Ellipsis:
                res = (list(res[:-1]), res[-1])
            return res
        return ()


# 3.10+
if hasattr(typing, 'TypeAlias'):
    TypeAlias = typing.TypeAlias
# 3.9
elif sys.version_info[:2] >= (3, 9):
    @_ExtensionsSpecialForm
    def TypeAlias(self, parameters):
        """Special marker indicating that an assignment should
        be recognized as a proper type alias definition by type
        checkers.

        For example::

            Predicate: TypeAlias = Callable[..., bool]

        It's invalid when used anywhere except as in the example above.
        """
        raise TypeError(f"{self} is not subscriptable")
# 3.8
else:
    TypeAlias = _ExtensionsSpecialForm(
        'TypeAlias',
        doc="""Special marker indicating that an assignment should
        be recognized as a proper type alias definition by type
        checkers.

        For example::

            Predicate: TypeAlias = Callable[..., bool]

        It's invalid when used anywhere except as in the example
        above."""
    )


def _set_default(type_param, default):
    type_param.has_default = lambda: default is not NoDefault
    type_param.__default__ = default


def _set_module(typevarlike):
    # for pickling:
    def_mod = _caller(depth=3)
    if def_mod != 'typing_extensions':
        typevarlike.__module__ = def_mod


class _DefaultMixin:
    """Mixin for TypeVarLike defaults."""

    __slots__ = ()
    __init__ = _set_default


# Classes using this metaclass must provide a _backported_typevarlike ClassVar
class _TypeVarLikeMeta(type):
    def __instancecheck__(cls, __instance: Any) -> bool:
        return isinstance(__instance, cls._backported_typevarlike)


if _PEP_696_IMPLEMENTED:
    from typing import TypeVar
else:
    # Add default and infer_variance parameters from PEP 696 and 695
    class TypeVar(metaclass=_TypeVarLikeMeta):
        """Type variable."""

        _backported_typevarlike = typing.TypeVar

        def __new__(cls, name, *constraints, bound=None,
                    covariant=False, contravariant=False,
                    default=NoDefault, infer_variance=False):
            if hasattr(typing, "TypeAliasType"):
                # PEP 695 implemented (3.12+), can pass infer_variance to typing.TypeVar
                typevar = typing.TypeVar(name, *constraints, bound=bound,
                                         covariant=covariant, contravariant=contravariant,
                                         infer_variance=infer_variance)
            else:
                typevar = typing.TypeVar(name, *constraints, bound=bound,
                                         covariant=covariant, contravariant=contravariant)
                if infer_variance and (covariant or contravariant):
                    raise ValueError("Variance cannot be specified with infer_variance.")
                typevar.__infer_variance__ = infer_variance

            _set_default(typevar, default)
            _set_module(typevar)

            def _tvar_prepare_subst(alias, args):
                if (
                    typevar.has_default()
                    and alias.__parameters__.index(typevar) == len(args)
                ):
                    args += (typevar.__default__,)
                return args

            typevar.__typing_prepare_subst__ = _tvar_prepare_subst
            return typevar

        def __init_subclass__(cls) -> None:
            raise TypeError(f"type '{__name__}.TypeVar' is not an acceptable base type")


# Python 3.10+ has PEP 612
if hasattr(typing, 'ParamSpecArgs'):
    ParamSpecArgs = typing.ParamSpecArgs
    ParamSpecKwargs = typing.ParamSpecKwargs
# 3.8-3.9
else:
    class _Immutable:
        """Mixin to indicate that object should not be copied."""
        __slots__ = ()

        def __copy__(self):
            return self

        def __deepcopy__(self, memo):
            return self

    class ParamSpecArgs(_Immutable):
        """The args for a ParamSpec object.

        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs.

        ParamSpecArgs objects have a reference back to their ParamSpec:

        P.args.__origin__ is P

        This type is meant for runtime introspection and has no special meaning to
        static type checkers.
        """
        def __init__(self, origin):
            self.__origin__ = origin

        def __repr__(self):
            return f"{self.__origin__.__name__}.args"

        def __eq__(self, other):
            if not isinstance(other, ParamSpecArgs):
                return NotImplemented
            return self.__origin__ == other.__origin__

    class ParamSpecKwargs(_Immutable):
        """The kwargs for a ParamSpec object.

        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.

        ParamSpecKwargs objects have a reference back to their ParamSpec:

        P.kwargs.__origin__ is P

        This type is meant for runtime introspection and has no special meaning to
        static type checkers.
        """
        def __init__(self, origin):
            self.__origin__ = origin

        def __repr__(self):
            return f"{self.__origin__.__name__}.kwargs"

        def __eq__(self, other):
            if not isinstance(other, ParamSpecKwargs):
                return NotImplemented
            return self.__origin__ == other.__origin__


if _PEP_696_IMPLEMENTED:
    from typing import ParamSpec

# 3.10+
elif hasattr(typing, 'ParamSpec'):

    # Add default parameter - PEP 696
    class ParamSpec(metaclass=_TypeVarLikeMeta):
        """Parameter specification."""

        _backported_typevarlike = typing.ParamSpec

        def __new__(cls, name, *, bound=None,
                    covariant=False, contravariant=False,
                    infer_variance=False, default=NoDefault):
            if hasattr(typing, "TypeAliasType"):
                # PEP 695 implemented, can pass infer_variance to typing.TypeVar
                paramspec = typing.ParamSpec(name, bound=bound,
                                             covariant=covariant,
                                             contravariant=contravariant,
                                             infer_variance=infer_variance)
            else:
                paramspec = typing.ParamSpec(name, bound=bound,
                                             covariant=covariant,
                                             contravariant=contravariant)
                paramspec.__infer_variance__ = infer_variance

            _set_default(paramspec, default)
            _set_module(paramspec)

            def _paramspec_prepare_subst(alias, args):
                params = alias.__parameters__
                i = params.index(paramspec)
                if i == len(args) and paramspec.has_default():
                    args = [*args, paramspec.__default__]
                if i >= len(args):
                    raise TypeError(f"Too few arguments for {alias}")
                # Special case where Z[[int, str, bool]] == Z[int, str, bool] in PEP 612.
                if len(params) == 1 and not typing._is_param_expr(args[0]):
                    assert i == 0
                    args = (args,)
                # Convert lists to tuples to help other libraries cache the results.
                elif isinstance(args[i], list):
                    args = (*args[:i], tuple(args[i]), *args[i + 1:])
                return args

            paramspec.__typing_prepare_subst__ = _paramspec_prepare_subst
            return paramspec

        def __init_subclass__(cls) -> None:
            raise TypeError(f"type '{__name__}.ParamSpec' is not an acceptable base type")

# 3.8-3.9
else:

    # Inherits from list as a workaround for Callable checks in Python < 3.9.2.
    class ParamSpec(list, _DefaultMixin):
        """Parameter specification variable.

        Usage::

           P = ParamSpec('P')

        Parameter specification variables exist primarily for the benefit of static
        type checkers.  They are used to forward the parameter types of one
        callable to another callable, a pattern commonly found in higher order
        functions and decorators.  They are only valid when used in ``Concatenate``,
        or s the first argument to ``Callable``. In Python 3.10 and higher,
        they are also supported in user-defined Generics at runtime.
        See class Generic for more information on generic types.  An
        example for annotating a decorator::

           T = TypeVar('T')
           P = ParamSpec('P')

           def add_logging(f: Callable[P, T]) -> Callable[P, T]:
               '''A type-safe decorator to add logging to a function.'''
               def inner(*args: P.args, **kwargs: P.kwargs) -> T:
                   logging.info(f'{f.__name__} was called')
                   return f(*args, **kwargs)
               return inner

           @add_logging
           def add_two(x: float, y: float) -> float:
               '''Add two numbers together.'''
               return x + y

        Parameter specification variables defined with covariant=True or
        contravariant=True can be used to declare covariant or contravariant
        generic types.  These keyword arguments are valid, but their actual semantics
        are yet to be decided.  See PEP 612 for details.

        Parameter specification variables can be introspected. e.g.:

           P.__name__ == 'T'
           P.__bound__ == None
           P.__covariant__ == False
           P.__contravariant__ == False

        Note that only parameter specification variables defined in global scope can
        be pickled.
        """

        # Trick Generic __parameters__.
        __class__ = typing.TypeVar

        @property
        def args(self):
            return ParamSpecArgs(self)

        @property
        def kwargs(self):
            return ParamSpecKwargs(self)

        def __init__(self, name, *, bound=None, covariant=False, contravariant=False,
                     infer_variance=False, default=NoDefault):
            list.__init__(self, [self])
            self.__name__ = name
            self.__covariant__ = bool(covariant)
            self.__contravariant__ = bool(contravariant)
            self.__infer_variance__ = bool(infer_variance)
            if bound:
                self.__bound__ = typing._type_check(bound, 'Bound must be a type.')
            else:
                self.__bound__ = None
            _DefaultMixin.__init__(self, default)

            # for pickling:
            def_mod = _caller()
            if def_mod != 'typing_extensions':
                self.__module__ = def_mod

        def __repr__(self):
            if self.__infer_variance__:
                prefix = ''
            elif self.__covariant__:
                prefix = '+'
            elif self.__contravariant__:
                prefix = '-'
            else:
                prefix = '~'
            return prefix + self.__name__

        def __hash__(self):
            return object.__hash__(self)

        def __eq__(self, other):
            return self is other

        def __reduce__(self):
            return self.__name__

        # Hack to get typing._type_check to pass.
        def __call__(self, *args, **kwargs):
            pass


# 3.8-3.9
if not hasattr(typing, 'Concatenate'):
    # Inherits from list as a workaround for Callable checks in Python < 3.9.2.

    # 3.9.0-1
    if not hasattr(typing, '_type_convert'):
        def _type_convert(arg, module=None, *, allow_special_forms=False):
            """For converting None to type(None), and strings to ForwardRef."""
            if arg is None:
                return type(None)
            if isinstance(arg, str):
                if sys.version_info <= (3, 9, 6):
                    return ForwardRef(arg)
                if sys.version_info <= (3, 9, 7):
                    return ForwardRef(arg, module=module)
                return ForwardRef(arg, module=module, is_class=allow_special_forms)
            return arg
    else:
        _type_convert = typing._type_convert

    class _ConcatenateGenericAlias(list):

        # Trick Generic into looking into this for __parameters__.
        __class__ = typing._GenericAlias

        # Flag in 3.8.
        _special = False

        def __init__(self, origin, args):
            super().__init__(args)
            self.__origin__ = origin
            self.__args__ = args

        def __repr__(self):
            _type_repr = typing._type_repr
            return (f'{_type_repr(self.__origin__)}'
                    f'[{", ".join(_type_repr(arg) for arg in self.__args__)}]')

        def __hash__(self):
            return hash((self.__origin__, self.__args__))

        # Hack to get typing._type_check to pass in Generic.
        def __call__(self, *args, **kwargs):
            pass

        @property
        def __parameters__(self):
            return tuple(
                tp for tp in self.__args__ if isinstance(tp, (typing.TypeVar, ParamSpec))
            )

        # 3.8; needed for typing._subst_tvars
        # 3.9 used by __getitem__ below
        def copy_with(self, params):
            if isinstance(params[-1], _ConcatenateGenericAlias):
                params = (*params[:-1], *params[-1].__args__)
            elif isinstance(params[-1], (list, tuple)):
                return (*params[:-1], *params[-1])
            elif (not (params[-1] is ... or isinstance(params[-1], ParamSpec))):
                raise TypeError("The last parameter to Concatenate should be a "
                        "ParamSpec variable or ellipsis.")
            return self.__class__(self.__origin__, params)

        # 3.9; accessed during GenericAlias.__getitem__ when substituting
        def __getitem__(self, args):
            if self.__origin__ in (Generic, Protocol):
                # Can't subscript Generic[...] or Protocol[...].
                raise TypeError(f"Cannot subscript already-subscripted {self}")
            if not self.__parameters__:
                raise TypeError(f"{self} is not a generic class")

            if not isinstance(args, tuple):
                args = (args,)
            args = _unpack_args(*(_type_convert(p) for p in args))
            params = self.__parameters__
            for param in params:
                prepare = getattr(param, "__typing_prepare_subst__", None)
                if prepare is not None:
                    args = prepare(self, args)
                # 3.8 - 3.9 & typing.ParamSpec
                elif isinstance(param, ParamSpec):
                    i = params.index(param)
                    if (
                        i == len(args)
                        and getattr(param, '__default__', NoDefault) is not NoDefault
                    ):
                        args = [*args, param.__default__]
                    if i >= len(args):
                        raise TypeError(f"Too few arguments for {self}")
                    # Special case for Z[[int, str, bool]] == Z[int, str, bool]
                    if len(params) == 1 and not _is_param_expr(args[0]):
                        assert i == 0
                        args = (args,)
                    elif (
                        isinstance(args[i], list)
                        # 3.8 - 3.9
                        # This class inherits from list do not convert
                        and not isinstance(args[i], _ConcatenateGenericAlias)
                    ):
                        args = (*args[:i], tuple(args[i]), *args[i + 1:])

            alen = len(args)
            plen = len(params)
            if alen != plen:
                raise TypeError(
                    f"Too {'many' if alen > plen else 'few'} arguments for {self};"
                    f" actual {alen}, expected {plen}"
                )

            subst = dict(zip(self.__parameters__, args))
            # determine new args
            new_args = []
            for arg in self.__args__:
                if isinstance(arg, type):
                    new_args.append(arg)
                    continue
                if isinstance(arg, TypeVar):
                    arg = subst[arg]
                    if (
                        (isinstance(arg, typing._GenericAlias) and _is_unpack(arg))
                        or (
                            hasattr(_types, "GenericAlias")
                            and isinstance(arg, _types.GenericAlias)
                            and getattr(arg, "__unpacked__", False)
                        )
                    ):
                        raise TypeError(f"{arg} is not valid as type argument")

                elif isinstance(arg,
                    typing._GenericAlias
                    if not hasattr(_types, "GenericAlias") else
                    (typing._GenericAlias, _types.GenericAlias)
                ):
                    subparams = arg.__parameters__
                    if subparams:
                        subargs = tuple(subst[x] for x in subparams)
                        arg = arg[subargs]
                new_args.append(arg)
            return self.copy_with(tuple(new_args))

# 3.10+
else:
    _ConcatenateGenericAlias = typing._ConcatenateGenericAlias

    # 3.10
    if sys.version_info < (3, 11):

        class _ConcatenateGenericAlias(typing._ConcatenateGenericAlias, _root=True):
            # needed for checks in collections.abc.Callable to accept this class
            __module__ = "typing"

            def copy_with(self, params):
                if isinstance(params[-1], (list, tuple)):
                    return (*params[:-1], *params[-1])
                if isinstance(params[-1], typing._ConcatenateGenericAlias):
                    params = (*params[:-1], *params[-1].__args__)
                elif not (params[-1] is ... or isinstance(params[-1], ParamSpec)):
                    raise TypeError("The last parameter to Concatenate should be a "
                            "ParamSpec variable or ellipsis.")
                return super(typing._ConcatenateGenericAlias, self).copy_with(params)

            def __getitem__(self, args):
                value = super().__getitem__(args)
                if isinstance(value, tuple) and any(_is_unpack(t) for t in value):
                    return tuple(_unpack_args(*(n for n in value)))
                return value


# 3.8-3.9.2
class _EllipsisDummy: ...


# 3.8-3.10
def _create_concatenate_alias(origin, parameters):
    if parameters[-1] is ... and sys.version_info < (3, 9, 2):
        # Hack: Arguments must be types, replace it with one.
        parameters = (*parameters[:-1], _EllipsisDummy)
    if sys.version_info >= (3, 10, 3):
        concatenate = _ConcatenateGenericAlias(origin, parameters,
                                        _typevar_types=(TypeVar, ParamSpec),
                                        _paramspec_tvars=True)
    else:
        concatenate = _ConcatenateGenericAlias(origin, parameters)
    if parameters[-1] is not _EllipsisDummy:
        return concatenate
    # Remove dummy again
    concatenate.__args__ = tuple(p if p is not _EllipsisDummy else ...
                                    for p in concatenate.__args__)
    if sys.version_info < (3, 10):
        # backport needs __args__ adjustment only
        return concatenate
    concatenate.__parameters__ = tuple(p for p in concatenate.__parameters__
                                        if p is not _EllipsisDummy)
    return concatenate


# 3.8-3.10
@typing._tp_cache
def _concatenate_getitem(self, parameters):
    if parameters == ():
        raise TypeError("Cannot take a Concatenate of no types.")
    if not isinstance(parameters, tuple):
        parameters = (parameters,)
    if not (parameters[-1] is ... or isinstance(parameters[-1], ParamSpec)):
        raise TypeError("The last parameter to Concatenate should be a "
                        "ParamSpec variable or ellipsis.")
    msg = "Concatenate[arg, ...]: each arg must be a type."
    parameters = (*(typing._type_check(p, msg) for p in parameters[:-1]),
                    parameters[-1])
    return _create_concatenate_alias(self, parameters)


# 3.11+; Concatenate does not accept ellipsis in 3.10
if sys.version_info >= (3, 11):
    Concatenate = typing.Concatenate
# 3.9-3.10
elif sys.version_info[:2] >= (3, 9):
    @_ExtensionsSpecialForm
    def Concatenate(self, parameters):
        """Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a
        higher order function which adds, removes or transforms parameters of a
        callable.

        For example::

           Callable[Concatenate[int, P], int]

        See PEP 612 for detailed information.
        """
        return _concatenate_getitem(self, parameters)
# 3.8
else:
    class _ConcatenateForm(_ExtensionsSpecialForm, _root=True):
        def __getitem__(self, parameters):
            return _concatenate_getitem(self, parameters)

    Concatenate = _ConcatenateForm(
        'Concatenate',
        doc="""Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a
        higher order function which adds, removes or transforms parameters of a
        callable.

        For example::

           Callable[Concatenate[int, P], int]

        See PEP 612 for detailed information.
        """)

# 3.10+
if hasattr(typing, 'TypeGuard'):
    TypeGuard = typing.TypeGuard
# 3.9
elif sys.version_info[:2] >= (3, 9):
    @_ExtensionsSpecialForm
    def TypeGuard(self, parameters):
        """Special typing form used to annotate the return type of a user-defined
        type guard function.  ``TypeGuard`` only accepts a single type argument.
        At runtime, functions marked this way should return a boolean.

        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static
        type checkers to determine a more precise type of an expression within a
        program's code flow.  Usually type narrowing is done by analyzing
        conditional code flow and applying the narrowing to a block of code.  The
        conditional expression here is sometimes referred to as a "type guard".

        Sometimes it would be convenient to use a user-defined boolean function
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its
        return type to alert static type checkers to this intention.

        Using  ``-> TypeGuard`` tells the static type checker that for a given
        function:

        1. The return value is a boolean.
        2. If the return value is ``True``, the type of its argument
        is the type inside ``TypeGuard``.

        For example::

            def is_str(val: Union[str, float]):
                # "isinstance" type guard
                if isinstance(val, str):
                    # Type of ``val`` is narrowed to ``str``
                    ...
                else:
                    # Else, type of ``val`` is narrowed to ``float``.
                    ...

        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower
        form of ``TypeA`` (it can even be a wider form) and this may lead to
        type-unsafe results.  The main reason is to allow for things like
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not
        a subtype of the former, since ``List`` is invariant.  The responsibility of
        writing type-safe type guards is left to the user.

        ``TypeGuard`` also works with type variables.  For more information, see
        PEP 647 (User-Defined Type Guards).
        """
        item = typing._type_check(parameters, f'{self} accepts only a single type.')
        return typing._GenericAlias(self, (item,))
# 3.8
else:
    class _TypeGuardForm(_ExtensionsSpecialForm, _root=True):
        def __getitem__(self, parameters):
            item = typing._type_check(parameters,
                                      f'{self._name} accepts only a single type')
            return typing._GenericAlias(self, (item,))

    TypeGuard = _TypeGuardForm(
        'TypeGuard',
        doc="""Special typing form used to annotate the return type of a user-defined
        type guard function.  ``TypeGuard`` only accepts a single type argument.
        At runtime, functions marked this way should return a boolean.

        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static
        type checkers to determine a more precise type of an expression within a
        program's code flow.  Usually type narrowing is done by analyzing
        conditional code flow and applying the narrowing to a block of code.  The
        conditional expression here is sometimes referred to as a "type guard".

        Sometimes it would be convenient to use a user-defined boolean function
        as a type guard.  Such a function should use ``TypeGuard[...]`` as its
        return type to alert static type checkers to this intention.

        Using  ``-> TypeGuard`` tells the static type checker that for a given
        function:

        1. The return value is a boolean.
        2. If the return value is ``True``, the type of its argument
        is the type inside ``TypeGuard``.

        For example::

            def is_str(val: Union[str, float]):
                # "isinstance" type guard
                if isinstance(val, str):
                    # Type of ``val`` is narrowed to ``str``
                    ...
                else:
                    # Else, type of ``val`` is narrowed to ``float``.
                    ...

        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower
        form of ``TypeA`` (it can even be a wider form) and this may lead to
        type-unsafe results.  The main reason is to allow for things like
        narrowing ``List[object]`` to ``List[str]`` even though the latter is not
        a subtype of the former, since ``List`` is invariant.  The responsibility of
        writing type-safe type guards is left to the user.

        ``TypeGuard`` also works with type variables.  For more information, see
        PEP 647 (User-Defined Type Guards).
        """)

# 3.13+
if hasattr(typing, 'TypeIs'):
    TypeIs = typing.TypeIs
# 3.9
elif sys.version_info[:2] >= (3, 9):
    @_ExtensionsSpecialForm
    def TypeIs(self, parameters):
        """Special typing form used to annotate the return type of a user-defined
        type narrower function.  ``TypeIs`` only accepts a single type argument.
        At runtime, functions marked this way should return a boolean.

        ``TypeIs`` aims to benefit *type narrowing* -- a technique used by static
        type checkers to determine a more precise type of an expression within a
        program's code flow.  Usually type narrowing is done by analyzing
        conditional code flow and applying the narrowing to a block of code.  The
        conditional expression here is sometimes referred to as a "type guard".

        Sometimes it would be convenient to use a user-defined boolean function
        as a type guard.  Such a function should use ``TypeIs[...]`` as its
        return type to alert static type checkers to this intention.

        Using  ``-> TypeIs`` tells the static type checker that for a given
        function:

        1. The return value is a boolean.
        2. If the return value is ``True``, the type of its argument
        is the intersection of the type inside ``TypeIs`` and the argument's
        previously known type.

        For example::

            def is_awaitable(val: object) -> TypeIs[Awaitable[Any]]:
                return hasattr(val, '__await__')

            def f(val: Union[int, Awaitable[int]]) -> int:
                if is_awaitable(val):
                    assert_type(val, Awaitable[int])
                else:
                    assert_type(val, int)

        ``TypeIs`` also works with type variables.  For more information, see
        PEP 742 (Narrowing types with TypeIs).
        """
        item = typing._type_check(parameters, f'{self} accepts only a single type.')
        return typing._GenericAlias(self, (item,))
# 3.8
else:
    class _TypeIsForm(_ExtensionsSpecialForm, _root=True):
        def __getitem__(self, parameters):
            item = typing._type_check(parameters,
                                      f'{self._name} accepts only a single type')
            return typing._GenericAlias(self, (item,))

    TypeIs = _TypeIsForm(
        'TypeIs',
        doc="""Special typing form used to annotate the return type of a user-defined
        type narrower function.  ``TypeIs`` only accepts a single type argument.
        At runtime, functions marked this way should return a boolean.

        ``TypeIs`` aims to benefit *type narrowing* -- a technique used by static
        type checkers to determine a more precise type of an expression within a
        program's code flow.  Usually type narrowing is done by analyzing
        conditional code flow and applying the narrowing to a block of code.  The
        conditional expression here is sometimes referred to as a "type guard".

        Sometimes it would be convenient to use a user-defined boolean function
        as a type guard.  Such a function should use ``TypeIs[...]`` as its
        return type to alert static type checkers to this intention.

        Using  ``-> TypeIs`` tells the static type checker that for a given
        function:

        1. The return value is a boolean.
        2. If the return value is ``True``, the type of its argument
        is the intersection of the type inside ``TypeIs`` and the argument's
        previously known type.

        For example::

            def is_awaitable(val: object) -> TypeIs[Awaitable[Any]]:
                return hasattr(val, '__await__')

            def f(val: Union[int, Awaitable[int]]) -> int:
                if is_awaitable(val):
                    assert_type(val, Awaitable[int])
                else:
                    assert_type(val, int)

        ``TypeIs`` also works with type variables.  For more information, see
        PEP 742 (Narrowing types with TypeIs).
        """)

# 3.14+?
if hasattr(typing, 'TypeForm'):
    TypeForm = typing.TypeForm
# 3.9
elif sys.version_info[:2] >= (3, 9):
    class _TypeFormForm(_ExtensionsSpecialForm, _root=True):
        # TypeForm(X) is equivalent to X but indicates to the type checker
        # that the object is a TypeForm.
        def __call__(self, obj, /):
            return obj

    @_TypeFormForm
    def TypeForm(self, parameters):
        """A special form representing the value that results from the evaluation
        of a type expression. This value encodes the information supplied in the
        type expression, and it represents the type described by that type expression.

        When used in a type expression, TypeForm describes a set of type form objects.
        It accepts a single type argument, which must be a valid type expression.
        ``TypeForm[T]`` describes the set of all type form objects that represent
        the type T or types that are assignable to T.

        Usage:

            def cast[T](typ: TypeForm[T], value: Any) -> T: ...

            reveal_type(cast(int, "x"))  # int

        See PEP 747 for more information.
        """
        item = typing._type_check(parameters, f'{self} accepts only a single type.')
        return typing._GenericAlias(self, (item,))
# 3.8
else:
    class _TypeFormForm(_ExtensionsSpecialForm, _root=True):
        def __getitem__(self, parameters):
            item = typing._type_check(parameters,
                                      f'{self._name} accepts only a single type')
            return typing._GenericAlias(self, (item,))

        def __call__(self, obj, /):
            return obj

    TypeForm = _TypeFormForm(
        'TypeForm',
        doc="""A special form representing the value that results from the evaluation
        of a type expression. This value encodes the information supplied in the
        type expression, and it represents the type described by that type expression.

        When used in a type expression, TypeForm describes a set of type form objects.
        It accepts a single type argument, which must be a valid type expression.
        ``TypeForm[T]`` describes the set of all type form objects that represent
        the type T or types that are assignable to T.

        Usage:

            def cast[T](typ: TypeForm[T], value: Any) -> T: ...

            reveal_type(cast(int, "x"))  # int

        See PEP 747 for more information.
        """)


# Vendored from cpython typing._SpecialFrom
class _SpecialForm(typing._Final, _root=True):
    __slots__ = ('_name', '__doc__', '_getitem')

    def __init__(self, getitem):
        self._getitem = getitem
        self._name = getitem.__name__
        self.__doc__ = getitem.__doc__

    def __getattr__(self, item):
        if item in {'__name__', '__qualname__'}:
            return self._name

        raise AttributeError(item)

    def __mro_entries__(self, bases):
        raise TypeError(f"Cannot subclass {self!r}")

    def __repr__(self):
        return f'typing_extensions.{self._name}'

    def __reduce__(self):
        return self._name

    def __call__(self, *args, **kwds):
        raise TypeError(f"Cannot instantiate {self!r}")

    def __or__(self, other):
        return typing.Union[self, other]

    def __ror__(self, other):
        return typing.Union[other, self]

    def __instancecheck__(self, obj):
        raise TypeError(f"{self} cannot be used with isinstance()")

    def __subclasscheck__(self, cls):
        raise TypeError(f"{self} cannot be used with issubclass()")

    @typing._tp_cache
    def __getitem__(self, parameters):
        return self._getitem(self, parameters)


if hasattr(typing, "LiteralString"):  # 3.11+
    LiteralString = typing.LiteralString
else:
    @_SpecialForm
    def LiteralString(self, params):
        """Represents an arbitrary literal string.

        Example::

          from typing_extensions import LiteralString

          def query(sql: LiteralString) -> ...:
              ...

          query("SELECT * FROM table")  # ok
          query(f"SELECT * FROM {input()}")  # not ok

        See PEP 675 for details.

        """
        raise TypeError(f"{self} is not subscriptable")


if hasattr(typing, "Self"):  # 3.11+
    Self = typing.Self
else:
    @_SpecialForm
    def Self(self, params):
        """Used to spell the type of "self" in classes.

        Example::

          from typing import Self

          class ReturnsSelf:
              def parse(self, data: bytes) -> Self:
                  ...
                  return self

        """

        raise TypeError(f"{self} is not subscriptable")


if hasattr(typing, "Never"):  # 3.11+
    Never = typing.Never
else:
    @_SpecialForm
    def Never(self, params):
        """The bottom type, a type that has no members.

        This can be used to define a function that should never be
        called, or a function that never returns::

            from typing_extensions import Never

            def never_call_me(arg: Never) -> None:
                pass

            def int_or_str(arg: int | str) -> None:
                never_call_me(arg)  # type checker error
                match arg:
                    case int():
                        print("It's an int")
                    case str():
                        print("It's a str")
                    case _:
                        never_call_me(arg)  # ok, arg is of type Never

        """

        raise TypeError(f"{self} is not subscriptable")


if hasattr(typing, 'Required'):  # 3.11+
    Required = typing.Required
    NotRequired = typing.NotRequired
elif sys.version_info[:2] >= (3, 9):  # 3.9-3.10
    @_ExtensionsSpecialForm
    def Required(self, parameters):
        """A special typing construct to mark a key of a total=False TypedDict
        as required. For example:

            class Movie(TypedDict, total=False):
                title: Required[str]
                year: int

            m = Movie(
                title='The Matrix',  # typechecker error if key is omitted
                year=1999,
            )

        There is no runtime checking that a required key is actually provided
        when instantiating a related TypedDict.
        """
        item = typing._type_check(parameters, f'{self._name} accepts only a single type.')
        return typing._GenericAlias(self, (item,))

    @_ExtensionsSpecialForm
    def NotRequired(self, parameters):
        """A special typing construct to mark a key of a TypedDict as
        potentially missing. For example:

            class Movie(TypedDict):
                title: str
                year: NotRequired[int]

            m = Movie(
                title='The Matrix',  # typechecker error if key is omitted
                year=1999,
            )
        """
        item = typing._type_check(parameters, f'{self._name} accepts only a single type.')
        return typing._GenericAlias(self, (item,))

else:  # 3.8
    class _RequiredForm(_ExtensionsSpecialForm, _root=True):
        def __getitem__(self, parameters):
            item = typing._type_check(parameters,
                                      f'{self._name} accepts only a single type.')
            return typing._GenericAlias(self, (item,))

    Required = _RequiredForm(
        'Required',
        doc="""A special typing construct to mark a key of a total=False TypedDict
        as required. For example:

            class Movie(TypedDict, total=False):
                title: Required[str]
                year: int

            m = Movie(
                title='The Matrix',  # typechecker error if key is omitted
                year=1999,
            )

        There is no runtime checking that a required key is actually provided
        when instantiating a related TypedDict.
        """)
    NotRequired = _RequiredForm(
        'NotRequired',
        doc="""A special typing construct to mark a key of a TypedDict as
        potentially missing. For example:

            class Movie(TypedDict):
                title: str
                year: NotRequired[int]

            m = Movie(
                title='The Matrix',  # typechecker error if key is omitted
                year=1999,
            )
        """)


if hasattr(typing, 'ReadOnly'):
    ReadOnly = typing.ReadOnly
elif sys.version_info[:2] >= (3, 9):  # 3.9-3.12
    @_ExtensionsSpecialForm
    def ReadOnly(self, parameters):
        """A special typing construct to mark an item of a TypedDict as read-only.

        For example:

            class Movie(TypedDict):
                title: ReadOnly[str]
                year: int

            def mutate_movie(m: Movie) -> None:
                m["year"] = 1992  # allowed
                m["title"] = "The Matrix"  # typechecker error

        There is no runtime checking for this property.
        """
        item = typing._type_check(parameters, f'{self._name} accepts only a single type.')
        return typing._GenericAlias(self, (item,))

else:  # 3.8
    class _ReadOnlyForm(_ExtensionsSpecialForm, _root=True):
        def __getitem__(self, parameters):
            item = typing._type_check(parameters,
                                      f'{self._name} accepts only a single type.')
            return typing._GenericAlias(self, (item,))

    ReadOnly = _ReadOnlyForm(
        'ReadOnly',
        doc="""A special typing construct to mark a key of a TypedDict as read-only.

        For example:

            class Movie(TypedDict):
                title: ReadOnly[str]
                year: int

            def mutate_movie(m: Movie) -> None:
                m["year"] = 1992  # allowed
                m["title"] = "The Matrix"  # typechecker error

        There is no runtime checking for this propery.
        """)


_UNPACK_DOC = """\
Type unpack operator.

The type unpack operator takes the child types from some container type,
such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For
example:

  # For some generic class `Foo`:
  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]

  Ts = TypeVarTuple('Ts')
  # Specifies that `Bar` is generic in an arbitrary number of types.
  # (Think of `Ts` as a tuple of an arbitrary number of individual
  #  `TypeVar`s, which the `Unpack` is 'pulling out' directly into the
  #  `Generic[]`.)
  class Bar(Generic[Unpack[Ts]]): ...
  Bar[int]  # Valid
  Bar[int, str]  # Also valid

From Python 3.11, this can also be done using the `*` operator:

    Foo[*tuple[int, str]]
    class Bar(Generic[*Ts]): ...

The operator can also be used along with a `TypedDict` to annotate
`**kwargs` in a function signature. For instance:

  class Movie(TypedDict):
    name: str
    year: int

  # This function expects two keyword arguments - *name* of type `str` and
  # *year* of type `int`.
  def foo(**kwargs: Unpack[Movie]): ...

Note that there is only some runtime checking of this operator. Not
everything the runtime allows may be accepted by static type checkers.

For more information, see PEP 646 and PEP 692.
"""


if sys.version_info >= (3, 12):  # PEP 692 changed the repr of Unpack[]
    Unpack = typing.Unpack

    def _is_unpack(obj):
        return get_origin(obj) is Unpack

elif sys.version_info[:2] >= (3, 9):  # 3.9+
    class _UnpackSpecialForm(_ExtensionsSpecialForm, _root=True):
        def __init__(self, getitem):
            super().__init__(getitem)
            self.__doc__ = _UNPACK_DOC

    class _UnpackAlias(typing._GenericAlias, _root=True):
        if sys.version_info < (3, 11):
            # needed for compatibility with Generic[Unpack[Ts]]
            __class__ = typing.TypeVar

        @property
        def __typing_unpacked_tuple_args__(self):
            assert self.__origin__ is Unpack
            assert len(self.__args__) == 1
            arg, = self.__args__
            if isinstance(arg, (typing._GenericAlias, _types.GenericAlias)):
                if arg.__origin__ is not tuple:
                    raise TypeError("Unpack[...] must be used with a tuple type")
                return arg.__args__
            return None

        @property
        def __typing_is_unpacked_typevartuple__(self):
            assert self.__origin__ is Unpack
            assert len(self.__args__) == 1
            return isinstance(self.__args__[0], TypeVarTuple)

        def __getitem__(self, args):
            if self.__typing_is_unpacked_typevartuple__:
                return args
            return super().__getitem__(args)

    @_UnpackSpecialForm
    def Unpack(self, parameters):
        item = typing._type_check(parameters, f'{self._name} accepts only a single type.')
        return _UnpackAlias(self, (item,))

    def _is_unpack(obj):
        return isinstance(obj, _UnpackAlias)

else:  # 3.8
    class _UnpackAlias(typing._GenericAlias, _root=True):
        __class__ = typing.TypeVar

        @property
        def __typing_unpacked_tuple_args__(self):
            assert self.__origin__ is Unpack
            assert len(self.__args__) == 1
            arg, = self.__args__
            if isinstance(arg, typing._GenericAlias):
                if arg.__origin__ is not tuple:
                    raise TypeError("Unpack[...] must be used with a tuple type")
                return arg.__args__
            return None

        @property
        def __typing_is_unpacked_typevartuple__(self):
            assert self.__origin__ is Unpack
            assert len(self.__args__) == 1
            return isinstance(self.__args__[0], TypeVarTuple)

        def __getitem__(self, args):
            if self.__typing_is_unpacked_typevartuple__:
                return args
            return super().__getitem__(args)

    class _UnpackForm(_ExtensionsSpecialForm, _root=True):
        def __getitem__(self, parameters):
            item = typing._type_check(parameters,
                                      f'{self._name} accepts only a single type.')
            return _UnpackAlias(self, (item,))

    Unpack = _UnpackForm('Unpack', doc=_UNPACK_DOC)

    def _is_unpack(obj):
        return isinstance(obj, _UnpackAlias)


def _unpack_args(*args):
    newargs = []
    for arg in args:
        subargs = getattr(arg, '__typing_unpacked_tuple_args__', None)
        if subargs is not None and (not (subargs and subargs[-1] is ...)):
            newargs.extend(subargs)
        else:
            newargs.append(arg)
    return newargs


if _PEP_696_IMPLEMENTED:
    from typing import TypeVarTuple

elif hasattr(typing, "TypeVarTuple"):  # 3.11+

    # Add default parameter - PEP 696
    class TypeVarTuple(metaclass=_TypeVarLikeMeta):
        """Type variable tuple."""

        _backported_typevarlike = typing.TypeVarTuple

        def __new__(cls, name, *, default=NoDefault):
            tvt = typing.TypeVarTuple(name)
            _set_default(tvt, default)
            _set_module(tvt)

            def _typevartuple_prepare_subst(alias, args):
                params = alias.__parameters__
                typevartuple_index = params.index(tvt)
                for param in params[typevartuple_index + 1:]:
                    if isinstance(param, TypeVarTuple):
                        raise TypeError(
                            f"More than one TypeVarTuple parameter in {alias}"
                        )

                alen = len(args)
                plen = len(params)
                left = typevartuple_index
                right = plen - typevartuple_index - 1
                var_tuple_index = None
                fillarg = None
                for k, arg in enumerate(args):
                    if not isinstance(arg, type):
                        subargs = getattr(arg, '__typing_unpacked_tuple_args__', None)
                        if subargs and len(subargs) == 2 and subargs[-1] is ...:
                            if var_tuple_index is not None:
                                raise TypeError(
                                    "More than one unpacked "
                                    "arbitrary-length tuple argument"
                                )
                            var_tuple_index = k
                            fillarg = subargs[0]
                if var_tuple_index is not None:
                    left = min(left, var_tuple_index)
                    right = min(right, alen - var_tuple_index - 1)
                elif left + right > alen:
                    raise TypeError(f"Too few arguments for {alias};"
                                    f" actual {alen}, expected at least {plen - 1}")
                if left == alen - right and tvt.has_default():
                    replacement = _unpack_args(tvt.__default__)
                else:
                    replacement = args[left: alen - right]

                return (
                    *args[:left],
                    *([fillarg] * (typevartuple_index - left)),
                    replacement,
                    *([fillarg] * (plen - right - left - typevartuple_index - 1)),
                    *args[alen - right:],
                )

            tvt.__typing_prepare_subst__ = _typevartuple_prepare_subst
            return tvt

        def __init_subclass__(self, *args, **kwds):
            raise TypeError("Cannot subclass special typing classes")

else:  # <=3.10
    class TypeVarTuple(_DefaultMixin):
        """Type variable tuple.

        Usage::

            Ts = TypeVarTuple('Ts')

        In the same way that a normal type variable is a stand-in for a single
        type such as ``int``, a type variable *tuple* is a stand-in for a *tuple*
        type such as ``Tuple[int, str]``.

        Type variable tuples can be used in ``Generic`` declarations.
        Consider the following example::

            class Array(Generic[*Ts]): ...

        The ``Ts`` type variable tuple here behaves like ``tuple[T1, T2]``,
        where ``T1`` and ``T2`` are type variables. To use these type variables
        as type parameters of ``Array``, we must *unpack* the type variable tuple using
        the star operator: ``*Ts``. The signature of ``Array`` then behaves
        as if we had simply written ``class Array(Generic[T1, T2]): ...``.
        In contrast to ``Generic[T1, T2]``, however, ``Generic[*Shape]`` allows
        us to parameterise the class with an *arbitrary* number of type parameters.

        Type variable tuples can be used anywhere a normal ``TypeVar`` can.
        This includes class definitions, as shown above, as well as function
        signatures and variable annotations::

            class Array(Generic[*Ts]):

                def __init__(self, shape: Tuple[*Ts]):
                    self._shape: Tuple[*Ts] = shape

                def get_shape(self) -> Tuple[*Ts]:
                    return self._shape

            shape = (Height(480), Width(640))
            x: Array[Height, Width] = Array(shape)
            y = abs(x)  # Inferred type is Array[Height, Width]
            z = x + x   #        ...    is Array[Height, Width]
            x.get_shape()  #     ...    is tuple[Height, Width]

        """

        # Trick Generic __parameters__.
        __class__ = typing.TypeVar

        def __iter__(self):
            yield self.__unpacked__

        def __init__(self, name, *, default=NoDefault):
            self.__name__ = name
            _DefaultMixin.__init__(self, default)

            # for pickling:
            def_mod = _caller()
            if def_mod != 'typing_extensions':
                self.__module__ = def_mod

            self.__unpacked__ = Unpack[self]

        def __repr__(self):
            return self.__name__

        def __hash__(self):
            return object.__hash__(self)

        def __eq__(self, other):
            return self is other

        def __reduce__(self):
            return self.__name__

        def __init_subclass__(self, *args, **kwds):
            if '_root' not in kwds:
                raise TypeError("Cannot subclass special typing classes")


if hasattr(typing, "reveal_type"):  # 3.11+
    reveal_type = typing.reveal_type
else:  # <=3.10
    def reveal_type(obj: T, /) -> T:
        """Reveal the inferred type of a variable.

        When a static type checker encounters a call to ``reveal_type()``,
        it will emit the inferred type of the argument::

            x: int = 1
            reveal_type(x)

        Running a static type checker (e.g., ``mypy``) on this example
        will produce output similar to 'Revealed type is "builtins.int"'.

        At runtime, the function prints the runtime type of the
        argument and returns it unchanged.

        """
        print(f"Runtime type is {type(obj).__name__!r}", file=sys.stderr)
        return obj


if hasattr(typing, "_ASSERT_NEVER_REPR_MAX_LENGTH"):  # 3.11+
    _ASSERT_NEVER_REPR_MAX_LENGTH = typing._ASSERT_NEVER_REPR_MAX_LENGTH
else:  # <=3.10
    _ASSERT_NEVER_REPR_MAX_LENGTH = 100


if hasattr(typing, "assert_never"):  # 3.11+
    assert_never = typing.assert_never
else:  # <=3.10
    def assert_never(arg: Never, /) -> Never:
        """Assert to the type checker that a line of code is unreachable.

        Example::

            def int_or_str(arg: int | str) -> None:
                match arg:
                    case int():
                        print("It's an int")
                    case str():
                        print("It's a str")
                    case _:
                        assert_never(arg)

        If a type checker finds that a call to assert_never() is
        reachable, it will emit an error.

        At runtime, this throws an exception when called.

        """
        value = repr(arg)
        if len(value) > _ASSERT_NEVER_REPR_MAX_LENGTH:
            value = value[:_ASSERT_NEVER_REPR_MAX_LENGTH] + '...'
        raise AssertionError(f"Expected code to be unreachable, but got: {value}")


if sys.version_info >= (3, 12):  # 3.12+
    # dataclass_transform exists in 3.11 but lacks the frozen_default parameter
    dataclass_transform = typing.dataclass_transform
else:  # <=3.11
    def dataclass_transform(
        *,
        eq_default: bool = True,
        order_default: bool = False,
        kw_only_default: bool = False,
        frozen_default: bool = False,
        field_specifiers: typing.Tuple[
            typing.Union[typing.Type[typing.Any], typing.Callable[..., typing.Any]],
            ...
        ] = (),
        **kwargs: typing.Any,
    ) -> typing.Callable[[T], T]:
        """Decorator that marks a function, class, or metaclass as providing
        dataclass-like behavior.

        Example:

            from typing_extensions import dataclass_transform

            _T = TypeVar("_T")

            # Used on a decorator function
            @dataclass_transform()
            def create_model(cls: type[_T]) -> type[_T]:
                ...
                return cls

            @create_model
            class CustomerModel:
                id: int
                name: str

            # Used on a base class
            @dataclass_transform()
            class ModelBase: ...

            class CustomerModel(ModelBase):
                id: int
                name: str

            # Used on a metaclass
            @dataclass_transform()
            class ModelMeta(type): ...

            class ModelBase(metaclass=ModelMeta): ...

            class CustomerModel(ModelBase):
                id: int
                name: str

        Each of the ``CustomerModel`` classes defined in this example will now
        behave similarly to a dataclass created with the ``@dataclasses.dataclass``
        decorator. For example, the type checker will synthesize an ``__init__``
        method.

        The arguments to this decorator can be used to customize this behavior:
        - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be
          True or False if it is omitted by the caller.
        - ``order_default`` indicates whether the ``order`` parameter is
          assumed to be True or False if it is omitted by the caller.
        - ``kw_only_default`` indicates whether the ``kw_only`` parameter is
          assumed to be True or False if it is omitted by the caller.
        - ``frozen_default`` indicates whether the ``frozen`` parameter is
          assumed to be True or False if it is omitted by the caller.
        - ``field_specifiers`` specifies a static list of supported classes
          or functions that describe fields, similar to ``dataclasses.field()``.

        At runtime, this decorator records its arguments in the
        ``__dataclass_transform__`` attribute on the decorated object.

        See PEP 681 for details.

        """
        def decorator(cls_or_fn):
            cls_or_fn.__dataclass_transform__ = {
                "eq_default": eq_default,
                "order_default": order_default,
                "kw_only_default": kw_only_default,
                "frozen_default": frozen_default,
                "field_specifiers": field_specifiers,
                "kwargs": kwargs,
            }
            return cls_or_fn
        return decorator


if hasattr(typing, "override"):  # 3.12+
    override = typing.override
else:  # <=3.11
    _F = typing.TypeVar("_F", bound=typing.Callable[..., typing.Any])

    def override(arg: _F, /) -> _F:
        """Indicate that a method is intended to override a method in a base class.

        Usage:

            class Base:
                def method(self) -> None:
                    pass

            class Child(Base):
                @override
                def method(self) -> None:
                    super().method()

        When this decorator is applied to a method, the type checker will
        validate that it overrides a method with the same name on a base class.
        This helps prevent bugs that may occur when a base class is changed
        without an equivalent change to a child class.

        There is no runtime checking of these properties. The decorator
        sets the ``__override__`` attribute to ``True`` on the decorated object
        to allow runtime introspection.

        See PEP 698 for details.

        """
        try:
            arg.__override__ = True
        except (AttributeError, TypeError):
            # Skip the attribute silently if it is not writable.
            # AttributeError happens if the object has __slots__ or a
            # read-only property, TypeError if it's a builtin class.
            pass
        return arg


# Python 3.13.3+ contains a fix for the wrapped __new__
if sys.version_info >= (3, 13, 3):
    deprecated = warnings.deprecated
else:
    _T = typing.TypeVar("_T")

    class deprecated:
        """Indicate that a class, function or overload is deprecated.

        When this decorator is applied to an object, the type checker
        will generate a diagnostic on usage of the deprecated object.

        Usage:

            @deprecated("Use B instead")
            class A:
                pass

            @deprecated("Use g instead")
            def f():
                pass

            @overload
            @deprecated("int support is deprecated")
            def g(x: int) -> int: ...
            @overload
            def g(x: str) -> int: ...

        The warning specified by *category* will be emitted at runtime
        on use of deprecated objects. For functions, that happens on calls;
        for classes, on instantiation and on creation of subclasses.
        If the *category* is ``None``, no warning is emitted at runtime.
        The *stacklevel* determines where the
        warning is emitted. If it is ``1`` (the default), the warning
        is emitted at the direct caller of the deprecated object; if it
        is higher, it is emitted further up the stack.
        Static type checker behavior is not affected by the *category*
        and *stacklevel* arguments.

        The deprecation message passed to the decorator is saved in the
        ``__deprecated__`` attribute on the decorated object.
        If applied to an overload, the decorator
        must be after the ``@overload`` decorator for the attribute to
        exist on the overload as returned by ``get_overloads()``.

        See PEP 702 for details.

        """
        def __init__(
            self,
            message: str,
            /,
            *,
            category: typing.Optional[typing.Type[Warning]] = DeprecationWarning,
            stacklevel: int = 1,
        ) -> None:
            if not isinstance(message, str):
                raise TypeError(
                    "Expected an object of type str for 'message', not "
                    f"{type(message).__name__!r}"
                )
            self.message = message
            self.category = category
            self.stacklevel = stacklevel

        def __call__(self, arg: _T, /) -> _T:
            # Make sure the inner functions created below don't
            # retain a reference to self.
            msg = self.message
            category = self.category
            stacklevel = self.stacklevel
            if category is None:
                arg.__deprecated__ = msg
                return arg
            elif isinstance(arg, type):
                import functools
                from types import MethodType

                original_new = arg.__new__

                @functools.wraps(original_new)
                def __new__(cls, /, *args, **kwargs):
                    if cls is arg:
                        warnings.warn(msg, category=category, stacklevel=stacklevel + 1)
                    if original_new is not object.__new__:
                        return original_new(cls, *args, **kwargs)
                    # Mirrors a similar check in object.__new__.
                    elif cls.__init__ is object.__init__ and (args or kwargs):
                        raise TypeError(f"{cls.__name__}() takes no arguments")
                    else:
                        return original_new(cls)

                arg.__new__ = staticmethod(__new__)

                original_init_subclass = arg.__init_subclass__
                # We need slightly different behavior if __init_subclass__
                # is a bound method (likely if it was implemented in Python)
                if isinstance(original_init_subclass, MethodType):
                    original_init_subclass = original_init_subclass.__func__

                    @functools.wraps(original_init_subclass)
                    def __init_subclass__(*args, **kwargs):
                        warnings.warn(msg, category=category, stacklevel=stacklevel + 1)
                        return original_init_subclass(*args, **kwargs)

                    arg.__init_subclass__ = classmethod(__init_subclass__)
                # Or otherwise, which likely means it's a builtin such as
                # object's implementation of __init_subclass__.
                else:
                    @functools.wraps(original_init_subclass)
                    def __init_subclass__(*args, **kwargs):
                        warnings.warn(msg, category=category, stacklevel=stacklevel + 1)
                        return original_init_subclass(*args, **kwargs)

                    arg.__init_subclass__ = __init_subclass__

                arg.__deprecated__ = __new__.__deprecated__ = msg
                __init_subclass__.__deprecated__ = msg
                return arg
            elif callable(arg):
                import asyncio.coroutines
                import functools
                import inspect

                @functools.wraps(arg)
                def wrapper(*args, **kwargs):
                    warnings.warn(msg, category=category, stacklevel=stacklevel + 1)
                    return arg(*args, **kwargs)

                if asyncio.coroutines.iscoroutinefunction(arg):
                    if sys.version_info >= (3, 12):
                        wrapper = inspect.markcoroutinefunction(wrapper)
                    else:
                        wrapper._is_coroutine = asyncio.coroutines._is_coroutine

                arg.__deprecated__ = wrapper.__deprecated__ = msg
                return wrapper
            else:
                raise TypeError(
                    "@deprecated decorator with non-None category must be applied to "
                    f"a class or callable, not {arg!r}"
                )

if sys.version_info < (3, 10):
    def _is_param_expr(arg):
        return arg is ... or isinstance(
            arg, (tuple, list, ParamSpec, _ConcatenateGenericAlias)
        )
else:
    def _is_param_expr(arg):
        return arg is ... or isinstance(
            arg,
            (
                tuple,
                list,
                ParamSpec,
                _ConcatenateGenericAlias,
                typing._ConcatenateGenericAlias,
            ),
        )


# We have to do some monkey patching to deal with the dual nature of
# Unpack/TypeVarTuple:
# - We want Unpack to be a kind of TypeVar so it gets accepted in
#   Generic[Unpack[Ts]]
# - We want it to *not* be treated as a TypeVar for the purposes of
#   counting generic parameters, so that when we subscript a generic,
#   the runtime doesn't try to substitute the Unpack with the subscripted type.
if not hasattr(typing, "TypeVarTuple"):
    def _check_generic(cls, parameters, elen=_marker):
        """Check correct count for parameters of a generic cls (internal helper).

        This gives a nice error message in case of count mismatch.
        """
        # If substituting a single ParamSpec with multiple arguments
        # we do not check the count
        if (inspect.isclass(cls) and issubclass(cls, typing.Generic)
            and len(cls.__parameters__) == 1
            and isinstance(cls.__parameters__[0], ParamSpec)
            and parameters
            and not _is_param_expr(parameters[0])
        ):
            # Generic modifies parameters variable, but here we cannot do this
            return

        if not elen:
            raise TypeError(f"{cls} is not a generic class")
        if elen is _marker:
            if not hasattr(cls, "__parameters__") or not cls.__parameters__:
                raise TypeError(f"{cls} is not a generic class")
            elen = len(cls.__parameters__)
        alen = len(parameters)
        if alen != elen:
            expect_val = elen
            if hasattr(cls, "__parameters__"):
                parameters = [p for p in cls.__parameters__ if not _is_unpack(p)]
                num_tv_tuples = sum(isinstance(p, TypeVarTuple) for p in parameters)
                if (num_tv_tuples > 0) and (alen >= elen - num_tv_tuples):
                    return

                # deal with TypeVarLike defaults
                # required TypeVarLikes cannot appear after a defaulted one.
                if alen < elen:
                    # since we validate TypeVarLike default in _collect_type_vars
                    # or _collect_parameters we can safely check parameters[alen]
                    if (
                        getattr(parameters[alen], '__default__', NoDefault)
                        is not NoDefault
                    ):
                        return

                    num_default_tv = sum(getattr(p, '__default__', NoDefault)
                                         is not NoDefault for p in parameters)

                    elen -= num_default_tv

                    expect_val = f"at least {elen}"

            things = "arguments" if sys.version_info >= (3, 10) else "parameters"
            raise TypeError(f"Too {'many' if alen > elen else 'few'} {things}"
                            f" for {cls}; actual {alen}, expected {expect_val}")
else:
    # Python 3.11+

    def _check_generic(cls, parameters, elen):
        """Check correct count for parameters of a generic cls (internal helper).

        This gives a nice error message in case of count mismatch.
        """
        if not elen:
            raise TypeError(f"{cls} is not a generic class")
        alen = len(parameters)
        if alen != elen:
            expect_val = elen
            if hasattr(cls, "__parameters__"):
                parameters = [p for p in cls.__parameters__ if not _is_unpack(p)]

                # deal with TypeVarLike defaults
                # required TypeVarLikes cannot appear after a defaulted one.
                if alen < elen:
                    # since we validate TypeVarLike default in _collect_type_vars
                    # or _collect_parameters we can safely check parameters[alen]
                    if (
                        getattr(parameters[alen], '__default__', NoDefault)
                        is not NoDefault
                    ):
                        return

                    num_default_tv = sum(getattr(p, '__default__', NoDefault)
                                         is not NoDefault for p in parameters)

                    elen -= num_default_tv

                    expect_val = f"at least {elen}"

            raise TypeError(f"Too {'many' if alen > elen else 'few'} arguments"
                            f" for {cls}; actual {alen}, expected {expect_val}")

if not _PEP_696_IMPLEMENTED:
    typing._check_generic = _check_generic


def _has_generic_or_protocol_as_origin() -> bool:
    try:
        frame = sys._getframe(2)
    # - Catch AttributeError: not all Python implementations have sys._getframe()
    # - Catch ValueError: maybe we're called from an unexpected module
    #   and the call stack isn't deep enough
    except (AttributeError, ValueError):
        return False  # err on the side of leniency
    else:
        # If we somehow get invoked from outside typing.py,
        # also err on the side of leniency
        if frame.f_globals.get("__name__") != "typing":
            return False
        origin = frame.f_locals.get("origin")
        # Cannot use "in" because origin may be an object with a buggy __eq__ that
        # throws an error.
        return origin is typing.Generic or origin is Protocol or origin is typing.Protocol


_TYPEVARTUPLE_TYPES = {TypeVarTuple, getattr(typing, "TypeVarTuple", None)}


def _is_unpacked_typevartuple(x) -> bool:
    if get_origin(x) is not Unpack:
        return False
    args = get_args(x)
    return (
        bool(args)
        and len(args) == 1
        and type(args[0]) in _TYPEVARTUPLE_TYPES
    )


# Python 3.11+ _collect_type_vars was renamed to _collect_parameters
if hasattr(typing, '_collect_type_vars'):
    def _collect_type_vars(types, typevar_types=None):
        """Collect all type variable contained in types in order of
        first appearance (lexicographic order). For example::

            _collect_type_vars((T, List[S, T])) == (T, S)
        """
        if typevar_types is None:
            typevar_types = typing.TypeVar
        tvars = []

        # A required TypeVarLike cannot appear after a TypeVarLike with a default
        # if it was a direct call to `Generic[]` or `Protocol[]`
        enforce_default_ordering = _has_generic_or_protocol_as_origin()
        default_encountered = False

        # Also, a TypeVarLike with a default cannot appear after a TypeVarTuple
        type_var_tuple_encountered = False

        for t in types:
            if _is_unpacked_typevartuple(t):
                type_var_tuple_encountered = True
            elif (
                isinstance(t, typevar_types) and not isinstance(t, _UnpackAlias)
                and t not in tvars
            ):
                if enforce_default_ordering:
                    has_default = getattr(t, '__default__', NoDefault) is not NoDefault
                    if has_default:
                        if type_var_tuple_encountered:
                            raise TypeError('Type parameter with a default'
                                            ' follows TypeVarTuple')
                        default_encountered = True
                    elif default_encountered:
                        raise TypeError(f'Type parameter {t!r} without a default'
                                        ' follows type parameter with a default')

                tvars.append(t)
            if _should_collect_from_parameters(t):
                tvars.extend([t for t in t.__parameters__ if t not in tvars])
            elif isinstance(t, tuple):
                # Collect nested type_vars
                # tuple wrapped by  _prepare_paramspec_params(cls, params)
                for x in t:
                    for collected in _collect_type_vars([x]):
                        if collected not in tvars:
                            tvars.append(collected)
        return tuple(tvars)

    typing._collect_type_vars = _collect_type_vars
else:
    def _collect_parameters(args):
        """Collect all type variables and parameter specifications in args
        in order of first appearance (lexicographic order).

        For example::

            assert _collect_parameters((T, Callable[P, T])) == (T, P)
        """
        parameters = []

        # A required TypeVarLike cannot appear after a TypeVarLike with default
        # if it was a direct call to `Generic[]` or `Protocol[]`
        enforce_default_ordering = _has_generic_or_protocol_as_origin()
        default_encountered = False

        # Also, a TypeVarLike with a default cannot appear after a TypeVarTuple
        type_var_tuple_encountered = False

        for t in args:
            if isinstance(t, type):
                # We don't want __parameters__ descriptor of a bare Python class.
                pass
            elif isinstance(t, tuple):
                # `t` might be a tuple, when `ParamSpec` is substituted with
                # `[T, int]`, or `[int, *Ts]`, etc.
                for x in t:
                    for collected in _collect_parameters([x]):
                        if collected not in parameters:
                            parameters.append(collected)
            elif hasattr(t, '__typing_subst__'):
                if t not in parameters:
                    if enforce_default_ordering:
                        has_default = (
                            getattr(t, '__default__', NoDefault) is not NoDefault
                        )

                        if type_var_tuple_encountered and has_default:
                            raise TypeError('Type parameter with a default'
                                            ' follows TypeVarTuple')

                        if has_default:
                            default_encountered = True
                        elif default_encountered:
                            raise TypeError(f'Type parameter {t!r} without a default'
                                            ' follows type parameter with a default')

                    parameters.append(t)
            else:
                if _is_unpacked_typevartuple(t):
                    type_var_tuple_encountered = True
                for x in getattr(t, '__parameters__', ()):
                    if x not in parameters:
                        parameters.append(x)

        return tuple(parameters)

    if not _PEP_696_IMPLEMENTED:
        typing._collect_parameters = _collect_parameters

# Backport typing.NamedTuple as it exists in Python 3.13.
# In 3.11, the ability to define generic `NamedTuple`s was supported.
# This was explicitly disallowed in 3.9-3.10, and only half-worked in <=3.8.
# On 3.12, we added __orig_bases__ to call-based NamedTuples
# On 3.13, we deprecated kwargs-based NamedTuples
if sys.version_info >= (3, 13):
    NamedTuple = typing.NamedTuple
else:
    def _make_nmtuple(name, types, module, defaults=()):
        fields = [n for n, t in types]
        annotations = {n: typing._type_check(t, f"field {n} annotation must be a type")
                       for n, t in types}
        nm_tpl = collections.namedtuple(name, fields,
                                        defaults=defaults, module=module)
        nm_tpl.__annotations__ = nm_tpl.__new__.__annotations__ = annotations
        # The `_field_types` attribute was removed in 3.9;
        # in earlier versions, it is the same as the `__annotations__` attribute
        if sys.version_info < (3, 9):
            nm_tpl._field_types = annotations
        return nm_tpl

    _prohibited_namedtuple_fields = typing._prohibited
    _special_namedtuple_fields = frozenset({'__module__', '__name__', '__annotations__'})

    class _NamedTupleMeta(type):
        def __new__(cls, typename, bases, ns):
            assert _NamedTuple in bases
            for base in bases:
                if base is not _NamedTuple and base is not typing.Generic:
                    raise TypeError(
                        'can only inherit from a NamedTuple type and Generic')
            bases = tuple(tuple if base is _NamedTuple else base for base in bases)
            if "__annotations__" in ns:
                types = ns["__annotations__"]
            elif "__annotate__" in ns:
                # TODO: Use inspect.VALUE here, and make the annotations lazily evaluated
                types = ns["__annotate__"](1)
            else:
                types = {}
            default_names = []
            for field_name in types:
                if field_name in ns:
                    default_names.append(field_name)
                elif default_names:
                    raise TypeError(f"Non-default namedtuple field {field_name} "
                                    f"cannot follow default field"
                                    f"{'s' if len(default_names) > 1 else ''} "
                                    f"{', '.join(default_names)}")
            nm_tpl = _make_nmtuple(
                typename, types.items(),
                defaults=[ns[n] for n in default_names],
                module=ns['__module__']
            )
            nm_tpl.__bases__ = bases
            if typing.Generic in bases:
                if hasattr(typing, '_generic_class_getitem'):  # 3.12+
                    nm_tpl.__class_getitem__ = classmethod(typing._generic_class_getitem)
                else:
                    class_getitem = typing.Generic.__class_getitem__.__func__
                    nm_tpl.__class_getitem__ = classmethod(class_getitem)
            # update from user namespace without overriding special namedtuple attributes
            for key, val in ns.items():
                if key in _prohibited_namedtuple_fields:
                    raise AttributeError("Cannot overwrite NamedTuple attribute " + key)
                elif key not in _special_namedtuple_fields:
                    if key not in nm_tpl._fields:
                        setattr(nm_tpl, key, ns[key])
                    try:
                        set_name = type(val).__set_name__
                    except AttributeError:
                        pass
                    else:
                        try:
                            set_name(val, nm_tpl, key)
                        except BaseException as e:
                            msg = (
                                f"Error calling __set_name__ on {type(val).__name__!r} "
                                f"instance {key!r} in {typename!r}"
                            )
                            # BaseException.add_note() existed on py311,
                            # but the __set_name__ machinery didn't start
                            # using add_note() until py312.
                            # Making sure exceptions are raised in the same way
                            # as in "normal" classes seems most important here.
                            if sys.version_info >= (3, 12):
                                e.add_note(msg)
                                raise
                            else:
                                raise RuntimeError(msg) from e

            if typing.Generic in bases:
                nm_tpl.__init_subclass__()
            return nm_tpl

    _NamedTuple = type.__new__(_NamedTupleMeta, 'NamedTuple', (), {})

    def _namedtuple_mro_entries(bases):
        assert NamedTuple in bases
        return (_NamedTuple,)

    @_ensure_subclassable(_namedtuple_mro_entries)
    def NamedTuple(typename, fields=_marker, /, **kwargs):
        """Typed version of namedtuple.

        Usage::

            class Employee(NamedTuple):
                name: str
                id: int

        This is equivalent to::

            Employee = collections.namedtuple('Employee', ['name', 'id'])

        The resulting class has an extra __annotations__ attribute, giving a
        dict that maps field names to types.  (The field names are also in
        the _fields attribute, which is part of the namedtuple API.)
        An alternative equivalent functional syntax is also accepted::

            Employee = NamedTuple('Employee', [('name', str), ('id', int)])
        """
        if fields is _marker:
            if kwargs:
                deprecated_thing = "Creating NamedTuple classes using keyword arguments"
                deprecation_msg = (
                    "{name} is deprecated and will be disallowed in Python {remove}. "
                    "Use the class-based or functional syntax instead."
                )
            else:
                deprecated_thing = "Failing to pass a value for the 'fields' parameter"
                example = f"`{typename} = NamedTuple({typename!r}, [])`"
                deprecation_msg = (
                    "{name} is deprecated and will be disallowed in Python {remove}. "
                    "To create a NamedTuple class with 0 fields "
                    "using the functional syntax, "
                    "pass an empty list, e.g. "
                ) + example + "."
        elif fields is None:
            if kwargs:
                raise TypeError(
                    "Cannot pass `None` as the 'fields' parameter "
                    "and also specify fields using keyword arguments"
                )
            else:
                deprecated_thing = "Passing `None` as the 'fields' parameter"
                example = f"`{typename} = NamedTuple({typename!r}, [])`"
                deprecation_msg = (
                    "{name} is deprecated and will be disallowed in Python {remove}. "
                    "To create a NamedTuple class with 0 fields "
                    "using the functional syntax, "
                    "pass an empty list, e.g. "
                ) + example + "."
        elif kwargs:
            raise TypeError("Either list of fields or keywords"
                            " can be provided to NamedTuple, not both")
        if fields is _marker or fields is None:
            warnings.warn(
                deprecation_msg.format(name=deprecated_thing, remove="3.15"),
                DeprecationWarning,
                stacklevel=2,
            )
            fields = kwargs.items()
        nt = _make_nmtuple(typename, fields, module=_caller())
        nt.__orig_bases__ = (NamedTuple,)
        return nt


if hasattr(collections.abc, "Buffer"):
    Buffer = collections.abc.Buffer
else:
    class Buffer(abc.ABC):  # noqa: B024
        """Base class for classes that implement the buffer protocol.

        The buffer protocol allows Python objects to expose a low-level
        memory buffer interface. Before Python 3.12, it is not possible
        to implement the buffer protocol in pure Python code, or even
        to check whether a class implements the buffer protocol. In
        Python 3.12 and higher, the ``__buffer__`` method allows access
        to the buffer protocol from Python code, and the
        ``collections.abc.Buffer`` ABC allows checking whether a class
        implements the buffer protocol.

        To indicate support for the buffer protocol in earlier versions,
        inherit from this ABC, either in a stub file or at runtime,
        or use ABC registration. This ABC provides no methods, because
        there is no Python-accessible methods shared by pre-3.12 buffer
        classes. It is useful primarily for static checks.

        """

    # As a courtesy, register the most common stdlib buffer classes.
    Buffer.register(memoryview)
    Buffer.register(bytearray)
    Buffer.register(bytes)


# Backport of types.get_original_bases, available on 3.12+ in CPython
if hasattr(_types, "get_original_bases"):
    get_original_bases = _types.get_original_bases
else:
    def get_original_bases(cls, /):
        """Return the class's "original" bases prior to modification by `__mro_entries__`.

        Examples::

            from typing import TypeVar, Generic
            from typing_extensions import NamedTuple, TypedDict

            T = TypeVar("T")
            class Foo(Generic[T]): ...
            class Bar(Foo[int], float): ...
            class Baz(list[str]): ...
            Eggs = NamedTuple("Eggs", [("a", int), ("b", str)])
            Spam = TypedDict("Spam", {"a": int, "b": str})

            assert get_original_bases(Bar) == (Foo[int], float)
            assert get_original_bases(Baz) == (list[str],)
            assert get_original_bases(Eggs) == (NamedTuple,)
            assert get_original_bases(Spam) == (TypedDict,)
            assert get_original_bases(int) == (object,)
        """
        try:
            return cls.__dict__.get("__orig_bases__", cls.__bases__)
        except AttributeError:
            raise TypeError(
                f'Expected an instance of type, not {type(cls).__name__!r}'
            ) from None


# NewType is a class on Python 3.10+, making it pickleable
# The error message for subclassing instances of NewType was improved on 3.11+
if sys.version_info >= (3, 11):
    NewType = typing.NewType
else:
    class NewType:
        """NewType creates simple unique types with almost zero
        runtime overhead. NewType(name, tp) is considered a subtype of tp
        by static type checkers. At runtime, NewType(name, tp) returns
        a dummy callable that simply returns its argument. Usage::
            UserId = NewType('UserId', int)
            def name_by_id(user_id: UserId) -> str:
                ...
            UserId('user')          # Fails type check
            name_by_id(42)          # Fails type check
            name_by_id(UserId(42))  # OK
            num = UserId(5) + 1     # type: int
        """

        def __call__(self, obj, /):
            return obj

        def __init__(self, name, tp):
            self.__qualname__ = name
            if '.' in name:
                name = name.rpartition('.')[-1]
            self.__name__ = name
            self.__supertype__ = tp
            def_mod = _caller()
            if def_mod != 'typing_extensions':
                self.__module__ = def_mod

        def __mro_entries__(self, bases):
            # We defined __mro_entries__ to get a better error message
            # if a user attempts to subclass a NewType instance. bpo-46170
            supercls_name = self.__name__

            class Dummy:
                def __init_subclass__(cls):
                    subcls_name = cls.__name__
                    raise TypeError(
                        f"Cannot subclass an instance of NewType. "
                        f"Perhaps you were looking for: "
                        f"`{subcls_name} = NewType({subcls_name!r}, {supercls_name})`"
                    )

            return (Dummy,)

        def __repr__(self):
            return f'{self.__module__}.{self.__qualname__}'

        def __reduce__(self):
            return self.__qualname__

        if sys.version_info >= (3, 10):
            # PEP 604 methods
            # It doesn't make sense to have these methods on Python <3.10

            def __or__(self, other):
                return typing.Union[self, other]

            def __ror__(self, other):
                return typing.Union[other, self]


if sys.version_info >= (3, 14):
    TypeAliasType = typing.TypeAliasType
# 3.8-3.13
else:
    if sys.version_info >= (3, 12):
        # 3.12-3.14
        def _is_unionable(obj):
            """Corresponds to is_unionable() in unionobject.c in CPython."""
            return obj is None or isinstance(obj, (
                type,
                _types.GenericAlias,
                _types.UnionType,
                typing.TypeAliasType,
                TypeAliasType,
            ))
    else:
        # 3.8-3.11
        def _is_unionable(obj):
            """Corresponds to is_unionable() in unionobject.c in CPython."""
            return obj is None or isinstance(obj, (
                type,
                _types.GenericAlias,
                _types.UnionType,
                TypeAliasType,
            ))

    if sys.version_info < (3, 10):
        # Copied and pasted from https://github.com/python/cpython/blob/986a4e1b6fcae7fe7a1d0a26aea446107dd58dd2/Objects/genericaliasobject.c#L568-L582,
        # so that we emulate the behaviour of `types.GenericAlias`
        # on the latest versions of CPython
        _ATTRIBUTE_DELEGATION_EXCLUSIONS = frozenset({
            "__class__",
            "__bases__",
            "__origin__",
            "__args__",
            "__unpacked__",
            "__parameters__",
            "__typing_unpacked_tuple_args__",
            "__mro_entries__",
            "__reduce_ex__",
            "__reduce__",
            "__copy__",
            "__deepcopy__",
        })

        class _TypeAliasGenericAlias(typing._GenericAlias, _root=True):
            def __getattr__(self, attr):
                if attr in _ATTRIBUTE_DELEGATION_EXCLUSIONS:
                    return object.__getattr__(self, attr)
                return getattr(self.__origin__, attr)

            if sys.version_info < (3, 9):
                def __getitem__(self, item):
                    result = super().__getitem__(item)
                    result.__class__ = type(self)
                    return result

    class TypeAliasType:
        """Create named, parameterized type aliases.

        This provides a backport of the new `type` statement in Python 3.12:

            type ListOrSet[T] = list[T] | set[T]

        is equivalent to:

            T = TypeVar("T")
            ListOrSet = TypeAliasType("ListOrSet", list[T] | set[T], type_params=(T,))

        The name ListOrSet can then be used as an alias for the type it refers to.

        The type_params argument should contain all the type parameters used
        in the value of the type alias. If the alias is not generic, this
        argument is omitted.

        Static type checkers should only support type aliases declared using
        TypeAliasType that follow these rules:

        - The first argument (the name) must be a string literal.
        - The TypeAliasType instance must be immediately assigned to a variable
          of the same name. (For example, 'X = TypeAliasType("Y", int)' is invalid,
          as is 'X, Y = TypeAliasType("X", int), TypeAliasType("Y", int)').

        """

        def __init__(self, name: str, value, *, type_params=()):
            if not isinstance(name, str):
                raise TypeError("TypeAliasType name must be a string")
            if not isinstance(type_params, tuple):
                raise TypeError("type_params must be a tuple")
            self.__value__ = value
            self.__type_params__ = type_params

            default_value_encountered = False
            parameters = []
            for type_param in type_params:
                if (
                    not isinstance(type_param, (TypeVar, TypeVarTuple, ParamSpec))
                    # 3.8-3.11
                    # Unpack Backport passes isinstance(type_param, TypeVar)
                    or _is_unpack(type_param)
                ):
                    raise TypeError(f"Expected a type param, got {type_param!r}")
                has_default = (
                    getattr(type_param, '__default__', NoDefault) is not NoDefault
                )
                if default_value_encountered and not has_default:
                    raise TypeError(f"non-default type parameter '{type_param!r}'"
                                    " follows default type parameter")
                if has_default:
                    default_value_encountered = True
                if isinstance(type_param, TypeVarTuple):
                    parameters.extend(type_param)
                else:
                    parameters.append(type_param)
            self.__parameters__ = tuple(parameters)
            def_mod = _caller()
            if def_mod != 'typing_extensions':
                self.__module__ = def_mod
            # Setting this attribute closes the TypeAliasType from further modification
            self.__name__ = name

        def __setattr__(self, name: str, value: object, /) -> None:
            if hasattr(self, "__name__"):
                self._raise_attribute_error(name)
            super().__setattr__(name, value)

        def __delattr__(self, name: str, /) -> Never:
            self._raise_attribute_error(name)

        def _raise_attribute_error(self, name: str) -> Never:
            # Match the Python 3.12 error messages exactly
            if name == "__name__":
                raise AttributeError("readonly attribute")
            elif name in {"__value__", "__type_params__", "__parameters__", "__module__"}:
                raise AttributeError(
                    f"attribute '{name}' of 'typing.TypeAliasType' objects "
                    "is not writable"
                )
            else:
                raise AttributeError(
                    f"'typing.TypeAliasType' object has no attribute '{name}'"
                )

        def __repr__(self) -> str:
            return self.__name__

        if sys.version_info < (3, 11):
            def _check_single_param(self, param, recursion=0):
                # Allow [], [int], [int, str], [int, ...], [int, T]
                if param is ...:
                    return ...
                if param is None:
                    return None
                # Note in <= 3.9 _ConcatenateGenericAlias inherits from list
                if isinstance(param, list) and recursion == 0:
                    return [self._check_single_param(arg, recursion+1)
                            for arg in param]
                return typing._type_check(
                        param, f'Subscripting {self.__name__} requires a type.'
                    )

        def _check_parameters(self, parameters):
            if sys.version_info < (3, 11):
                return tuple(
                    self._check_single_param(item)
                    for item in parameters
                )
            return tuple(typing._type_check(
                        item, f'Subscripting {self.__name__} requires a type.'
                    )
                    for item in parameters
            )

        def __getitem__(self, parameters):
            if not self.__type_params__:
                raise TypeError("Only generic type aliases are subscriptable")
            if not isinstance(parameters, tuple):
                parameters = (parameters,)
            # Using 3.9 here will create problems with Concatenate
            if sys.version_info >= (3, 10):
                return _types.GenericAlias(self, parameters)
            type_vars = _collect_type_vars(parameters)
            parameters = self._check_parameters(parameters)
            alias = _TypeAliasGenericAlias(self, parameters)
            # alias.__parameters__ is not complete if Concatenate is present
            # as it is converted to a list from which no parameters are extracted.
            if alias.__parameters__ != type_vars:
                alias.__parameters__ = type_vars
            return alias

        def __reduce__(self):
            return self.__name__

        def __init_subclass__(cls, *args, **kwargs):
            raise TypeError(
                "type 'typing_extensions.TypeAliasType' is not an acceptable base type"
            )

        # The presence of this method convinces typing._type_check
        # that TypeAliasTypes are types.
        def __call__(self):
            raise TypeError("Type alias is not callable")

        if sys.version_info >= (3, 10):
            def __or__(self, right):
                # For forward compatibility with 3.12, reject Unions
                # that are not accepted by the built-in Union.
                if not _is_unionable(right):
                    return NotImplemented
                return typing.Union[self, right]

            def __ror__(self, left):
                if not _is_unionable(left):
                    return NotImplemented
                return typing.Union[left, self]


if hasattr(typing, "is_protocol"):
    is_protocol = typing.is_protocol
    get_protocol_members = typing.get_protocol_members
else:
    def is_protocol(tp: type, /) -> bool:
        """Return True if the given type is a Protocol.

        Example::

            >>> from typing_extensions import Protocol, is_protocol
            >>> class P(Protocol):
            ...     def a(self) -> str: ...
            ...     b: int
            >>> is_protocol(P)
            True
            >>> is_protocol(int)
            False
        """
        return (
            isinstance(tp, type)
            and getattr(tp, '_is_protocol', False)
            and tp is not Protocol
            and tp is not typing.Protocol
        )

    def get_protocol_members(tp: type, /) -> typing.FrozenSet[str]:
        """Return the set of members defined in a Protocol.

        Example::

            >>> from typing_extensions import Protocol, get_protocol_members
            >>> class P(Protocol):
            ...     def a(self) -> str: ...
            ...     b: int
            >>> get_protocol_members(P)
            frozenset({'a', 'b'})

        Raise a TypeError for arguments that are not Protocols.
        """
        if not is_protocol(tp):
            raise TypeError(f'{tp!r} is not a Protocol')
        if hasattr(tp, '__protocol_attrs__'):
            return frozenset(tp.__protocol_attrs__)
        return frozenset(_get_protocol_attrs(tp))


if hasattr(typing, "Doc"):
    Doc = typing.Doc
else:
    class Doc:
        """Define the documentation of a type annotation using ``Annotated``, to be
         used in class attributes, function and method parameters, return values,
         and variables.

        The value should be a positional-only string literal to allow static tools
        like editors and documentation generators to use it.

        This complements docstrings.

        The string value passed is available in the attribute ``documentation``.

        Example::

            >>> from typing_extensions import Annotated, Doc
            >>> def hi(to: Annotated[str, Doc("Who to say hi to")]) -> None: ...
        """
        def __init__(self, documentation: str, /) -> None:
            self.documentation = documentation

        def __repr__(self) -> str:
            return f"Doc({self.documentation!r})"

        def __hash__(self) -> int:
            return hash(self.documentation)

        def __eq__(self, other: object) -> bool:
            if not isinstance(other, Doc):
                return NotImplemented
            return self.documentation == other.documentation


_CapsuleType = getattr(_types, "CapsuleType", None)

if _CapsuleType is None:
    try:
        import _socket
    except ImportError:
        pass
    else:
        _CAPI = getattr(_socket, "CAPI", None)
        if _CAPI is not None:
            _CapsuleType = type(_CAPI)

if _CapsuleType is not None:
    CapsuleType = _CapsuleType
    __all__.append("CapsuleType")


# Using this convoluted approach so that this keeps working
# whether we end up using PEP 649 as written, PEP 749, or
# some other variation: in any case, inspect.get_annotations
# will continue to exist and will gain a `format` parameter.
_PEP_649_OR_749_IMPLEMENTED = (
    hasattr(inspect, 'get_annotations')
    and inspect.get_annotations.__kwdefaults__ is not None
    and "format" in inspect.get_annotations.__kwdefaults__
)


class Format(enum.IntEnum):
    VALUE = 1
    FORWARDREF = 2
    STRING = 3


if _PEP_649_OR_749_IMPLEMENTED:
    get_annotations = inspect.get_annotations
else:
    def get_annotations(obj, *, globals=None, locals=None, eval_str=False,
                        format=Format.VALUE):
        """Compute the annotations dict for an object.

        obj may be a callable, class, or module.
        Passing in an object of any other type raises TypeError.

        Returns a dict.  get_annotations() returns a new dict every time
        it's called; calling it twice on the same object will return two
        different but equivalent dicts.

        This is a backport of `inspect.get_annotations`, which has been
        in the standard library since Python 3.10. See the standard library
        documentation for more:

            https://docs.python.org/3/library/inspect.html#inspect.get_annotations

        This backport adds the *format* argument introduced by PEP 649. The
        three formats supported are:
        * VALUE: the annotations are returned as-is. This is the default and
          it is compatible with the behavior on previous Python versions.
        * FORWARDREF: return annotations as-is if possible, but replace any
          undefined names with ForwardRef objects. The implementation proposed by
          PEP 649 relies on language changes that cannot be backported; the
          typing-extensions implementation simply returns the same result as VALUE.
        * STRING: return annotations as strings, in a format close to the original
          source. Again, this behavior cannot be replicated directly in a backport.
          As an approximation, typing-extensions retrieves the annotations under
          VALUE semantics and then stringifies them.

        The purpose of this backport is to allow users who would like to use
        FORWARDREF or STRING semantics once PEP 649 is implemented, but who also
        want to support earlier Python versions, to simply write:

            typing_extensions.get_annotations(obj, format=Format.FORWARDREF)

        """
        format = Format(format)

        if eval_str and format is not Format.VALUE:
            raise ValueError("eval_str=True is only supported with format=Format.VALUE")

        if isinstance(obj, type):
            # class
            obj_dict = getattr(obj, '__dict__', None)
            if obj_dict and hasattr(obj_dict, 'get'):
                ann = obj_dict.get('__annotations__', None)
                if isinstance(ann, _types.GetSetDescriptorType):
                    ann = None
            else:
                ann = None

            obj_globals = None
            module_name = getattr(obj, '__module__', None)
            if module_name:
                module = sys.modules.get(module_name, None)
                if module:
                    obj_globals = getattr(module, '__dict__', None)
            obj_locals = dict(vars(obj))
            unwrap = obj
        elif isinstance(obj, _types.ModuleType):
            # module
            ann = getattr(obj, '__annotations__', None)
            obj_globals = obj.__dict__
            obj_locals = None
            unwrap = None
        elif callable(obj):
            # this includes types.Function, types.BuiltinFunctionType,
            # types.BuiltinMethodType, functools.partial, functools.singledispatch,
            # "class funclike" from Lib/test/test_inspect... on and on it goes.
            ann = getattr(obj, '__annotations__', None)
            obj_globals = getattr(obj, '__globals__', None)
            obj_locals = None
            unwrap = obj
        elif hasattr(obj, '__annotations__'):
            ann = obj.__annotations__
            obj_globals = obj_locals = unwrap = None
        else:
            raise TypeError(f"{obj!r} is not a module, class, or callable.")

        if ann is None:
            return {}

        if not isinstance(ann, dict):
            raise ValueError(f"{obj!r}.__annotations__ is neither a dict nor None")

        if not ann:
            return {}

        if not eval_str:
            if format is Format.STRING:
                return {
                    key: value if isinstance(value, str) else typing._type_repr(value)
                    for key, value in ann.items()
                }
            return dict(ann)

        if unwrap is not None:
            while True:
                if hasattr(unwrap, '__wrapped__'):
                    unwrap = unwrap.__wrapped__
                    continue
                if isinstance(unwrap, functools.partial):
                    unwrap = unwrap.func
                    continue
                break
            if hasattr(unwrap, "__globals__"):
                obj_globals = unwrap.__globals__

        if globals is None:
            globals = obj_globals
        if locals is None:
            locals = obj_locals or {}

        # "Inject" type parameters into the local namespace
        # (unless they are shadowed by assignments *in* the local namespace),
        # as a way of emulating annotation scopes when calling `eval()`
        if type_params := getattr(obj, "__type_params__", ()):
            locals = {param.__name__: param for param in type_params} | locals

        return_value = {key:
            value if not isinstance(value, str) else eval(value, globals, locals)
            for key, value in ann.items() }
        return return_value


if hasattr(typing, "evaluate_forward_ref"):
    evaluate_forward_ref = typing.evaluate_forward_ref
else:
    # Implements annotationlib.ForwardRef.evaluate
    def _eval_with_owner(
        forward_ref, *, owner=None, globals=None, locals=None, type_params=None
    ):
        if forward_ref.__forward_evaluated__:
            return forward_ref.__forward_value__
        if getattr(forward_ref, "__cell__", None) is not None:
            try:
                value = forward_ref.__cell__.cell_contents
            except ValueError:
                pass
            else:
                forward_ref.__forward_evaluated__ = True
                forward_ref.__forward_value__ = value
                return value
        if owner is None:
            owner = getattr(forward_ref, "__owner__", None)

        if (
            globals is None
            and getattr(forward_ref, "__forward_module__", None) is not None
        ):
            globals = getattr(
                sys.modules.get(forward_ref.__forward_module__, None), "__dict__", None
            )
        if globals is None:
            globals = getattr(forward_ref, "__globals__", None)
        if globals is None:
            if isinstance(owner, type):
                module_name = getattr(owner, "__module__", None)
                if module_name:
                    module = sys.modules.get(module_name, None)
                    if module:
                        globals = getattr(module, "__dict__", None)
            elif isinstance(owner, _types.ModuleType):
                globals = getattr(owner, "__dict__", None)
            elif callable(owner):
                globals = getattr(owner, "__globals__", None)

        # If we pass None to eval() below, the globals of this module are used.
        if globals is None:
            globals = {}

        if locals is None:
            locals = {}
            if isinstance(owner, type):
                locals.update(vars(owner))

        if type_params is None and owner is not None:
            # "Inject" type parameters into the local namespace
            # (unless they are shadowed by assignments *in* the local namespace),
            # as a way of emulating annotation scopes when calling `eval()`
            type_params = getattr(owner, "__type_params__", None)

        # type parameters require some special handling,
        # as they exist in their own scope
        # but `eval()` does not have a dedicated parameter for that scope.
        # For classes, names in type parameter scopes should override
        # names in the global scope (which here are called `localns`!),
        # but should in turn be overridden by names in the class scope
        # (which here are called `globalns`!)
        if type_params is not None:
            globals = dict(globals)
            locals = dict(locals)
            for param in type_params:
                param_name = param.__name__
                if (
                    _FORWARD_REF_HAS_CLASS and not forward_ref.__forward_is_class__
                ) or param_name not in globals:
                    globals[param_name] = param
                    locals.pop(param_name, None)

        arg = forward_ref.__forward_arg__
        if arg.isidentifier() and not keyword.iskeyword(arg):
            if arg in locals:
                value = locals[arg]
            elif arg in globals:
                value = globals[arg]
            elif hasattr(builtins, arg):
                return getattr(builtins, arg)
            else:
                raise NameError(arg)
        else:
            code = forward_ref.__forward_code__
            value = eval(code, globals, locals)
        forward_ref.__forward_evaluated__ = True
        forward_ref.__forward_value__ = value
        return value

    def _lax_type_check(
        value, msg, is_argument=True, *, module=None, allow_special_forms=False
    ):
        """
        A lax Python 3.11+ like version of typing._type_check
        """
        if hasattr(typing, "_type_convert"):
            if (
                sys.version_info >= (3, 10, 3)
                or (3, 9, 10) < sys.version_info[:3] < (3, 10)
            ):
                # allow_special_forms introduced later cpython/#30926 (bpo-46539)
                type_ = typing._type_convert(
                    value,
                    module=module,
                    allow_special_forms=allow_special_forms,
                )
            # module was added with bpo-41249 before is_class (bpo-46539)
            elif "__forward_module__" in typing.ForwardRef.__slots__:
                type_ = typing._type_convert(value, module=module)
            else:
                type_ = typing._type_convert(value)
        else:
            if value is None:
                return type(None)
            if isinstance(value, str):
                return ForwardRef(value)
            type_ = value
        invalid_generic_forms = (Generic, Protocol)
        if not allow_special_forms:
            invalid_generic_forms += (ClassVar,)
            if is_argument:
                invalid_generic_forms += (Final,)
        if (
            isinstance(type_, typing._GenericAlias)
            and get_origin(type_) in invalid_generic_forms
        ):
            raise TypeError(f"{type_} is not valid as type argument") from None
        if type_ in (Any, LiteralString, NoReturn, Never, Self, TypeAlias):
            return type_
        if allow_special_forms and type_ in (ClassVar, Final):
            return type_
        if (
            isinstance(type_, (_SpecialForm, typing._SpecialForm))
            or type_ in (Generic, Protocol)
        ):
            raise TypeError(f"Plain {type_} is not valid as type argument") from None
        if type(type_) is tuple:  # lax version with tuple instead of callable
            raise TypeError(f"{msg} Got {type_!r:.100}.")
        return type_

    def evaluate_forward_ref(
        forward_ref,
        *,
        owner=None,
        globals=None,
        locals=None,
        type_params=None,
        format=Format.VALUE,
        _recursive_guard=frozenset(),
    ):
        """Evaluate a forward reference as a type hint.

        This is similar to calling the ForwardRef.evaluate() method,
        but unlike that method, evaluate_forward_ref() also:

        * Recursively evaluates forward references nested within the type hint.
        * Rejects certain objects that are not valid type hints.
        * Replaces type hints that evaluate to None with types.NoneType.
        * Supports the *FORWARDREF* and *STRING* formats.

        *forward_ref* must be an instance of ForwardRef. *owner*, if given,
        should be the object that holds the annotations that the forward reference
        derived from, such as a module, class object, or function. It is used to
        infer the namespaces to use for looking up names. *globals* and *locals*
        can also be explicitly given to provide the global and local namespaces.
        *type_params* is a tuple of type parameters that are in scope when
        evaluating the forward reference. This parameter must be provided (though
        it may be an empty tuple) if *owner* is not given and the forward reference
        does not already have an owner set. *format* specifies the format of the
        annotation and is a member of the annotationlib.Format enum.

        """
        if format == Format.STRING:
            return forward_ref.__forward_arg__
        if forward_ref.__forward_arg__ in _recursive_guard:
            return forward_ref

        # Evaluate the forward reference
        try:
            value = _eval_with_owner(
                forward_ref,
                owner=owner,
                globals=globals,
                locals=locals,
                type_params=type_params,
            )
        except NameError:
            if format == Format.FORWARDREF:
                return forward_ref
            else:
                raise

        msg = "Forward references must evaluate to types."
        if not _FORWARD_REF_HAS_CLASS:
            allow_special_forms = not forward_ref.__forward_is_argument__
        else:
            allow_special_forms = forward_ref.__forward_is_class__
        type_ = _lax_type_check(
            value,
            msg,
            is_argument=forward_ref.__forward_is_argument__,
            allow_special_forms=allow_special_forms,
        )

        # Recursively evaluate the type
        if isinstance(type_, ForwardRef):
            if getattr(type_, "__forward_module__", True) is not None:
                globals = None
            return evaluate_forward_ref(
                type_,
                globals=globals,
                locals=locals,
                 type_params=type_params, owner=owner,
                _recursive_guard=_recursive_guard, format=format
            )
        if sys.version_info < (3, 12, 5) and type_params:
            # Make use of type_params
            locals = dict(locals) if locals else {}
            for tvar in type_params:
                if tvar.__name__ not in locals:  # lets not overwrite something present
                    locals[tvar.__name__] = tvar
        if sys.version_info < (3, 9):
            return typing._eval_type(
                type_,
                globals,
                locals,
            )
        if sys.version_info < (3, 12, 5):
            return typing._eval_type(
                type_,
                globals,
                locals,
                recursive_guard=_recursive_guard | {forward_ref.__forward_arg__},
            )
        if sys.version_info < (3, 14):
            return typing._eval_type(
                type_,
                globals,
                locals,
                type_params,
                recursive_guard=_recursive_guard | {forward_ref.__forward_arg__},
            )
        return typing._eval_type(
            type_,
            globals,
            locals,
            type_params,
            recursive_guard=_recursive_guard | {forward_ref.__forward_arg__},
            format=format,
            owner=owner,
        )


# Aliases for items that have always been in typing.
# Explicitly assign these (rather than using `from typing import *` at the top),
# so that we get a CI error if one of these is deleted from typing.py
# in a future version of Python
AbstractSet = typing.AbstractSet
AnyStr = typing.AnyStr
BinaryIO = typing.BinaryIO
Callable = typing.Callable
Collection = typing.Collection
Container = typing.Container
Dict = typing.Dict
ForwardRef = typing.ForwardRef
FrozenSet = typing.FrozenSet
Generic = typing.Generic
Hashable = typing.Hashable
IO = typing.IO
ItemsView = typing.ItemsView
Iterable = typing.Iterable
Iterator = typing.Iterator
KeysView = typing.KeysView
List = typing.List
Mapping = typing.Mapping
MappingView = typing.MappingView
Match = typing.Match
MutableMapping = typing.MutableMapping
MutableSequence = typing.MutableSequence
MutableSet = typing.MutableSet
Optional = typing.Optional
Pattern = typing.Pattern
Reversible = typing.Reversible
Sequence = typing.Sequence
Set = typing.Set
Sized = typing.Sized
TextIO = typing.TextIO
Tuple = typing.Tuple
Union = typing.Union
ValuesView = typing.ValuesView
cast = typing.cast
no_type_check = typing.no_type_check
no_type_check_decorator = typing.no_type_check_decorator


# ================================================================================
# Datei: venv\Lib\site-packages\typing_inspection\__init__.py
# ================================================================================



# ================================================================================
# Datei: venv\Lib\site-packages\typing_inspection\introspection.py
# ================================================================================

"""High-level introspection utilities, used to inspect type annotations."""

from __future__ import annotations

import sys
import types
from collections.abc import Generator, Sequence
from dataclasses import InitVar
from enum import Enum, IntEnum, auto
from typing import Any, Literal, NamedTuple, cast

from typing_extensions import TypeAlias, assert_never, get_args, get_origin

from . import typing_objects

__all__ = (
    'AnnotationSource',
    'ForbiddenQualifier',
    'InspectedAnnotation',
    'Qualifier',
    'get_literal_values',
    'inspect_annotation',
    'is_union_origin',
)

if sys.version_info >= (3, 10):

    def is_union_origin(obj: Any, /) -> bool:
        """Return whether the provided origin is the union form.

        ```pycon
        >>> is_union_origin(typing.Union)
        True
        >>> is_union_origin(get_origin(int | str))
        True
        ```
        """
        return typing_objects.is_union(obj) or obj is types.UnionType

else:

    def is_union_origin(obj: Any, /) -> bool:
        """Return whether the provided origin is the union form.

        ```pycon
        >>> is_union_origin(typing.Union)
        True
        >>> is_union_origin(get_origin(int | str))
        True
        ```
        """
        return typing_objects.is_union(obj)


def _literal_type_check(value: Any, /) -> None:
    """Type check the provided literal value against the legal parameters."""
    if (
        not isinstance(value, (int, bytes, str, bool, Enum, typing_objects.NoneType))
        and value is not typing_objects.NoneType
    ):
        raise TypeError(f'{value} is not a valid literal value, must be one of: int, bytes, str, Enum, None.')


def get_literal_values(
    annotation: Any,
    /,
    *,
    type_check: bool = False,
    unpack_type_aliases: Literal['skip', 'lenient', 'eager'] = 'eager',
) -> Generator[Any]:
    """Yield the values contained in the provided [`Literal`][typing.Literal] [special form][].

    Args:
        annotation: The [`Literal`][typing.Literal] [special form][] to unpack.
        type_check: Whether to check if the literal values are [legal parameters][literal-legal-parameters].
            Raises a [`TypeError`][] otherwise.
        unpack_type_aliases: What to do when encountering [PEP 695](https://peps.python.org/pep-0695/)
            [type aliases][type-aliases]. Can be one of:

            - `'skip'`: Do not try to parse type aliases. Note that this can lead to incorrect results:
              ```pycon
              >>> type MyAlias = Literal[1, 2]
              >>> list(get_literal_values(Literal[MyAlias, 3], unpack_type_aliases="skip"))
              [MyAlias, 3]
              ```

            - `'lenient'`: Try to parse type aliases, and fallback to `'skip'` if the type alias can't be inspected
              (because of an undefined forward reference).

            - `'eager'`: Parse type aliases and raise any encountered [`NameError`][] exceptions (the default):
              ```pycon
              >>> type MyAlias = Literal[1, 2]
              >>> list(get_literal_values(Literal[MyAlias, 3], unpack_type_aliases="eager"))
              [1, 2, 3]
              ```

    Note:
        While `None` is [equivalent to][none] `type(None)`, the runtime implementation of [`Literal`][typing.Literal]
        does not de-duplicate them. This function makes sure this de-duplication is applied:

        ```pycon
        >>> list(get_literal_values(Literal[NoneType, None]))
        [None]
        ```

    Example:
        ```pycon
        >>> type Ints = Literal[1, 2]
        >>> list(get_literal_values(Literal[1, Ints], unpack_type_alias="skip"))
        ["a", Ints]
        >>> list(get_literal_values(Literal[1, Ints]))
        [1, 2]
        >>> list(get_literal_values(Literal[1.0], type_check=True))
        Traceback (most recent call last):
        ...
        TypeError: 1.0 is not a valid literal value, must be one of: int, bytes, str, Enum, None.
        ```
    """
    # `literal` is guaranteed to be a `Literal[...]` special form, so use
    # `__args__` directly instead of calling `get_args()`.

    if unpack_type_aliases == 'skip':
        _has_none = False
        # `Literal` parameters are already deduplicated, no need to do it ourselves.
        # (we only check for `None` and `NoneType`, which should be considered as duplicates).
        for arg in annotation.__args__:
            if type_check:
                _literal_type_check(arg)
            if arg is None or arg is typing_objects.NoneType:
                if not _has_none:
                    yield None
                _has_none = True
            else:
                yield arg
    else:
        # We'll need to manually deduplicate parameters, see the `Literal` implementation in `typing`.
        values_and_type: list[tuple[Any, type[Any]]] = []

        for arg in annotation.__args__:
            # Note: we could also check for generic aliases with a type alias as an origin.
            # However, it is very unlikely that this happens as type variables can't appear in
            # `Literal` forms, so the only valid (but unnecessary) use case would be something like:
            # `type Test[T] = Literal['a']` (and then use `Test[SomeType]`).
            if typing_objects.is_typealiastype(arg):
                try:
                    alias_value = arg.__value__
                except NameError:
                    if unpack_type_aliases == 'eager':
                        raise
                    # unpack_type_aliases == "lenient":
                    if type_check:
                        _literal_type_check(arg)
                    values_and_type.append((arg, type(arg)))
                else:
                    sub_args = get_literal_values(
                        alias_value, type_check=type_check, unpack_type_aliases=unpack_type_aliases
                    )
                    values_and_type.extend((a, type(a)) for a in sub_args)  # pyright: ignore[reportUnknownArgumentType]
            else:
                if type_check:
                    _literal_type_check(arg)
                if arg is typing_objects.NoneType:
                    values_and_type.append((None, typing_objects.NoneType))
                else:
                    values_and_type.append((arg, type(arg)))  # pyright: ignore[reportUnknownArgumentType]

        try:
            dct = dict.fromkeys(values_and_type)
        except TypeError:
            # Unhashable parameters, the Python implementation allows them
            yield from (p for p, _ in values_and_type)
        else:
            yield from (p for p, _ in dct)


Qualifier: TypeAlias = Literal['required', 'not_required', 'read_only', 'class_var', 'init_var', 'final']
"""A [type qualifier][]."""

_all_qualifiers: set[Qualifier] = set(get_args(Qualifier))


# TODO at some point, we could switch to an enum flag, so that multiple sources
# can be combined. However, is there a need for this?
class AnnotationSource(IntEnum):
    # TODO if/when https://peps.python.org/pep-0767/ is accepted, add 'read_only'
    # to CLASS and NAMED_TUPLE (even though for named tuples it is redundant).

    """The source of an annotation, e.g. a class or a function.

    Depending on the source, different [type qualifiers][type qualifier] may be (dis)allowed.
    """

    ASSIGNMENT_OR_VARIABLE = auto()
    """An annotation used in an assignment or variable annotation:

    ```python
    x: Final[int] = 1
    y: Final[str]
    ```

    **Allowed type qualifiers:** [`Final`][typing.Final].
    """

    CLASS = auto()
    """An annotation used in the body of a class:

    ```python
    class Test:
        x: Final[int] = 1
        y: ClassVar[str]
    ```

    **Allowed type qualifiers:** [`ClassVar`][typing.ClassVar], [`Final`][typing.Final].
    """

    DATACLASS = auto()
    """An annotation used in the body of a dataclass:

    ```python
    @dataclass
    class Test:
        x: Final[int] = 1
        y: InitVar[str] = 'test'
    ```

    **Allowed type qualifiers:** [`ClassVar`][typing.ClassVar], [`Final`][typing.Final], [`InitVar`][dataclasses-init-only-variables].
    """  # noqa: E501

    TYPED_DICT = auto()
    """An annotation used in the body of a [`TypedDict`][typing.TypedDict]:

    ```python
    class TD(TypedDict):
        x: Required[ReadOnly[int]]
        y: ReadOnly[NotRequired[str]]
    ```

    **Allowed type qualifiers:** [`ReadOnly`][typing.ReadOnly], [`Required`][typing.Required],
    [`NotRequired`][typing.NotRequired].
    """

    NAMED_TUPLE = auto()
    """An annotation used in the body of a [`NamedTuple`][typing.NamedTuple].

    ```python
    class NT(NamedTuple):
        x: int
        y: str
    ```

    **Allowed type qualifiers:** none.
    """

    FUNCTION = auto()
    """An annotation used in a function, either for a parameter or the return value.

    ```python
    def func(a: int) -> str:
        ...
    ```

    **Allowed type qualifiers:** none.
    """

    ANY = auto()
    """An annotation that might come from any source.

    **Allowed type qualifiers:** all.
    """

    BARE = auto()
    """An annotation that is inspected as is.

    **Allowed type qualifiers:** none.
    """

    @property
    def allowed_qualifiers(self) -> set[Qualifier]:
        """The allowed [type qualifiers][type qualifier] for this annotation source."""
        # TODO use a match statement when Python 3.9 support is dropped.
        if self is AnnotationSource.ASSIGNMENT_OR_VARIABLE:
            return {'final'}
        elif self is AnnotationSource.CLASS:
            return {'final', 'class_var'}
        elif self is AnnotationSource.DATACLASS:
            return {'final', 'class_var', 'init_var'}
        elif self is AnnotationSource.TYPED_DICT:
            return {'required', 'not_required', 'read_only'}
        elif self in (AnnotationSource.NAMED_TUPLE, AnnotationSource.FUNCTION, AnnotationSource.BARE):
            return set()
        elif self is AnnotationSource.ANY:
            return _all_qualifiers
        else:  # pragma: no cover
            assert_never(self)


class ForbiddenQualifier(Exception):
    """The provided [type qualifier][] is forbidden."""

    qualifier: Qualifier
    """The forbidden qualifier."""

    def __init__(self, qualifier: Qualifier, /) -> None:
        self.qualifier = qualifier


class _UnknownTypeEnum(Enum):
    UNKNOWN = auto()

    def __str__(self) -> str:
        return 'UNKNOWN'

    def __repr__(self) -> str:
        return '<UNKNOWN>'


UNKNOWN = _UnknownTypeEnum.UNKNOWN
"""A sentinel value used when no [type expression][] is present."""

_UnkownType: TypeAlias = Literal[_UnknownTypeEnum.UNKNOWN]
"""The type of the [`UNKNOWN`][typing_inspection.introspection.UNKNOWN] sentinel value."""


class InspectedAnnotation(NamedTuple):
    """The result of the inspected annotation."""

    type: Any | _UnkownType
    """The final [type expression][], with [type qualifiers][type qualifier] and annotated metadata stripped.

    If no type expression is available, the [`UNKNOWN`][typing_inspection.introspection.UNKNOWN] sentinel
    value is used instead. This is the case when a [type qualifier][] is used with no type annotation:

    ```python
    ID: Final = 1

    class C:
        x: ClassVar = 'test'
    ```
    """

    qualifiers: set[Qualifier]
    """The [type qualifiers][type qualifier] present on the annotation."""

    metadata: Sequence[Any]
    """The annotated metadata."""


def inspect_annotation(  # noqa: PLR0915
    annotation: Any,
    /,
    *,
    annotation_source: AnnotationSource,
    unpack_type_aliases: Literal['skip', 'lenient', 'eager'] = 'skip',
) -> InspectedAnnotation:
    """Inspect an [annotation expression][], extracting any [type qualifier][] and metadata.

    An [annotation expression][] is a [type expression][] optionally surrounded by one or more
    [type qualifiers][type qualifier] or by [`Annotated`][typing.Annotated]. This function will:

    - Unwrap the type expression, keeping track of the type qualifiers.
    - Unwrap [`Annotated`][typing.Annotated] forms, keeping track of the annotated metadata.

    Args:
        annotation: The annotation expression to be inspected.
        annotation_source: The source of the annotation. Depending on the source (e.g. a class), different type
            qualifiers may be (dis)allowed. To allow any type qualifier, use
            [`AnnotationSource.ANY`][typing_inspection.introspection.AnnotationSource.ANY].
        unpack_type_aliases: What to do when encountering [PEP 695](https://peps.python.org/pep-0695/)
            [type aliases][type-aliases]. Can be one of:

            - `'skip'`: Do not try to parse type aliases (the default):
              ```pycon
              >>> type MyInt = Annotated[int, 'meta']
              >>> inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases='skip')
              InspectedAnnotation(type=MyInt, qualifiers={}, metadata=[])
              ```

            - `'lenient'`: Try to parse type aliases, and fallback to `'skip'` if the type alias
              can't be inspected (because of an undefined forward reference):
              ```pycon
              >>> type MyInt = Annotated[Undefined, 'meta']
              >>> inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases='lenient')
              InspectedAnnotation(type=MyInt, qualifiers={}, metadata=[])
              >>> Undefined = int
              >>> inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases='lenient')
              InspectedAnnotation(type=int, qualifiers={}, metadata=['meta'])
              ```

            - `'eager'`: Parse type aliases and raise any encountered [`NameError`][] exceptions.

    Returns:
        The result of the inspected annotation, where the type expression, used qualifiers and metadata is stored.

    Example:
        ```pycon
        >>> inspect_annotation(
        ...     Final[Annotated[ClassVar[Annotated[int, 'meta_1']], 'meta_2']],
        ...     annotation_source=AnnotationSource.CLASS,
        ... )
        ...
        InspectedAnnotation(type=int, qualifiers={'class_var', 'final'}, metadata=['meta_1', 'meta_2'])
        ```
    """
    allowed_qualifiers = annotation_source.allowed_qualifiers
    qualifiers: set[Qualifier] = set()
    metadata: list[Any] = []

    while True:
        annotation, _meta = _unpack_annotated(annotation, unpack_type_aliases=unpack_type_aliases)
        if _meta:
            metadata = _meta + metadata
            continue

        origin = get_origin(annotation)
        if origin is not None:
            if typing_objects.is_classvar(origin):
                if 'class_var' not in allowed_qualifiers:
                    raise ForbiddenQualifier('class_var')
                qualifiers.add('class_var')
                annotation = annotation.__args__[0]
            elif typing_objects.is_final(origin):
                if 'final' not in allowed_qualifiers:
                    raise ForbiddenQualifier('final')
                qualifiers.add('final')
                annotation = annotation.__args__[0]
            elif typing_objects.is_required(origin):
                if 'required' not in allowed_qualifiers:
                    raise ForbiddenQualifier('required')
                qualifiers.add('required')
                annotation = annotation.__args__[0]
            elif typing_objects.is_notrequired(origin):
                if 'not_required' not in allowed_qualifiers:
                    raise ForbiddenQualifier('not_required')
                qualifiers.add('not_required')
                annotation = annotation.__args__[0]
            elif typing_objects.is_readonly(origin):
                if 'read_only' not in allowed_qualifiers:
                    raise ForbiddenQualifier('not_required')
                qualifiers.add('read_only')
                annotation = annotation.__args__[0]
            else:
                # origin is not None but not a type qualifier nor `Annotated` (e.g. `list[int]`):
                break
        elif isinstance(annotation, InitVar):
            if 'init_var' not in allowed_qualifiers:
                raise ForbiddenQualifier('init_var')
            qualifiers.add('init_var')
            annotation = cast(Any, annotation.type)
        else:
            break

    # `Final`, `ClassVar` and `InitVar` are type qualifiers allowed to be used as a bare annotation:
    if typing_objects.is_final(annotation):
        if 'final' not in allowed_qualifiers:
            raise ForbiddenQualifier('final')
        qualifiers.add('final')
        annotation = UNKNOWN
    elif typing_objects.is_classvar(annotation):
        if 'class_var' not in allowed_qualifiers:
            raise ForbiddenQualifier('class_var')
        qualifiers.add('class_var')
        annotation = UNKNOWN
    elif annotation is InitVar:
        if 'init_var' not in allowed_qualifiers:
            raise ForbiddenQualifier('init_var')
        qualifiers.add('init_var')
        annotation = UNKNOWN

    return InspectedAnnotation(annotation, qualifiers, metadata)


def _unpack_annotated_inner(
    annotation: Any, unpack_type_aliases: Literal['lenient', 'eager'], check_annotated: bool
) -> tuple[Any, list[Any]]:
    origin = get_origin(annotation)
    if check_annotated and typing_objects.is_annotated(origin):
        annotated_type = annotation.__origin__
        metadata = list(annotation.__metadata__)

        # The annotated type might be a PEP 695 type alias, so we need to recursively
        # unpack it. Because Python already flattens `Annotated[Annotated[<type>, ...], ...]` forms,
        # we can skip the `is_annotated()` check in the next call:
        annotated_type, sub_meta = _unpack_annotated_inner(
            annotated_type, unpack_type_aliases=unpack_type_aliases, check_annotated=False
        )
        metadata = sub_meta + metadata
        return annotated_type, metadata
    elif typing_objects.is_typealiastype(annotation):
        try:
            value = annotation.__value__
        except NameError:
            if unpack_type_aliases == 'eager':
                raise
        else:
            typ, metadata = _unpack_annotated_inner(
                value, unpack_type_aliases=unpack_type_aliases, check_annotated=True
            )
            if metadata:
                # Having metadata means the type alias' `__value__` was an `Annotated` form
                # (or, recursively, a type alias to an `Annotated` form). It is important to check
                # for this, as we don't want to unpack other type aliases (e.g. `type MyInt = int`).
                return typ, metadata
            return annotation, []
    elif typing_objects.is_typealiastype(origin):
        # When parameterized, PEP 695 type aliases become generic aliases
        # (e.g. with `type MyList[T] = Annotated[list[T], ...]`, `MyList[int]`
        # is a generic alias).
        try:
            value = origin.__value__
        except NameError:
            if unpack_type_aliases == 'eager':
                raise
        else:
            # While Python already handles type variable replacement for simple `Annotated` forms,
            # we need to manually apply the same logic for PEP 695 type aliases:
            # - With `MyList = Annotated[list[T], ...]`, `MyList[int] == Annotated[list[int], ...]`
            # - With `type MyList[T] = Annotated[list[T], ...]`, `MyList[int].__value__ == Annotated[list[T], ...]`.

            try:
                # To do so, we emulate the parameterization of the value with the arguments:
                # with `type MyList[T] = Annotated[list[T], ...]`, to emulate `MyList[int]`,
                # we do `Annotated[list[T], ...][int]` (which gives `Annotated[list[T], ...]`):
                value = value[annotation.__args__]
            except TypeError:
                # Might happen if the type alias is parameterized, but its value doesn't have any
                # type variables, e.g. `type MyInt[T] = int`.
                pass
            typ, metadata = _unpack_annotated_inner(
                value, unpack_type_aliases=unpack_type_aliases, check_annotated=True
            )
            if metadata:
                return typ, metadata
            return annotation, []

    return annotation, []


# This could eventually be made public:
def _unpack_annotated(
    annotation: Any, /, *, unpack_type_aliases: Literal['skip', 'lenient', 'eager'] = 'eager'
) -> tuple[Any, list[Any]]:
    if unpack_type_aliases == 'skip':
        if typing_objects.is_annotated(get_origin(annotation)):
            return annotation.__origin__, list(annotation.__metadata__)
        else:
            return annotation, []

    return _unpack_annotated_inner(annotation, unpack_type_aliases=unpack_type_aliases, check_annotated=True)


# ================================================================================
# Datei: venv\Lib\site-packages\typing_inspection\typing_objects.py
# ================================================================================

"""Low-level introspection utilities for [`typing`][] members.

The provided functions in this module check against both the [`typing`][] and [`typing_extensions`][]
variants, if they exists and are different.
"""
# ruff: noqa: UP006

import collections.abc
import contextlib
import re
import sys
import typing
import warnings
from textwrap import dedent
from types import FunctionType, GenericAlias
from typing import Any, Final

import typing_extensions
from typing_extensions import LiteralString, TypeAliasType, TypeIs, deprecated

__all__ = (
    'DEPRECATED_ALIASES',
    'NoneType',
    'is_annotated',
    'is_any',
    'is_classvar',
    'is_concatenate',
    'is_deprecated',
    'is_final',
    'is_generic',
    'is_literal',
    'is_literalstring',
    'is_namedtuple',
    'is_never',
    'is_newtype',
    'is_nodefault',
    'is_noreturn',
    'is_notrequired',
    'is_paramspec',
    'is_paramspecargs',
    'is_paramspeckwargs',
    'is_readonly',
    'is_required',
    'is_self',
    'is_typealias',
    'is_typealiastype',
    'is_typeguard',
    'is_typeis',
    'is_typevar',
    'is_typevartuple',
    'is_union',
    'is_unpack',
)

_IS_PY310 = sys.version_info[:2] == (3, 10)


def _compile_identity_check_function(member: LiteralString, function_name: LiteralString) -> FunctionType:
    """Create a function checking that the function argument is the (unparameterized) typing :paramref:`member`.

    The function will make sure to check against both the `typing` and `typing_extensions`
    variants as depending on the Python version, the `typing_extensions` variant might be different.
    For instance, on Python 3.9:

    ```pycon
    >>> from typing import Literal as t_Literal
    >>> from typing_extensions import Literal as te_Literal, get_origin

    >>> t_Literal is te_Literal
    False
    >>> get_origin(t_Literal[1])
    typing.Literal
    >>> get_origin(te_Literal[1])
    typing_extensions.Literal
    ```
    """
    in_typing = hasattr(typing, member)
    in_typing_extensions = hasattr(typing_extensions, member)

    if in_typing and in_typing_extensions:
        if getattr(typing, member) is getattr(typing_extensions, member):
            check_code = f'obj is typing.{member}'
        else:
            check_code = f'obj is typing.{member} or obj is typing_extensions.{member}'
    elif in_typing and not in_typing_extensions:
        check_code = f'obj is typing.{member}'
    elif not in_typing and in_typing_extensions:
        check_code = f'obj is typing_extensions.{member}'
    else:
        check_code = 'False'

    func_code = dedent(f"""
    def {function_name}(obj: Any, /) -> bool:
        return {check_code}
    """)

    locals_: dict[str, Any] = {}
    globals_: dict[str, Any] = {'Any': Any, 'typing': typing, 'typing_extensions': typing_extensions}
    exec(func_code, globals_, locals_)
    return locals_[function_name]


def _compile_isinstance_check_function(member: LiteralString, function_name: LiteralString) -> FunctionType:
    """Create a function checking that the function is an instance of the typing `member`.

    The function will make sure to check against both the `typing` and `typing_extensions`
    variants as depending on the Python version, the `typing_extensions` variant might be different.
    """
    in_typing = hasattr(typing, member)
    in_typing_extensions = hasattr(typing_extensions, member)

    if in_typing and in_typing_extensions:
        if getattr(typing, member) is getattr(typing_extensions, member):
            check_code = f'isinstance(obj, typing.{member})'
        else:
            check_code = f'isinstance(obj, (typing.{member}, typing_extensions.{member}))'
    elif in_typing and not in_typing_extensions:
        check_code = f'isinstance(obj, typing.{member})'
    elif not in_typing and in_typing_extensions:
        check_code = f'isinstance(obj, typing_extensions.{member})'
    else:
        check_code = 'False'

    func_code = dedent(f"""
    def {function_name}(obj: Any, /) -> 'TypeIs[{member}]':
        return {check_code}
    """)

    locals_: dict[str, Any] = {}
    globals_: dict[str, Any] = {'Any': Any, 'typing': typing, 'typing_extensions': typing_extensions}
    exec(func_code, globals_, locals_)
    return locals_[function_name]


if sys.version_info >= (3, 10):
    from types import NoneType
else:
    NoneType = type(None)

# Keep this ordered, as per `typing.__all__`:

is_annotated = _compile_identity_check_function('Annotated', 'is_annotated')
is_annotated.__doc__ = """
Return whether the argument is the [`Annotated`][typing.Annotated] [special form][].

```pycon
>>> is_annotated(Annotated)
True
>>> is_annotated(Annotated[int, ...])
False
```
"""

is_any = _compile_identity_check_function('Any', 'is_any')
is_any.__doc__ = """
Return whether the argument is the [`Any`][typing.Any] [special form][].

```pycon
>>> is_any(Any)
True
```
"""

is_classvar = _compile_identity_check_function('ClassVar', 'is_classvar')
is_classvar.__doc__ = """
Return whether the argument is the [`ClassVar`][typing.ClassVar] [type qualifier][].

```pycon
>>> is_classvar(ClassVar)
True
>>> is_classvar(ClassVar[int])
>>> False
```
"""

is_concatenate = _compile_identity_check_function('Concatenate', 'is_concatenate')
is_concatenate.__doc__ = """
Return whether the argument is the [`Concatenate`][typing.Concatenate] [special form][].

```pycon
>>> is_concatenate(Concatenate)
True
>>> is_concatenate(Concatenate[int, P])
False
```
"""

is_final = _compile_identity_check_function('Final', 'is_final')
is_final.__doc__ = """
Return whether the argument is the [`Final`][typing.Final] [type qualifier][].

```pycon
>>> is_final(Final)
True
>>> is_final(Final[int])
False
```
"""

# ForwardRef?

is_generic = _compile_identity_check_function('Generic', 'is_generic')
is_generic.__doc__ = """
Return whether the argument is the [`Generic`][typing.Generic] [special form][].

```pycon
>>> is_generic(Generic)
True
>>> is_generic(Generic[T])
False
```
"""

is_literal = _compile_identity_check_function('Literal', 'is_literal')
is_literal.__doc__ = """
Return whether the argument is the [`Literal`][typing.Literal] [special form][].

```pycon
>>> is_literal(Literal)
True
>>> is_literal(Literal["a"])
False
```
"""


# `get_origin(Optional[int]) is Union`, so `is_optional()` isn't implemented.

is_paramspec = _compile_isinstance_check_function('ParamSpec', 'is_paramspec')
is_paramspec.__doc__ = """
Return whether the argument is an instance of [`ParamSpec`][typing.ParamSpec].

```pycon
>>> P = ParamSpec('P')
>>> is_paramspec(P)
True
```
"""

# Protocol?

is_typevar = _compile_isinstance_check_function('TypeVar', 'is_typevar')
is_typevar.__doc__ = """
Return whether the argument is an instance of [`TypeVar`][typing.TypeVar].

```pycon
>>> T = TypeVar('T')
>>> is_typevar(T)
True
```
"""

is_typevartuple = _compile_isinstance_check_function('TypeVarTuple', 'is_typevartuple')
is_typevartuple.__doc__ = """
Return whether the argument is an instance of [`TypeVarTuple`][typing.TypeVarTuple].

```pycon
>>> Ts = TypeVarTuple('Ts')
>>> is_typevartuple(Ts)
True
```
"""

is_union = _compile_identity_check_function('Union', 'is_union')
is_union.__doc__ = """
Return whether the argument is the [`Union`][typing.Union] [special form][].

This function can also be used to check for the [`Optional`][typing.Optional] [special form][],
as at runtime, `Optional[int]` is equivalent to `Union[int, None]`.

```pycon
>>> is_union(Union)
True
>>> is_union(Union[int, str])
False
```

!!! warning
    This does not check for unions using the [new syntax][types-union] (e.g. `int | str`).
"""


def is_namedtuple(obj: Any, /) -> bool:
    """Return whether the argument is a named tuple type.

    This includes [`NamedTuple`][typing.NamedTuple] subclasses and classes created from the
    [`collections.namedtuple`][] factory function.

    ```pycon
    >>> class User(NamedTuple):
    ...     name: str
    ...
    >>> is_namedtuple(User)
    True
    >>> City = collections.namedtuple('City', [])
    >>> is_namedtuple(City)
    True
    >>> is_namedtuple(NamedTuple)
    False
    ```
    """
    return isinstance(obj, type) and issubclass(obj, tuple) and hasattr(obj, '_fields')  # pyright: ignore[reportUnknownArgumentType]


# TypedDict?

# BinaryIO? IO? TextIO?

is_literalstring = _compile_identity_check_function('LiteralString', 'is_literalstring')
is_literalstring.__doc__ = """
Return whether the argument is the [`LiteralString`][typing.LiteralString] [special form][].

```pycon
>>> is_literalstring(LiteralString)
True
```
"""

is_never = _compile_identity_check_function('Never', 'is_never')
is_never.__doc__ = """
Return whether the argument is the [`Never`][typing.Never] [special form][].

```pycon
>>> is_never(Never)
True
```
"""

if sys.version_info >= (3, 10):
    is_newtype = _compile_isinstance_check_function('NewType', 'is_newtype')
else:  # On Python 3.10, `NewType` is a function.

    def is_newtype(obj: Any, /) -> bool:
        return hasattr(obj, '__supertype__')


is_newtype.__doc__ = """
Return whether the argument is a [`NewType`][typing.NewType].

```pycon
>>> UserId = NewType("UserId", int)
>>> is_newtype(UserId)
True
```
"""

is_nodefault = _compile_identity_check_function('NoDefault', 'is_nodefault')
is_nodefault.__doc__ = """
Return whether the argument is the [`NoDefault`][typing.NoDefault] sentinel object.

```pycon
>>> is_nodefault(NoDefault)
True
```
"""

is_noreturn = _compile_identity_check_function('NoReturn', 'is_noreturn')
is_noreturn.__doc__ = """
Return whether the argument is the [`NoReturn`][typing.NoReturn] [special form][].

```pycon
>>> is_noreturn(NoReturn)
True
>>> is_noreturn(Never)
False
```
"""

is_notrequired = _compile_identity_check_function('NotRequired', 'is_notrequired')
is_notrequired.__doc__ = """
Return whether the argument is the [`NotRequired`][typing.NotRequired] [special form][].

```pycon
>>> is_notrequired(NotRequired)
True
```
"""

is_paramspecargs = _compile_isinstance_check_function('ParamSpecArgs', 'is_paramspecargs')
is_paramspecargs.__doc__ = """
Return whether the argument is an instance of [`ParamSpecArgs`][typing.ParamSpecArgs].

```pycon
>>> P = ParamSpec('P')
>>> is_paramspecargs(P.args)
True
```
"""

is_paramspeckwargs = _compile_isinstance_check_function('ParamSpecKwargs', 'is_paramspeckwargs')
is_paramspeckwargs.__doc__ = """
Return whether the argument is an instance of [`ParamSpecKwargs`][typing.ParamSpecKwargs].

```pycon
>>> P = ParamSpec('P')
>>> is_paramspeckwargs(P.kwargs)
True
```
"""

is_readonly = _compile_identity_check_function('ReadOnly', 'is_readonly')
is_readonly.__doc__ = """
Return whether the argument is the [`ReadOnly`][typing.ReadOnly] [special form][].

```pycon
>>> is_readonly(ReadOnly)
True
```
"""

is_required = _compile_identity_check_function('Required', 'is_required')
is_required.__doc__ = """
Return whether the argument is the [`Required`][typing.Required] [special form][].

```pycon
>>> is_required(Required)
True
```
"""

is_self = _compile_identity_check_function('Self', 'is_self')
is_self.__doc__ = """
Return whether the argument is the [`Self`][typing.Self] [special form][].

```pycon
>>> is_self(Self)
True
```
"""

# TYPE_CHECKING?

is_typealias = _compile_identity_check_function('TypeAlias', 'is_typealias')
is_typealias.__doc__ = """
Return whether the argument is the [`TypeAlias`][typing.TypeAlias] [special form][].

```pycon
>>> is_typealias(TypeAlias)
True
```
"""

is_typeguard = _compile_identity_check_function('TypeGuard', 'is_typeguard')
is_typeguard.__doc__ = """
Return whether the argument is the [`TypeGuard`][typing.TypeGuard] [special form][].

```pycon
>>> is_typeguard(TypeGuard)
True
```
"""

is_typeis = _compile_identity_check_function('TypeIs', 'is_typeis')
is_typeis.__doc__ = """
Return whether the argument is the [`TypeIs`][typing.TypeIs] [special form][].

```pycon
>>> is_typeis(TypeIs)
True
```
"""

_is_typealiastype_inner = _compile_isinstance_check_function('TypeAliasType', '_is_typealiastype_inner')


if _IS_PY310:
    # Parameterized PEP 695 type aliases are instances of `types.GenericAlias` in typing_extensions>=4.13.0.
    # On Python 3.10, with `Alias[int]` being such an instance of `GenericAlias`,
    # `isinstance(Alias[int], TypeAliasType)` returns `True`.
    # See https://github.com/python/cpython/issues/89828.
    def is_typealiastype(obj: Any, /) -> 'TypeIs[TypeAliasType]':
        return type(obj) is not GenericAlias and _is_typealiastype_inner(obj)
else:
    is_typealiastype = _compile_isinstance_check_function('TypeAliasType', 'is_typealiastype')

is_typealiastype.__doc__ = """
Return whether the argument is a [`TypeAliasType`][typing.TypeAliasType] instance.

```pycon
>>> type MyInt = int
>>> is_typealiastype(MyInt)
True
>>> MyStr = TypeAliasType("MyStr", str)
>>> is_typealiastype(MyStr):
True
>>> type MyList[T] = list[T]
>>> is_typealiastype(MyList[int])
False
```
"""

is_unpack = _compile_identity_check_function('Unpack', 'is_unpack')
is_unpack.__doc__ = """
Return whether the argument is the [`Unpack`][typing.Unpack] [special form][].

```pycon
>>> is_unpack(Unpack)
True
>>> is_unpack(Unpack[Ts])
False
```
"""


if sys.version_info >= (3, 13):

    def is_deprecated(obj: Any, /) -> 'TypeIs[deprecated]':
        return isinstance(obj, (warnings.deprecated, typing_extensions.deprecated))

else:

    def is_deprecated(obj: Any, /) -> 'TypeIs[deprecated]':
        return isinstance(obj, typing_extensions.deprecated)


is_deprecated.__doc__ = """
Return whether the argument is a [`deprecated`][warnings.deprecated] instance.

This also includes the [`typing_extensions` backport][typing_extensions.deprecated].

```pycon
>>> is_deprecated(warnings.deprecated('message'))
True
>>> is_deprecated(typing_extensions('deprecated'))
True
```
"""


# Aliases defined in the `typing` module using `typing._SpecialGenericAlias` (itself aliases as `alias()`):
DEPRECATED_ALIASES: Final[dict[Any, type[Any]]] = {
    typing.Hashable: collections.abc.Hashable,
    typing.Awaitable: collections.abc.Awaitable,
    typing.Coroutine: collections.abc.Coroutine,
    typing.AsyncIterable: collections.abc.AsyncIterable,
    typing.AsyncIterator: collections.abc.AsyncIterator,
    typing.Iterable: collections.abc.Iterable,
    typing.Iterator: collections.abc.Iterator,
    typing.Reversible: collections.abc.Reversible,
    typing.Sized: collections.abc.Sized,
    typing.Container: collections.abc.Container,
    typing.Collection: collections.abc.Collection,
    # type ignore reason: https://github.com/python/typeshed/issues/6257:
    typing.Callable: collections.abc.Callable,  # pyright: ignore[reportAssignmentType, reportUnknownMemberType]
    typing.AbstractSet: collections.abc.Set,
    typing.MutableSet: collections.abc.MutableSet,
    typing.Mapping: collections.abc.Mapping,
    typing.MutableMapping: collections.abc.MutableMapping,
    typing.Sequence: collections.abc.Sequence,
    typing.MutableSequence: collections.abc.MutableSequence,
    typing.Tuple: tuple,
    typing.List: list,
    typing.Deque: collections.deque,
    typing.Set: set,
    typing.FrozenSet: frozenset,
    typing.MappingView: collections.abc.MappingView,
    typing.KeysView: collections.abc.KeysView,
    typing.ItemsView: collections.abc.ItemsView,
    typing.ValuesView: collections.abc.ValuesView,
    typing.Dict: dict,
    typing.DefaultDict: collections.defaultdict,
    typing.OrderedDict: collections.OrderedDict,
    typing.Counter: collections.Counter,
    typing.ChainMap: collections.ChainMap,
    typing.Generator: collections.abc.Generator,
    typing.AsyncGenerator: collections.abc.AsyncGenerator,
    typing.Type: type,
    # Defined in `typing.__getattr__`:
    typing.Pattern: re.Pattern,
    typing.Match: re.Match,
    typing.ContextManager: contextlib.AbstractContextManager,
    typing.AsyncContextManager: contextlib.AbstractAsyncContextManager,
    # Skipped: `ByteString` (deprecated, removed in 3.14)
}
"""A mapping between the deprecated typing aliases to their replacement, as per [PEP 585](https://peps.python.org/pep-0585/)."""


# Add the `typing_extensions` aliases:
for alias, target in list(DEPRECATED_ALIASES.items()):
    # Use `alias.__name__` when we drop support for Python 3.9
    if (te_alias := getattr(typing_extensions, alias._name, None)) is not None:
        DEPRECATED_ALIASES[te_alias] = target


# ================================================================================
# Datei: venv\Lib\site-packages\yaml\__init__.py
# ================================================================================


from .error import *

from .tokens import *
from .events import *
from .nodes import *

from .loader import *
from .dumper import *

__version__ = '6.0.2'
try:
    from .cyaml import *
    __with_libyaml__ = True
except ImportError:
    __with_libyaml__ = False

import io

#------------------------------------------------------------------------------
# XXX "Warnings control" is now deprecated. Leaving in the API function to not
# break code that uses it.
#------------------------------------------------------------------------------
def warnings(settings=None):
    if settings is None:
        return {}

#------------------------------------------------------------------------------
def scan(stream, Loader=Loader):
    """
    Scan a YAML stream and produce scanning tokens.
    """
    loader = Loader(stream)
    try:
        while loader.check_token():
            yield loader.get_token()
    finally:
        loader.dispose()

def parse(stream, Loader=Loader):
    """
    Parse a YAML stream and produce parsing events.
    """
    loader = Loader(stream)
    try:
        while loader.check_event():
            yield loader.get_event()
    finally:
        loader.dispose()

def compose(stream, Loader=Loader):
    """
    Parse the first YAML document in a stream
    and produce the corresponding representation tree.
    """
    loader = Loader(stream)
    try:
        return loader.get_single_node()
    finally:
        loader.dispose()

def compose_all(stream, Loader=Loader):
    """
    Parse all YAML documents in a stream
    and produce corresponding representation trees.
    """
    loader = Loader(stream)
    try:
        while loader.check_node():
            yield loader.get_node()
    finally:
        loader.dispose()

def load(stream, Loader):
    """
    Parse the first YAML document in a stream
    and produce the corresponding Python object.
    """
    loader = Loader(stream)
    try:
        return loader.get_single_data()
    finally:
        loader.dispose()

def load_all(stream, Loader):
    """
    Parse all YAML documents in a stream
    and produce corresponding Python objects.
    """
    loader = Loader(stream)
    try:
        while loader.check_data():
            yield loader.get_data()
    finally:
        loader.dispose()

def full_load(stream):
    """
    Parse the first YAML document in a stream
    and produce the corresponding Python object.

    Resolve all tags except those known to be
    unsafe on untrusted input.
    """
    return load(stream, FullLoader)

def full_load_all(stream):
    """
    Parse all YAML documents in a stream
    and produce corresponding Python objects.

    Resolve all tags except those known to be
    unsafe on untrusted input.
    """
    return load_all(stream, FullLoader)

def safe_load(stream):
    """
    Parse the first YAML document in a stream
    and produce the corresponding Python object.

    Resolve only basic YAML tags. This is known
    to be safe for untrusted input.
    """
    return load(stream, SafeLoader)

def safe_load_all(stream):
    """
    Parse all YAML documents in a stream
    and produce corresponding Python objects.

    Resolve only basic YAML tags. This is known
    to be safe for untrusted input.
    """
    return load_all(stream, SafeLoader)

def unsafe_load(stream):
    """
    Parse the first YAML document in a stream
    and produce the corresponding Python object.

    Resolve all tags, even those known to be
    unsafe on untrusted input.
    """
    return load(stream, UnsafeLoader)

def unsafe_load_all(stream):
    """
    Parse all YAML documents in a stream
    and produce corresponding Python objects.

    Resolve all tags, even those known to be
    unsafe on untrusted input.
    """
    return load_all(stream, UnsafeLoader)

def emit(events, stream=None, Dumper=Dumper,
        canonical=None, indent=None, width=None,
        allow_unicode=None, line_break=None):
    """
    Emit YAML parsing events into a stream.
    If stream is None, return the produced string instead.
    """
    getvalue = None
    if stream is None:
        stream = io.StringIO()
        getvalue = stream.getvalue
    dumper = Dumper(stream, canonical=canonical, indent=indent, width=width,
            allow_unicode=allow_unicode, line_break=line_break)
    try:
        for event in events:
            dumper.emit(event)
    finally:
        dumper.dispose()
    if getvalue:
        return getvalue()

def serialize_all(nodes, stream=None, Dumper=Dumper,
        canonical=None, indent=None, width=None,
        allow_unicode=None, line_break=None,
        encoding=None, explicit_start=None, explicit_end=None,
        version=None, tags=None):
    """
    Serialize a sequence of representation trees into a YAML stream.
    If stream is None, return the produced string instead.
    """
    getvalue = None
    if stream is None:
        if encoding is None:
            stream = io.StringIO()
        else:
            stream = io.BytesIO()
        getvalue = stream.getvalue
    dumper = Dumper(stream, canonical=canonical, indent=indent, width=width,
            allow_unicode=allow_unicode, line_break=line_break,
            encoding=encoding, version=version, tags=tags,
            explicit_start=explicit_start, explicit_end=explicit_end)
    try:
        dumper.open()
        for node in nodes:
            dumper.serialize(node)
        dumper.close()
    finally:
        dumper.dispose()
    if getvalue:
        return getvalue()

def serialize(node, stream=None, Dumper=Dumper, **kwds):
    """
    Serialize a representation tree into a YAML stream.
    If stream is None, return the produced string instead.
    """
    return serialize_all([node], stream, Dumper=Dumper, **kwds)

def dump_all(documents, stream=None, Dumper=Dumper,
        default_style=None, default_flow_style=False,
        canonical=None, indent=None, width=None,
        allow_unicode=None, line_break=None,
        encoding=None, explicit_start=None, explicit_end=None,
        version=None, tags=None, sort_keys=True):
    """
    Serialize a sequence of Python objects into a YAML stream.
    If stream is None, return the produced string instead.
    """
    getvalue = None
    if stream is None:
        if encoding is None:
            stream = io.StringIO()
        else:
            stream = io.BytesIO()
        getvalue = stream.getvalue
    dumper = Dumper(stream, default_style=default_style,
            default_flow_style=default_flow_style,
            canonical=canonical, indent=indent, width=width,
            allow_unicode=allow_unicode, line_break=line_break,
            encoding=encoding, version=version, tags=tags,
            explicit_start=explicit_start, explicit_end=explicit_end, sort_keys=sort_keys)
    try:
        dumper.open()
        for data in documents:
            dumper.represent(data)
        dumper.close()
    finally:
        dumper.dispose()
    if getvalue:
        return getvalue()

def dump(data, stream=None, Dumper=Dumper, **kwds):
    """
    Serialize a Python object into a YAML stream.
    If stream is None, return the produced string instead.
    """
    return dump_all([data], stream, Dumper=Dumper, **kwds)

def safe_dump_all(documents, stream=None, **kwds):
    """
    Serialize a sequence of Python objects into a YAML stream.
    Produce only basic YAML tags.
    If stream is None, return the produced string instead.
    """
    return dump_all(documents, stream, Dumper=SafeDumper, **kwds)

def safe_dump(data, stream=None, **kwds):
    """
    Serialize a Python object into a YAML stream.
    Produce only basic YAML tags.
    If stream is None, return the produced string instead.
    """
    return dump_all([data], stream, Dumper=SafeDumper, **kwds)

def add_implicit_resolver(tag, regexp, first=None,
        Loader=None, Dumper=Dumper):
    """
    Add an implicit scalar detector.
    If an implicit scalar value matches the given regexp,
    the corresponding tag is assigned to the scalar.
    first is a sequence of possible initial characters or None.
    """
    if Loader is None:
        loader.Loader.add_implicit_resolver(tag, regexp, first)
        loader.FullLoader.add_implicit_resolver(tag, regexp, first)
        loader.UnsafeLoader.add_implicit_resolver(tag, regexp, first)
    else:
        Loader.add_implicit_resolver(tag, regexp, first)
    Dumper.add_implicit_resolver(tag, regexp, first)

def add_path_resolver(tag, path, kind=None, Loader=None, Dumper=Dumper):
    """
    Add a path based resolver for the given tag.
    A path is a list of keys that forms a path
    to a node in the representation tree.
    Keys can be string values, integers, or None.
    """
    if Loader is None:
        loader.Loader.add_path_resolver(tag, path, kind)
        loader.FullLoader.add_path_resolver(tag, path, kind)
        loader.UnsafeLoader.add_path_resolver(tag, path, kind)
    else:
        Loader.add_path_resolver(tag, path, kind)
    Dumper.add_path_resolver(tag, path, kind)

def add_constructor(tag, constructor, Loader=None):
    """
    Add a constructor for the given tag.
    Constructor is a function that accepts a Loader instance
    and a node object and produces the corresponding Python object.
    """
    if Loader is None:
        loader.Loader.add_constructor(tag, constructor)
        loader.FullLoader.add_constructor(tag, constructor)
        loader.UnsafeLoader.add_constructor(tag, constructor)
    else:
        Loader.add_constructor(tag, constructor)

def add_multi_constructor(tag_prefix, multi_constructor, Loader=None):
    """
    Add a multi-constructor for the given tag prefix.
    Multi-constructor is called for a node if its tag starts with tag_prefix.
    Multi-constructor accepts a Loader instance, a tag suffix,
    and a node object and produces the corresponding Python object.
    """
    if Loader is None:
        loader.Loader.add_multi_constructor(tag_prefix, multi_constructor)
        loader.FullLoader.add_multi_constructor(tag_prefix, multi_constructor)
        loader.UnsafeLoader.add_multi_constructor(tag_prefix, multi_constructor)
    else:
        Loader.add_multi_constructor(tag_prefix, multi_constructor)

def add_representer(data_type, representer, Dumper=Dumper):
    """
    Add a representer for the given type.
    Representer is a function accepting a Dumper instance
    and an instance of the given data type
    and producing the corresponding representation node.
    """
    Dumper.add_representer(data_type, representer)

def add_multi_representer(data_type, multi_representer, Dumper=Dumper):
    """
    Add a representer for the given type.
    Multi-representer is a function accepting a Dumper instance
    and an instance of the given data type or subtype
    and producing the corresponding representation node.
    """
    Dumper.add_multi_representer(data_type, multi_representer)

class YAMLObjectMetaclass(type):
    """
    The metaclass for YAMLObject.
    """
    def __init__(cls, name, bases, kwds):
        super(YAMLObjectMetaclass, cls).__init__(name, bases, kwds)
        if 'yaml_tag' in kwds and kwds['yaml_tag'] is not None:
            if isinstance(cls.yaml_loader, list):
                for loader in cls.yaml_loader:
                    loader.add_constructor(cls.yaml_tag, cls.from_yaml)
            else:
                cls.yaml_loader.add_constructor(cls.yaml_tag, cls.from_yaml)

            cls.yaml_dumper.add_representer(cls, cls.to_yaml)

class YAMLObject(metaclass=YAMLObjectMetaclass):
    """
    An object that can dump itself to a YAML stream
    and load itself from a YAML stream.
    """

    __slots__ = ()  # no direct instantiation, so allow immutable subclasses

    yaml_loader = [Loader, FullLoader, UnsafeLoader]
    yaml_dumper = Dumper

    yaml_tag = None
    yaml_flow_style = None

    @classmethod
    def from_yaml(cls, loader, node):
        """
        Convert a representation node to a Python object.
        """
        return loader.construct_yaml_object(node, cls)

    @classmethod
    def to_yaml(cls, dumper, data):
        """
        Convert a Python object to a representation node.
        """
        return dumper.represent_yaml_object(cls.yaml_tag, data, cls,
                flow_style=cls.yaml_flow_style)



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\composer.py
# ================================================================================


__all__ = ['Composer', 'ComposerError']

from .error import MarkedYAMLError
from .events import *
from .nodes import *

class ComposerError(MarkedYAMLError):
    pass

class Composer:

    def __init__(self):
        self.anchors = {}

    def check_node(self):
        # Drop the STREAM-START event.
        if self.check_event(StreamStartEvent):
            self.get_event()

        # If there are more documents available?
        return not self.check_event(StreamEndEvent)

    def get_node(self):
        # Get the root node of the next document.
        if not self.check_event(StreamEndEvent):
            return self.compose_document()

    def get_single_node(self):
        # Drop the STREAM-START event.
        self.get_event()

        # Compose a document if the stream is not empty.
        document = None
        if not self.check_event(StreamEndEvent):
            document = self.compose_document()

        # Ensure that the stream contains no more documents.
        if not self.check_event(StreamEndEvent):
            event = self.get_event()
            raise ComposerError("expected a single document in the stream",
                    document.start_mark, "but found another document",
                    event.start_mark)

        # Drop the STREAM-END event.
        self.get_event()

        return document

    def compose_document(self):
        # Drop the DOCUMENT-START event.
        self.get_event()

        # Compose the root node.
        node = self.compose_node(None, None)

        # Drop the DOCUMENT-END event.
        self.get_event()

        self.anchors = {}
        return node

    def compose_node(self, parent, index):
        if self.check_event(AliasEvent):
            event = self.get_event()
            anchor = event.anchor
            if anchor not in self.anchors:
                raise ComposerError(None, None, "found undefined alias %r"
                        % anchor, event.start_mark)
            return self.anchors[anchor]
        event = self.peek_event()
        anchor = event.anchor
        if anchor is not None:
            if anchor in self.anchors:
                raise ComposerError("found duplicate anchor %r; first occurrence"
                        % anchor, self.anchors[anchor].start_mark,
                        "second occurrence", event.start_mark)
        self.descend_resolver(parent, index)
        if self.check_event(ScalarEvent):
            node = self.compose_scalar_node(anchor)
        elif self.check_event(SequenceStartEvent):
            node = self.compose_sequence_node(anchor)
        elif self.check_event(MappingStartEvent):
            node = self.compose_mapping_node(anchor)
        self.ascend_resolver()
        return node

    def compose_scalar_node(self, anchor):
        event = self.get_event()
        tag = event.tag
        if tag is None or tag == '!':
            tag = self.resolve(ScalarNode, event.value, event.implicit)
        node = ScalarNode(tag, event.value,
                event.start_mark, event.end_mark, style=event.style)
        if anchor is not None:
            self.anchors[anchor] = node
        return node

    def compose_sequence_node(self, anchor):
        start_event = self.get_event()
        tag = start_event.tag
        if tag is None or tag == '!':
            tag = self.resolve(SequenceNode, None, start_event.implicit)
        node = SequenceNode(tag, [],
                start_event.start_mark, None,
                flow_style=start_event.flow_style)
        if anchor is not None:
            self.anchors[anchor] = node
        index = 0
        while not self.check_event(SequenceEndEvent):
            node.value.append(self.compose_node(node, index))
            index += 1
        end_event = self.get_event()
        node.end_mark = end_event.end_mark
        return node

    def compose_mapping_node(self, anchor):
        start_event = self.get_event()
        tag = start_event.tag
        if tag is None or tag == '!':
            tag = self.resolve(MappingNode, None, start_event.implicit)
        node = MappingNode(tag, [],
                start_event.start_mark, None,
                flow_style=start_event.flow_style)
        if anchor is not None:
            self.anchors[anchor] = node
        while not self.check_event(MappingEndEvent):
            #key_event = self.peek_event()
            item_key = self.compose_node(node, None)
            #if item_key in node.value:
            #    raise ComposerError("while composing a mapping", start_event.start_mark,
            #            "found duplicate key", key_event.start_mark)
            item_value = self.compose_node(node, item_key)
            #node.value[item_key] = item_value
            node.value.append((item_key, item_value))
        end_event = self.get_event()
        node.end_mark = end_event.end_mark
        return node



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\constructor.py
# ================================================================================


__all__ = [
    'BaseConstructor',
    'SafeConstructor',
    'FullConstructor',
    'UnsafeConstructor',
    'Constructor',
    'ConstructorError'
]

from .error import *
from .nodes import *

import collections.abc, datetime, base64, binascii, re, sys, types

class ConstructorError(MarkedYAMLError):
    pass

class BaseConstructor:

    yaml_constructors = {}
    yaml_multi_constructors = {}

    def __init__(self):
        self.constructed_objects = {}
        self.recursive_objects = {}
        self.state_generators = []
        self.deep_construct = False

    def check_data(self):
        # If there are more documents available?
        return self.check_node()

    def check_state_key(self, key):
        """Block special attributes/methods from being set in a newly created
        object, to prevent user-controlled methods from being called during
        deserialization"""
        if self.get_state_keys_blacklist_regexp().match(key):
            raise ConstructorError(None, None,
                "blacklisted key '%s' in instance state found" % (key,), None)

    def get_data(self):
        # Construct and return the next document.
        if self.check_node():
            return self.construct_document(self.get_node())

    def get_single_data(self):
        # Ensure that the stream contains a single document and construct it.
        node = self.get_single_node()
        if node is not None:
            return self.construct_document(node)
        return None

    def construct_document(self, node):
        data = self.construct_object(node)
        while self.state_generators:
            state_generators = self.state_generators
            self.state_generators = []
            for generator in state_generators:
                for dummy in generator:
                    pass
        self.constructed_objects = {}
        self.recursive_objects = {}
        self.deep_construct = False
        return data

    def construct_object(self, node, deep=False):
        if node in self.constructed_objects:
            return self.constructed_objects[node]
        if deep:
            old_deep = self.deep_construct
            self.deep_construct = True
        if node in self.recursive_objects:
            raise ConstructorError(None, None,
                    "found unconstructable recursive node", node.start_mark)
        self.recursive_objects[node] = None
        constructor = None
        tag_suffix = None
        if node.tag in self.yaml_constructors:
            constructor = self.yaml_constructors[node.tag]
        else:
            for tag_prefix in self.yaml_multi_constructors:
                if tag_prefix is not None and node.tag.startswith(tag_prefix):
                    tag_suffix = node.tag[len(tag_prefix):]
                    constructor = self.yaml_multi_constructors[tag_prefix]
                    break
            else:
                if None in self.yaml_multi_constructors:
                    tag_suffix = node.tag
                    constructor = self.yaml_multi_constructors[None]
                elif None in self.yaml_constructors:
                    constructor = self.yaml_constructors[None]
                elif isinstance(node, ScalarNode):
                    constructor = self.__class__.construct_scalar
                elif isinstance(node, SequenceNode):
                    constructor = self.__class__.construct_sequence
                elif isinstance(node, MappingNode):
                    constructor = self.__class__.construct_mapping
        if tag_suffix is None:
            data = constructor(self, node)
        else:
            data = constructor(self, tag_suffix, node)
        if isinstance(data, types.GeneratorType):
            generator = data
            data = next(generator)
            if self.deep_construct:
                for dummy in generator:
                    pass
            else:
                self.state_generators.append(generator)
        self.constructed_objects[node] = data
        del self.recursive_objects[node]
        if deep:
            self.deep_construct = old_deep
        return data

    def construct_scalar(self, node):
        if not isinstance(node, ScalarNode):
            raise ConstructorError(None, None,
                    "expected a scalar node, but found %s" % node.id,
                    node.start_mark)
        return node.value

    def construct_sequence(self, node, deep=False):
        if not isinstance(node, SequenceNode):
            raise ConstructorError(None, None,
                    "expected a sequence node, but found %s" % node.id,
                    node.start_mark)
        return [self.construct_object(child, deep=deep)
                for child in node.value]

    def construct_mapping(self, node, deep=False):
        if not isinstance(node, MappingNode):
            raise ConstructorError(None, None,
                    "expected a mapping node, but found %s" % node.id,
                    node.start_mark)
        mapping = {}
        for key_node, value_node in node.value:
            key = self.construct_object(key_node, deep=deep)
            if not isinstance(key, collections.abc.Hashable):
                raise ConstructorError("while constructing a mapping", node.start_mark,
                        "found unhashable key", key_node.start_mark)
            value = self.construct_object(value_node, deep=deep)
            mapping[key] = value
        return mapping

    def construct_pairs(self, node, deep=False):
        if not isinstance(node, MappingNode):
            raise ConstructorError(None, None,
                    "expected a mapping node, but found %s" % node.id,
                    node.start_mark)
        pairs = []
        for key_node, value_node in node.value:
            key = self.construct_object(key_node, deep=deep)
            value = self.construct_object(value_node, deep=deep)
            pairs.append((key, value))
        return pairs

    @classmethod
    def add_constructor(cls, tag, constructor):
        if not 'yaml_constructors' in cls.__dict__:
            cls.yaml_constructors = cls.yaml_constructors.copy()
        cls.yaml_constructors[tag] = constructor

    @classmethod
    def add_multi_constructor(cls, tag_prefix, multi_constructor):
        if not 'yaml_multi_constructors' in cls.__dict__:
            cls.yaml_multi_constructors = cls.yaml_multi_constructors.copy()
        cls.yaml_multi_constructors[tag_prefix] = multi_constructor

class SafeConstructor(BaseConstructor):

    def construct_scalar(self, node):
        if isinstance(node, MappingNode):
            for key_node, value_node in node.value:
                if key_node.tag == 'tag:yaml.org,2002:value':
                    return self.construct_scalar(value_node)
        return super().construct_scalar(node)

    def flatten_mapping(self, node):
        merge = []
        index = 0
        while index < len(node.value):
            key_node, value_node = node.value[index]
            if key_node.tag == 'tag:yaml.org,2002:merge':
                del node.value[index]
                if isinstance(value_node, MappingNode):
                    self.flatten_mapping(value_node)
                    merge.extend(value_node.value)
                elif isinstance(value_node, SequenceNode):
                    submerge = []
                    for subnode in value_node.value:
                        if not isinstance(subnode, MappingNode):
                            raise ConstructorError("while constructing a mapping",
                                    node.start_mark,
                                    "expected a mapping for merging, but found %s"
                                    % subnode.id, subnode.start_mark)
                        self.flatten_mapping(subnode)
                        submerge.append(subnode.value)
                    submerge.reverse()
                    for value in submerge:
                        merge.extend(value)
                else:
                    raise ConstructorError("while constructing a mapping", node.start_mark,
                            "expected a mapping or list of mappings for merging, but found %s"
                            % value_node.id, value_node.start_mark)
            elif key_node.tag == 'tag:yaml.org,2002:value':
                key_node.tag = 'tag:yaml.org,2002:str'
                index += 1
            else:
                index += 1
        if merge:
            node.value = merge + node.value

    def construct_mapping(self, node, deep=False):
        if isinstance(node, MappingNode):
            self.flatten_mapping(node)
        return super().construct_mapping(node, deep=deep)

    def construct_yaml_null(self, node):
        self.construct_scalar(node)
        return None

    bool_values = {
        'yes':      True,
        'no':       False,
        'true':     True,
        'false':    False,
        'on':       True,
        'off':      False,
    }

    def construct_yaml_bool(self, node):
        value = self.construct_scalar(node)
        return self.bool_values[value.lower()]

    def construct_yaml_int(self, node):
        value = self.construct_scalar(node)
        value = value.replace('_', '')
        sign = +1
        if value[0] == '-':
            sign = -1
        if value[0] in '+-':
            value = value[1:]
        if value == '0':
            return 0
        elif value.startswith('0b'):
            return sign*int(value[2:], 2)
        elif value.startswith('0x'):
            return sign*int(value[2:], 16)
        elif value[0] == '0':
            return sign*int(value, 8)
        elif ':' in value:
            digits = [int(part) for part in value.split(':')]
            digits.reverse()
            base = 1
            value = 0
            for digit in digits:
                value += digit*base
                base *= 60
            return sign*value
        else:
            return sign*int(value)

    inf_value = 1e300
    while inf_value != inf_value*inf_value:
        inf_value *= inf_value
    nan_value = -inf_value/inf_value   # Trying to make a quiet NaN (like C99).

    def construct_yaml_float(self, node):
        value = self.construct_scalar(node)
        value = value.replace('_', '').lower()
        sign = +1
        if value[0] == '-':
            sign = -1
        if value[0] in '+-':
            value = value[1:]
        if value == '.inf':
            return sign*self.inf_value
        elif value == '.nan':
            return self.nan_value
        elif ':' in value:
            digits = [float(part) for part in value.split(':')]
            digits.reverse()
            base = 1
            value = 0.0
            for digit in digits:
                value += digit*base
                base *= 60
            return sign*value
        else:
            return sign*float(value)

    def construct_yaml_binary(self, node):
        try:
            value = self.construct_scalar(node).encode('ascii')
        except UnicodeEncodeError as exc:
            raise ConstructorError(None, None,
                    "failed to convert base64 data into ascii: %s" % exc,
                    node.start_mark)
        try:
            if hasattr(base64, 'decodebytes'):
                return base64.decodebytes(value)
            else:
                return base64.decodestring(value)
        except binascii.Error as exc:
            raise ConstructorError(None, None,
                    "failed to decode base64 data: %s" % exc, node.start_mark)

    timestamp_regexp = re.compile(
            r'''^(?P<year>[0-9][0-9][0-9][0-9])
                -(?P<month>[0-9][0-9]?)
                -(?P<day>[0-9][0-9]?)
                (?:(?:[Tt]|[ \t]+)
                (?P<hour>[0-9][0-9]?)
                :(?P<minute>[0-9][0-9])
                :(?P<second>[0-9][0-9])
                (?:\.(?P<fraction>[0-9]*))?
                (?:[ \t]*(?P<tz>Z|(?P<tz_sign>[-+])(?P<tz_hour>[0-9][0-9]?)
                (?::(?P<tz_minute>[0-9][0-9]))?))?)?$''', re.X)

    def construct_yaml_timestamp(self, node):
        value = self.construct_scalar(node)
        match = self.timestamp_regexp.match(node.value)
        values = match.groupdict()
        year = int(values['year'])
        month = int(values['month'])
        day = int(values['day'])
        if not values['hour']:
            return datetime.date(year, month, day)
        hour = int(values['hour'])
        minute = int(values['minute'])
        second = int(values['second'])
        fraction = 0
        tzinfo = None
        if values['fraction']:
            fraction = values['fraction'][:6]
            while len(fraction) < 6:
                fraction += '0'
            fraction = int(fraction)
        if values['tz_sign']:
            tz_hour = int(values['tz_hour'])
            tz_minute = int(values['tz_minute'] or 0)
            delta = datetime.timedelta(hours=tz_hour, minutes=tz_minute)
            if values['tz_sign'] == '-':
                delta = -delta
            tzinfo = datetime.timezone(delta)
        elif values['tz']:
            tzinfo = datetime.timezone.utc
        return datetime.datetime(year, month, day, hour, minute, second, fraction,
                                 tzinfo=tzinfo)

    def construct_yaml_omap(self, node):
        # Note: we do not check for duplicate keys, because it's too
        # CPU-expensive.
        omap = []
        yield omap
        if not isinstance(node, SequenceNode):
            raise ConstructorError("while constructing an ordered map", node.start_mark,
                    "expected a sequence, but found %s" % node.id, node.start_mark)
        for subnode in node.value:
            if not isinstance(subnode, MappingNode):
                raise ConstructorError("while constructing an ordered map", node.start_mark,
                        "expected a mapping of length 1, but found %s" % subnode.id,
                        subnode.start_mark)
            if len(subnode.value) != 1:
                raise ConstructorError("while constructing an ordered map", node.start_mark,
                        "expected a single mapping item, but found %d items" % len(subnode.value),
                        subnode.start_mark)
            key_node, value_node = subnode.value[0]
            key = self.construct_object(key_node)
            value = self.construct_object(value_node)
            omap.append((key, value))

    def construct_yaml_pairs(self, node):
        # Note: the same code as `construct_yaml_omap`.
        pairs = []
        yield pairs
        if not isinstance(node, SequenceNode):
            raise ConstructorError("while constructing pairs", node.start_mark,
                    "expected a sequence, but found %s" % node.id, node.start_mark)
        for subnode in node.value:
            if not isinstance(subnode, MappingNode):
                raise ConstructorError("while constructing pairs", node.start_mark,
                        "expected a mapping of length 1, but found %s" % subnode.id,
                        subnode.start_mark)
            if len(subnode.value) != 1:
                raise ConstructorError("while constructing pairs", node.start_mark,
                        "expected a single mapping item, but found %d items" % len(subnode.value),
                        subnode.start_mark)
            key_node, value_node = subnode.value[0]
            key = self.construct_object(key_node)
            value = self.construct_object(value_node)
            pairs.append((key, value))

    def construct_yaml_set(self, node):
        data = set()
        yield data
        value = self.construct_mapping(node)
        data.update(value)

    def construct_yaml_str(self, node):
        return self.construct_scalar(node)

    def construct_yaml_seq(self, node):
        data = []
        yield data
        data.extend(self.construct_sequence(node))

    def construct_yaml_map(self, node):
        data = {}
        yield data
        value = self.construct_mapping(node)
        data.update(value)

    def construct_yaml_object(self, node, cls):
        data = cls.__new__(cls)
        yield data
        if hasattr(data, '__setstate__'):
            state = self.construct_mapping(node, deep=True)
            data.__setstate__(state)
        else:
            state = self.construct_mapping(node)
            data.__dict__.update(state)

    def construct_undefined(self, node):
        raise ConstructorError(None, None,
                "could not determine a constructor for the tag %r" % node.tag,
                node.start_mark)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:null',
        SafeConstructor.construct_yaml_null)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:bool',
        SafeConstructor.construct_yaml_bool)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:int',
        SafeConstructor.construct_yaml_int)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:float',
        SafeConstructor.construct_yaml_float)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:binary',
        SafeConstructor.construct_yaml_binary)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:timestamp',
        SafeConstructor.construct_yaml_timestamp)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:omap',
        SafeConstructor.construct_yaml_omap)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:pairs',
        SafeConstructor.construct_yaml_pairs)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:set',
        SafeConstructor.construct_yaml_set)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:str',
        SafeConstructor.construct_yaml_str)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:seq',
        SafeConstructor.construct_yaml_seq)

SafeConstructor.add_constructor(
        'tag:yaml.org,2002:map',
        SafeConstructor.construct_yaml_map)

SafeConstructor.add_constructor(None,
        SafeConstructor.construct_undefined)

class FullConstructor(SafeConstructor):
    # 'extend' is blacklisted because it is used by
    # construct_python_object_apply to add `listitems` to a newly generate
    # python instance
    def get_state_keys_blacklist(self):
        return ['^extend$', '^__.*__$']

    def get_state_keys_blacklist_regexp(self):
        if not hasattr(self, 'state_keys_blacklist_regexp'):
            self.state_keys_blacklist_regexp = re.compile('(' + '|'.join(self.get_state_keys_blacklist()) + ')')
        return self.state_keys_blacklist_regexp

    def construct_python_str(self, node):
        return self.construct_scalar(node)

    def construct_python_unicode(self, node):
        return self.construct_scalar(node)

    def construct_python_bytes(self, node):
        try:
            value = self.construct_scalar(node).encode('ascii')
        except UnicodeEncodeError as exc:
            raise ConstructorError(None, None,
                    "failed to convert base64 data into ascii: %s" % exc,
                    node.start_mark)
        try:
            if hasattr(base64, 'decodebytes'):
                return base64.decodebytes(value)
            else:
                return base64.decodestring(value)
        except binascii.Error as exc:
            raise ConstructorError(None, None,
                    "failed to decode base64 data: %s" % exc, node.start_mark)

    def construct_python_long(self, node):
        return self.construct_yaml_int(node)

    def construct_python_complex(self, node):
       return complex(self.construct_scalar(node))

    def construct_python_tuple(self, node):
        return tuple(self.construct_sequence(node))

    def find_python_module(self, name, mark, unsafe=False):
        if not name:
            raise ConstructorError("while constructing a Python module", mark,
                    "expected non-empty name appended to the tag", mark)
        if unsafe:
            try:
                __import__(name)
            except ImportError as exc:
                raise ConstructorError("while constructing a Python module", mark,
                        "cannot find module %r (%s)" % (name, exc), mark)
        if name not in sys.modules:
            raise ConstructorError("while constructing a Python module", mark,
                    "module %r is not imported" % name, mark)
        return sys.modules[name]

    def find_python_name(self, name, mark, unsafe=False):
        if not name:
            raise ConstructorError("while constructing a Python object", mark,
                    "expected non-empty name appended to the tag", mark)
        if '.' in name:
            module_name, object_name = name.rsplit('.', 1)
        else:
            module_name = 'builtins'
            object_name = name
        if unsafe:
            try:
                __import__(module_name)
            except ImportError as exc:
                raise ConstructorError("while constructing a Python object", mark,
                        "cannot find module %r (%s)" % (module_name, exc), mark)
        if module_name not in sys.modules:
            raise ConstructorError("while constructing a Python object", mark,
                    "module %r is not imported" % module_name, mark)
        module = sys.modules[module_name]
        if not hasattr(module, object_name):
            raise ConstructorError("while constructing a Python object", mark,
                    "cannot find %r in the module %r"
                    % (object_name, module.__name__), mark)
        return getattr(module, object_name)

    def construct_python_name(self, suffix, node):
        value = self.construct_scalar(node)
        if value:
            raise ConstructorError("while constructing a Python name", node.start_mark,
                    "expected the empty value, but found %r" % value, node.start_mark)
        return self.find_python_name(suffix, node.start_mark)

    def construct_python_module(self, suffix, node):
        value = self.construct_scalar(node)
        if value:
            raise ConstructorError("while constructing a Python module", node.start_mark,
                    "expected the empty value, but found %r" % value, node.start_mark)
        return self.find_python_module(suffix, node.start_mark)

    def make_python_instance(self, suffix, node,
            args=None, kwds=None, newobj=False, unsafe=False):
        if not args:
            args = []
        if not kwds:
            kwds = {}
        cls = self.find_python_name(suffix, node.start_mark)
        if not (unsafe or isinstance(cls, type)):
            raise ConstructorError("while constructing a Python instance", node.start_mark,
                    "expected a class, but found %r" % type(cls),
                    node.start_mark)
        if newobj and isinstance(cls, type):
            return cls.__new__(cls, *args, **kwds)
        else:
            return cls(*args, **kwds)

    def set_python_instance_state(self, instance, state, unsafe=False):
        if hasattr(instance, '__setstate__'):
            instance.__setstate__(state)
        else:
            slotstate = {}
            if isinstance(state, tuple) and len(state) == 2:
                state, slotstate = state
            if hasattr(instance, '__dict__'):
                if not unsafe and state:
                    for key in state.keys():
                        self.check_state_key(key)
                instance.__dict__.update(state)
            elif state:
                slotstate.update(state)
            for key, value in slotstate.items():
                if not unsafe:
                    self.check_state_key(key)
                setattr(instance, key, value)

    def construct_python_object(self, suffix, node):
        # Format:
        #   !!python/object:module.name { ... state ... }
        instance = self.make_python_instance(suffix, node, newobj=True)
        yield instance
        deep = hasattr(instance, '__setstate__')
        state = self.construct_mapping(node, deep=deep)
        self.set_python_instance_state(instance, state)

    def construct_python_object_apply(self, suffix, node, newobj=False):
        # Format:
        #   !!python/object/apply       # (or !!python/object/new)
        #   args: [ ... arguments ... ]
        #   kwds: { ... keywords ... }
        #   state: ... state ...
        #   listitems: [ ... listitems ... ]
        #   dictitems: { ... dictitems ... }
        # or short format:
        #   !!python/object/apply [ ... arguments ... ]
        # The difference between !!python/object/apply and !!python/object/new
        # is how an object is created, check make_python_instance for details.
        if isinstance(node, SequenceNode):
            args = self.construct_sequence(node, deep=True)
            kwds = {}
            state = {}
            listitems = []
            dictitems = {}
        else:
            value = self.construct_mapping(node, deep=True)
            args = value.get('args', [])
            kwds = value.get('kwds', {})
            state = value.get('state', {})
            listitems = value.get('listitems', [])
            dictitems = value.get('dictitems', {})
        instance = self.make_python_instance(suffix, node, args, kwds, newobj)
        if state:
            self.set_python_instance_state(instance, state)
        if listitems:
            instance.extend(listitems)
        if dictitems:
            for key in dictitems:
                instance[key] = dictitems[key]
        return instance

    def construct_python_object_new(self, suffix, node):
        return self.construct_python_object_apply(suffix, node, newobj=True)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/none',
    FullConstructor.construct_yaml_null)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/bool',
    FullConstructor.construct_yaml_bool)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/str',
    FullConstructor.construct_python_str)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/unicode',
    FullConstructor.construct_python_unicode)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/bytes',
    FullConstructor.construct_python_bytes)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/int',
    FullConstructor.construct_yaml_int)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/long',
    FullConstructor.construct_python_long)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/float',
    FullConstructor.construct_yaml_float)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/complex',
    FullConstructor.construct_python_complex)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/list',
    FullConstructor.construct_yaml_seq)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/tuple',
    FullConstructor.construct_python_tuple)

FullConstructor.add_constructor(
    'tag:yaml.org,2002:python/dict',
    FullConstructor.construct_yaml_map)

FullConstructor.add_multi_constructor(
    'tag:yaml.org,2002:python/name:',
    FullConstructor.construct_python_name)

class UnsafeConstructor(FullConstructor):

    def find_python_module(self, name, mark):
        return super(UnsafeConstructor, self).find_python_module(name, mark, unsafe=True)

    def find_python_name(self, name, mark):
        return super(UnsafeConstructor, self).find_python_name(name, mark, unsafe=True)

    def make_python_instance(self, suffix, node, args=None, kwds=None, newobj=False):
        return super(UnsafeConstructor, self).make_python_instance(
            suffix, node, args, kwds, newobj, unsafe=True)

    def set_python_instance_state(self, instance, state):
        return super(UnsafeConstructor, self).set_python_instance_state(
            instance, state, unsafe=True)

UnsafeConstructor.add_multi_constructor(
    'tag:yaml.org,2002:python/module:',
    UnsafeConstructor.construct_python_module)

UnsafeConstructor.add_multi_constructor(
    'tag:yaml.org,2002:python/object:',
    UnsafeConstructor.construct_python_object)

UnsafeConstructor.add_multi_constructor(
    'tag:yaml.org,2002:python/object/new:',
    UnsafeConstructor.construct_python_object_new)

UnsafeConstructor.add_multi_constructor(
    'tag:yaml.org,2002:python/object/apply:',
    UnsafeConstructor.construct_python_object_apply)

# Constructor is same as UnsafeConstructor. Need to leave this in place in case
# people have extended it directly.
class Constructor(UnsafeConstructor):
    pass


# ================================================================================
# Datei: venv\Lib\site-packages\yaml\cyaml.py
# ================================================================================


__all__ = [
    'CBaseLoader', 'CSafeLoader', 'CFullLoader', 'CUnsafeLoader', 'CLoader',
    'CBaseDumper', 'CSafeDumper', 'CDumper'
]

from yaml._yaml import CParser, CEmitter

from .constructor import *

from .serializer import *
from .representer import *

from .resolver import *

class CBaseLoader(CParser, BaseConstructor, BaseResolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        BaseConstructor.__init__(self)
        BaseResolver.__init__(self)

class CSafeLoader(CParser, SafeConstructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        SafeConstructor.__init__(self)
        Resolver.__init__(self)

class CFullLoader(CParser, FullConstructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        FullConstructor.__init__(self)
        Resolver.__init__(self)

class CUnsafeLoader(CParser, UnsafeConstructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        UnsafeConstructor.__init__(self)
        Resolver.__init__(self)

class CLoader(CParser, Constructor, Resolver):

    def __init__(self, stream):
        CParser.__init__(self, stream)
        Constructor.__init__(self)
        Resolver.__init__(self)

class CBaseDumper(CEmitter, BaseRepresenter, BaseResolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=False,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None, sort_keys=True):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style, sort_keys=sort_keys)
        Resolver.__init__(self)

class CSafeDumper(CEmitter, SafeRepresenter, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=False,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None, sort_keys=True):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        SafeRepresenter.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style, sort_keys=sort_keys)
        Resolver.__init__(self)

class CDumper(CEmitter, Serializer, Representer, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=False,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None, sort_keys=True):
        CEmitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width, encoding=encoding,
                allow_unicode=allow_unicode, line_break=line_break,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style, sort_keys=sort_keys)
        Resolver.__init__(self)



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\dumper.py
# ================================================================================


__all__ = ['BaseDumper', 'SafeDumper', 'Dumper']

from .emitter import *
from .serializer import *
from .representer import *
from .resolver import *

class BaseDumper(Emitter, Serializer, BaseRepresenter, BaseResolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=False,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None, sort_keys=True):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style, sort_keys=sort_keys)
        Resolver.__init__(self)

class SafeDumper(Emitter, Serializer, SafeRepresenter, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=False,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None, sort_keys=True):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        SafeRepresenter.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style, sort_keys=sort_keys)
        Resolver.__init__(self)

class Dumper(Emitter, Serializer, Representer, Resolver):

    def __init__(self, stream,
            default_style=None, default_flow_style=False,
            canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None,
            encoding=None, explicit_start=None, explicit_end=None,
            version=None, tags=None, sort_keys=True):
        Emitter.__init__(self, stream, canonical=canonical,
                indent=indent, width=width,
                allow_unicode=allow_unicode, line_break=line_break)
        Serializer.__init__(self, encoding=encoding,
                explicit_start=explicit_start, explicit_end=explicit_end,
                version=version, tags=tags)
        Representer.__init__(self, default_style=default_style,
                default_flow_style=default_flow_style, sort_keys=sort_keys)
        Resolver.__init__(self)



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\emitter.py
# ================================================================================


# Emitter expects events obeying the following grammar:
# stream ::= STREAM-START document* STREAM-END
# document ::= DOCUMENT-START node DOCUMENT-END
# node ::= SCALAR | sequence | mapping
# sequence ::= SEQUENCE-START node* SEQUENCE-END
# mapping ::= MAPPING-START (node node)* MAPPING-END

__all__ = ['Emitter', 'EmitterError']

from .error import YAMLError
from .events import *

class EmitterError(YAMLError):
    pass

class ScalarAnalysis:
    def __init__(self, scalar, empty, multiline,
            allow_flow_plain, allow_block_plain,
            allow_single_quoted, allow_double_quoted,
            allow_block):
        self.scalar = scalar
        self.empty = empty
        self.multiline = multiline
        self.allow_flow_plain = allow_flow_plain
        self.allow_block_plain = allow_block_plain
        self.allow_single_quoted = allow_single_quoted
        self.allow_double_quoted = allow_double_quoted
        self.allow_block = allow_block

class Emitter:

    DEFAULT_TAG_PREFIXES = {
        '!' : '!',
        'tag:yaml.org,2002:' : '!!',
    }

    def __init__(self, stream, canonical=None, indent=None, width=None,
            allow_unicode=None, line_break=None):

        # The stream should have the methods `write` and possibly `flush`.
        self.stream = stream

        # Encoding can be overridden by STREAM-START.
        self.encoding = None

        # Emitter is a state machine with a stack of states to handle nested
        # structures.
        self.states = []
        self.state = self.expect_stream_start

        # Current event and the event queue.
        self.events = []
        self.event = None

        # The current indentation level and the stack of previous indents.
        self.indents = []
        self.indent = None

        # Flow level.
        self.flow_level = 0

        # Contexts.
        self.root_context = False
        self.sequence_context = False
        self.mapping_context = False
        self.simple_key_context = False

        # Characteristics of the last emitted character:
        #  - current position.
        #  - is it a whitespace?
        #  - is it an indention character
        #    (indentation space, '-', '?', or ':')?
        self.line = 0
        self.column = 0
        self.whitespace = True
        self.indention = True

        # Whether the document requires an explicit document indicator
        self.open_ended = False

        # Formatting details.
        self.canonical = canonical
        self.allow_unicode = allow_unicode
        self.best_indent = 2
        if indent and 1 < indent < 10:
            self.best_indent = indent
        self.best_width = 80
        if width and width > self.best_indent*2:
            self.best_width = width
        self.best_line_break = '\n'
        if line_break in ['\r', '\n', '\r\n']:
            self.best_line_break = line_break

        # Tag prefixes.
        self.tag_prefixes = None

        # Prepared anchor and tag.
        self.prepared_anchor = None
        self.prepared_tag = None

        # Scalar analysis and style.
        self.analysis = None
        self.style = None

    def dispose(self):
        # Reset the state attributes (to clear self-references)
        self.states = []
        self.state = None

    def emit(self, event):
        self.events.append(event)
        while not self.need_more_events():
            self.event = self.events.pop(0)
            self.state()
            self.event = None

    # In some cases, we wait for a few next events before emitting.

    def need_more_events(self):
        if not self.events:
            return True
        event = self.events[0]
        if isinstance(event, DocumentStartEvent):
            return self.need_events(1)
        elif isinstance(event, SequenceStartEvent):
            return self.need_events(2)
        elif isinstance(event, MappingStartEvent):
            return self.need_events(3)
        else:
            return False

    def need_events(self, count):
        level = 0
        for event in self.events[1:]:
            if isinstance(event, (DocumentStartEvent, CollectionStartEvent)):
                level += 1
            elif isinstance(event, (DocumentEndEvent, CollectionEndEvent)):
                level -= 1
            elif isinstance(event, StreamEndEvent):
                level = -1
            if level < 0:
                return False
        return (len(self.events) < count+1)

    def increase_indent(self, flow=False, indentless=False):
        self.indents.append(self.indent)
        if self.indent is None:
            if flow:
                self.indent = self.best_indent
            else:
                self.indent = 0
        elif not indentless:
            self.indent += self.best_indent

    # States.

    # Stream handlers.

    def expect_stream_start(self):
        if isinstance(self.event, StreamStartEvent):
            if self.event.encoding and not hasattr(self.stream, 'encoding'):
                self.encoding = self.event.encoding
            self.write_stream_start()
            self.state = self.expect_first_document_start
        else:
            raise EmitterError("expected StreamStartEvent, but got %s"
                    % self.event)

    def expect_nothing(self):
        raise EmitterError("expected nothing, but got %s" % self.event)

    # Document handlers.

    def expect_first_document_start(self):
        return self.expect_document_start(first=True)

    def expect_document_start(self, first=False):
        if isinstance(self.event, DocumentStartEvent):
            if (self.event.version or self.event.tags) and self.open_ended:
                self.write_indicator('...', True)
                self.write_indent()
            if self.event.version:
                version_text = self.prepare_version(self.event.version)
                self.write_version_directive(version_text)
            self.tag_prefixes = self.DEFAULT_TAG_PREFIXES.copy()
            if self.event.tags:
                handles = sorted(self.event.tags.keys())
                for handle in handles:
                    prefix = self.event.tags[handle]
                    self.tag_prefixes[prefix] = handle
                    handle_text = self.prepare_tag_handle(handle)
                    prefix_text = self.prepare_tag_prefix(prefix)
                    self.write_tag_directive(handle_text, prefix_text)
            implicit = (first and not self.event.explicit and not self.canonical
                    and not self.event.version and not self.event.tags
                    and not self.check_empty_document())
            if not implicit:
                self.write_indent()
                self.write_indicator('---', True)
                if self.canonical:
                    self.write_indent()
            self.state = self.expect_document_root
        elif isinstance(self.event, StreamEndEvent):
            if self.open_ended:
                self.write_indicator('...', True)
                self.write_indent()
            self.write_stream_end()
            self.state = self.expect_nothing
        else:
            raise EmitterError("expected DocumentStartEvent, but got %s"
                    % self.event)

    def expect_document_end(self):
        if isinstance(self.event, DocumentEndEvent):
            self.write_indent()
            if self.event.explicit:
                self.write_indicator('...', True)
                self.write_indent()
            self.flush_stream()
            self.state = self.expect_document_start
        else:
            raise EmitterError("expected DocumentEndEvent, but got %s"
                    % self.event)

    def expect_document_root(self):
        self.states.append(self.expect_document_end)
        self.expect_node(root=True)

    # Node handlers.

    def expect_node(self, root=False, sequence=False, mapping=False,
            simple_key=False):
        self.root_context = root
        self.sequence_context = sequence
        self.mapping_context = mapping
        self.simple_key_context = simple_key
        if isinstance(self.event, AliasEvent):
            self.expect_alias()
        elif isinstance(self.event, (ScalarEvent, CollectionStartEvent)):
            self.process_anchor('&')
            self.process_tag()
            if isinstance(self.event, ScalarEvent):
                self.expect_scalar()
            elif isinstance(self.event, SequenceStartEvent):
                if self.flow_level or self.canonical or self.event.flow_style   \
                        or self.check_empty_sequence():
                    self.expect_flow_sequence()
                else:
                    self.expect_block_sequence()
            elif isinstance(self.event, MappingStartEvent):
                if self.flow_level or self.canonical or self.event.flow_style   \
                        or self.check_empty_mapping():
                    self.expect_flow_mapping()
                else:
                    self.expect_block_mapping()
        else:
            raise EmitterError("expected NodeEvent, but got %s" % self.event)

    def expect_alias(self):
        if self.event.anchor is None:
            raise EmitterError("anchor is not specified for alias")
        self.process_anchor('*')
        self.state = self.states.pop()

    def expect_scalar(self):
        self.increase_indent(flow=True)
        self.process_scalar()
        self.indent = self.indents.pop()
        self.state = self.states.pop()

    # Flow sequence handlers.

    def expect_flow_sequence(self):
        self.write_indicator('[', True, whitespace=True)
        self.flow_level += 1
        self.increase_indent(flow=True)
        self.state = self.expect_first_flow_sequence_item

    def expect_first_flow_sequence_item(self):
        if isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            self.write_indicator(']', False)
            self.state = self.states.pop()
        else:
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            self.states.append(self.expect_flow_sequence_item)
            self.expect_node(sequence=True)

    def expect_flow_sequence_item(self):
        if isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            if self.canonical:
                self.write_indicator(',', False)
                self.write_indent()
            self.write_indicator(']', False)
            self.state = self.states.pop()
        else:
            self.write_indicator(',', False)
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            self.states.append(self.expect_flow_sequence_item)
            self.expect_node(sequence=True)

    # Flow mapping handlers.

    def expect_flow_mapping(self):
        self.write_indicator('{', True, whitespace=True)
        self.flow_level += 1
        self.increase_indent(flow=True)
        self.state = self.expect_first_flow_mapping_key

    def expect_first_flow_mapping_key(self):
        if isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            self.write_indicator('}', False)
            self.state = self.states.pop()
        else:
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            if not self.canonical and self.check_simple_key():
                self.states.append(self.expect_flow_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator('?', True)
                self.states.append(self.expect_flow_mapping_value)
                self.expect_node(mapping=True)

    def expect_flow_mapping_key(self):
        if isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.flow_level -= 1
            if self.canonical:
                self.write_indicator(',', False)
                self.write_indent()
            self.write_indicator('}', False)
            self.state = self.states.pop()
        else:
            self.write_indicator(',', False)
            if self.canonical or self.column > self.best_width:
                self.write_indent()
            if not self.canonical and self.check_simple_key():
                self.states.append(self.expect_flow_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator('?', True)
                self.states.append(self.expect_flow_mapping_value)
                self.expect_node(mapping=True)

    def expect_flow_mapping_simple_value(self):
        self.write_indicator(':', False)
        self.states.append(self.expect_flow_mapping_key)
        self.expect_node(mapping=True)

    def expect_flow_mapping_value(self):
        if self.canonical or self.column > self.best_width:
            self.write_indent()
        self.write_indicator(':', True)
        self.states.append(self.expect_flow_mapping_key)
        self.expect_node(mapping=True)

    # Block sequence handlers.

    def expect_block_sequence(self):
        indentless = (self.mapping_context and not self.indention)
        self.increase_indent(flow=False, indentless=indentless)
        self.state = self.expect_first_block_sequence_item

    def expect_first_block_sequence_item(self):
        return self.expect_block_sequence_item(first=True)

    def expect_block_sequence_item(self, first=False):
        if not first and isinstance(self.event, SequenceEndEvent):
            self.indent = self.indents.pop()
            self.state = self.states.pop()
        else:
            self.write_indent()
            self.write_indicator('-', True, indention=True)
            self.states.append(self.expect_block_sequence_item)
            self.expect_node(sequence=True)

    # Block mapping handlers.

    def expect_block_mapping(self):
        self.increase_indent(flow=False)
        self.state = self.expect_first_block_mapping_key

    def expect_first_block_mapping_key(self):
        return self.expect_block_mapping_key(first=True)

    def expect_block_mapping_key(self, first=False):
        if not first and isinstance(self.event, MappingEndEvent):
            self.indent = self.indents.pop()
            self.state = self.states.pop()
        else:
            self.write_indent()
            if self.check_simple_key():
                self.states.append(self.expect_block_mapping_simple_value)
                self.expect_node(mapping=True, simple_key=True)
            else:
                self.write_indicator('?', True, indention=True)
                self.states.append(self.expect_block_mapping_value)
                self.expect_node(mapping=True)

    def expect_block_mapping_simple_value(self):
        self.write_indicator(':', False)
        self.states.append(self.expect_block_mapping_key)
        self.expect_node(mapping=True)

    def expect_block_mapping_value(self):
        self.write_indent()
        self.write_indicator(':', True, indention=True)
        self.states.append(self.expect_block_mapping_key)
        self.expect_node(mapping=True)

    # Checkers.

    def check_empty_sequence(self):
        return (isinstance(self.event, SequenceStartEvent) and self.events
                and isinstance(self.events[0], SequenceEndEvent))

    def check_empty_mapping(self):
        return (isinstance(self.event, MappingStartEvent) and self.events
                and isinstance(self.events[0], MappingEndEvent))

    def check_empty_document(self):
        if not isinstance(self.event, DocumentStartEvent) or not self.events:
            return False
        event = self.events[0]
        return (isinstance(event, ScalarEvent) and event.anchor is None
                and event.tag is None and event.implicit and event.value == '')

    def check_simple_key(self):
        length = 0
        if isinstance(self.event, NodeEvent) and self.event.anchor is not None:
            if self.prepared_anchor is None:
                self.prepared_anchor = self.prepare_anchor(self.event.anchor)
            length += len(self.prepared_anchor)
        if isinstance(self.event, (ScalarEvent, CollectionStartEvent))  \
                and self.event.tag is not None:
            if self.prepared_tag is None:
                self.prepared_tag = self.prepare_tag(self.event.tag)
            length += len(self.prepared_tag)
        if isinstance(self.event, ScalarEvent):
            if self.analysis is None:
                self.analysis = self.analyze_scalar(self.event.value)
            length += len(self.analysis.scalar)
        return (length < 128 and (isinstance(self.event, AliasEvent)
            or (isinstance(self.event, ScalarEvent)
                    and not self.analysis.empty and not self.analysis.multiline)
            or self.check_empty_sequence() or self.check_empty_mapping()))

    # Anchor, Tag, and Scalar processors.

    def process_anchor(self, indicator):
        if self.event.anchor is None:
            self.prepared_anchor = None
            return
        if self.prepared_anchor is None:
            self.prepared_anchor = self.prepare_anchor(self.event.anchor)
        if self.prepared_anchor:
            self.write_indicator(indicator+self.prepared_anchor, True)
        self.prepared_anchor = None

    def process_tag(self):
        tag = self.event.tag
        if isinstance(self.event, ScalarEvent):
            if self.style is None:
                self.style = self.choose_scalar_style()
            if ((not self.canonical or tag is None) and
                ((self.style == '' and self.event.implicit[0])
                        or (self.style != '' and self.event.implicit[1]))):
                self.prepared_tag = None
                return
            if self.event.implicit[0] and tag is None:
                tag = '!'
                self.prepared_tag = None
        else:
            if (not self.canonical or tag is None) and self.event.implicit:
                self.prepared_tag = None
                return
        if tag is None:
            raise EmitterError("tag is not specified")
        if self.prepared_tag is None:
            self.prepared_tag = self.prepare_tag(tag)
        if self.prepared_tag:
            self.write_indicator(self.prepared_tag, True)
        self.prepared_tag = None

    def choose_scalar_style(self):
        if self.analysis is None:
            self.analysis = self.analyze_scalar(self.event.value)
        if self.event.style == '"' or self.canonical:
            return '"'
        if not self.event.style and self.event.implicit[0]:
            if (not (self.simple_key_context and
                    (self.analysis.empty or self.analysis.multiline))
                and (self.flow_level and self.analysis.allow_flow_plain
                    or (not self.flow_level and self.analysis.allow_block_plain))):
                return ''
        if self.event.style and self.event.style in '|>':
            if (not self.flow_level and not self.simple_key_context
                    and self.analysis.allow_block):
                return self.event.style
        if not self.event.style or self.event.style == '\'':
            if (self.analysis.allow_single_quoted and
                    not (self.simple_key_context and self.analysis.multiline)):
                return '\''
        return '"'

    def process_scalar(self):
        if self.analysis is None:
            self.analysis = self.analyze_scalar(self.event.value)
        if self.style is None:
            self.style = self.choose_scalar_style()
        split = (not self.simple_key_context)
        #if self.analysis.multiline and split    \
        #        and (not self.style or self.style in '\'\"'):
        #    self.write_indent()
        if self.style == '"':
            self.write_double_quoted(self.analysis.scalar, split)
        elif self.style == '\'':
            self.write_single_quoted(self.analysis.scalar, split)
        elif self.style == '>':
            self.write_folded(self.analysis.scalar)
        elif self.style == '|':
            self.write_literal(self.analysis.scalar)
        else:
            self.write_plain(self.analysis.scalar, split)
        self.analysis = None
        self.style = None

    # Analyzers.

    def prepare_version(self, version):
        major, minor = version
        if major != 1:
            raise EmitterError("unsupported YAML version: %d.%d" % (major, minor))
        return '%d.%d' % (major, minor)

    def prepare_tag_handle(self, handle):
        if not handle:
            raise EmitterError("tag handle must not be empty")
        if handle[0] != '!' or handle[-1] != '!':
            raise EmitterError("tag handle must start and end with '!': %r" % handle)
        for ch in handle[1:-1]:
            if not ('0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'    \
                    or ch in '-_'):
                raise EmitterError("invalid character %r in the tag handle: %r"
                        % (ch, handle))
        return handle

    def prepare_tag_prefix(self, prefix):
        if not prefix:
            raise EmitterError("tag prefix must not be empty")
        chunks = []
        start = end = 0
        if prefix[0] == '!':
            end = 1
        while end < len(prefix):
            ch = prefix[end]
            if '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z' \
                    or ch in '-;/?!:@&=+$,_.~*\'()[]':
                end += 1
            else:
                if start < end:
                    chunks.append(prefix[start:end])
                start = end = end+1
                data = ch.encode('utf-8')
                for ch in data:
                    chunks.append('%%%02X' % ord(ch))
        if start < end:
            chunks.append(prefix[start:end])
        return ''.join(chunks)

    def prepare_tag(self, tag):
        if not tag:
            raise EmitterError("tag must not be empty")
        if tag == '!':
            return tag
        handle = None
        suffix = tag
        prefixes = sorted(self.tag_prefixes.keys())
        for prefix in prefixes:
            if tag.startswith(prefix)   \
                    and (prefix == '!' or len(prefix) < len(tag)):
                handle = self.tag_prefixes[prefix]
                suffix = tag[len(prefix):]
        chunks = []
        start = end = 0
        while end < len(suffix):
            ch = suffix[end]
            if '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z' \
                    or ch in '-;/?:@&=+$,_.~*\'()[]'   \
                    or (ch == '!' and handle != '!'):
                end += 1
            else:
                if start < end:
                    chunks.append(suffix[start:end])
                start = end = end+1
                data = ch.encode('utf-8')
                for ch in data:
                    chunks.append('%%%02X' % ch)
        if start < end:
            chunks.append(suffix[start:end])
        suffix_text = ''.join(chunks)
        if handle:
            return '%s%s' % (handle, suffix_text)
        else:
            return '!<%s>' % suffix_text

    def prepare_anchor(self, anchor):
        if not anchor:
            raise EmitterError("anchor must not be empty")
        for ch in anchor:
            if not ('0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'    \
                    or ch in '-_'):
                raise EmitterError("invalid character %r in the anchor: %r"
                        % (ch, anchor))
        return anchor

    def analyze_scalar(self, scalar):

        # Empty scalar is a special case.
        if not scalar:
            return ScalarAnalysis(scalar=scalar, empty=True, multiline=False,
                    allow_flow_plain=False, allow_block_plain=True,
                    allow_single_quoted=True, allow_double_quoted=True,
                    allow_block=False)

        # Indicators and special characters.
        block_indicators = False
        flow_indicators = False
        line_breaks = False
        special_characters = False

        # Important whitespace combinations.
        leading_space = False
        leading_break = False
        trailing_space = False
        trailing_break = False
        break_space = False
        space_break = False

        # Check document indicators.
        if scalar.startswith('---') or scalar.startswith('...'):
            block_indicators = True
            flow_indicators = True

        # First character or preceded by a whitespace.
        preceded_by_whitespace = True

        # Last character or followed by a whitespace.
        followed_by_whitespace = (len(scalar) == 1 or
                scalar[1] in '\0 \t\r\n\x85\u2028\u2029')

        # The previous character is a space.
        previous_space = False

        # The previous character is a break.
        previous_break = False

        index = 0
        while index < len(scalar):
            ch = scalar[index]

            # Check for indicators.
            if index == 0:
                # Leading indicators are special characters.
                if ch in '#,[]{}&*!|>\'\"%@`':
                    flow_indicators = True
                    block_indicators = True
                if ch in '?:':
                    flow_indicators = True
                    if followed_by_whitespace:
                        block_indicators = True
                if ch == '-' and followed_by_whitespace:
                    flow_indicators = True
                    block_indicators = True
            else:
                # Some indicators cannot appear within a scalar as well.
                if ch in ',?[]{}':
                    flow_indicators = True
                if ch == ':':
                    flow_indicators = True
                    if followed_by_whitespace:
                        block_indicators = True
                if ch == '#' and preceded_by_whitespace:
                    flow_indicators = True
                    block_indicators = True

            # Check for line breaks, special, and unicode characters.
            if ch in '\n\x85\u2028\u2029':
                line_breaks = True
            if not (ch == '\n' or '\x20' <= ch <= '\x7E'):
                if (ch == '\x85' or '\xA0' <= ch <= '\uD7FF'
                        or '\uE000' <= ch <= '\uFFFD'
                        or '\U00010000' <= ch < '\U0010ffff') and ch != '\uFEFF':
                    unicode_characters = True
                    if not self.allow_unicode:
                        special_characters = True
                else:
                    special_characters = True

            # Detect important whitespace combinations.
            if ch == ' ':
                if index == 0:
                    leading_space = True
                if index == len(scalar)-1:
                    trailing_space = True
                if previous_break:
                    break_space = True
                previous_space = True
                previous_break = False
            elif ch in '\n\x85\u2028\u2029':
                if index == 0:
                    leading_break = True
                if index == len(scalar)-1:
                    trailing_break = True
                if previous_space:
                    space_break = True
                previous_space = False
                previous_break = True
            else:
                previous_space = False
                previous_break = False

            # Prepare for the next character.
            index += 1
            preceded_by_whitespace = (ch in '\0 \t\r\n\x85\u2028\u2029')
            followed_by_whitespace = (index+1 >= len(scalar) or
                    scalar[index+1] in '\0 \t\r\n\x85\u2028\u2029')

        # Let's decide what styles are allowed.
        allow_flow_plain = True
        allow_block_plain = True
        allow_single_quoted = True
        allow_double_quoted = True
        allow_block = True

        # Leading and trailing whitespaces are bad for plain scalars.
        if (leading_space or leading_break
                or trailing_space or trailing_break):
            allow_flow_plain = allow_block_plain = False

        # We do not permit trailing spaces for block scalars.
        if trailing_space:
            allow_block = False

        # Spaces at the beginning of a new line are only acceptable for block
        # scalars.
        if break_space:
            allow_flow_plain = allow_block_plain = allow_single_quoted = False

        # Spaces followed by breaks, as well as special character are only
        # allowed for double quoted scalars.
        if space_break or special_characters:
            allow_flow_plain = allow_block_plain =  \
            allow_single_quoted = allow_block = False

        # Although the plain scalar writer supports breaks, we never emit
        # multiline plain scalars.
        if line_breaks:
            allow_flow_plain = allow_block_plain = False

        # Flow indicators are forbidden for flow plain scalars.
        if flow_indicators:
            allow_flow_plain = False

        # Block indicators are forbidden for block plain scalars.
        if block_indicators:
            allow_block_plain = False

        return ScalarAnalysis(scalar=scalar,
                empty=False, multiline=line_breaks,
                allow_flow_plain=allow_flow_plain,
                allow_block_plain=allow_block_plain,
                allow_single_quoted=allow_single_quoted,
                allow_double_quoted=allow_double_quoted,
                allow_block=allow_block)

    # Writers.

    def flush_stream(self):
        if hasattr(self.stream, 'flush'):
            self.stream.flush()

    def write_stream_start(self):
        # Write BOM if needed.
        if self.encoding and self.encoding.startswith('utf-16'):
            self.stream.write('\uFEFF'.encode(self.encoding))

    def write_stream_end(self):
        self.flush_stream()

    def write_indicator(self, indicator, need_whitespace,
            whitespace=False, indention=False):
        if self.whitespace or not need_whitespace:
            data = indicator
        else:
            data = ' '+indicator
        self.whitespace = whitespace
        self.indention = self.indention and indention
        self.column += len(data)
        self.open_ended = False
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)

    def write_indent(self):
        indent = self.indent or 0
        if not self.indention or self.column > indent   \
                or (self.column == indent and not self.whitespace):
            self.write_line_break()
        if self.column < indent:
            self.whitespace = True
            data = ' '*(indent-self.column)
            self.column = indent
            if self.encoding:
                data = data.encode(self.encoding)
            self.stream.write(data)

    def write_line_break(self, data=None):
        if data is None:
            data = self.best_line_break
        self.whitespace = True
        self.indention = True
        self.line += 1
        self.column = 0
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)

    def write_version_directive(self, version_text):
        data = '%%YAML %s' % version_text
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)
        self.write_line_break()

    def write_tag_directive(self, handle_text, prefix_text):
        data = '%%TAG %s %s' % (handle_text, prefix_text)
        if self.encoding:
            data = data.encode(self.encoding)
        self.stream.write(data)
        self.write_line_break()

    # Scalar streams.

    def write_single_quoted(self, text, split=True):
        self.write_indicator('\'', True)
        spaces = False
        breaks = False
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if spaces:
                if ch is None or ch != ' ':
                    if start+1 == end and self.column > self.best_width and split   \
                            and start != 0 and end != len(text):
                        self.write_indent()
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            elif breaks:
                if ch is None or ch not in '\n\x85\u2028\u2029':
                    if text[start] == '\n':
                        self.write_line_break()
                    for br in text[start:end]:
                        if br == '\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    self.write_indent()
                    start = end
            else:
                if ch is None or ch in ' \n\x85\u2028\u2029' or ch == '\'':
                    if start < end:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                        start = end
            if ch == '\'':
                data = '\'\''
                self.column += 2
                if self.encoding:
                    data = data.encode(self.encoding)
                self.stream.write(data)
                start = end + 1
            if ch is not None:
                spaces = (ch == ' ')
                breaks = (ch in '\n\x85\u2028\u2029')
            end += 1
        self.write_indicator('\'', False)

    ESCAPE_REPLACEMENTS = {
        '\0':       '0',
        '\x07':     'a',
        '\x08':     'b',
        '\x09':     't',
        '\x0A':     'n',
        '\x0B':     'v',
        '\x0C':     'f',
        '\x0D':     'r',
        '\x1B':     'e',
        '\"':       '\"',
        '\\':       '\\',
        '\x85':     'N',
        '\xA0':     '_',
        '\u2028':   'L',
        '\u2029':   'P',
    }

    def write_double_quoted(self, text, split=True):
        self.write_indicator('"', True)
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if ch is None or ch in '"\\\x85\u2028\u2029\uFEFF' \
                    or not ('\x20' <= ch <= '\x7E'
                        or (self.allow_unicode
                            and ('\xA0' <= ch <= '\uD7FF'
                                or '\uE000' <= ch <= '\uFFFD'))):
                if start < end:
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end
                if ch is not None:
                    if ch in self.ESCAPE_REPLACEMENTS:
                        data = '\\'+self.ESCAPE_REPLACEMENTS[ch]
                    elif ch <= '\xFF':
                        data = '\\x%02X' % ord(ch)
                    elif ch <= '\uFFFF':
                        data = '\\u%04X' % ord(ch)
                    else:
                        data = '\\U%08X' % ord(ch)
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end+1
            if 0 < end < len(text)-1 and (ch == ' ' or start >= end)    \
                    and self.column+(end-start) > self.best_width and split:
                data = text[start:end]+'\\'
                if start < end:
                    start = end
                self.column += len(data)
                if self.encoding:
                    data = data.encode(self.encoding)
                self.stream.write(data)
                self.write_indent()
                self.whitespace = False
                self.indention = False
                if text[start] == ' ':
                    data = '\\'
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
            end += 1
        self.write_indicator('"', False)

    def determine_block_hints(self, text):
        hints = ''
        if text:
            if text[0] in ' \n\x85\u2028\u2029':
                hints += str(self.best_indent)
            if text[-1] not in '\n\x85\u2028\u2029':
                hints += '-'
            elif len(text) == 1 or text[-2] in '\n\x85\u2028\u2029':
                hints += '+'
        return hints

    def write_folded(self, text):
        hints = self.determine_block_hints(text)
        self.write_indicator('>'+hints, True)
        if hints[-1:] == '+':
            self.open_ended = True
        self.write_line_break()
        leading_space = True
        spaces = False
        breaks = True
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if breaks:
                if ch is None or ch not in '\n\x85\u2028\u2029':
                    if not leading_space and ch is not None and ch != ' '   \
                            and text[start] == '\n':
                        self.write_line_break()
                    leading_space = (ch == ' ')
                    for br in text[start:end]:
                        if br == '\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    if ch is not None:
                        self.write_indent()
                    start = end
            elif spaces:
                if ch != ' ':
                    if start+1 == end and self.column > self.best_width:
                        self.write_indent()
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            else:
                if ch is None or ch in ' \n\x85\u2028\u2029':
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    if ch is None:
                        self.write_line_break()
                    start = end
            if ch is not None:
                breaks = (ch in '\n\x85\u2028\u2029')
                spaces = (ch == ' ')
            end += 1

    def write_literal(self, text):
        hints = self.determine_block_hints(text)
        self.write_indicator('|'+hints, True)
        if hints[-1:] == '+':
            self.open_ended = True
        self.write_line_break()
        breaks = True
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if breaks:
                if ch is None or ch not in '\n\x85\u2028\u2029':
                    for br in text[start:end]:
                        if br == '\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    if ch is not None:
                        self.write_indent()
                    start = end
            else:
                if ch is None or ch in '\n\x85\u2028\u2029':
                    data = text[start:end]
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    if ch is None:
                        self.write_line_break()
                    start = end
            if ch is not None:
                breaks = (ch in '\n\x85\u2028\u2029')
            end += 1

    def write_plain(self, text, split=True):
        if self.root_context:
            self.open_ended = True
        if not text:
            return
        if not self.whitespace:
            data = ' '
            self.column += len(data)
            if self.encoding:
                data = data.encode(self.encoding)
            self.stream.write(data)
        self.whitespace = False
        self.indention = False
        spaces = False
        breaks = False
        start = end = 0
        while end <= len(text):
            ch = None
            if end < len(text):
                ch = text[end]
            if spaces:
                if ch != ' ':
                    if start+1 == end and self.column > self.best_width and split:
                        self.write_indent()
                        self.whitespace = False
                        self.indention = False
                    else:
                        data = text[start:end]
                        self.column += len(data)
                        if self.encoding:
                            data = data.encode(self.encoding)
                        self.stream.write(data)
                    start = end
            elif breaks:
                if ch not in '\n\x85\u2028\u2029':
                    if text[start] == '\n':
                        self.write_line_break()
                    for br in text[start:end]:
                        if br == '\n':
                            self.write_line_break()
                        else:
                            self.write_line_break(br)
                    self.write_indent()
                    self.whitespace = False
                    self.indention = False
                    start = end
            else:
                if ch is None or ch in ' \n\x85\u2028\u2029':
                    data = text[start:end]
                    self.column += len(data)
                    if self.encoding:
                        data = data.encode(self.encoding)
                    self.stream.write(data)
                    start = end
            if ch is not None:
                spaces = (ch == ' ')
                breaks = (ch in '\n\x85\u2028\u2029')
            end += 1


# ================================================================================
# Datei: venv\Lib\site-packages\yaml\error.py
# ================================================================================


__all__ = ['Mark', 'YAMLError', 'MarkedYAMLError']

class Mark:

    def __init__(self, name, index, line, column, buffer, pointer):
        self.name = name
        self.index = index
        self.line = line
        self.column = column
        self.buffer = buffer
        self.pointer = pointer

    def get_snippet(self, indent=4, max_length=75):
        if self.buffer is None:
            return None
        head = ''
        start = self.pointer
        while start > 0 and self.buffer[start-1] not in '\0\r\n\x85\u2028\u2029':
            start -= 1
            if self.pointer-start > max_length/2-1:
                head = ' ... '
                start += 5
                break
        tail = ''
        end = self.pointer
        while end < len(self.buffer) and self.buffer[end] not in '\0\r\n\x85\u2028\u2029':
            end += 1
            if end-self.pointer > max_length/2-1:
                tail = ' ... '
                end -= 5
                break
        snippet = self.buffer[start:end]
        return ' '*indent + head + snippet + tail + '\n'  \
                + ' '*(indent+self.pointer-start+len(head)) + '^'

    def __str__(self):
        snippet = self.get_snippet()
        where = "  in \"%s\", line %d, column %d"   \
                % (self.name, self.line+1, self.column+1)
        if snippet is not None:
            where += ":\n"+snippet
        return where

class YAMLError(Exception):
    pass

class MarkedYAMLError(YAMLError):

    def __init__(self, context=None, context_mark=None,
            problem=None, problem_mark=None, note=None):
        self.context = context
        self.context_mark = context_mark
        self.problem = problem
        self.problem_mark = problem_mark
        self.note = note

    def __str__(self):
        lines = []
        if self.context is not None:
            lines.append(self.context)
        if self.context_mark is not None  \
            and (self.problem is None or self.problem_mark is None
                    or self.context_mark.name != self.problem_mark.name
                    or self.context_mark.line != self.problem_mark.line
                    or self.context_mark.column != self.problem_mark.column):
            lines.append(str(self.context_mark))
        if self.problem is not None:
            lines.append(self.problem)
        if self.problem_mark is not None:
            lines.append(str(self.problem_mark))
        if self.note is not None:
            lines.append(self.note)
        return '\n'.join(lines)



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\events.py
# ================================================================================


# Abstract classes.

class Event(object):
    def __init__(self, start_mark=None, end_mark=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        attributes = [key for key in ['anchor', 'tag', 'implicit', 'value']
                if hasattr(self, key)]
        arguments = ', '.join(['%s=%r' % (key, getattr(self, key))
                for key in attributes])
        return '%s(%s)' % (self.__class__.__name__, arguments)

class NodeEvent(Event):
    def __init__(self, anchor, start_mark=None, end_mark=None):
        self.anchor = anchor
        self.start_mark = start_mark
        self.end_mark = end_mark

class CollectionStartEvent(NodeEvent):
    def __init__(self, anchor, tag, implicit, start_mark=None, end_mark=None,
            flow_style=None):
        self.anchor = anchor
        self.tag = tag
        self.implicit = implicit
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.flow_style = flow_style

class CollectionEndEvent(Event):
    pass

# Implementations.

class StreamStartEvent(Event):
    def __init__(self, start_mark=None, end_mark=None, encoding=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.encoding = encoding

class StreamEndEvent(Event):
    pass

class DocumentStartEvent(Event):
    def __init__(self, start_mark=None, end_mark=None,
            explicit=None, version=None, tags=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.explicit = explicit
        self.version = version
        self.tags = tags

class DocumentEndEvent(Event):
    def __init__(self, start_mark=None, end_mark=None,
            explicit=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.explicit = explicit

class AliasEvent(NodeEvent):
    pass

class ScalarEvent(NodeEvent):
    def __init__(self, anchor, tag, implicit, value,
            start_mark=None, end_mark=None, style=None):
        self.anchor = anchor
        self.tag = tag
        self.implicit = implicit
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style

class SequenceStartEvent(CollectionStartEvent):
    pass

class SequenceEndEvent(CollectionEndEvent):
    pass

class MappingStartEvent(CollectionStartEvent):
    pass

class MappingEndEvent(CollectionEndEvent):
    pass



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\loader.py
# ================================================================================


__all__ = ['BaseLoader', 'FullLoader', 'SafeLoader', 'Loader', 'UnsafeLoader']

from .reader import *
from .scanner import *
from .parser import *
from .composer import *
from .constructor import *
from .resolver import *

class BaseLoader(Reader, Scanner, Parser, Composer, BaseConstructor, BaseResolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        BaseConstructor.__init__(self)
        BaseResolver.__init__(self)

class FullLoader(Reader, Scanner, Parser, Composer, FullConstructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        FullConstructor.__init__(self)
        Resolver.__init__(self)

class SafeLoader(Reader, Scanner, Parser, Composer, SafeConstructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        SafeConstructor.__init__(self)
        Resolver.__init__(self)

class Loader(Reader, Scanner, Parser, Composer, Constructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        Constructor.__init__(self)
        Resolver.__init__(self)

# UnsafeLoader is the same as Loader (which is and was always unsafe on
# untrusted input). Use of either Loader or UnsafeLoader should be rare, since
# FullLoad should be able to load almost all YAML safely. Loader is left intact
# to ensure backwards compatibility.
class UnsafeLoader(Reader, Scanner, Parser, Composer, Constructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        Constructor.__init__(self)
        Resolver.__init__(self)


# ================================================================================
# Datei: venv\Lib\site-packages\yaml\nodes.py
# ================================================================================


class Node(object):
    def __init__(self, tag, value, start_mark, end_mark):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        value = self.value
        #if isinstance(value, list):
        #    if len(value) == 0:
        #        value = '<empty>'
        #    elif len(value) == 1:
        #        value = '<1 item>'
        #    else:
        #        value = '<%d items>' % len(value)
        #else:
        #    if len(value) > 75:
        #        value = repr(value[:70]+u' ... ')
        #    else:
        #        value = repr(value)
        value = repr(value)
        return '%s(tag=%r, value=%s)' % (self.__class__.__name__, self.tag, value)

class ScalarNode(Node):
    id = 'scalar'
    def __init__(self, tag, value,
            start_mark=None, end_mark=None, style=None):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style

class CollectionNode(Node):
    def __init__(self, tag, value,
            start_mark=None, end_mark=None, flow_style=None):
        self.tag = tag
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.flow_style = flow_style

class SequenceNode(CollectionNode):
    id = 'sequence'

class MappingNode(CollectionNode):
    id = 'mapping'



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\parser.py
# ================================================================================


# The following YAML grammar is LL(1) and is parsed by a recursive descent
# parser.
#
# stream            ::= STREAM-START implicit_document? explicit_document* STREAM-END
# implicit_document ::= block_node DOCUMENT-END*
# explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
# block_node_or_indentless_sequence ::=
#                       ALIAS
#                       | properties (block_content | indentless_block_sequence)?
#                       | block_content
#                       | indentless_block_sequence
# block_node        ::= ALIAS
#                       | properties block_content?
#                       | block_content
# flow_node         ::= ALIAS
#                       | properties flow_content?
#                       | flow_content
# properties        ::= TAG ANCHOR? | ANCHOR TAG?
# block_content     ::= block_collection | flow_collection | SCALAR
# flow_content      ::= flow_collection | SCALAR
# block_collection  ::= block_sequence | block_mapping
# flow_collection   ::= flow_sequence | flow_mapping
# block_sequence    ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
# indentless_sequence   ::= (BLOCK-ENTRY block_node?)+
# block_mapping     ::= BLOCK-MAPPING_START
#                       ((KEY block_node_or_indentless_sequence?)?
#                       (VALUE block_node_or_indentless_sequence?)?)*
#                       BLOCK-END
# flow_sequence     ::= FLOW-SEQUENCE-START
#                       (flow_sequence_entry FLOW-ENTRY)*
#                       flow_sequence_entry?
#                       FLOW-SEQUENCE-END
# flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
# flow_mapping      ::= FLOW-MAPPING-START
#                       (flow_mapping_entry FLOW-ENTRY)*
#                       flow_mapping_entry?
#                       FLOW-MAPPING-END
# flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?
#
# FIRST sets:
#
# stream: { STREAM-START }
# explicit_document: { DIRECTIVE DOCUMENT-START }
# implicit_document: FIRST(block_node)
# block_node: { ALIAS TAG ANCHOR SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START }
# flow_node: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START }
# block_content: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }
# flow_content: { FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }
# block_collection: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START }
# flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }
# block_sequence: { BLOCK-SEQUENCE-START }
# block_mapping: { BLOCK-MAPPING-START }
# block_node_or_indentless_sequence: { ALIAS ANCHOR TAG SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START BLOCK-ENTRY }
# indentless_sequence: { ENTRY }
# flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }
# flow_sequence: { FLOW-SEQUENCE-START }
# flow_mapping: { FLOW-MAPPING-START }
# flow_sequence_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }
# flow_mapping_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }

__all__ = ['Parser', 'ParserError']

from .error import MarkedYAMLError
from .tokens import *
from .events import *
from .scanner import *

class ParserError(MarkedYAMLError):
    pass

class Parser:
    # Since writing a recursive-descendant parser is a straightforward task, we
    # do not give many comments here.

    DEFAULT_TAGS = {
        '!':   '!',
        '!!':  'tag:yaml.org,2002:',
    }

    def __init__(self):
        self.current_event = None
        self.yaml_version = None
        self.tag_handles = {}
        self.states = []
        self.marks = []
        self.state = self.parse_stream_start

    def dispose(self):
        # Reset the state attributes (to clear self-references)
        self.states = []
        self.state = None

    def check_event(self, *choices):
        # Check the type of the next event.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        if self.current_event is not None:
            if not choices:
                return True
            for choice in choices:
                if isinstance(self.current_event, choice):
                    return True
        return False

    def peek_event(self):
        # Get the next event.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        return self.current_event

    def get_event(self):
        # Get the next event and proceed further.
        if self.current_event is None:
            if self.state:
                self.current_event = self.state()
        value = self.current_event
        self.current_event = None
        return value

    # stream    ::= STREAM-START implicit_document? explicit_document* STREAM-END
    # implicit_document ::= block_node DOCUMENT-END*
    # explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*

    def parse_stream_start(self):

        # Parse the stream start.
        token = self.get_token()
        event = StreamStartEvent(token.start_mark, token.end_mark,
                encoding=token.encoding)

        # Prepare the next state.
        self.state = self.parse_implicit_document_start

        return event

    def parse_implicit_document_start(self):

        # Parse an implicit document.
        if not self.check_token(DirectiveToken, DocumentStartToken,
                StreamEndToken):
            self.tag_handles = self.DEFAULT_TAGS
            token = self.peek_token()
            start_mark = end_mark = token.start_mark
            event = DocumentStartEvent(start_mark, end_mark,
                    explicit=False)

            # Prepare the next state.
            self.states.append(self.parse_document_end)
            self.state = self.parse_block_node

            return event

        else:
            return self.parse_document_start()

    def parse_document_start(self):

        # Parse any extra document end indicators.
        while self.check_token(DocumentEndToken):
            self.get_token()

        # Parse an explicit document.
        if not self.check_token(StreamEndToken):
            token = self.peek_token()
            start_mark = token.start_mark
            version, tags = self.process_directives()
            if not self.check_token(DocumentStartToken):
                raise ParserError(None, None,
                        "expected '<document start>', but found %r"
                        % self.peek_token().id,
                        self.peek_token().start_mark)
            token = self.get_token()
            end_mark = token.end_mark
            event = DocumentStartEvent(start_mark, end_mark,
                    explicit=True, version=version, tags=tags)
            self.states.append(self.parse_document_end)
            self.state = self.parse_document_content
        else:
            # Parse the end of the stream.
            token = self.get_token()
            event = StreamEndEvent(token.start_mark, token.end_mark)
            assert not self.states
            assert not self.marks
            self.state = None
        return event

    def parse_document_end(self):

        # Parse the document end.
        token = self.peek_token()
        start_mark = end_mark = token.start_mark
        explicit = False
        if self.check_token(DocumentEndToken):
            token = self.get_token()
            end_mark = token.end_mark
            explicit = True
        event = DocumentEndEvent(start_mark, end_mark,
                explicit=explicit)

        # Prepare the next state.
        self.state = self.parse_document_start

        return event

    def parse_document_content(self):
        if self.check_token(DirectiveToken,
                DocumentStartToken, DocumentEndToken, StreamEndToken):
            event = self.process_empty_scalar(self.peek_token().start_mark)
            self.state = self.states.pop()
            return event
        else:
            return self.parse_block_node()

    def process_directives(self):
        self.yaml_version = None
        self.tag_handles = {}
        while self.check_token(DirectiveToken):
            token = self.get_token()
            if token.name == 'YAML':
                if self.yaml_version is not None:
                    raise ParserError(None, None,
                            "found duplicate YAML directive", token.start_mark)
                major, minor = token.value
                if major != 1:
                    raise ParserError(None, None,
                            "found incompatible YAML document (version 1.* is required)",
                            token.start_mark)
                self.yaml_version = token.value
            elif token.name == 'TAG':
                handle, prefix = token.value
                if handle in self.tag_handles:
                    raise ParserError(None, None,
                            "duplicate tag handle %r" % handle,
                            token.start_mark)
                self.tag_handles[handle] = prefix
        if self.tag_handles:
            value = self.yaml_version, self.tag_handles.copy()
        else:
            value = self.yaml_version, None
        for key in self.DEFAULT_TAGS:
            if key not in self.tag_handles:
                self.tag_handles[key] = self.DEFAULT_TAGS[key]
        return value

    # block_node_or_indentless_sequence ::= ALIAS
    #               | properties (block_content | indentless_block_sequence)?
    #               | block_content
    #               | indentless_block_sequence
    # block_node    ::= ALIAS
    #                   | properties block_content?
    #                   | block_content
    # flow_node     ::= ALIAS
    #                   | properties flow_content?
    #                   | flow_content
    # properties    ::= TAG ANCHOR? | ANCHOR TAG?
    # block_content     ::= block_collection | flow_collection | SCALAR
    # flow_content      ::= flow_collection | SCALAR
    # block_collection  ::= block_sequence | block_mapping
    # flow_collection   ::= flow_sequence | flow_mapping

    def parse_block_node(self):
        return self.parse_node(block=True)

    def parse_flow_node(self):
        return self.parse_node()

    def parse_block_node_or_indentless_sequence(self):
        return self.parse_node(block=True, indentless_sequence=True)

    def parse_node(self, block=False, indentless_sequence=False):
        if self.check_token(AliasToken):
            token = self.get_token()
            event = AliasEvent(token.value, token.start_mark, token.end_mark)
            self.state = self.states.pop()
        else:
            anchor = None
            tag = None
            start_mark = end_mark = tag_mark = None
            if self.check_token(AnchorToken):
                token = self.get_token()
                start_mark = token.start_mark
                end_mark = token.end_mark
                anchor = token.value
                if self.check_token(TagToken):
                    token = self.get_token()
                    tag_mark = token.start_mark
                    end_mark = token.end_mark
                    tag = token.value
            elif self.check_token(TagToken):
                token = self.get_token()
                start_mark = tag_mark = token.start_mark
                end_mark = token.end_mark
                tag = token.value
                if self.check_token(AnchorToken):
                    token = self.get_token()
                    end_mark = token.end_mark
                    anchor = token.value
            if tag is not None:
                handle, suffix = tag
                if handle is not None:
                    if handle not in self.tag_handles:
                        raise ParserError("while parsing a node", start_mark,
                                "found undefined tag handle %r" % handle,
                                tag_mark)
                    tag = self.tag_handles[handle]+suffix
                else:
                    tag = suffix
            #if tag == '!':
            #    raise ParserError("while parsing a node", start_mark,
            #            "found non-specific tag '!'", tag_mark,
            #            "Please check 'http://pyyaml.org/wiki/YAMLNonSpecificTag' and share your opinion.")
            if start_mark is None:
                start_mark = end_mark = self.peek_token().start_mark
            event = None
            implicit = (tag is None or tag == '!')
            if indentless_sequence and self.check_token(BlockEntryToken):
                end_mark = self.peek_token().end_mark
                event = SequenceStartEvent(anchor, tag, implicit,
                        start_mark, end_mark)
                self.state = self.parse_indentless_sequence_entry
            else:
                if self.check_token(ScalarToken):
                    token = self.get_token()
                    end_mark = token.end_mark
                    if (token.plain and tag is None) or tag == '!':
                        implicit = (True, False)
                    elif tag is None:
                        implicit = (False, True)
                    else:
                        implicit = (False, False)
                    event = ScalarEvent(anchor, tag, implicit, token.value,
                            start_mark, end_mark, style=token.style)
                    self.state = self.states.pop()
                elif self.check_token(FlowSequenceStartToken):
                    end_mark = self.peek_token().end_mark
                    event = SequenceStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=True)
                    self.state = self.parse_flow_sequence_first_entry
                elif self.check_token(FlowMappingStartToken):
                    end_mark = self.peek_token().end_mark
                    event = MappingStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=True)
                    self.state = self.parse_flow_mapping_first_key
                elif block and self.check_token(BlockSequenceStartToken):
                    end_mark = self.peek_token().start_mark
                    event = SequenceStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=False)
                    self.state = self.parse_block_sequence_first_entry
                elif block and self.check_token(BlockMappingStartToken):
                    end_mark = self.peek_token().start_mark
                    event = MappingStartEvent(anchor, tag, implicit,
                            start_mark, end_mark, flow_style=False)
                    self.state = self.parse_block_mapping_first_key
                elif anchor is not None or tag is not None:
                    # Empty scalars are allowed even if a tag or an anchor is
                    # specified.
                    event = ScalarEvent(anchor, tag, (implicit, False), '',
                            start_mark, end_mark)
                    self.state = self.states.pop()
                else:
                    if block:
                        node = 'block'
                    else:
                        node = 'flow'
                    token = self.peek_token()
                    raise ParserError("while parsing a %s node" % node, start_mark,
                            "expected the node content, but found %r" % token.id,
                            token.start_mark)
        return event

    # block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END

    def parse_block_sequence_first_entry(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_block_sequence_entry()

    def parse_block_sequence_entry(self):
        if self.check_token(BlockEntryToken):
            token = self.get_token()
            if not self.check_token(BlockEntryToken, BlockEndToken):
                self.states.append(self.parse_block_sequence_entry)
                return self.parse_block_node()
            else:
                self.state = self.parse_block_sequence_entry
                return self.process_empty_scalar(token.end_mark)
        if not self.check_token(BlockEndToken):
            token = self.peek_token()
            raise ParserError("while parsing a block collection", self.marks[-1],
                    "expected <block end>, but found %r" % token.id, token.start_mark)
        token = self.get_token()
        event = SequenceEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    # indentless_sequence ::= (BLOCK-ENTRY block_node?)+

    def parse_indentless_sequence_entry(self):
        if self.check_token(BlockEntryToken):
            token = self.get_token()
            if not self.check_token(BlockEntryToken,
                    KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_indentless_sequence_entry)
                return self.parse_block_node()
            else:
                self.state = self.parse_indentless_sequence_entry
                return self.process_empty_scalar(token.end_mark)
        token = self.peek_token()
        event = SequenceEndEvent(token.start_mark, token.start_mark)
        self.state = self.states.pop()
        return event

    # block_mapping     ::= BLOCK-MAPPING_START
    #                       ((KEY block_node_or_indentless_sequence?)?
    #                       (VALUE block_node_or_indentless_sequence?)?)*
    #                       BLOCK-END

    def parse_block_mapping_first_key(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_block_mapping_key()

    def parse_block_mapping_key(self):
        if self.check_token(KeyToken):
            token = self.get_token()
            if not self.check_token(KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_block_mapping_value)
                return self.parse_block_node_or_indentless_sequence()
            else:
                self.state = self.parse_block_mapping_value
                return self.process_empty_scalar(token.end_mark)
        if not self.check_token(BlockEndToken):
            token = self.peek_token()
            raise ParserError("while parsing a block mapping", self.marks[-1],
                    "expected <block end>, but found %r" % token.id, token.start_mark)
        token = self.get_token()
        event = MappingEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_block_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(KeyToken, ValueToken, BlockEndToken):
                self.states.append(self.parse_block_mapping_key)
                return self.parse_block_node_or_indentless_sequence()
            else:
                self.state = self.parse_block_mapping_key
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_block_mapping_key
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    # flow_sequence     ::= FLOW-SEQUENCE-START
    #                       (flow_sequence_entry FLOW-ENTRY)*
    #                       flow_sequence_entry?
    #                       FLOW-SEQUENCE-END
    # flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
    #
    # Note that while production rules for both flow_sequence_entry and
    # flow_mapping_entry are equal, their interpretations are different.
    # For `flow_sequence_entry`, the part `KEY flow_node? (VALUE flow_node?)?`
    # generate an inline mapping (set syntax).

    def parse_flow_sequence_first_entry(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_flow_sequence_entry(first=True)

    def parse_flow_sequence_entry(self, first=False):
        if not self.check_token(FlowSequenceEndToken):
            if not first:
                if self.check_token(FlowEntryToken):
                    self.get_token()
                else:
                    token = self.peek_token()
                    raise ParserError("while parsing a flow sequence", self.marks[-1],
                            "expected ',' or ']', but got %r" % token.id, token.start_mark)
            
            if self.check_token(KeyToken):
                token = self.peek_token()
                event = MappingStartEvent(None, None, True,
                        token.start_mark, token.end_mark,
                        flow_style=True)
                self.state = self.parse_flow_sequence_entry_mapping_key
                return event
            elif not self.check_token(FlowSequenceEndToken):
                self.states.append(self.parse_flow_sequence_entry)
                return self.parse_flow_node()
        token = self.get_token()
        event = SequenceEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_flow_sequence_entry_mapping_key(self):
        token = self.get_token()
        if not self.check_token(ValueToken,
                FlowEntryToken, FlowSequenceEndToken):
            self.states.append(self.parse_flow_sequence_entry_mapping_value)
            return self.parse_flow_node()
        else:
            self.state = self.parse_flow_sequence_entry_mapping_value
            return self.process_empty_scalar(token.end_mark)

    def parse_flow_sequence_entry_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(FlowEntryToken, FlowSequenceEndToken):
                self.states.append(self.parse_flow_sequence_entry_mapping_end)
                return self.parse_flow_node()
            else:
                self.state = self.parse_flow_sequence_entry_mapping_end
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_flow_sequence_entry_mapping_end
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    def parse_flow_sequence_entry_mapping_end(self):
        self.state = self.parse_flow_sequence_entry
        token = self.peek_token()
        return MappingEndEvent(token.start_mark, token.start_mark)

    # flow_mapping  ::= FLOW-MAPPING-START
    #                   (flow_mapping_entry FLOW-ENTRY)*
    #                   flow_mapping_entry?
    #                   FLOW-MAPPING-END
    # flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?

    def parse_flow_mapping_first_key(self):
        token = self.get_token()
        self.marks.append(token.start_mark)
        return self.parse_flow_mapping_key(first=True)

    def parse_flow_mapping_key(self, first=False):
        if not self.check_token(FlowMappingEndToken):
            if not first:
                if self.check_token(FlowEntryToken):
                    self.get_token()
                else:
                    token = self.peek_token()
                    raise ParserError("while parsing a flow mapping", self.marks[-1],
                            "expected ',' or '}', but got %r" % token.id, token.start_mark)
            if self.check_token(KeyToken):
                token = self.get_token()
                if not self.check_token(ValueToken,
                        FlowEntryToken, FlowMappingEndToken):
                    self.states.append(self.parse_flow_mapping_value)
                    return self.parse_flow_node()
                else:
                    self.state = self.parse_flow_mapping_value
                    return self.process_empty_scalar(token.end_mark)
            elif not self.check_token(FlowMappingEndToken):
                self.states.append(self.parse_flow_mapping_empty_value)
                return self.parse_flow_node()
        token = self.get_token()
        event = MappingEndEvent(token.start_mark, token.end_mark)
        self.state = self.states.pop()
        self.marks.pop()
        return event

    def parse_flow_mapping_value(self):
        if self.check_token(ValueToken):
            token = self.get_token()
            if not self.check_token(FlowEntryToken, FlowMappingEndToken):
                self.states.append(self.parse_flow_mapping_key)
                return self.parse_flow_node()
            else:
                self.state = self.parse_flow_mapping_key
                return self.process_empty_scalar(token.end_mark)
        else:
            self.state = self.parse_flow_mapping_key
            token = self.peek_token()
            return self.process_empty_scalar(token.start_mark)

    def parse_flow_mapping_empty_value(self):
        self.state = self.parse_flow_mapping_key
        return self.process_empty_scalar(self.peek_token().start_mark)

    def process_empty_scalar(self, mark):
        return ScalarEvent(None, None, (True, False), '', mark, mark)



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\reader.py
# ================================================================================

# This module contains abstractions for the input stream. You don't have to
# looks further, there are no pretty code.
#
# We define two classes here.
#
#   Mark(source, line, column)
# It's just a record and its only use is producing nice error messages.
# Parser does not use it for any other purposes.
#
#   Reader(source, data)
# Reader determines the encoding of `data` and converts it to unicode.
# Reader provides the following methods and attributes:
#   reader.peek(length=1) - return the next `length` characters
#   reader.forward(length=1) - move the current position to `length` characters.
#   reader.index - the number of the current character.
#   reader.line, stream.column - the line and the column of the current character.

__all__ = ['Reader', 'ReaderError']

from .error import YAMLError, Mark

import codecs, re

class ReaderError(YAMLError):

    def __init__(self, name, position, character, encoding, reason):
        self.name = name
        self.character = character
        self.position = position
        self.encoding = encoding
        self.reason = reason

    def __str__(self):
        if isinstance(self.character, bytes):
            return "'%s' codec can't decode byte #x%02x: %s\n"  \
                    "  in \"%s\", position %d"    \
                    % (self.encoding, ord(self.character), self.reason,
                            self.name, self.position)
        else:
            return "unacceptable character #x%04x: %s\n"    \
                    "  in \"%s\", position %d"    \
                    % (self.character, self.reason,
                            self.name, self.position)

class Reader(object):
    # Reader:
    # - determines the data encoding and converts it to a unicode string,
    # - checks if characters are in allowed range,
    # - adds '\0' to the end.

    # Reader accepts
    #  - a `bytes` object,
    #  - a `str` object,
    #  - a file-like object with its `read` method returning `str`,
    #  - a file-like object with its `read` method returning `unicode`.

    # Yeah, it's ugly and slow.

    def __init__(self, stream):
        self.name = None
        self.stream = None
        self.stream_pointer = 0
        self.eof = True
        self.buffer = ''
        self.pointer = 0
        self.raw_buffer = None
        self.raw_decode = None
        self.encoding = None
        self.index = 0
        self.line = 0
        self.column = 0
        if isinstance(stream, str):
            self.name = "<unicode string>"
            self.check_printable(stream)
            self.buffer = stream+'\0'
        elif isinstance(stream, bytes):
            self.name = "<byte string>"
            self.raw_buffer = stream
            self.determine_encoding()
        else:
            self.stream = stream
            self.name = getattr(stream, 'name', "<file>")
            self.eof = False
            self.raw_buffer = None
            self.determine_encoding()

    def peek(self, index=0):
        try:
            return self.buffer[self.pointer+index]
        except IndexError:
            self.update(index+1)
            return self.buffer[self.pointer+index]

    def prefix(self, length=1):
        if self.pointer+length >= len(self.buffer):
            self.update(length)
        return self.buffer[self.pointer:self.pointer+length]

    def forward(self, length=1):
        if self.pointer+length+1 >= len(self.buffer):
            self.update(length+1)
        while length:
            ch = self.buffer[self.pointer]
            self.pointer += 1
            self.index += 1
            if ch in '\n\x85\u2028\u2029'  \
                    or (ch == '\r' and self.buffer[self.pointer] != '\n'):
                self.line += 1
                self.column = 0
            elif ch != '\uFEFF':
                self.column += 1
            length -= 1

    def get_mark(self):
        if self.stream is None:
            return Mark(self.name, self.index, self.line, self.column,
                    self.buffer, self.pointer)
        else:
            return Mark(self.name, self.index, self.line, self.column,
                    None, None)

    def determine_encoding(self):
        while not self.eof and (self.raw_buffer is None or len(self.raw_buffer) < 2):
            self.update_raw()
        if isinstance(self.raw_buffer, bytes):
            if self.raw_buffer.startswith(codecs.BOM_UTF16_LE):
                self.raw_decode = codecs.utf_16_le_decode
                self.encoding = 'utf-16-le'
            elif self.raw_buffer.startswith(codecs.BOM_UTF16_BE):
                self.raw_decode = codecs.utf_16_be_decode
                self.encoding = 'utf-16-be'
            else:
                self.raw_decode = codecs.utf_8_decode
                self.encoding = 'utf-8'
        self.update(1)

    NON_PRINTABLE = re.compile('[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFFFD\U00010000-\U0010ffff]')
    def check_printable(self, data):
        match = self.NON_PRINTABLE.search(data)
        if match:
            character = match.group()
            position = self.index+(len(self.buffer)-self.pointer)+match.start()
            raise ReaderError(self.name, position, ord(character),
                    'unicode', "special characters are not allowed")

    def update(self, length):
        if self.raw_buffer is None:
            return
        self.buffer = self.buffer[self.pointer:]
        self.pointer = 0
        while len(self.buffer) < length:
            if not self.eof:
                self.update_raw()
            if self.raw_decode is not None:
                try:
                    data, converted = self.raw_decode(self.raw_buffer,
                            'strict', self.eof)
                except UnicodeDecodeError as exc:
                    character = self.raw_buffer[exc.start]
                    if self.stream is not None:
                        position = self.stream_pointer-len(self.raw_buffer)+exc.start
                    else:
                        position = exc.start
                    raise ReaderError(self.name, position, character,
                            exc.encoding, exc.reason)
            else:
                data = self.raw_buffer
                converted = len(data)
            self.check_printable(data)
            self.buffer += data
            self.raw_buffer = self.raw_buffer[converted:]
            if self.eof:
                self.buffer += '\0'
                self.raw_buffer = None
                break

    def update_raw(self, size=4096):
        data = self.stream.read(size)
        if self.raw_buffer is None:
            self.raw_buffer = data
        else:
            self.raw_buffer += data
        self.stream_pointer += len(data)
        if not data:
            self.eof = True


# ================================================================================
# Datei: venv\Lib\site-packages\yaml\representer.py
# ================================================================================


__all__ = ['BaseRepresenter', 'SafeRepresenter', 'Representer',
    'RepresenterError']

from .error import *
from .nodes import *

import datetime, copyreg, types, base64, collections

class RepresenterError(YAMLError):
    pass

class BaseRepresenter:

    yaml_representers = {}
    yaml_multi_representers = {}

    def __init__(self, default_style=None, default_flow_style=False, sort_keys=True):
        self.default_style = default_style
        self.sort_keys = sort_keys
        self.default_flow_style = default_flow_style
        self.represented_objects = {}
        self.object_keeper = []
        self.alias_key = None

    def represent(self, data):
        node = self.represent_data(data)
        self.serialize(node)
        self.represented_objects = {}
        self.object_keeper = []
        self.alias_key = None

    def represent_data(self, data):
        if self.ignore_aliases(data):
            self.alias_key = None
        else:
            self.alias_key = id(data)
        if self.alias_key is not None:
            if self.alias_key in self.represented_objects:
                node = self.represented_objects[self.alias_key]
                #if node is None:
                #    raise RepresenterError("recursive objects are not allowed: %r" % data)
                return node
            #self.represented_objects[alias_key] = None
            self.object_keeper.append(data)
        data_types = type(data).__mro__
        if data_types[0] in self.yaml_representers:
            node = self.yaml_representers[data_types[0]](self, data)
        else:
            for data_type in data_types:
                if data_type in self.yaml_multi_representers:
                    node = self.yaml_multi_representers[data_type](self, data)
                    break
            else:
                if None in self.yaml_multi_representers:
                    node = self.yaml_multi_representers[None](self, data)
                elif None in self.yaml_representers:
                    node = self.yaml_representers[None](self, data)
                else:
                    node = ScalarNode(None, str(data))
        #if alias_key is not None:
        #    self.represented_objects[alias_key] = node
        return node

    @classmethod
    def add_representer(cls, data_type, representer):
        if not 'yaml_representers' in cls.__dict__:
            cls.yaml_representers = cls.yaml_representers.copy()
        cls.yaml_representers[data_type] = representer

    @classmethod
    def add_multi_representer(cls, data_type, representer):
        if not 'yaml_multi_representers' in cls.__dict__:
            cls.yaml_multi_representers = cls.yaml_multi_representers.copy()
        cls.yaml_multi_representers[data_type] = representer

    def represent_scalar(self, tag, value, style=None):
        if style is None:
            style = self.default_style
        node = ScalarNode(tag, value, style=style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        return node

    def represent_sequence(self, tag, sequence, flow_style=None):
        value = []
        node = SequenceNode(tag, value, flow_style=flow_style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        best_style = True
        for item in sequence:
            node_item = self.represent_data(item)
            if not (isinstance(node_item, ScalarNode) and not node_item.style):
                best_style = False
            value.append(node_item)
        if flow_style is None:
            if self.default_flow_style is not None:
                node.flow_style = self.default_flow_style
            else:
                node.flow_style = best_style
        return node

    def represent_mapping(self, tag, mapping, flow_style=None):
        value = []
        node = MappingNode(tag, value, flow_style=flow_style)
        if self.alias_key is not None:
            self.represented_objects[self.alias_key] = node
        best_style = True
        if hasattr(mapping, 'items'):
            mapping = list(mapping.items())
            if self.sort_keys:
                try:
                    mapping = sorted(mapping)
                except TypeError:
                    pass
        for item_key, item_value in mapping:
            node_key = self.represent_data(item_key)
            node_value = self.represent_data(item_value)
            if not (isinstance(node_key, ScalarNode) and not node_key.style):
                best_style = False
            if not (isinstance(node_value, ScalarNode) and not node_value.style):
                best_style = False
            value.append((node_key, node_value))
        if flow_style is None:
            if self.default_flow_style is not None:
                node.flow_style = self.default_flow_style
            else:
                node.flow_style = best_style
        return node

    def ignore_aliases(self, data):
        return False

class SafeRepresenter(BaseRepresenter):

    def ignore_aliases(self, data):
        if data is None:
            return True
        if isinstance(data, tuple) and data == ():
            return True
        if isinstance(data, (str, bytes, bool, int, float)):
            return True

    def represent_none(self, data):
        return self.represent_scalar('tag:yaml.org,2002:null', 'null')

    def represent_str(self, data):
        return self.represent_scalar('tag:yaml.org,2002:str', data)

    def represent_binary(self, data):
        if hasattr(base64, 'encodebytes'):
            data = base64.encodebytes(data).decode('ascii')
        else:
            data = base64.encodestring(data).decode('ascii')
        return self.represent_scalar('tag:yaml.org,2002:binary', data, style='|')

    def represent_bool(self, data):
        if data:
            value = 'true'
        else:
            value = 'false'
        return self.represent_scalar('tag:yaml.org,2002:bool', value)

    def represent_int(self, data):
        return self.represent_scalar('tag:yaml.org,2002:int', str(data))

    inf_value = 1e300
    while repr(inf_value) != repr(inf_value*inf_value):
        inf_value *= inf_value

    def represent_float(self, data):
        if data != data or (data == 0.0 and data == 1.0):
            value = '.nan'
        elif data == self.inf_value:
            value = '.inf'
        elif data == -self.inf_value:
            value = '-.inf'
        else:
            value = repr(data).lower()
            # Note that in some cases `repr(data)` represents a float number
            # without the decimal parts.  For instance:
            #   >>> repr(1e17)
            #   '1e17'
            # Unfortunately, this is not a valid float representation according
            # to the definition of the `!!float` tag.  We fix this by adding
            # '.0' before the 'e' symbol.
            if '.' not in value and 'e' in value:
                value = value.replace('e', '.0e', 1)
        return self.represent_scalar('tag:yaml.org,2002:float', value)

    def represent_list(self, data):
        #pairs = (len(data) > 0 and isinstance(data, list))
        #if pairs:
        #    for item in data:
        #        if not isinstance(item, tuple) or len(item) != 2:
        #            pairs = False
        #            break
        #if not pairs:
            return self.represent_sequence('tag:yaml.org,2002:seq', data)
        #value = []
        #for item_key, item_value in data:
        #    value.append(self.represent_mapping(u'tag:yaml.org,2002:map',
        #        [(item_key, item_value)]))
        #return SequenceNode(u'tag:yaml.org,2002:pairs', value)

    def represent_dict(self, data):
        return self.represent_mapping('tag:yaml.org,2002:map', data)

    def represent_set(self, data):
        value = {}
        for key in data:
            value[key] = None
        return self.represent_mapping('tag:yaml.org,2002:set', value)

    def represent_date(self, data):
        value = data.isoformat()
        return self.represent_scalar('tag:yaml.org,2002:timestamp', value)

    def represent_datetime(self, data):
        value = data.isoformat(' ')
        return self.represent_scalar('tag:yaml.org,2002:timestamp', value)

    def represent_yaml_object(self, tag, data, cls, flow_style=None):
        if hasattr(data, '__getstate__'):
            state = data.__getstate__()
        else:
            state = data.__dict__.copy()
        return self.represent_mapping(tag, state, flow_style=flow_style)

    def represent_undefined(self, data):
        raise RepresenterError("cannot represent an object", data)

SafeRepresenter.add_representer(type(None),
        SafeRepresenter.represent_none)

SafeRepresenter.add_representer(str,
        SafeRepresenter.represent_str)

SafeRepresenter.add_representer(bytes,
        SafeRepresenter.represent_binary)

SafeRepresenter.add_representer(bool,
        SafeRepresenter.represent_bool)

SafeRepresenter.add_representer(int,
        SafeRepresenter.represent_int)

SafeRepresenter.add_representer(float,
        SafeRepresenter.represent_float)

SafeRepresenter.add_representer(list,
        SafeRepresenter.represent_list)

SafeRepresenter.add_representer(tuple,
        SafeRepresenter.represent_list)

SafeRepresenter.add_representer(dict,
        SafeRepresenter.represent_dict)

SafeRepresenter.add_representer(set,
        SafeRepresenter.represent_set)

SafeRepresenter.add_representer(datetime.date,
        SafeRepresenter.represent_date)

SafeRepresenter.add_representer(datetime.datetime,
        SafeRepresenter.represent_datetime)

SafeRepresenter.add_representer(None,
        SafeRepresenter.represent_undefined)

class Representer(SafeRepresenter):

    def represent_complex(self, data):
        if data.imag == 0.0:
            data = '%r' % data.real
        elif data.real == 0.0:
            data = '%rj' % data.imag
        elif data.imag > 0:
            data = '%r+%rj' % (data.real, data.imag)
        else:
            data = '%r%rj' % (data.real, data.imag)
        return self.represent_scalar('tag:yaml.org,2002:python/complex', data)

    def represent_tuple(self, data):
        return self.represent_sequence('tag:yaml.org,2002:python/tuple', data)

    def represent_name(self, data):
        name = '%s.%s' % (data.__module__, data.__name__)
        return self.represent_scalar('tag:yaml.org,2002:python/name:'+name, '')

    def represent_module(self, data):
        return self.represent_scalar(
                'tag:yaml.org,2002:python/module:'+data.__name__, '')

    def represent_object(self, data):
        # We use __reduce__ API to save the data. data.__reduce__ returns
        # a tuple of length 2-5:
        #   (function, args, state, listitems, dictitems)

        # For reconstructing, we calls function(*args), then set its state,
        # listitems, and dictitems if they are not None.

        # A special case is when function.__name__ == '__newobj__'. In this
        # case we create the object with args[0].__new__(*args).

        # Another special case is when __reduce__ returns a string - we don't
        # support it.

        # We produce a !!python/object, !!python/object/new or
        # !!python/object/apply node.

        cls = type(data)
        if cls in copyreg.dispatch_table:
            reduce = copyreg.dispatch_table[cls](data)
        elif hasattr(data, '__reduce_ex__'):
            reduce = data.__reduce_ex__(2)
        elif hasattr(data, '__reduce__'):
            reduce = data.__reduce__()
        else:
            raise RepresenterError("cannot represent an object", data)
        reduce = (list(reduce)+[None]*5)[:5]
        function, args, state, listitems, dictitems = reduce
        args = list(args)
        if state is None:
            state = {}
        if listitems is not None:
            listitems = list(listitems)
        if dictitems is not None:
            dictitems = dict(dictitems)
        if function.__name__ == '__newobj__':
            function = args[0]
            args = args[1:]
            tag = 'tag:yaml.org,2002:python/object/new:'
            newobj = True
        else:
            tag = 'tag:yaml.org,2002:python/object/apply:'
            newobj = False
        function_name = '%s.%s' % (function.__module__, function.__name__)
        if not args and not listitems and not dictitems \
                and isinstance(state, dict) and newobj:
            return self.represent_mapping(
                    'tag:yaml.org,2002:python/object:'+function_name, state)
        if not listitems and not dictitems  \
                and isinstance(state, dict) and not state:
            return self.represent_sequence(tag+function_name, args)
        value = {}
        if args:
            value['args'] = args
        if state or not isinstance(state, dict):
            value['state'] = state
        if listitems:
            value['listitems'] = listitems
        if dictitems:
            value['dictitems'] = dictitems
        return self.represent_mapping(tag+function_name, value)

    def represent_ordered_dict(self, data):
        # Provide uniform representation across different Python versions.
        data_type = type(data)
        tag = 'tag:yaml.org,2002:python/object/apply:%s.%s' \
                % (data_type.__module__, data_type.__name__)
        items = [[key, value] for key, value in data.items()]
        return self.represent_sequence(tag, [items])

Representer.add_representer(complex,
        Representer.represent_complex)

Representer.add_representer(tuple,
        Representer.represent_tuple)

Representer.add_multi_representer(type,
        Representer.represent_name)

Representer.add_representer(collections.OrderedDict,
        Representer.represent_ordered_dict)

Representer.add_representer(types.FunctionType,
        Representer.represent_name)

Representer.add_representer(types.BuiltinFunctionType,
        Representer.represent_name)

Representer.add_representer(types.ModuleType,
        Representer.represent_module)

Representer.add_multi_representer(object,
        Representer.represent_object)



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\resolver.py
# ================================================================================


__all__ = ['BaseResolver', 'Resolver']

from .error import *
from .nodes import *

import re

class ResolverError(YAMLError):
    pass

class BaseResolver:

    DEFAULT_SCALAR_TAG = 'tag:yaml.org,2002:str'
    DEFAULT_SEQUENCE_TAG = 'tag:yaml.org,2002:seq'
    DEFAULT_MAPPING_TAG = 'tag:yaml.org,2002:map'

    yaml_implicit_resolvers = {}
    yaml_path_resolvers = {}

    def __init__(self):
        self.resolver_exact_paths = []
        self.resolver_prefix_paths = []

    @classmethod
    def add_implicit_resolver(cls, tag, regexp, first):
        if not 'yaml_implicit_resolvers' in cls.__dict__:
            implicit_resolvers = {}
            for key in cls.yaml_implicit_resolvers:
                implicit_resolvers[key] = cls.yaml_implicit_resolvers[key][:]
            cls.yaml_implicit_resolvers = implicit_resolvers
        if first is None:
            first = [None]
        for ch in first:
            cls.yaml_implicit_resolvers.setdefault(ch, []).append((tag, regexp))

    @classmethod
    def add_path_resolver(cls, tag, path, kind=None):
        # Note: `add_path_resolver` is experimental.  The API could be changed.
        # `new_path` is a pattern that is matched against the path from the
        # root to the node that is being considered.  `node_path` elements are
        # tuples `(node_check, index_check)`.  `node_check` is a node class:
        # `ScalarNode`, `SequenceNode`, `MappingNode` or `None`.  `None`
        # matches any kind of a node.  `index_check` could be `None`, a boolean
        # value, a string value, or a number.  `None` and `False` match against
        # any _value_ of sequence and mapping nodes.  `True` matches against
        # any _key_ of a mapping node.  A string `index_check` matches against
        # a mapping value that corresponds to a scalar key which content is
        # equal to the `index_check` value.  An integer `index_check` matches
        # against a sequence value with the index equal to `index_check`.
        if not 'yaml_path_resolvers' in cls.__dict__:
            cls.yaml_path_resolvers = cls.yaml_path_resolvers.copy()
        new_path = []
        for element in path:
            if isinstance(element, (list, tuple)):
                if len(element) == 2:
                    node_check, index_check = element
                elif len(element) == 1:
                    node_check = element[0]
                    index_check = True
                else:
                    raise ResolverError("Invalid path element: %s" % element)
            else:
                node_check = None
                index_check = element
            if node_check is str:
                node_check = ScalarNode
            elif node_check is list:
                node_check = SequenceNode
            elif node_check is dict:
                node_check = MappingNode
            elif node_check not in [ScalarNode, SequenceNode, MappingNode]  \
                    and not isinstance(node_check, str) \
                    and node_check is not None:
                raise ResolverError("Invalid node checker: %s" % node_check)
            if not isinstance(index_check, (str, int))  \
                    and index_check is not None:
                raise ResolverError("Invalid index checker: %s" % index_check)
            new_path.append((node_check, index_check))
        if kind is str:
            kind = ScalarNode
        elif kind is list:
            kind = SequenceNode
        elif kind is dict:
            kind = MappingNode
        elif kind not in [ScalarNode, SequenceNode, MappingNode]    \
                and kind is not None:
            raise ResolverError("Invalid node kind: %s" % kind)
        cls.yaml_path_resolvers[tuple(new_path), kind] = tag

    def descend_resolver(self, current_node, current_index):
        if not self.yaml_path_resolvers:
            return
        exact_paths = {}
        prefix_paths = []
        if current_node:
            depth = len(self.resolver_prefix_paths)
            for path, kind in self.resolver_prefix_paths[-1]:
                if self.check_resolver_prefix(depth, path, kind,
                        current_node, current_index):
                    if len(path) > depth:
                        prefix_paths.append((path, kind))
                    else:
                        exact_paths[kind] = self.yaml_path_resolvers[path, kind]
        else:
            for path, kind in self.yaml_path_resolvers:
                if not path:
                    exact_paths[kind] = self.yaml_path_resolvers[path, kind]
                else:
                    prefix_paths.append((path, kind))
        self.resolver_exact_paths.append(exact_paths)
        self.resolver_prefix_paths.append(prefix_paths)

    def ascend_resolver(self):
        if not self.yaml_path_resolvers:
            return
        self.resolver_exact_paths.pop()
        self.resolver_prefix_paths.pop()

    def check_resolver_prefix(self, depth, path, kind,
            current_node, current_index):
        node_check, index_check = path[depth-1]
        if isinstance(node_check, str):
            if current_node.tag != node_check:
                return
        elif node_check is not None:
            if not isinstance(current_node, node_check):
                return
        if index_check is True and current_index is not None:
            return
        if (index_check is False or index_check is None)    \
                and current_index is None:
            return
        if isinstance(index_check, str):
            if not (isinstance(current_index, ScalarNode)
                    and index_check == current_index.value):
                return
        elif isinstance(index_check, int) and not isinstance(index_check, bool):
            if index_check != current_index:
                return
        return True

    def resolve(self, kind, value, implicit):
        if kind is ScalarNode and implicit[0]:
            if value == '':
                resolvers = self.yaml_implicit_resolvers.get('', [])
            else:
                resolvers = self.yaml_implicit_resolvers.get(value[0], [])
            wildcard_resolvers = self.yaml_implicit_resolvers.get(None, [])
            for tag, regexp in resolvers + wildcard_resolvers:
                if regexp.match(value):
                    return tag
            implicit = implicit[1]
        if self.yaml_path_resolvers:
            exact_paths = self.resolver_exact_paths[-1]
            if kind in exact_paths:
                return exact_paths[kind]
            if None in exact_paths:
                return exact_paths[None]
        if kind is ScalarNode:
            return self.DEFAULT_SCALAR_TAG
        elif kind is SequenceNode:
            return self.DEFAULT_SEQUENCE_TAG
        elif kind is MappingNode:
            return self.DEFAULT_MAPPING_TAG

class Resolver(BaseResolver):
    pass

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:bool',
        re.compile(r'''^(?:yes|Yes|YES|no|No|NO
                    |true|True|TRUE|false|False|FALSE
                    |on|On|ON|off|Off|OFF)$''', re.X),
        list('yYnNtTfFoO'))

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:float',
        re.compile(r'''^(?:[-+]?(?:[0-9][0-9_]*)\.[0-9_]*(?:[eE][-+][0-9]+)?
                    |\.[0-9][0-9_]*(?:[eE][-+][0-9]+)?
                    |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*
                    |[-+]?\.(?:inf|Inf|INF)
                    |\.(?:nan|NaN|NAN))$''', re.X),
        list('-+0123456789.'))

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:int',
        re.compile(r'''^(?:[-+]?0b[0-1_]+
                    |[-+]?0[0-7_]+
                    |[-+]?(?:0|[1-9][0-9_]*)
                    |[-+]?0x[0-9a-fA-F_]+
                    |[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$''', re.X),
        list('-+0123456789'))

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:merge',
        re.compile(r'^(?:<<)$'),
        ['<'])

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:null',
        re.compile(r'''^(?: ~
                    |null|Null|NULL
                    | )$''', re.X),
        ['~', 'n', 'N', ''])

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:timestamp',
        re.compile(r'''^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]
                    |[0-9][0-9][0-9][0-9] -[0-9][0-9]? -[0-9][0-9]?
                     (?:[Tt]|[ \t]+)[0-9][0-9]?
                     :[0-9][0-9] :[0-9][0-9] (?:\.[0-9]*)?
                     (?:[ \t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$''', re.X),
        list('0123456789'))

Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:value',
        re.compile(r'^(?:=)$'),
        ['='])

# The following resolver is only for documentation purposes. It cannot work
# because plain scalars cannot start with '!', '&', or '*'.
Resolver.add_implicit_resolver(
        'tag:yaml.org,2002:yaml',
        re.compile(r'^(?:!|&|\*)$'),
        list('!&*'))



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\scanner.py
# ================================================================================


# Scanner produces tokens of the following types:
# STREAM-START
# STREAM-END
# DIRECTIVE(name, value)
# DOCUMENT-START
# DOCUMENT-END
# BLOCK-SEQUENCE-START
# BLOCK-MAPPING-START
# BLOCK-END
# FLOW-SEQUENCE-START
# FLOW-MAPPING-START
# FLOW-SEQUENCE-END
# FLOW-MAPPING-END
# BLOCK-ENTRY
# FLOW-ENTRY
# KEY
# VALUE
# ALIAS(value)
# ANCHOR(value)
# TAG(value)
# SCALAR(value, plain, style)
#
# Read comments in the Scanner code for more details.
#

__all__ = ['Scanner', 'ScannerError']

from .error import MarkedYAMLError
from .tokens import *

class ScannerError(MarkedYAMLError):
    pass

class SimpleKey:
    # See below simple keys treatment.

    def __init__(self, token_number, required, index, line, column, mark):
        self.token_number = token_number
        self.required = required
        self.index = index
        self.line = line
        self.column = column
        self.mark = mark

class Scanner:

    def __init__(self):
        """Initialize the scanner."""
        # It is assumed that Scanner and Reader will have a common descendant.
        # Reader do the dirty work of checking for BOM and converting the
        # input data to Unicode. It also adds NUL to the end.
        #
        # Reader supports the following methods
        #   self.peek(i=0)       # peek the next i-th character
        #   self.prefix(l=1)     # peek the next l characters
        #   self.forward(l=1)    # read the next l characters and move the pointer.

        # Had we reached the end of the stream?
        self.done = False

        # The number of unclosed '{' and '['. `flow_level == 0` means block
        # context.
        self.flow_level = 0

        # List of processed tokens that are not yet emitted.
        self.tokens = []

        # Add the STREAM-START token.
        self.fetch_stream_start()

        # Number of tokens that were emitted through the `get_token` method.
        self.tokens_taken = 0

        # The current indentation level.
        self.indent = -1

        # Past indentation levels.
        self.indents = []

        # Variables related to simple keys treatment.

        # A simple key is a key that is not denoted by the '?' indicator.
        # Example of simple keys:
        #   ---
        #   block simple key: value
        #   ? not a simple key:
        #   : { flow simple key: value }
        # We emit the KEY token before all keys, so when we find a potential
        # simple key, we try to locate the corresponding ':' indicator.
        # Simple keys should be limited to a single line and 1024 characters.

        # Can a simple key start at the current position? A simple key may
        # start:
        # - at the beginning of the line, not counting indentation spaces
        #       (in block context),
        # - after '{', '[', ',' (in the flow context),
        # - after '?', ':', '-' (in the block context).
        # In the block context, this flag also signifies if a block collection
        # may start at the current position.
        self.allow_simple_key = True

        # Keep track of possible simple keys. This is a dictionary. The key
        # is `flow_level`; there can be no more that one possible simple key
        # for each level. The value is a SimpleKey record:
        #   (token_number, required, index, line, column, mark)
        # A simple key may start with ALIAS, ANCHOR, TAG, SCALAR(flow),
        # '[', or '{' tokens.
        self.possible_simple_keys = {}

    # Public methods.

    def check_token(self, *choices):
        # Check if the next token is one of the given types.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            if not choices:
                return True
            for choice in choices:
                if isinstance(self.tokens[0], choice):
                    return True
        return False

    def peek_token(self):
        # Return the next token, but do not delete if from the queue.
        # Return None if no more tokens.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            return self.tokens[0]
        else:
            return None

    def get_token(self):
        # Return the next token.
        while self.need_more_tokens():
            self.fetch_more_tokens()
        if self.tokens:
            self.tokens_taken += 1
            return self.tokens.pop(0)

    # Private methods.

    def need_more_tokens(self):
        if self.done:
            return False
        if not self.tokens:
            return True
        # The current token may be a potential simple key, so we
        # need to look further.
        self.stale_possible_simple_keys()
        if self.next_possible_simple_key() == self.tokens_taken:
            return True

    def fetch_more_tokens(self):

        # Eat whitespaces and comments until we reach the next token.
        self.scan_to_next_token()

        # Remove obsolete possible simple keys.
        self.stale_possible_simple_keys()

        # Compare the current indentation and column. It may add some tokens
        # and decrease the current indentation level.
        self.unwind_indent(self.column)

        # Peek the next character.
        ch = self.peek()

        # Is it the end of stream?
        if ch == '\0':
            return self.fetch_stream_end()

        # Is it a directive?
        if ch == '%' and self.check_directive():
            return self.fetch_directive()

        # Is it the document start?
        if ch == '-' and self.check_document_start():
            return self.fetch_document_start()

        # Is it the document end?
        if ch == '.' and self.check_document_end():
            return self.fetch_document_end()

        # TODO: support for BOM within a stream.
        #if ch == '\uFEFF':
        #    return self.fetch_bom()    <-- issue BOMToken

        # Note: the order of the following checks is NOT significant.

        # Is it the flow sequence start indicator?
        if ch == '[':
            return self.fetch_flow_sequence_start()

        # Is it the flow mapping start indicator?
        if ch == '{':
            return self.fetch_flow_mapping_start()

        # Is it the flow sequence end indicator?
        if ch == ']':
            return self.fetch_flow_sequence_end()

        # Is it the flow mapping end indicator?
        if ch == '}':
            return self.fetch_flow_mapping_end()

        # Is it the flow entry indicator?
        if ch == ',':
            return self.fetch_flow_entry()

        # Is it the block entry indicator?
        if ch == '-' and self.check_block_entry():
            return self.fetch_block_entry()

        # Is it the key indicator?
        if ch == '?' and self.check_key():
            return self.fetch_key()

        # Is it the value indicator?
        if ch == ':' and self.check_value():
            return self.fetch_value()

        # Is it an alias?
        if ch == '*':
            return self.fetch_alias()

        # Is it an anchor?
        if ch == '&':
            return self.fetch_anchor()

        # Is it a tag?
        if ch == '!':
            return self.fetch_tag()

        # Is it a literal scalar?
        if ch == '|' and not self.flow_level:
            return self.fetch_literal()

        # Is it a folded scalar?
        if ch == '>' and not self.flow_level:
            return self.fetch_folded()

        # Is it a single quoted scalar?
        if ch == '\'':
            return self.fetch_single()

        # Is it a double quoted scalar?
        if ch == '\"':
            return self.fetch_double()

        # It must be a plain scalar then.
        if self.check_plain():
            return self.fetch_plain()

        # No? It's an error. Let's produce a nice error message.
        raise ScannerError("while scanning for the next token", None,
                "found character %r that cannot start any token" % ch,
                self.get_mark())

    # Simple keys treatment.

    def next_possible_simple_key(self):
        # Return the number of the nearest possible simple key. Actually we
        # don't need to loop through the whole dictionary. We may replace it
        # with the following code:
        #   if not self.possible_simple_keys:
        #       return None
        #   return self.possible_simple_keys[
        #           min(self.possible_simple_keys.keys())].token_number
        min_token_number = None
        for level in self.possible_simple_keys:
            key = self.possible_simple_keys[level]
            if min_token_number is None or key.token_number < min_token_number:
                min_token_number = key.token_number
        return min_token_number

    def stale_possible_simple_keys(self):
        # Remove entries that are no longer possible simple keys. According to
        # the YAML specification, simple keys
        # - should be limited to a single line,
        # - should be no longer than 1024 characters.
        # Disabling this procedure will allow simple keys of any length and
        # height (may cause problems if indentation is broken though).
        for level in list(self.possible_simple_keys):
            key = self.possible_simple_keys[level]
            if key.line != self.line  \
                    or self.index-key.index > 1024:
                if key.required:
                    raise ScannerError("while scanning a simple key", key.mark,
                            "could not find expected ':'", self.get_mark())
                del self.possible_simple_keys[level]

    def save_possible_simple_key(self):
        # The next token may start a simple key. We check if it's possible
        # and save its position. This function is called for
        #   ALIAS, ANCHOR, TAG, SCALAR(flow), '[', and '{'.

        # Check if a simple key is required at the current position.
        required = not self.flow_level and self.indent == self.column

        # The next token might be a simple key. Let's save it's number and
        # position.
        if self.allow_simple_key:
            self.remove_possible_simple_key()
            token_number = self.tokens_taken+len(self.tokens)
            key = SimpleKey(token_number, required,
                    self.index, self.line, self.column, self.get_mark())
            self.possible_simple_keys[self.flow_level] = key

    def remove_possible_simple_key(self):
        # Remove the saved possible key position at the current flow level.
        if self.flow_level in self.possible_simple_keys:
            key = self.possible_simple_keys[self.flow_level]
            
            if key.required:
                raise ScannerError("while scanning a simple key", key.mark,
                        "could not find expected ':'", self.get_mark())

            del self.possible_simple_keys[self.flow_level]

    # Indentation functions.

    def unwind_indent(self, column):

        ## In flow context, tokens should respect indentation.
        ## Actually the condition should be `self.indent >= column` according to
        ## the spec. But this condition will prohibit intuitively correct
        ## constructions such as
        ## key : {
        ## }
        #if self.flow_level and self.indent > column:
        #    raise ScannerError(None, None,
        #            "invalid indentation or unclosed '[' or '{'",
        #            self.get_mark())

        # In the flow context, indentation is ignored. We make the scanner less
        # restrictive then specification requires.
        if self.flow_level:
            return

        # In block context, we may need to issue the BLOCK-END tokens.
        while self.indent > column:
            mark = self.get_mark()
            self.indent = self.indents.pop()
            self.tokens.append(BlockEndToken(mark, mark))

    def add_indent(self, column):
        # Check if we need to increase indentation.
        if self.indent < column:
            self.indents.append(self.indent)
            self.indent = column
            return True
        return False

    # Fetchers.

    def fetch_stream_start(self):
        # We always add STREAM-START as the first token and STREAM-END as the
        # last token.

        # Read the token.
        mark = self.get_mark()
        
        # Add STREAM-START.
        self.tokens.append(StreamStartToken(mark, mark,
            encoding=self.encoding))
        

    def fetch_stream_end(self):

        # Set the current indentation to -1.
        self.unwind_indent(-1)

        # Reset simple keys.
        self.remove_possible_simple_key()
        self.allow_simple_key = False
        self.possible_simple_keys = {}

        # Read the token.
        mark = self.get_mark()
        
        # Add STREAM-END.
        self.tokens.append(StreamEndToken(mark, mark))

        # The steam is finished.
        self.done = True

    def fetch_directive(self):
        
        # Set the current indentation to -1.
        self.unwind_indent(-1)

        # Reset simple keys.
        self.remove_possible_simple_key()
        self.allow_simple_key = False

        # Scan and add DIRECTIVE.
        self.tokens.append(self.scan_directive())

    def fetch_document_start(self):
        self.fetch_document_indicator(DocumentStartToken)

    def fetch_document_end(self):
        self.fetch_document_indicator(DocumentEndToken)

    def fetch_document_indicator(self, TokenClass):

        # Set the current indentation to -1.
        self.unwind_indent(-1)

        # Reset simple keys. Note that there could not be a block collection
        # after '---'.
        self.remove_possible_simple_key()
        self.allow_simple_key = False

        # Add DOCUMENT-START or DOCUMENT-END.
        start_mark = self.get_mark()
        self.forward(3)
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_sequence_start(self):
        self.fetch_flow_collection_start(FlowSequenceStartToken)

    def fetch_flow_mapping_start(self):
        self.fetch_flow_collection_start(FlowMappingStartToken)

    def fetch_flow_collection_start(self, TokenClass):

        # '[' and '{' may start a simple key.
        self.save_possible_simple_key()

        # Increase the flow level.
        self.flow_level += 1

        # Simple keys are allowed after '[' and '{'.
        self.allow_simple_key = True

        # Add FLOW-SEQUENCE-START or FLOW-MAPPING-START.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_sequence_end(self):
        self.fetch_flow_collection_end(FlowSequenceEndToken)

    def fetch_flow_mapping_end(self):
        self.fetch_flow_collection_end(FlowMappingEndToken)

    def fetch_flow_collection_end(self, TokenClass):

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Decrease the flow level.
        self.flow_level -= 1

        # No simple keys after ']' or '}'.
        self.allow_simple_key = False

        # Add FLOW-SEQUENCE-END or FLOW-MAPPING-END.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(TokenClass(start_mark, end_mark))

    def fetch_flow_entry(self):

        # Simple keys are allowed after ','.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add FLOW-ENTRY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(FlowEntryToken(start_mark, end_mark))

    def fetch_block_entry(self):

        # Block context needs additional checks.
        if not self.flow_level:

            # Are we allowed to start a new entry?
            if not self.allow_simple_key:
                raise ScannerError(None, None,
                        "sequence entries are not allowed here",
                        self.get_mark())

            # We may need to add BLOCK-SEQUENCE-START.
            if self.add_indent(self.column):
                mark = self.get_mark()
                self.tokens.append(BlockSequenceStartToken(mark, mark))

        # It's an error for the block entry to occur in the flow context,
        # but we let the parser detect this.
        else:
            pass

        # Simple keys are allowed after '-'.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add BLOCK-ENTRY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(BlockEntryToken(start_mark, end_mark))

    def fetch_key(self):
        
        # Block context needs additional checks.
        if not self.flow_level:

            # Are we allowed to start a key (not necessary a simple)?
            if not self.allow_simple_key:
                raise ScannerError(None, None,
                        "mapping keys are not allowed here",
                        self.get_mark())

            # We may need to add BLOCK-MAPPING-START.
            if self.add_indent(self.column):
                mark = self.get_mark()
                self.tokens.append(BlockMappingStartToken(mark, mark))

        # Simple keys are allowed after '?' in the block context.
        self.allow_simple_key = not self.flow_level

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Add KEY.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(KeyToken(start_mark, end_mark))

    def fetch_value(self):

        # Do we determine a simple key?
        if self.flow_level in self.possible_simple_keys:

            # Add KEY.
            key = self.possible_simple_keys[self.flow_level]
            del self.possible_simple_keys[self.flow_level]
            self.tokens.insert(key.token_number-self.tokens_taken,
                    KeyToken(key.mark, key.mark))

            # If this key starts a new block mapping, we need to add
            # BLOCK-MAPPING-START.
            if not self.flow_level:
                if self.add_indent(key.column):
                    self.tokens.insert(key.token_number-self.tokens_taken,
                            BlockMappingStartToken(key.mark, key.mark))

            # There cannot be two simple keys one after another.
            self.allow_simple_key = False

        # It must be a part of a complex key.
        else:
            
            # Block context needs additional checks.
            # (Do we really need them? They will be caught by the parser
            # anyway.)
            if not self.flow_level:

                # We are allowed to start a complex value if and only if
                # we can start a simple key.
                if not self.allow_simple_key:
                    raise ScannerError(None, None,
                            "mapping values are not allowed here",
                            self.get_mark())

            # If this value starts a new block mapping, we need to add
            # BLOCK-MAPPING-START.  It will be detected as an error later by
            # the parser.
            if not self.flow_level:
                if self.add_indent(self.column):
                    mark = self.get_mark()
                    self.tokens.append(BlockMappingStartToken(mark, mark))

            # Simple keys are allowed after ':' in the block context.
            self.allow_simple_key = not self.flow_level

            # Reset possible simple key on the current level.
            self.remove_possible_simple_key()

        # Add VALUE.
        start_mark = self.get_mark()
        self.forward()
        end_mark = self.get_mark()
        self.tokens.append(ValueToken(start_mark, end_mark))

    def fetch_alias(self):

        # ALIAS could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after ALIAS.
        self.allow_simple_key = False

        # Scan and add ALIAS.
        self.tokens.append(self.scan_anchor(AliasToken))

    def fetch_anchor(self):

        # ANCHOR could start a simple key.
        self.save_possible_simple_key()

        # No simple keys after ANCHOR.
        self.allow_simple_key = False

        # Scan and add ANCHOR.
        self.tokens.append(self.scan_anchor(AnchorToken))

    def fetch_tag(self):

        # TAG could start a simple key.
        self.save_possible_simple_key()

        # No simple keys after TAG.
        self.allow_simple_key = False

        # Scan and add TAG.
        self.tokens.append(self.scan_tag())

    def fetch_literal(self):
        self.fetch_block_scalar(style='|')

    def fetch_folded(self):
        self.fetch_block_scalar(style='>')

    def fetch_block_scalar(self, style):

        # A simple key may follow a block scalar.
        self.allow_simple_key = True

        # Reset possible simple key on the current level.
        self.remove_possible_simple_key()

        # Scan and add SCALAR.
        self.tokens.append(self.scan_block_scalar(style))

    def fetch_single(self):
        self.fetch_flow_scalar(style='\'')

    def fetch_double(self):
        self.fetch_flow_scalar(style='"')

    def fetch_flow_scalar(self, style):

        # A flow scalar could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after flow scalars.
        self.allow_simple_key = False

        # Scan and add SCALAR.
        self.tokens.append(self.scan_flow_scalar(style))

    def fetch_plain(self):

        # A plain scalar could be a simple key.
        self.save_possible_simple_key()

        # No simple keys after plain scalars. But note that `scan_plain` will
        # change this flag if the scan is finished at the beginning of the
        # line.
        self.allow_simple_key = False

        # Scan and add SCALAR. May change `allow_simple_key`.
        self.tokens.append(self.scan_plain())

    # Checkers.

    def check_directive(self):

        # DIRECTIVE:        ^ '%' ...
        # The '%' indicator is already checked.
        if self.column == 0:
            return True

    def check_document_start(self):

        # DOCUMENT-START:   ^ '---' (' '|'\n')
        if self.column == 0:
            if self.prefix(3) == '---'  \
                    and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                return True

    def check_document_end(self):

        # DOCUMENT-END:     ^ '...' (' '|'\n')
        if self.column == 0:
            if self.prefix(3) == '...'  \
                    and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                return True

    def check_block_entry(self):

        # BLOCK-ENTRY:      '-' (' '|'\n')
        return self.peek(1) in '\0 \t\r\n\x85\u2028\u2029'

    def check_key(self):

        # KEY(flow context):    '?'
        if self.flow_level:
            return True

        # KEY(block context):   '?' (' '|'\n')
        else:
            return self.peek(1) in '\0 \t\r\n\x85\u2028\u2029'

    def check_value(self):

        # VALUE(flow context):  ':'
        if self.flow_level:
            return True

        # VALUE(block context): ':' (' '|'\n')
        else:
            return self.peek(1) in '\0 \t\r\n\x85\u2028\u2029'

    def check_plain(self):

        # A plain scalar may start with any non-space character except:
        #   '-', '?', ':', ',', '[', ']', '{', '}',
        #   '#', '&', '*', '!', '|', '>', '\'', '\"',
        #   '%', '@', '`'.
        #
        # It may also start with
        #   '-', '?', ':'
        # if it is followed by a non-space character.
        #
        # Note that we limit the last rule to the block context (except the
        # '-' character) because we want the flow context to be space
        # independent.
        ch = self.peek()
        return ch not in '\0 \t\r\n\x85\u2028\u2029-?:,[]{}#&*!|>\'\"%@`'  \
                or (self.peek(1) not in '\0 \t\r\n\x85\u2028\u2029'
                        and (ch == '-' or (not self.flow_level and ch in '?:')))

    # Scanners.

    def scan_to_next_token(self):
        # We ignore spaces, line breaks and comments.
        # If we find a line break in the block context, we set the flag
        # `allow_simple_key` on.
        # The byte order mark is stripped if it's the first character in the
        # stream. We do not yet support BOM inside the stream as the
        # specification requires. Any such mark will be considered as a part
        # of the document.
        #
        # TODO: We need to make tab handling rules more sane. A good rule is
        #   Tabs cannot precede tokens
        #   BLOCK-SEQUENCE-START, BLOCK-MAPPING-START, BLOCK-END,
        #   KEY(block), VALUE(block), BLOCK-ENTRY
        # So the checking code is
        #   if <TAB>:
        #       self.allow_simple_keys = False
        # We also need to add the check for `allow_simple_keys == True` to
        # `unwind_indent` before issuing BLOCK-END.
        # Scanners for block, flow, and plain scalars need to be modified.

        if self.index == 0 and self.peek() == '\uFEFF':
            self.forward()
        found = False
        while not found:
            while self.peek() == ' ':
                self.forward()
            if self.peek() == '#':
                while self.peek() not in '\0\r\n\x85\u2028\u2029':
                    self.forward()
            if self.scan_line_break():
                if not self.flow_level:
                    self.allow_simple_key = True
            else:
                found = True

    def scan_directive(self):
        # See the specification for details.
        start_mark = self.get_mark()
        self.forward()
        name = self.scan_directive_name(start_mark)
        value = None
        if name == 'YAML':
            value = self.scan_yaml_directive_value(start_mark)
            end_mark = self.get_mark()
        elif name == 'TAG':
            value = self.scan_tag_directive_value(start_mark)
            end_mark = self.get_mark()
        else:
            end_mark = self.get_mark()
            while self.peek() not in '\0\r\n\x85\u2028\u2029':
                self.forward()
        self.scan_directive_ignored_line(start_mark)
        return DirectiveToken(name, value, start_mark, end_mark)

    def scan_directive_name(self, start_mark):
        # See the specification for details.
        length = 0
        ch = self.peek(length)
        while '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'  \
                or ch in '-_':
            length += 1
            ch = self.peek(length)
        if not length:
            raise ScannerError("while scanning a directive", start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch, self.get_mark())
        value = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch, self.get_mark())
        return value

    def scan_yaml_directive_value(self, start_mark):
        # See the specification for details.
        while self.peek() == ' ':
            self.forward()
        major = self.scan_yaml_directive_number(start_mark)
        if self.peek() != '.':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit or '.', but found %r" % self.peek(),
                    self.get_mark())
        self.forward()
        minor = self.scan_yaml_directive_number(start_mark)
        if self.peek() not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit or ' ', but found %r" % self.peek(),
                    self.get_mark())
        return (major, minor)

    def scan_yaml_directive_number(self, start_mark):
        # See the specification for details.
        ch = self.peek()
        if not ('0' <= ch <= '9'):
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a digit, but found %r" % ch, self.get_mark())
        length = 0
        while '0' <= self.peek(length) <= '9':
            length += 1
        value = int(self.prefix(length))
        self.forward(length)
        return value

    def scan_tag_directive_value(self, start_mark):
        # See the specification for details.
        while self.peek() == ' ':
            self.forward()
        handle = self.scan_tag_directive_handle(start_mark)
        while self.peek() == ' ':
            self.forward()
        prefix = self.scan_tag_directive_prefix(start_mark)
        return (handle, prefix)

    def scan_tag_directive_handle(self, start_mark):
        # See the specification for details.
        value = self.scan_tag_handle('directive', start_mark)
        ch = self.peek()
        if ch != ' ':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected ' ', but found %r" % ch, self.get_mark())
        return value

    def scan_tag_directive_prefix(self, start_mark):
        # See the specification for details.
        value = self.scan_tag_uri('directive', start_mark)
        ch = self.peek()
        if ch not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected ' ', but found %r" % ch, self.get_mark())
        return value

    def scan_directive_ignored_line(self, start_mark):
        # See the specification for details.
        while self.peek() == ' ':
            self.forward()
        if self.peek() == '#':
            while self.peek() not in '\0\r\n\x85\u2028\u2029':
                self.forward()
        ch = self.peek()
        if ch not in '\0\r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a directive", start_mark,
                    "expected a comment or a line break, but found %r"
                        % ch, self.get_mark())
        self.scan_line_break()

    def scan_anchor(self, TokenClass):
        # The specification does not restrict characters for anchors and
        # aliases. This may lead to problems, for instance, the document:
        #   [ *alias, value ]
        # can be interpreted in two ways, as
        #   [ "value" ]
        # and
        #   [ *alias , "value" ]
        # Therefore we restrict aliases to numbers and ASCII letters.
        start_mark = self.get_mark()
        indicator = self.peek()
        if indicator == '*':
            name = 'alias'
        else:
            name = 'anchor'
        self.forward()
        length = 0
        ch = self.peek(length)
        while '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'  \
                or ch in '-_':
            length += 1
            ch = self.peek(length)
        if not length:
            raise ScannerError("while scanning an %s" % name, start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch, self.get_mark())
        value = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch not in '\0 \t\r\n\x85\u2028\u2029?:,]}%@`':
            raise ScannerError("while scanning an %s" % name, start_mark,
                    "expected alphabetic or numeric character, but found %r"
                    % ch, self.get_mark())
        end_mark = self.get_mark()
        return TokenClass(value, start_mark, end_mark)

    def scan_tag(self):
        # See the specification for details.
        start_mark = self.get_mark()
        ch = self.peek(1)
        if ch == '<':
            handle = None
            self.forward(2)
            suffix = self.scan_tag_uri('tag', start_mark)
            if self.peek() != '>':
                raise ScannerError("while parsing a tag", start_mark,
                        "expected '>', but found %r" % self.peek(),
                        self.get_mark())
            self.forward()
        elif ch in '\0 \t\r\n\x85\u2028\u2029':
            handle = None
            suffix = '!'
            self.forward()
        else:
            length = 1
            use_handle = False
            while ch not in '\0 \r\n\x85\u2028\u2029':
                if ch == '!':
                    use_handle = True
                    break
                length += 1
                ch = self.peek(length)
            handle = '!'
            if use_handle:
                handle = self.scan_tag_handle('tag', start_mark)
            else:
                handle = '!'
                self.forward()
            suffix = self.scan_tag_uri('tag', start_mark)
        ch = self.peek()
        if ch not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a tag", start_mark,
                    "expected ' ', but found %r" % ch, self.get_mark())
        value = (handle, suffix)
        end_mark = self.get_mark()
        return TagToken(value, start_mark, end_mark)

    def scan_block_scalar(self, style):
        # See the specification for details.

        if style == '>':
            folded = True
        else:
            folded = False

        chunks = []
        start_mark = self.get_mark()

        # Scan the header.
        self.forward()
        chomping, increment = self.scan_block_scalar_indicators(start_mark)
        self.scan_block_scalar_ignored_line(start_mark)

        # Determine the indentation level and go to the first non-empty line.
        min_indent = self.indent+1
        if min_indent < 1:
            min_indent = 1
        if increment is None:
            breaks, max_indent, end_mark = self.scan_block_scalar_indentation()
            indent = max(min_indent, max_indent)
        else:
            indent = min_indent+increment-1
            breaks, end_mark = self.scan_block_scalar_breaks(indent)
        line_break = ''

        # Scan the inner part of the block scalar.
        while self.column == indent and self.peek() != '\0':
            chunks.extend(breaks)
            leading_non_space = self.peek() not in ' \t'
            length = 0
            while self.peek(length) not in '\0\r\n\x85\u2028\u2029':
                length += 1
            chunks.append(self.prefix(length))
            self.forward(length)
            line_break = self.scan_line_break()
            breaks, end_mark = self.scan_block_scalar_breaks(indent)
            if self.column == indent and self.peek() != '\0':

                # Unfortunately, folding rules are ambiguous.
                #
                # This is the folding according to the specification:
                
                if folded and line_break == '\n'    \
                        and leading_non_space and self.peek() not in ' \t':
                    if not breaks:
                        chunks.append(' ')
                else:
                    chunks.append(line_break)
                
                # This is Clark Evans's interpretation (also in the spec
                # examples):
                #
                #if folded and line_break == '\n':
                #    if not breaks:
                #        if self.peek() not in ' \t':
                #            chunks.append(' ')
                #        else:
                #            chunks.append(line_break)
                #else:
                #    chunks.append(line_break)
            else:
                break

        # Chomp the tail.
        if chomping is not False:
            chunks.append(line_break)
        if chomping is True:
            chunks.extend(breaks)

        # We are done.
        return ScalarToken(''.join(chunks), False, start_mark, end_mark,
                style)

    def scan_block_scalar_indicators(self, start_mark):
        # See the specification for details.
        chomping = None
        increment = None
        ch = self.peek()
        if ch in '+-':
            if ch == '+':
                chomping = True
            else:
                chomping = False
            self.forward()
            ch = self.peek()
            if ch in '0123456789':
                increment = int(ch)
                if increment == 0:
                    raise ScannerError("while scanning a block scalar", start_mark,
                            "expected indentation indicator in the range 1-9, but found 0",
                            self.get_mark())
                self.forward()
        elif ch in '0123456789':
            increment = int(ch)
            if increment == 0:
                raise ScannerError("while scanning a block scalar", start_mark,
                        "expected indentation indicator in the range 1-9, but found 0",
                        self.get_mark())
            self.forward()
            ch = self.peek()
            if ch in '+-':
                if ch == '+':
                    chomping = True
                else:
                    chomping = False
                self.forward()
        ch = self.peek()
        if ch not in '\0 \r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a block scalar", start_mark,
                    "expected chomping or indentation indicators, but found %r"
                    % ch, self.get_mark())
        return chomping, increment

    def scan_block_scalar_ignored_line(self, start_mark):
        # See the specification for details.
        while self.peek() == ' ':
            self.forward()
        if self.peek() == '#':
            while self.peek() not in '\0\r\n\x85\u2028\u2029':
                self.forward()
        ch = self.peek()
        if ch not in '\0\r\n\x85\u2028\u2029':
            raise ScannerError("while scanning a block scalar", start_mark,
                    "expected a comment or a line break, but found %r" % ch,
                    self.get_mark())
        self.scan_line_break()

    def scan_block_scalar_indentation(self):
        # See the specification for details.
        chunks = []
        max_indent = 0
        end_mark = self.get_mark()
        while self.peek() in ' \r\n\x85\u2028\u2029':
            if self.peek() != ' ':
                chunks.append(self.scan_line_break())
                end_mark = self.get_mark()
            else:
                self.forward()
                if self.column > max_indent:
                    max_indent = self.column
        return chunks, max_indent, end_mark

    def scan_block_scalar_breaks(self, indent):
        # See the specification for details.
        chunks = []
        end_mark = self.get_mark()
        while self.column < indent and self.peek() == ' ':
            self.forward()
        while self.peek() in '\r\n\x85\u2028\u2029':
            chunks.append(self.scan_line_break())
            end_mark = self.get_mark()
            while self.column < indent and self.peek() == ' ':
                self.forward()
        return chunks, end_mark

    def scan_flow_scalar(self, style):
        # See the specification for details.
        # Note that we loose indentation rules for quoted scalars. Quoted
        # scalars don't need to adhere indentation because " and ' clearly
        # mark the beginning and the end of them. Therefore we are less
        # restrictive then the specification requires. We only need to check
        # that document separators are not included in scalars.
        if style == '"':
            double = True
        else:
            double = False
        chunks = []
        start_mark = self.get_mark()
        quote = self.peek()
        self.forward()
        chunks.extend(self.scan_flow_scalar_non_spaces(double, start_mark))
        while self.peek() != quote:
            chunks.extend(self.scan_flow_scalar_spaces(double, start_mark))
            chunks.extend(self.scan_flow_scalar_non_spaces(double, start_mark))
        self.forward()
        end_mark = self.get_mark()
        return ScalarToken(''.join(chunks), False, start_mark, end_mark,
                style)

    ESCAPE_REPLACEMENTS = {
        '0':    '\0',
        'a':    '\x07',
        'b':    '\x08',
        't':    '\x09',
        '\t':   '\x09',
        'n':    '\x0A',
        'v':    '\x0B',
        'f':    '\x0C',
        'r':    '\x0D',
        'e':    '\x1B',
        ' ':    '\x20',
        '\"':   '\"',
        '\\':   '\\',
        '/':    '/',
        'N':    '\x85',
        '_':    '\xA0',
        'L':    '\u2028',
        'P':    '\u2029',
    }

    ESCAPE_CODES = {
        'x':    2,
        'u':    4,
        'U':    8,
    }

    def scan_flow_scalar_non_spaces(self, double, start_mark):
        # See the specification for details.
        chunks = []
        while True:
            length = 0
            while self.peek(length) not in '\'\"\\\0 \t\r\n\x85\u2028\u2029':
                length += 1
            if length:
                chunks.append(self.prefix(length))
                self.forward(length)
            ch = self.peek()
            if not double and ch == '\'' and self.peek(1) == '\'':
                chunks.append('\'')
                self.forward(2)
            elif (double and ch == '\'') or (not double and ch in '\"\\'):
                chunks.append(ch)
                self.forward()
            elif double and ch == '\\':
                self.forward()
                ch = self.peek()
                if ch in self.ESCAPE_REPLACEMENTS:
                    chunks.append(self.ESCAPE_REPLACEMENTS[ch])
                    self.forward()
                elif ch in self.ESCAPE_CODES:
                    length = self.ESCAPE_CODES[ch]
                    self.forward()
                    for k in range(length):
                        if self.peek(k) not in '0123456789ABCDEFabcdef':
                            raise ScannerError("while scanning a double-quoted scalar", start_mark,
                                    "expected escape sequence of %d hexadecimal numbers, but found %r" %
                                        (length, self.peek(k)), self.get_mark())
                    code = int(self.prefix(length), 16)
                    chunks.append(chr(code))
                    self.forward(length)
                elif ch in '\r\n\x85\u2028\u2029':
                    self.scan_line_break()
                    chunks.extend(self.scan_flow_scalar_breaks(double, start_mark))
                else:
                    raise ScannerError("while scanning a double-quoted scalar", start_mark,
                            "found unknown escape character %r" % ch, self.get_mark())
            else:
                return chunks

    def scan_flow_scalar_spaces(self, double, start_mark):
        # See the specification for details.
        chunks = []
        length = 0
        while self.peek(length) in ' \t':
            length += 1
        whitespaces = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch == '\0':
            raise ScannerError("while scanning a quoted scalar", start_mark,
                    "found unexpected end of stream", self.get_mark())
        elif ch in '\r\n\x85\u2028\u2029':
            line_break = self.scan_line_break()
            breaks = self.scan_flow_scalar_breaks(double, start_mark)
            if line_break != '\n':
                chunks.append(line_break)
            elif not breaks:
                chunks.append(' ')
            chunks.extend(breaks)
        else:
            chunks.append(whitespaces)
        return chunks

    def scan_flow_scalar_breaks(self, double, start_mark):
        # See the specification for details.
        chunks = []
        while True:
            # Instead of checking indentation, we check for document
            # separators.
            prefix = self.prefix(3)
            if (prefix == '---' or prefix == '...')   \
                    and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                raise ScannerError("while scanning a quoted scalar", start_mark,
                        "found unexpected document separator", self.get_mark())
            while self.peek() in ' \t':
                self.forward()
            if self.peek() in '\r\n\x85\u2028\u2029':
                chunks.append(self.scan_line_break())
            else:
                return chunks

    def scan_plain(self):
        # See the specification for details.
        # We add an additional restriction for the flow context:
        #   plain scalars in the flow context cannot contain ',' or '?'.
        # We also keep track of the `allow_simple_key` flag here.
        # Indentation rules are loosed for the flow context.
        chunks = []
        start_mark = self.get_mark()
        end_mark = start_mark
        indent = self.indent+1
        # We allow zero indentation for scalars, but then we need to check for
        # document separators at the beginning of the line.
        #if indent == 0:
        #    indent = 1
        spaces = []
        while True:
            length = 0
            if self.peek() == '#':
                break
            while True:
                ch = self.peek(length)
                if ch in '\0 \t\r\n\x85\u2028\u2029'    \
                        or (ch == ':' and
                                self.peek(length+1) in '\0 \t\r\n\x85\u2028\u2029'
                                      + (u',[]{}' if self.flow_level else u''))\
                        or (self.flow_level and ch in ',?[]{}'):
                    break
                length += 1
            if length == 0:
                break
            self.allow_simple_key = False
            chunks.extend(spaces)
            chunks.append(self.prefix(length))
            self.forward(length)
            end_mark = self.get_mark()
            spaces = self.scan_plain_spaces(indent, start_mark)
            if not spaces or self.peek() == '#' \
                    or (not self.flow_level and self.column < indent):
                break
        return ScalarToken(''.join(chunks), True, start_mark, end_mark)

    def scan_plain_spaces(self, indent, start_mark):
        # See the specification for details.
        # The specification is really confusing about tabs in plain scalars.
        # We just forbid them completely. Do not use tabs in YAML!
        chunks = []
        length = 0
        while self.peek(length) in ' ':
            length += 1
        whitespaces = self.prefix(length)
        self.forward(length)
        ch = self.peek()
        if ch in '\r\n\x85\u2028\u2029':
            line_break = self.scan_line_break()
            self.allow_simple_key = True
            prefix = self.prefix(3)
            if (prefix == '---' or prefix == '...')   \
                    and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                return
            breaks = []
            while self.peek() in ' \r\n\x85\u2028\u2029':
                if self.peek() == ' ':
                    self.forward()
                else:
                    breaks.append(self.scan_line_break())
                    prefix = self.prefix(3)
                    if (prefix == '---' or prefix == '...')   \
                            and self.peek(3) in '\0 \t\r\n\x85\u2028\u2029':
                        return
            if line_break != '\n':
                chunks.append(line_break)
            elif not breaks:
                chunks.append(' ')
            chunks.extend(breaks)
        elif whitespaces:
            chunks.append(whitespaces)
        return chunks

    def scan_tag_handle(self, name, start_mark):
        # See the specification for details.
        # For some strange reasons, the specification does not allow '_' in
        # tag handles. I have allowed it anyway.
        ch = self.peek()
        if ch != '!':
            raise ScannerError("while scanning a %s" % name, start_mark,
                    "expected '!', but found %r" % ch, self.get_mark())
        length = 1
        ch = self.peek(length)
        if ch != ' ':
            while '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'  \
                    or ch in '-_':
                length += 1
                ch = self.peek(length)
            if ch != '!':
                self.forward(length)
                raise ScannerError("while scanning a %s" % name, start_mark,
                        "expected '!', but found %r" % ch, self.get_mark())
            length += 1
        value = self.prefix(length)
        self.forward(length)
        return value

    def scan_tag_uri(self, name, start_mark):
        # See the specification for details.
        # Note: we do not check if URI is well-formed.
        chunks = []
        length = 0
        ch = self.peek(length)
        while '0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z'  \
                or ch in '-;/?:@&=+$,_.!~*\'()[]%':
            if ch == '%':
                chunks.append(self.prefix(length))
                self.forward(length)
                length = 0
                chunks.append(self.scan_uri_escapes(name, start_mark))
            else:
                length += 1
            ch = self.peek(length)
        if length:
            chunks.append(self.prefix(length))
            self.forward(length)
            length = 0
        if not chunks:
            raise ScannerError("while parsing a %s" % name, start_mark,
                    "expected URI, but found %r" % ch, self.get_mark())
        return ''.join(chunks)

    def scan_uri_escapes(self, name, start_mark):
        # See the specification for details.
        codes = []
        mark = self.get_mark()
        while self.peek() == '%':
            self.forward()
            for k in range(2):
                if self.peek(k) not in '0123456789ABCDEFabcdef':
                    raise ScannerError("while scanning a %s" % name, start_mark,
                            "expected URI escape sequence of 2 hexadecimal numbers, but found %r"
                            % self.peek(k), self.get_mark())
            codes.append(int(self.prefix(2), 16))
            self.forward(2)
        try:
            value = bytes(codes).decode('utf-8')
        except UnicodeDecodeError as exc:
            raise ScannerError("while scanning a %s" % name, start_mark, str(exc), mark)
        return value

    def scan_line_break(self):
        # Transforms:
        #   '\r\n'      :   '\n'
        #   '\r'        :   '\n'
        #   '\n'        :   '\n'
        #   '\x85'      :   '\n'
        #   '\u2028'    :   '\u2028'
        #   '\u2029     :   '\u2029'
        #   default     :   ''
        ch = self.peek()
        if ch in '\r\n\x85':
            if self.prefix(2) == '\r\n':
                self.forward(2)
            else:
                self.forward()
            return '\n'
        elif ch in '\u2028\u2029':
            self.forward()
            return ch
        return ''


# ================================================================================
# Datei: venv\Lib\site-packages\yaml\serializer.py
# ================================================================================


__all__ = ['Serializer', 'SerializerError']

from .error import YAMLError
from .events import *
from .nodes import *

class SerializerError(YAMLError):
    pass

class Serializer:

    ANCHOR_TEMPLATE = 'id%03d'

    def __init__(self, encoding=None,
            explicit_start=None, explicit_end=None, version=None, tags=None):
        self.use_encoding = encoding
        self.use_explicit_start = explicit_start
        self.use_explicit_end = explicit_end
        self.use_version = version
        self.use_tags = tags
        self.serialized_nodes = {}
        self.anchors = {}
        self.last_anchor_id = 0
        self.closed = None

    def open(self):
        if self.closed is None:
            self.emit(StreamStartEvent(encoding=self.use_encoding))
            self.closed = False
        elif self.closed:
            raise SerializerError("serializer is closed")
        else:
            raise SerializerError("serializer is already opened")

    def close(self):
        if self.closed is None:
            raise SerializerError("serializer is not opened")
        elif not self.closed:
            self.emit(StreamEndEvent())
            self.closed = True

    #def __del__(self):
    #    self.close()

    def serialize(self, node):
        if self.closed is None:
            raise SerializerError("serializer is not opened")
        elif self.closed:
            raise SerializerError("serializer is closed")
        self.emit(DocumentStartEvent(explicit=self.use_explicit_start,
            version=self.use_version, tags=self.use_tags))
        self.anchor_node(node)
        self.serialize_node(node, None, None)
        self.emit(DocumentEndEvent(explicit=self.use_explicit_end))
        self.serialized_nodes = {}
        self.anchors = {}
        self.last_anchor_id = 0

    def anchor_node(self, node):
        if node in self.anchors:
            if self.anchors[node] is None:
                self.anchors[node] = self.generate_anchor(node)
        else:
            self.anchors[node] = None
            if isinstance(node, SequenceNode):
                for item in node.value:
                    self.anchor_node(item)
            elif isinstance(node, MappingNode):
                for key, value in node.value:
                    self.anchor_node(key)
                    self.anchor_node(value)

    def generate_anchor(self, node):
        self.last_anchor_id += 1
        return self.ANCHOR_TEMPLATE % self.last_anchor_id

    def serialize_node(self, node, parent, index):
        alias = self.anchors[node]
        if node in self.serialized_nodes:
            self.emit(AliasEvent(alias))
        else:
            self.serialized_nodes[node] = True
            self.descend_resolver(parent, index)
            if isinstance(node, ScalarNode):
                detected_tag = self.resolve(ScalarNode, node.value, (True, False))
                default_tag = self.resolve(ScalarNode, node.value, (False, True))
                implicit = (node.tag == detected_tag), (node.tag == default_tag)
                self.emit(ScalarEvent(alias, node.tag, implicit, node.value,
                    style=node.style))
            elif isinstance(node, SequenceNode):
                implicit = (node.tag
                            == self.resolve(SequenceNode, node.value, True))
                self.emit(SequenceStartEvent(alias, node.tag, implicit,
                    flow_style=node.flow_style))
                index = 0
                for item in node.value:
                    self.serialize_node(item, node, index)
                    index += 1
                self.emit(SequenceEndEvent())
            elif isinstance(node, MappingNode):
                implicit = (node.tag
                            == self.resolve(MappingNode, node.value, True))
                self.emit(MappingStartEvent(alias, node.tag, implicit,
                    flow_style=node.flow_style))
                for key, value in node.value:
                    self.serialize_node(key, node, None)
                    self.serialize_node(value, node, key)
                self.emit(MappingEndEvent())
            self.ascend_resolver()



# ================================================================================
# Datei: venv\Lib\site-packages\yaml\tokens.py
# ================================================================================


class Token(object):
    def __init__(self, start_mark, end_mark):
        self.start_mark = start_mark
        self.end_mark = end_mark
    def __repr__(self):
        attributes = [key for key in self.__dict__
                if not key.endswith('_mark')]
        attributes.sort()
        arguments = ', '.join(['%s=%r' % (key, getattr(self, key))
                for key in attributes])
        return '%s(%s)' % (self.__class__.__name__, arguments)

#class BOMToken(Token):
#    id = '<byte order mark>'

class DirectiveToken(Token):
    id = '<directive>'
    def __init__(self, name, value, start_mark, end_mark):
        self.name = name
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class DocumentStartToken(Token):
    id = '<document start>'

class DocumentEndToken(Token):
    id = '<document end>'

class StreamStartToken(Token):
    id = '<stream start>'
    def __init__(self, start_mark=None, end_mark=None,
            encoding=None):
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.encoding = encoding

class StreamEndToken(Token):
    id = '<stream end>'

class BlockSequenceStartToken(Token):
    id = '<block sequence start>'

class BlockMappingStartToken(Token):
    id = '<block mapping start>'

class BlockEndToken(Token):
    id = '<block end>'

class FlowSequenceStartToken(Token):
    id = '['

class FlowMappingStartToken(Token):
    id = '{'

class FlowSequenceEndToken(Token):
    id = ']'

class FlowMappingEndToken(Token):
    id = '}'

class KeyToken(Token):
    id = '?'

class ValueToken(Token):
    id = ':'

class BlockEntryToken(Token):
    id = '-'

class FlowEntryToken(Token):
    id = ','

class AliasToken(Token):
    id = '<alias>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class AnchorToken(Token):
    id = '<anchor>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class TagToken(Token):
    id = '<tag>'
    def __init__(self, value, start_mark, end_mark):
        self.value = value
        self.start_mark = start_mark
        self.end_mark = end_mark

class ScalarToken(Token):
    id = '<scalar>'
    def __init__(self, value, plain, start_mark, end_mark, style=None):
        self.value = value
        self.plain = plain
        self.start_mark = start_mark
        self.end_mark = end_mark
        self.style = style

