# MaehrDocs Code Übersicht

# Generiert am extract_code.py



# ================================================================================
# Datei: maehrdocs\__init__.py
# ================================================================================

"""
MaehrDocs - Automatisches Dokumentenmanagementsystem
Modularisierte Version mit verbesserter Struktur

Dieses Paket enthält alle Komponenten für das MaehrDocs System:
- Konfigurationsverwaltung
- Dokumentenverarbeitung
- Duplikaterkennung
- Grafische Benutzeroberfläche
"""

__version__ = '2.0.0'
__author__ = 'René Mähr'
__email__ = 'rene.maehr@web.de'

# Hauptklassen für einfachen Import
from .config import ConfigManager
from .document_processor import DocumentProcessor
from .duplicate_detector import DuplicateDetector

# Aliase für die GUI
from .gui import GuiApp

__all__ = [
    'ConfigManager',
    'DocumentProcessor',
    'DuplicateDetector',
    'GuiApp',
]

# ================================================================================
# Datei: maehrdocs\config.py
# ================================================================================

"""
Konfigurationsverwaltung für MaehrDocs
Enthält die ConfigManager-Klasse zum Laden, Speichern und Verwalten der Anwendungskonfiguration.

Dieses Modul bildet das Herzstück für alle konfigurationsbezogenen Funktionen und
gewährleistet eine konsistente, persistente Speicherung von Benutzereinstellungen.
Es unterstützt das Erstellen von Standardkonfigurationen und das sichere Speichern
und Laden von Konfigurationsdaten im YAML-Format.

Die Implementierung als Singleton-Pattern stellt sicher, dass im gesamten System
nur eine Instanz der Konfiguration existiert, um Dateninkonsistenzen zu vermeiden
und den Zugriff auf Konfigurationsdaten zu vereinheitlichen.
"""

import os
import yaml
import logging
from pathlib import Path
from typing import Dict, Any, Optional

class ConfigManager:
    """
    Verwaltet die Konfiguration des MaehrDocs-Systems als Singleton
    
    Stellt sicher, dass im gesamten System nur eine Instanz der
    Konfiguration existiert, um Inkonsistenzen zu vermeiden.
    Bietet Methoden zum Laden, Speichern und Zurücksetzen der Konfiguration.
    """
    
    # Singleton-Instanz
    _instance: Optional['ConfigManager'] = None
    
    # Klassenattribut für den Pfad zur Konfigurationsdatei
    DEFAULT_CONFIG_PATH = "autodocs_config.yaml"
    
    def __new__(cls, config_path=None):
        """
        Erstellt eine neue Instanz oder gibt die bestehende Singleton-Instanz zurück
        
        Args:
            config_path: Pfad zur Konfigurationsdatei (optional)
            
        Returns:
            ConfigManager: Die Singleton-Instanz
        """
        if cls._instance is None:
            cls._instance = super(ConfigManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self, config_path=None):
        """
        Initialisiert den ConfigManager
        
        Args:
            config_path: Pfad zur Konfigurationsdatei (optional)
        """
        # Vermeidet mehrfache Initialisierung des Singletons
        if self._initialized:
            return
            
        self.config_path = config_path or self.DEFAULT_CONFIG_PATH
        self.logger = logging.getLogger(__name__)
        self._config = None  # Lazy Loading - wird erst bei Bedarf geladen
        self._initialized = True
        
        self.logger.debug(f"ConfigManager initialisiert mit Pfad: {self.config_path}")
    
    @property
    def config(self) -> Dict[str, Any]:
        """
        Property-Getter für die Konfiguration mit Lazy Loading
        
        Returns:
            dict: Die aktuelle Konfiguration
        """
        if self._config is None:
            self._load_config()
        return self._config
    
    def get_config(self) -> Dict[str, Any]:
        """
        Gibt die aktuelle Konfiguration zurück
        
        Returns:
            dict: Die aktuelle Konfiguration
        """
        return self.config
    
    def _load_config(self) -> None:
        """
        Lädt die Konfiguration aus der YAML-Datei (intern)
        """
        try:
            if not os.path.exists(self.config_path):
                self.logger.info(f"Konfigurationsdatei {self.config_path} nicht gefunden. Erstelle Standardkonfiguration.")
                self._config = self.create_default_config()
                self.save_config(self._config)
            else:
                with open(self.config_path, 'r', encoding='utf-8') as file:
                    self._config = yaml.safe_load(file)
                    self.logger.info(f"Konfiguration aus {self.config_path} geladen.")
        except Exception as e:
            self.logger.error(f"Fehler beim Laden der Konfiguration: {str(e)}")
            self.logger.info("Verwende Standardkonfiguration.")
            self._config = self.create_default_config()
    
    def reload_config(self) -> Dict[str, Any]:
        """
        Lädt die Konfiguration neu und gibt sie zurück
        
        Nützlich, wenn die Konfigurationsdatei extern geändert wurde
        und die Änderungen übernommen werden sollen.
        
        Returns:
            dict: Die neu geladene Konfiguration
        """
        self._config = None  # Zurücksetzen, damit beim nächsten Zugriff neu geladen wird
        return self.config
    
    def save_config(self, config: Dict[str, Any]) -> bool:
        """
        Speichert die Konfiguration in die YAML-Datei
        
        Args:
            config: Die zu speichernde Konfiguration
            
        Returns:
            bool: True bei Erfolg, False bei Fehler
        """
        try:
            with open(self.config_path, 'w', encoding='utf-8') as file:
                yaml.dump(config, file, default_flow_style=False, allow_unicode=True)
                self.logger.info(f"Konfiguration in {self.config_path} gespeichert.")
            
            # Aktualisiere die interne Konfiguration
            self._config = config
            return True
            
        except Exception as e:
            self.logger.error(f"Fehler beim Speichern der Konfiguration: {str(e)}")
            return False
    
    def update_config(self, updates: Dict[str, Any], section: str = None) -> bool:
        """
        Aktualisiert die Konfiguration mit den angegebenen Werten
        
        Args:
            updates: Dictionary mit den zu aktualisierenden Werten
            section: Optional, Konfigurationsabschnitt (z.B. 'paths')
            
        Returns:
            bool: True bei Erfolg, False bei Fehler
        """
        try:
            if section:
                if section not in self.config:
                    self.config[section] = {}
                self.config[section].update(updates)
            else:
                self.config.update(updates)
                
            return self.save_config(self.config)
            
        except Exception as e:
            self.logger.error(f"Fehler beim Aktualisieren der Konfiguration: {str(e)}")
            return False
    
    def reset_section(self, section: str) -> bool:
        """
        Setzt einen Konfigurationsabschnitt auf die Standardwerte zurück
        
        Args:
            section: Name des Konfigurationsabschnitts
            
        Returns:
            bool: True bei Erfolg, False bei Fehler
        """
        try:
            default_config = self.create_default_config()
            if section in default_config:
                self.config[section] = default_config[section]
                return self.save_config(self.config)
            return False
            
        except Exception as e:
            self.logger.error(f"Fehler beim Zurücksetzen des Abschnitts {section}: {str(e)}")
            return False
    
    def reset_config(self) -> bool:
        """
        Setzt die gesamte Konfiguration auf die Standardwerte zurück
        
        Returns:
            bool: True bei Erfolg, False bei Fehler
        """
        try:
            self._config = self.create_default_config()
            return self.save_config(self._config)
            
        except Exception as e:
            self.logger.error(f"Fehler beim Zurücksetzen der Konfiguration: {str(e)}")
            return False
    
    def create_default_config(self) -> Dict[str, Any]:
        """
        Erstellt eine Standardkonfiguration
        
        Returns:
            dict: Die Standardkonfiguration
        """
        home_dir = str(Path.home())
        base_dir = os.path.join(home_dir, "OneDrive", "09_AutoDocs")
        
        # Stellen Sie sicher, dass die Standardordner existieren
        self._ensure_directories_exist([
            os.path.join(base_dir, "01_InboxDocs"),
            os.path.join(base_dir, "02_FinalDocs"),
            os.path.join(base_dir, "03_TrashDocs")
        ])
        
        # Standardkonfiguration
        return {
            "paths": {
                "input_dir": os.path.join(base_dir, "01_InboxDocs"),
                "output_dir": os.path.join(base_dir, "02_FinalDocs"),
                "trash_dir": os.path.join(base_dir, "03_TrashDocs")
            },
            "openai": {
                "model": "gpt-3.5-turbo",
                "temperature": 0.3,
                "max_retries": 3
            },
            "document_processing": {
                "max_file_size_mb": 20,
                "similarity_threshold": 0.85,
                "valid_doc_types": [
                    "rechnung",
                    "vertrag",
                    "brief",
                    "meldung",
                    "bescheid",
                    "dokument",
                    "antrag"
                ]
            },
            "gui": {
                "show_duplicate_popup": True,
                "notify_on_completion": True,
                "enable_sounds": False,
                "notify_on_new_documents": True
            }
        }
    
    def _ensure_directories_exist(self, directory_list):
        """
        Stellt sicher, dass die angegebenen Verzeichnisse existieren
        
        Args:
            directory_list: Liste der zu prüfenden Verzeichnisse
        """
        for directory in directory_list:
            try:
                if not os.path.exists(directory):
                    os.makedirs(directory)
                    self.logger.info(f"Verzeichnis erstellt: {directory}")
            except Exception as e:
                self.logger.error(f"Fehler beim Erstellen von Verzeichnis {directory}: {str(e)}")
                
    def get_value(self, key_path, default=None):
        """
        Holt einen Wert aus der Konfiguration mit Punktnotation (z.B. 'paths.input_dir')
        
        Args:
            key_path: Pfad zum Konfigurationsschlüssel mit Punkten getrennt
            default: Standardwert, falls der Schlüssel nicht existiert
            
        Returns:
            Der Wert aus der Konfiguration oder der Standardwert
        """
        try:
            keys = key_path.split('.')
            value = self.config
            
            for key in keys:
                if key in value:
                    value = value[key]
                else:
                    return default
                    
            return value
            
        except Exception:
            return default

# ================================================================================
# Datei: maehrdocs\document_processor.py
# ================================================================================

"""
DocumentProcessor für MaehrDocs
Hauptklasse zur Verarbeitung von Dokumenten
"""

import os
import logging
import time

from maehrdocs.text_extractor import TextExtractor
from maehrdocs.openai_integration import OpenAIIntegration
from maehrdocs.file_operations import FileOperations
from maehrdocs.filename_generator import FilenameGenerator
from maehrdocs.duplicate_detector import DuplicateDetector

# Rest der Klasse bleibt unverändert...

class DocumentProcessor:
    """
    Hauptklasse zur Verarbeitung von Dokumenten
    Koordiniert die Aktionen der verschiedenen Module
    """
    
    def __init__(self, config):
        """
        Initialisiert den DocumentProcessor mit der Konfiguration
        
        Args:
            config (dict): Konfiguration für die Dokumentenverarbeitung
        """
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Initialisiere die Hilfsmodule
        self.text_extractor = TextExtractor()
        self.openai_integration = OpenAIIntegration(config)
        self.file_operations = FileOperations(config)
        self.filename_generator = FilenameGenerator(config)
        self.duplicate_detector = DuplicateDetector()
        
        # Optionen
        self.verbose = 0  # Ausführlichkeitsstufe (0=normal, 1=verbose, 2=debug)
        self.force = False  # Dateien überschreiben
    
    def process_document(self, file_path, dry_run=False, force=False):
        """
        Verarbeitet ein einzelnes Dokument
        
        Args:
            file_path (str): Pfad zur PDF-Datei
            dry_run (bool): Wenn True, werden keine Dateioperationen durchgeführt
            force (bool): Wenn True, werden vorhandene Dateien überschrieben
            
        Returns:
            dict: Ergebnis der Verarbeitung oder None bei Fehler
        """
        try:
            # Zeit messen
            start_time = time.time()
            
            # Lokale Force-Option setzen
            self.force = force
            
            # Log
            self.logger.info(f"Verarbeite Dokument: {file_path}")
            
            # Prüfe, ob die Datei existiert und eine gültige PDF ist
            if not self.text_extractor.is_valid_pdf(
                file_path, 
                max_size_mb=self.config.get('document_processing', {}).get('max_file_size_mb', 20)
            ):
                return None
            
            # Text aus PDF extrahieren
            text = self.text_extractor.extract_text_from_pdf(file_path)
            if not text:
                self.logger.error(f"Konnte keinen Text aus der PDF extrahieren: {file_path}")
                return None
            
            # OpenAI-API verwenden, um Metadaten zu extrahieren
            valid_doc_types = self.config.get('document_processing', {}).get('valid_doc_types', [])
            doc_info = self.openai_integration.analyze_document(text, valid_doc_types)
            if not doc_info:
                self.logger.error(f"Fehler bei der KI-Analyse des Dokuments: {file_path}")
                return None
            
            # Prüfe, ob das Dokument ein Duplikat ist
            is_duplicate, duplicate_path = self._check_for_duplicates(text, file_path)
            
            # Erzeuge einen neuen Dateinamen basierend auf den extrahierten Informationen
            new_filename = self.filename_generator.generate_filename(doc_info)
            if not new_filename:
                self.logger.error(f"Konnte keinen gültigen Dateinamen generieren: {file_path}")
                return None
            
            # Ergebnisbericht erstellen
            result = {
                "original_file": file_path,
                "extracted_info": doc_info,
                "new_filename": new_filename,
                "is_duplicate": is_duplicate,
                "duplicate_path": duplicate_path if is_duplicate else None,
                "processing_time": time.time() - start_time
            }
            
            # Wenn nicht im Simulationsmodus, führe die Dateioperationen aus
            if not dry_run:
                self._move_file(file_path, new_filename, is_duplicate, force)
            else:
                self.logger.info(f"[SIMULATION] Würde Datei verschieben: {file_path} -> {new_filename}")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Fehler bei der Verarbeitung von {file_path}: {str(e)}", exc_info=True)
            return None

# ================================================================================
# Datei: maehrdocs\duplicate_detector.py
# ================================================================================

"""
Duplikaterkennung für MaehrDocs
Enthält die DuplicateDetector-Klasse zur Erkennung von ähnlichen Dokumenten
mittels Textvergleich und Jaccard-Ähnlichkeit mit optimierter Verarbeitung für deutsche Texte.
"""

class DuplicateDetector:
    """
    Klasse zur Erkennung von Dokumentduplikaten durch intelligenten Textvergleich.
    
    Verwendet eine Kombination aus:
    - Tokenisierung mit Entfernung deutscher Stopwörter
    - Bereinigung von unwichtigen Textbestandteilen
    - Jaccard-Ähnlichkeitskoeffizient für präzisen Vergleich
    
    Die Ähnlichkeitsbewertung berücksichtigt den inhaltlichen Kern von Dokumenten
    und reduziert den Einfluss von Formatierungen und Standardphrasen.
    """
    def __init__(self):
        # Erweiterte Liste deutscher Stopwörter für eine bessere Filterung
        self.STOPWORDS = {
            'der', 'die', 'das', 'und', 'mit', 'von', 'für', 'ist', 'ein', 'eine',
            'in', 'zu', 'den', 'dem', 'des', 'auf', 'als', 'nach', 'bei', 'an',
            'im', 'um', 'aus', 'über', 'vor', 'zum', 'zur', 'durch', 'wegen',
            'aber', 'oder', 'wenn', 'weil', 'dass', 'daß', 'denn', 'bis', 'wie',
            'so', 'nur', 'noch', 'schon', 'auch', 'alle', 'jede', 'jeder', 'jedes',
            'am', 'einem', 'einen', 'einer', 'eines', 'wird', 'werden', 'wurde',
            'wurden', 'haben', 'hat', 'hatte', 'hatten', 'sein', 'sind', 'war',
            'waren', 'nicht', 'sehr', 'ihr', 'ihre', 'seinen', 'seiner', 'ihrem'
        }

    def calculate_similarity(self, text1, text2):
        """
        Berechnet die Textähnlichkeit zwischen zwei Dokumenten mittels Jaccard-Ähnlichkeit.
        
        Der Algorithmus transformiert beide Texte in Wortmengen, entfernt dabei Stopwörter
        und berechnet das Verhältnis der gemeinsamen Wörter zur Gesamtwortzahl.
        
        Args:
            text1 (str): Text des ersten Dokuments
            text2 (str): Text des zweiten Dokuments
            
        Returns:
            float: Ähnlichkeitswert zwischen 0 (keine Ähnlichkeit) und 1 (identisch)
        """
        # Text in Wörter aufteilen
        words1 = set(self._tokenize(text1))
        words2 = set(self._tokenize(text2))

        # Leere Texte vermeiden
        if not words1 or not words2:
            return 0.0

        # Gemeinsame Wörter zählen
        common_words = words1.intersection(words2)

        # Jaccard-Ähnlichkeit berechnen:
        # J(A,B) = |A ∩ B| / |A ∪ B| = |A ∩ B| / (|A| + |B| - |A ∩ B|)
        similarity = len(common_words) / (len(words1) + len(words2) - len(common_words))
        return similarity

    def _tokenize(self, text):
        """
        Teilt einen Text in Wörter auf und bereinigt diese für den Vergleich.
        
        Der Prozess umfasst:
        1. Konvertierung in Kleinbuchstaben
        2. Extraktion von Wörtern mit regulärem Ausdruck
        3. Filterung von Stopwörtern
        4. Entfernung von Wörtern mit weniger als 3 Buchstaben
        
        Dies erhöht die Genauigkeit des Vergleichs, da unwichtige oder 
        sehr häufige Wörter den Ähnlichkeitswert nicht verzerren.
        
        Args:
            text (str): Der zu verarbeitende Text
            
        Returns:
            list: Liste der bereinigten, relevanten Wörter
        """
        if not text:
            return []

        # Alles klein schreiben
        text = text.lower()
        
        # Regular Expression für die Wortextraktion importieren
        import re

        # Wörter extrahieren, filtern und bereinigen:
        # - Nur Wörter mit mind. 3 Buchstaben behalten
        # - Stopwörter entfernen
        words = [w for w in re.findall(r'\b[a-z]{3,}\b', text) if w not in self.STOPWORDS]
        return words

# ================================================================================
# Datei: maehrdocs\error_handler.py
# ================================================================================

"""
Zentrale Fehlerbehandlung für MaehrDocs
Bietet eine einheitliche Schnittstelle zur Fehlerbehandlung und -protokollierung
"""

import logging
import traceback
import sys
from typing import Optional, Any, Callable, Type

class ErrorHandler:
    """
    Zentrale Klasse zur Fehlerbehandlung in MaehrDocs.
    
    Ermöglicht einheitliche Fehlerbehandlung für verschiedene Arten von Fehlern:
    - Erfasst Ausnahmen und leitet sie an das Messaging-System weiter
    - Bietet Kontext-Manager für fehleranfällige Operationen
    - Unterstützt hierarchische Fehlerbehandlung
    - Definiert klare Fehlercodes und -kategorien
    """
    
    def __init__(self, app=None):
        """
        Initialisiert den ErrorHandler
        
        Args:
            app: Die GuiApp-Instanz (optional)
        """
        self.app = app
        self.logger = logging.getLogger(__name__)
        # Fehlerklassen nach Schweregrad
        self.error_levels = {
            "critical": 50,  # Schwerwiegende Fehler, die sofortiges Beenden erfordern
            "error": 40,     # Standardfehler, die behandelt werden können
            "warning": 30,   # Warnungen, die den Betrieb nicht beeinträchtigen
            "info": 20       # Informationsmeldungen
        }
    
    def handle_exception(self, exception: Exception, context: str = None, level: str = "error") -> None:
        """
        Behandelt eine Exception und leitet sie entsprechend weiter
        
        Args:
            exception: Die aufgetretene Exception
            context: Kontextinformation zum Ort des Fehlers
            level: Schweregrad des Fehlers (critical, error, warning, info)
        """
        error_msg = str(exception)
        if context:
            error_msg = f"{context}: {error_msg}"
        
        # Stack-Trace für ausführlichere Protokollierung
        stack_trace = traceback.format_exc()
        
        # Logging
        log_level = self.error_levels.get(level, logging.ERROR)
        self.logger.log(log_level, error_msg)
        if log_level >= logging.ERROR:
            self.logger.debug(f"Stack-Trace:\n{stack_trace}")
        
        # Weiterleitung an das Messaging-System, wenn verfügbar
        if self.app and hasattr(self.app, 'messaging'):
            visual = level in ["critical", "error"]
            self.app.messaging.notify(
                message=error_msg, 
                level=level, 
                visual=visual,
                log=True
            )
            
            # Bei kritischen Fehlern Dialog anzeigen
            if level == "critical":
                self.app.messaging.dialog(
                    title="Kritischer Fehler",
                    message=f"{error_msg}\n\nDie Anwendung wird beendet.",
                    type="error"
                )
                # Anwendung beenden
                if hasattr(self.app, 'root'):
                    self.app.root.after(1000, self.app.root.destroy)
    
    def try_except(self, func: Callable, *args, context: str = None, 
                  level: str = "error", default_return: Any = None, **kwargs) -> Any:
        """
        Führt eine Funktion in einem try-except-Block aus
        
        Args:
            func: Die auszuführende Funktion
            *args: Positionsargumente für die Funktion
            context: Kontextinformation zum Ort des Fehlers
            level: Schweregrad des Fehlers
            default_return: Rückgabewert bei einem Fehler
            **kwargs: Schlüsselwortargumente für die Funktion
            
        Returns:
            Das Ergebnis der Funktion oder default_return bei einem Fehler
        """
        try:
            return func(*args, **kwargs)
        except Exception as e:
            self.handle_exception(e, context=context or f"Fehler in {func.__name__}", level=level)
            return default_return
    
    def safe_operation(self, context: str = None, level: str = "error", default_return: Any = None):
        """
        Context-Manager für fehleranfällige Operationen
        
        Args:
            context: Kontextinformation zum Ort des Fehlers
            level: Schweregrad des Fehlers
            default_return: Rückgabewert bei einem Fehler
            
        Returns:
            Ein Context-Manager für try-except-Blöcke
        """
        class SafeOperationContext:
            def __init__(self, handler, ctx, lvl, default):
                self.handler = handler
                self.context = ctx
                self.level = lvl
                self.default = default
                self.result = default
            
            def __enter__(self):
                return self
            
            def __exit__(self, exc_type, exc_val, exc_tb):
                if exc_val:
                    self.handler.handle_exception(exc_val, context=self.context, level=self.level)
                    return True  # Exception wurde behandelt
                return False
            
            def return_value(self, value):
                self.result = value
                return value
        
        return SafeOperationContext(self, context, level, default_return)

# ================================================================================
# Datei: maehrdocs\extract_code.py
# ================================================================================

#!/usr/bin/env python
"""
MaehrDocs Code Extractor

Dieses Skript durchsucht alle Python-Dateien im angegebenen Verzeichnis
und seiner Unterverzeichnisse und erstellt eine Textdatei mit dem gesamten Code.
"""

import os
import sys
from pathlib import Path

def extract_code(base_dir, output_file):
    """
    Extrahiert den Code aus allen Python-Dateien im angegebenen Verzeichnis
    und seinen Unterverzeichnissen.
    
    Args:
        base_dir: Das Basisverzeichnis, in dem gesucht werden soll
        output_file: Der Name der Ausgabedatei
    """
    # Alle Python-Dateien im Verzeichnis und Unterverzeichnissen finden
    python_files = []
    for root, dirs, files in os.walk(base_dir):
        # Ignoriere __pycache__ Verzeichnisse
        if "__pycache__" in root:
            continue
            
        for file in files:
            if file.endswith(".py"):
                file_path = os.path.join(root, file)
                rel_path = os.path.relpath(file_path, base_dir)
                python_files.append((rel_path, file_path))
    
    # Sortiere die Dateien nach relativem Pfad
    python_files.sort()
    
    # Öffne die Ausgabedatei
    with open(output_file, "w", encoding="utf-8") as out_file:
        out_file.write("# MaehrDocs Code Übersicht\n\n")
        out_file.write(f"# Generiert am {os.path.basename(__file__)}\n\n")
        
        # Für jede Python-Datei
        for rel_path, file_path in python_files:
            out_file.write(f"\n\n# {'='*80}\n")
            out_file.write(f"# Datei: {rel_path}\n")
            out_file.write(f"# {'='*80}\n\n")
            
            # Lese den Inhalt und schreibe ihn in die Ausgabedatei
            try:
                with open(file_path, "r", encoding="utf-8") as in_file:
                    content = in_file.read()
                    out_file.write(content)
            except Exception as e:
                out_file.write(f"# Fehler beim Lesen der Datei: {str(e)}\n")
    
    print(f"Code aus {len(python_files)} Python-Dateien wurde in '{output_file}' extrahiert.")

if __name__ == "__main__":
    # Wenn kein Verzeichnis angegeben wurde, verwende das aktuelle Verzeichnis
    if len(sys.argv) > 1:
        base_dir = sys.argv[1]
    else:
        base_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "maehrdocs")
        
        # Wenn das Verzeichnis nicht existiert, verwende das aktuelle Verzeichnis
        if not os.path.exists(base_dir):
            base_dir = "."
    
    # Wenn keine Ausgabedatei angegeben wurde, verwende einen Standardnamen
    if len(sys.argv) > 2:
        output_file = sys.argv[2]
    else:
        output_file = "maehrdocs_code_overview.txt"
    
    print(f"Extrahiere Code aus: {os.path.abspath(base_dir)}")
    print(f"Schreibe Ausgabe in: {output_file}")
    
    extract_code(base_dir, output_file)

# ================================================================================
# Datei: maehrdocs\file_operations.py
# ================================================================================

"""
Dateioperationen für MaehrDocs
Verwaltet alle Dateioperationen wie Verschieben, Kopieren, Umbenennen und Löschen
von Dokumenten im Rahmen des Dokumentenmanagementsystems.

Dieses Modul bietet eine zentrale Schnittstelle für alle dateibezogenen Operationen
und stellt sicher, dass Dokumente konsistent und fehlerfrei zwischen den verschiedenen
Systemordnern verschoben werden können, unter Berücksichtigung von Dateinamenskonflikten
und anderen potenziellen Problemen.
"""

import os
import shutil
import logging

class FileOperations:
    """
    Klasse zur Verwaltung von Dateioperationen im Dokumentenmanagementsystem.
    
    Diese Klasse ist verantwortlich für:
    - Verwalten der Ordnerstruktur (Eingang, Ausgang, Papierkorb)
    - Sichere Verschiebung von Dateien zwischen Ordnern
    - Behandlung von Dateinamenskonflikten
    - Erstellung von Sicherungskopien
    - Bereitstellung von Dateilisteninformationen
    
    Sie bildet die Grundlage für die sicheren Dateioperationen im
    gesamten Dokumentenmanagementsystem.
    """
    
    def __init__(self, config):
        """
        Initialisiert die Dateioperationen mit der Anwendungskonfiguration.
        
        Richtet Logging ein und stellt sicher, dass alle erforderlichen
        Verzeichnisse für die Dokumentenverarbeitung existieren.
        
        Args:
            config (dict): Konfigurationsdaten mit Pfadeinstellungen für die Ordner
        """
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Stelle sicher, dass alle erforderlichen Verzeichnisse existieren
        self._ensure_directories_exist()
    
    def _ensure_directories_exist(self):
        """
        Stellt sicher, dass alle erforderlichen Verzeichnisse existieren.
        
        Erstellt die Eingangs-, Ausgangs- und Papierkorbverzeichnisse,
        falls sie noch nicht vorhanden sind, um Dateisystemfehler bei
        der Dokumentenverarbeitung zu vermeiden.
        """
        try:
            for dir_path in [
                self.config['paths']['input_dir'],
                self.config['paths']['output_dir'],
                self.config['paths']['trash_dir']
            ]:
                if not os.path.exists(dir_path):
                    os.makedirs(dir_path)
                    self.logger.info(f"Verzeichnis erstellt: {dir_path}")
                    
        except Exception as e:
            self.logger.error(f"Fehler beim Erstellen der Verzeichnisse: {str(e)}")
    
    def move_to_output(self, file_path, new_filename, force=False):
       
        """
        Verschiebt eine Datei in den Ausgabeordner mit neuem Namen.
        
        Implementiert intelligente Konfliktbehandlung, indem bei bereits
        existierenden
         """

# ================================================================================
# Datei: maehrdocs\filename_generator.py
# ================================================================================

"""
Dateinamengenerator für MaehrDocs
Generiert standardisierte Dateinamen basierend auf extrahierten Dokumentinformationen.

Dieses Modul implementiert die Logik zur Erzeugung konsistenter, strukturierter Dateinamen
für verarbeitete Dokumente auf Basis der durch die KI-Analyse extrahierten Metadaten.
Es sorgt für einheitliche Benennung und bessere Auffindbarkeit der Dokumente.
"""

import os
import re
import logging
from datetime import datetime

class FilenameGenerator:
    """
    Klasse zur Generierung standardisierter Dateinamen für verarbeitete Dokumente.
    
    Diese Klasse ist verantwortlich für:
    - Formatierung von Datumsangaben in ein einheitliches Format
    - Validierung und Normalisierung von Dokumenttypen
    - Bereinigung von Absender- und Betreffsinformationen
    - Zusammenstellung der Informationen zu einem strukturierten Dateinamen
    
    Der generierte Dateiname folgt dem Schema:
    YYYY-MM-DD_Dokumenttyp_Absender_Betreff.pdf
    """
    
    def __init__(self, config):
        """
        Initialisiert den FilenameGenerator mit der Anwendungskonfiguration.
        
        Richtet Logging ein und initialisiert Parameter für die Dateinamensgenerierung,
        einschließlich ungültiger Zeichen und Längenbeschränkungen.
        
        Args:
            config (dict): Konfigurationsdaten mit gültigen Dokumenttypen
        """
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Ungültige Zeichen für Dateinamen
        self.invalid_chars = ['/', '\\', ':', '*', '?', '"', '<', '>', '|']
        
        # Maximale Länge für Dateinamen (für Dateisystembeschränkungen)
        self.max_filename_length = 240
    
    def generate_filename(self, doc_info):
        """
        Generiert einen standardisierten Dateinamen basierend auf den extrahierten Informationen.
        
        Verarbeitet die von der KI-Analyse extrahierten Dokumentinformationen und
        erstellt daraus einen konsistenten, strukturierten Dateinamen nach dem
        definierten Schema: YYYY-MM-DD_Dokumenttyp_Absender_Betreff.pdf
        
        Args:
            doc_info (dict): Extrahierte Dokumentinformationen (Datum, Typ, Absender, Betreff)
            
        Returns:
            str: Generierter Dateiname oder None bei Fehler
        """
        try:
            # Validiere und formatiere das Datum
            date_str = self._format_date(doc_info.get('datum', ''))
            
            # Validiere und formatiere den Dokumenttyp
            doc_type = self._format_document_type(doc_info.get('dokumenttyp', ''))
            
            # Formatiere den Absender
            sender = self._format_sender(doc_info.get('absender', ''))
            
            # Formatiere den Betreff
            subject = self._format_subject(doc_info.get('betreff', ''))
            
            # Generiere den Dateinamen im Format YYYY-MM-DD_Dokumenttyp_Absender_Betreff.pdf
            filename = f"{date_str}_{doc_type}_{sender}_{subject}.pdf"
            
            # Begrenze die Länge des Dateinamens
            if len(filename) > self.max_filename_length:
                base, ext = os.path.splitext(filename)
                filename = base[:self.max_filename_length - len(ext)] + ext
            
            return filename
            
        except Exception as e:
            self.logger.error(f"Fehler bei der Generierung des Dateinamens: {str(e)}")
            return None
    
    def _format_date(self, date_str):
        """
        Formatiert ein Datum im einheitlichen Format YYYY-MM-DD.
        
        Konvertiert verschiedene Datumsformate (DD.MM.YYYY, YYYY/MM/DD, etc.)
        in das standardisierte Format YYYY-MM-DD und behandelt unvollständige
        oder ungültige Datumsangaben, indem das aktuelle Datum als Fallback 
        verwendet wird.
        
        Args:
            date_str (str): Zu formatierendes Datum aus der Dokumentenanalyse
            
        Returns:
            str: Formatiertes Datum im Format YYYY-MM-DD
        """
        # Versuche, das Datum zu extrahieren und zu validieren
        try:
            # Wenn das Datum bereits im Format YYYY-MM-DD vorliegt
            if re.match(r'^\d{4}-\d{2}-\d{2}', date_str):
                return date_str[:10]  # Schneide auf YYYY-MM-DD
                
            # Versuche, das Datum im Format DD.MM.YYYY zu parsen
            elif re.match(r'^\d{1,2}\.\d{1,2}\.\d{4}', date_str):
                day, month, year = map(int, date_str.split('.')[:3])
                return f"{year:04d}-{month:02d}-{day:02d}"
                
            # Versuche, andere gängige Datumsformate zu parsen
            else:
                for fmt in ["%d.%m.%Y", "%Y/%m/%d", "%m/%d/%Y", "%d/%m/%Y"]:
                    try:
                        dt = datetime.strptime(date_str, fmt)
                        return dt.strftime("%Y-%m-%d")
                    except ValueError:
                        continue
                        
            # Wenn kein passendes Format gefunden wurde, verwende das aktuelle Datum
            return datetime.now().strftime("%Y-%m-%d")
            
        except Exception as e:
            self.logger.warning(f"Fehler beim Formatieren des Datums '{date_str}': {str(e)}")
            return datetime.now().strftime("%Y-%m-%d")
    
    def _format_document_type(self, doc_type):
        """
        Formatiert und validiert den Dokumenttyp gegen die Liste gültiger Typen.
        
        Normalisiert den Dokumenttyp und prüft, ob er in der konfigurierten Liste
        gültiger Dokumenttypen enthalten ist. Versucht auch, ähnliche Dokumenttypen
        zu finden, falls kein exakter Treffer vorliegt.
        
        Args:
            doc_type (str): Zu formatierender Dokumenttyp aus der Dokumentenanalyse
            
        Returns:
            str: Formatierter und validierter Dokumenttyp oder "dokument" als Fallback
        """
        # Normalisiere den Dokumenttyp (Kleinbuchstaben, Leerzeichen entfernen)
        doc_type = doc_type.lower().strip()
        
        # Prüfe, ob der Dokumenttyp gültig ist
        valid_doc_types = self.config.get('document_processing', {}).get('valid_doc_types', [])
        
        if doc_type in valid_doc_types:
            return doc_type
        
        # Versuche, ähnliche Dokumenttypen zu finden
        for valid_type in valid_doc_types:
            if valid_type in doc_type or doc_type in valid_type:
                return valid_type
        
        # Fallback
        return "dokument"
    
    def _format_sender(self, sender):
        """
        Formatiert den Absender für die Verwendung im Dateinamen.
        
        Entfernt ungültige Zeichen aus dem Absender, begrenzt die Länge
        und ersetzt Leerzeichen durch Unterstriche, um einen gültigen
        Dateinamensteil zu erzeugen.
        
        Args:
            sender (str): Zu formatierender Absender aus der Dokumentenanalyse
            
        Returns:
            str: Formatierter Absender oder "unbekannt" als Fallback
        """
        if not sender or not sender.strip():
            return "unbekannt"
        
        # Normalisiere den Absender
        sender = sender.strip()
        
        # Ersetze ungültige Zeichen
        for char in self.invalid_chars:
            sender = sender.replace(char, '_')
        
        # Entferne doppelte Unterstriche
        sender = re.sub(r'_{2,}', '_', sender)
        
        # Begrenze die Länge
        if len(sender) > 50:
            sender = sender[:50]
        
        return sender
    
    def _format_subject(self, subject):
        """
        Formatiert den Betreff für die Verwendung im Dateinamen.
        
        Entfernt ungültige Zeichen aus dem Betreff, begrenzt die Länge
        und ersetzt Leerzeichen durch Unterstriche, um einen gültigen
        Dateinamensteil zu erzeugen.
        
        Args:
            subject (str): Zu formatierender Betreff aus der Dokumentenanalyse
            
        Returns:
            str: Formatierter Betreff oder "ohne_betreff" als Fallback
        """
        if not subject or not subject.strip():
            return "ohne_betreff"
        
        # Normalisiere den Betreff
        subject = subject.strip()
        
        # Ersetze ungültige Zeichen
        for char in self.invalid_chars:
            subject = subject.replace(char, '_')
        
        # Entferne doppelte Unterstriche
        subject = re.sub(r'_{2,}', '_', subject)
        
        # Begrenze die Länge
        if len(subject) > 100:
            subject = subject[:100]
        
        return subject

# ================================================================================
# Datei: maehrdocs\gui\__init__.py
# ================================================================================

"""
GUI-Paket für MaehrDocs
Enthält alle GUI-bezogenen Komponenten und Funktionalitäten
"""

# Import der Hauptklasse
from .gui_core import GuiApp

# Import der Button-Komponenten
from .gui_buttons import (
    create_button, 
    create_icon_button, 
    create_toggle_button
)

# Import der Karten-Komponenten
from .gui_cards import (
    create_status_card, 
    create_info_card, 
    create_activity_card, 
    create_section_frame
)

# Import der Formular-Komponenten
from .gui_forms import create_form_field
from .gui_settings_components import create_settings_section

# Import der Dashboard-Funktionen
from .gui_dashboard import create_dashboard

# Import der Einstellungs-Funktionen
from .gui_settings import open_settings

# Import der Dokumentenansicht-Funktionen
from .gui_document_viewer import (
    compare_documents, 
    open_document
)

# Import der Event-Handler (jetzt aus gui_actions statt gui_handlers)
from .gui_actions import (
    process_documents, 
    simulate_processing, 
    process_single_file
)

# Spezifische Module aus der neuen Aufteilung
from .gui_document_actions import rebuild_config
from .gui_drop_handlers import handle_drop, copy_files_to_inbox
from .gui_command_executor import run_command_in_thread
from .gui_notification_handlers import handle_duplicate_from_log

# Exportiere die wichtigsten Klassen und Funktionen
__all__ = [
    'GuiApp',
    'create_button',
    'create_status_card',
    'create_dashboard',
    'open_settings',
    'compare_documents',
    'open_document',
    'process_documents',
    'rebuild_config',
    'handle_drop',
    'run_command_in_thread',
    'handle_duplicate_from_log'
]

# ================================================================================
# Datei: maehrdocs\gui\generate_module_docs.py
# ================================================================================

#!/usr/bin/env python
"""
MaehrDocs Modul-Dokumentations-Generator

Durchsucht alle Python-Dateien im MaehrDocs-Paket und erstellt eine Markdown-Dokumentation 
der Modulstruktur mit Funktionen und Klassen.
"""

import os
import re
import ast
import importlib.util
from pathlib import Path

def get_docstring(node):
    """Extrahiert den Docstring aus einem AST-Knoten."""
    if node.body and isinstance(node.body[0], ast.Expr) and isinstance(node.body[0].value, ast.Str):
        return node.body[0].value.s.strip()
    return ""

def analyze_python_file(file_path):
    """Analysiert eine Python-Datei und extrahiert Funktionen, Klassen und deren Docstrings."""
    with open(file_path, 'r', encoding='utf-8') as file:
        try:
            content = file.read()
            tree = ast.parse(content)
        except Exception as e:
            return {
                'module_docstring': f"Fehler beim Parsen: {str(e)}",
                'functions': [],
                'classes': []
            }
    
    module_docstring = get_docstring(tree)
    
    functions = []
    classes = []
    
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            func_docstring = get_docstring(node)
            # Einfache Zusammenfassung aus dem Docstring extrahieren
            summary = func_docstring.split('\n')[0] if func_docstring else "Keine Beschreibung verfügbar"
            functions.append({
                'name': node.name,
                'docstring': func_docstring,
                'summary': summary
            })
        elif isinstance(node, ast.ClassDef):
            class_docstring = get_docstring(node)
            summary = class_docstring.split('\n')[0] if class_docstring else "Keine Beschreibung verfügbar"
            
            methods = []
            for class_node in ast.walk(node):
                if isinstance(class_node, ast.FunctionDef):
                    method_docstring = get_docstring(class_node)
                    method_summary = method_docstring.split('\n')[0] if method_docstring else "Keine Beschreibung verfügbar"
                    methods.append({
                        'name': class_node.name,
                        'docstring': method_docstring,
                        'summary': method_summary
                    })
            
            classes.append({
                'name': node.name,
                'docstring': class_docstring,
                'summary': summary,
                'methods': methods
            })
    
    return {
        'module_docstring': module_docstring,
        'functions': functions,
        'classes': classes
    }

def generate_markdown(base_dir):
    """Generiert eine Markdown-Dokumentation der Module und deren Inhalte."""
    modules = {}
    
    # Nur Python-Dateien in unserem Zielordner und dessen Unterordnern durchsuchen
    for root, dirs, files in os.walk(base_dir):
        if '__pycache__' in root:
            continue
            
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                rel_path = os.path.relpath(file_path, base_dir)
                module_path = rel_path.replace(os.path.sep, '.').replace('.py', '')
                
                if module_path == '__init__':
                    # Für __init__.py-Dateien setzen wir den Namen auf den Ordnernamen
                    module_path = os.path.basename(root)
                
                modules[module_path] = {
                    'file_path': file_path,
                    'analysis': analyze_python_file(file_path)
                }
    
    # Markdown generieren
    markdown = "# MaehrDocs Modulübersicht\n\n"
    markdown += "Diese Dokumentation wurde automatisch generiert und bietet einen Überblick über alle Module im MaehrDocs Projekt.\n\n"
    
    # Table of Contents
    markdown += "## Inhaltsverzeichnis\n\n"
    
    markdown += "### Module\n"
    # Erst die Hauptmodule
    for module_name in sorted(modules.keys()):
        if '.' not in module_name:
            module = modules[module_name]
            module_docstring = module['analysis']['module_docstring']
            summary = module_docstring.split('\n')[0] if module_docstring else "Keine Beschreibung verfügbar"
            markdown += f"- [{module_name}](#{module_name.lower().replace('.', '-')}) - {summary}\n"
    
    # Dann die Untermodule nach Namespace sortiert
    namespaces = {}
    for module_name in sorted(modules.keys()):
        if '.' in module_name:
            namespace = module_name.split('.')[0]
            if namespace not in namespaces:
                namespaces[namespace] = []
            namespaces[namespace].append(module_name)
    
    for namespace in sorted(namespaces.keys()):
        markdown += f"\n### {namespace} Module\n"
        for module_name in sorted(namespaces[namespace]):
            module = modules[module_name]
            module_docstring = module['analysis']['module_docstring']
            summary = module_docstring.split('\n')[0] if module_docstring else "Keine Beschreibung verfügbar"
            markdown += f"- [{module_name}](#{module_name.lower().replace('.', '-')}) - {summary}\n"
    
    # Detaillierte Modulbeschreibungen
    markdown += "\n## Module\n\n"
    
    # Erst die Hauptmodule
    for module_name in sorted(modules.keys()):
        if '.' not in module_name:
            module = modules[module_name]
            markdown += generate_module_markdown(module_name, module)
    
    # Dann die Untermodule nach Namespace sortiert
    for namespace in sorted(namespaces.keys()):
        markdown += f"\n## {namespace} Module\n\n"
        for module_name in sorted(namespaces[namespace]):
            module = modules[module_name]
            markdown += generate_module_markdown(module_name, module)
    
    return markdown

def generate_module_markdown(module_name, module):
    """Generiert den Markdown-Abschnitt für ein bestimmtes Modul."""
    markdown = f"### {module_name}\n\n"
    
    # Dateipfad
    rel_path = os.path.relpath(module['file_path'])
    markdown += f"**Dateipfad:** `{rel_path}`\n\n"
    
    # Moduldokumentationsstring
    module_docstring = module['analysis']['module_docstring']
    if module_docstring:
        markdown += f"{module_docstring}\n\n"
    
    # Funktionen
    functions = module['analysis']['functions']
    if functions:
        markdown += "#### Funktionen\n\n"
        for func in functions:
            markdown += f"- `{func['name']}()` - {func['summary']}\n"
        markdown += "\n"
    
    # Klassen
    classes = module['analysis']['classes']
    if classes:
        markdown += "#### Klassen\n\n"
        for cls in classes:
            markdown += f"- `{cls['name']}` - {cls['summary']}\n"
            
            # Methoden
            methods = cls['methods']
            if methods:
                markdown += "  - Methoden:\n"
                for method in methods:
                    if method['name'] != '__init__':  # Private Methoden ausschließen
                        markdown += f"    - `{method['name']}()` - {method['summary']}\n"
        markdown += "\n"
    
    markdown += "---\n\n"
    return markdown

if __name__ == "__main__":
    # Pfad zum MaehrDocs-Paket
    base_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "maehrdocs")
    
    # Prüfen, ob das Verzeichnis existiert
    if not os.path.exists(base_dir):
        print(f"Das Verzeichnis {base_dir} wurde nicht gefunden.")
        # Versuche, das aktuelle Verzeichnis zu verwenden
        base_dir = "."
        print(f"Verwende stattdessen das aktuelle Verzeichnis: {os.path.abspath(base_dir)}")
    
    # Markdown generieren
    markdown = generate_markdown(base_dir)
    
    # In Datei schreiben
    output_file = "MaehrDocs_Modulübersicht.md"
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(markdown)
    
    print(f"Dokumentation wurde in {output_file} gespeichert.")

# ================================================================================
# Datei: maehrdocs\gui\gui_actions.py
# ================================================================================

"""
Event-Handler und Aktionen für MaehrDocs
Enthält Funktionen zur Verarbeitung von Benutzeraktionen und Ereignissen
"""

# Re-Exporte aus den spezialisierten Modulen für Abwärtskompatibilität

# Dokumentenaktionen
from .gui_document_actions import (
    process_documents,
    simulate_processing,
    process_single_file,
    rebuild_config
)

# Drag & Drop Handler
from .gui_drop_handlers import (
    handle_drop,
    copy_files_to_inbox
)

# Befehlsausführung
from .gui_command_executor import (
    run_command_in_thread,
    _run_command
)

# Benachrichtigungshandler
from .gui_notification_handlers import (
    handle_duplicate_from_log
)

# ================================================================================
# Datei: maehrdocs\gui\gui_alerts.py
# ================================================================================

"""
Benachrichtigungskomponenten für MaehrDocs
Zentrale Schnittstelle für Systembenachrichtigungen und Dialogfenster.

Dieses Modul dient als Kompatibilitätsschicht und leitet Aufrufe an die 
spezialisierten Module wie gui_notifications.py und gui_animations.py weiter,
um die Abwärtskompatibilität nach der Modularisierung zu gewährleisten.
"""

from maehrdocs.gui.gui_notifications import show_notification
from maehrdocs.gui.gui_animations import animate_window, fade_in, fade_out

def show_success(app, message, timeout=5000):
    """
    Zeigt eine Erfolgs-Benachrichtigung an.
    
    Erzeugt ein temporäres Popup-Fenster im erfolgreichen Stil (normalerweise grün),
    das nach einer bestimmten Zeit automatisch verschwindet.
    
    Args:
        app: Die GuiApp-Instanz
        message (str): Die anzuzeigende Nachricht
        timeout (int): Anzeigedauer in Millisekunden, bevor die Benachrichtigung verschwindet
        
    Returns:
        Das erzeugte Benachrichtigungsfenster
    """
    return show_notification(app, message, level="success", timeout=timeout)

def show_info(app, message, timeout=5000):
    """
    Zeigt eine Informations-Benachrichtigung an.
    
    Erzeugt ein temporäres Popup-Fenster im Infostil (normalerweise blau),
    das nach einer bestimmten Zeit automatisch verschwindet.
    
    Args:
        app: Die GuiApp-Instanz
        message (str): Die anzuzeigende Nachricht
        timeout (int): Anzeigedauer in Millisekunden, bevor die Benachrichtigung verschwindet
        
    Returns:
        Das erzeugte Benachrichtigungsfenster
    """
    return show_notification(app, message, level="info", timeout=timeout)

def show_warning(app, message, timeout=5000):
    """
    Zeigt eine Warnungs-Benachrichtigung an.
    
    Erzeugt ein temporäres Popup-Fenster im Warnungsstil (normalerweise gelb/orange),
    das nach einer bestimmten Zeit automatisch verschwindet.
    
    Args:
        app: Die GuiApp-Instanz
        message (str): Die anzuzeigende Nachricht
        timeout (int): Anzeigedauer in Millisekunden, bevor die Benachrichtigung verschwindet
        
    Returns:
        Das erzeugte Benachrichtigungsfenster
    """
    return show_notification(app, message, level="warning", timeout=timeout)

def show_error(app, message, timeout=5000):
    """
    Zeigt eine Fehler-Benachrichtigung an.
    
    Erzeugt ein temporäres Popup-Fenster im Fehlerstil (normalerweise rot),
    das nach einer bestimmten Zeit automatisch verschwindet.
    
    Args:
        app: Die GuiApp-Instanz
        message (str): Die anzuzeigende Nachricht
        timeout (int): Anzeigedauer in Millisekunden, bevor die Benachrichtigung verschwindet
        
    Returns:
        Das erzeugte Benachrichtigungsfenster
    """
    return show_notification(app, message, level="error", timeout=timeout)

# ================================================================================
# Datei: maehrdocs\gui\gui_animations.py
# ================================================================================

"""
Animations- und Effektkomponenten für MaehrDocs GUI
Enthält Funktionen für sanfte Übergänge und Animationen in der Benutzeroberfläche,
wie Fade-In/Fade-Out-Effekte für Fenster und andere visuelle Elemente.
"""

import tkinter as tk

def animate_window(window):
    """
    Animiert das Erscheinen eines Fensters mit Fade-In-Effekt.
    
    Das Fenster erscheint sanft, indem es von völliger Transparenz
    zu voller Sichtbarkeit übergeht. Dies erzeugt einen angenehmeren
    Benutzererfahrung als abruptes Erscheinen.
    
    Args:
        window: Das zu animierende Fenster (Toplevel)
        
    Returns:
        Das animierte Fenster-Objekt
    """
    # Start mit transparentem Fenster
    window.attributes("-alpha", 0)
    
    # Fade-In starten
    fade_in(window)
    
    return window

def fade_in(window, alpha=0):
    """
    Führt einen Fade-In-Effekt für ein Fenster durch.
    
    Erhöht schrittweise die Transparenz des Fensters von transparent
    zu vollständig sichtbar. Die Animation wird rekursiv mit zeitlicher
    Verzögerung durchgeführt.
    
    Args:
        window: Das Fenster
        alpha (float): Aktueller Alpha-Wert (Transparenz), Startwert
        
    Returns:
        Das Fenster-Objekt
    """
    # Alpha-Wert erhöhen
    alpha += 0.1
    
    # Prüfen, ob der maximale Wert erreicht ist
    if alpha <= 1:
        # Alpha-Wert setzen
        window.attributes("-alpha", alpha)
        
        # Nach 20ms erneut aufrufen
        window.after(20, lambda: fade_in(window, alpha))
    
    return window

def fade_out(window, alpha=1.0, destroy_window=True):
    """
    Führt einen Fade-Out-Effekt für ein Fenster durch.
    
    Verringert schrittweise die Transparenz des Fensters von vollständig
    sichtbar zu transparent. Nach Abschluss kann das Fenster optional
    zerstört werden.
    
    Args:
        window: Das Fenster
        alpha (float): Aktueller Alpha-Wert (Transparenz), Startwert
        destroy_window (bool): Ob das Fenster nach dem Fade-Out zerstört werden soll
        
    Returns:
        Das Fenster-Objekt oder None, wenn es zerstört wurde
    """
    # Alpha-Wert verringern
    alpha -= 0.1
    
    # Prüfen, ob der minimale Wert erreicht ist
    if alpha >= 0:
        # Alpha-Wert setzen
        window.attributes("-alpha", alpha)
        
        # Nach 20ms erneut aufrufen
        window.after(20, lambda: fade_out(window, alpha, destroy_window))
    elif destroy_window:
        # Fenster zerstören
        window.destroy()
        return None
    
    return window

# ================================================================================
# Datei: maehrdocs\gui\gui_buttons.py
# ================================================================================

"""
Button-Komponenten für MaehrDocs GUI
Enthält Funktionen zum Erstellen verschiedener Arten von Buttons
"""

import tkinter as tk

def create_button(app, parent, text, command, size="normal", bg=None):
    """
    Erstellt einen styled Button
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        text: Button-Text
        command: Callback-Funktion
        size: Größe (normal oder large)
        bg: Hintergrundfarbe (optional)
        
    Returns:
        tk.Button: Der erstellte Button
    """
    if bg is None:
        bg = app.colors["primary"]
        
    if size == "large":
        button = tk.Button(
            parent, 
            text=text,
            font=app.fonts["normal"],
            bg=bg,
            fg=app.colors["text_primary"],
            activebackground=app.colors["accent"],
            activeforeground=app.colors["text_primary"],
            relief=tk.FLAT,
            padx=15,
            pady=10,
            cursor="hand2",
            command=command
        )
    else:
        button = tk.Button(
            parent, 
            text=text,
            font=app.fonts["small"],
            bg=bg,
            fg=app.colors["text_primary"],
            activebackground=app.colors["accent"],
            activeforeground=app.colors["text_primary"],
            relief=tk.FLAT,
            padx=10,
            pady=5,
            cursor="hand2",
            command=command
        )
    
    return button

def create_icon_button(app, parent, icon_text, tooltip, command, size="normal", bg=None):
    """
    Erstellt einen Button mit Icon
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        icon_text: Unicode-Icon (z.B. "🔍")
        tooltip: Tooltip-Text
        command: Callback-Funktion
        size: Größe (normal oder large)
        bg: Hintergrundfarbe (optional)
        
    Returns:
        tk.Button: Der erstellte Button
    """
    if bg is None:
        bg = app.colors["primary"]
    
    # Icon-Schriftgröße basierend auf der Größe
    icon_size = 14 if size == "normal" else 18
    
    button = tk.Button(
        parent,
        text=icon_text,
        font=("Segoe UI", icon_size),
        bg=bg,
        fg=app.colors["text_primary"],
        activebackground=app.colors["accent"],
        activeforeground=app.colors["text_primary"],
        relief=tk.FLAT,
        padx=8 if size == "normal" else 12,
        pady=4 if size == "normal" else 8,
        cursor="hand2",
        command=command
    )
    
    # Tooltip
    _create_tooltip(button, tooltip)
    
    return button

def create_toggle_button(app, parent, text, command, is_active=False, size="normal"):
    """
    Erstellt einen Toggle-Button, der zwischen zwei Zuständen wechseln kann
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        text: Button-Text
        command: Callback-Funktion, die den aktuellen Zustand als Parameter erhält
        is_active: Anfangszustand (True = aktiv)
        size: Größe (normal oder large)
        
    Returns:
        tuple: (tk.Button, tk.BooleanVar) Der erstellte Button und die Variable für den Zustand
    """
    state_var = tk.BooleanVar(value=is_active)
    
    # Farben basierend auf dem Zustand
    active_bg = app.colors["success"]
    inactive_bg = app.colors["background_medium"]
    
    # Initial
    initial_bg = active_bg if is_active else inactive_bg
    
    button = create_button(
        app,
        parent,
        text,
        lambda: _toggle_button_state(app, button, state_var, command),
        size=size,
        bg=initial_bg
    )
    
    # Speichere Zustandsvariable und Farben als Attribute
    button.state_var = state_var
    button.active_bg = active_bg
    button.inactive_bg = inactive_bg
    
    return button, state_var

def _toggle_button_state(app, button, state_var, command):
    """
    Hilfsfunktion zum Umschalten des Button-Zustands
    
    Args:
        app: Instanz der GuiApp
        button: Der Toggle-Button
        state_var: Die BooleanVar für den Zustand
        command: Die Callback-Funktion
    """
    # Zustand umschalten
    new_state = not state_var.get()
    state_var.set(new_state)
    
    # Farbe ändern
    button.config(bg=button.active_bg if new_state else button.inactive_bg)
    
    # Callback aufrufen
    if command:
        command(new_state)

def _create_tooltip(widget, text):
    """
    Erstellt einen einfachen Tooltip für ein Widget
    
    Args:
        widget: Das Widget, für das der Tooltip erstellt werden soll
        text: Der Tooltip-Text
    """
    def enter(event):
        # Position des Tooltips
        x, y, _, _ = widget.bbox("insert")
        x += widget.winfo_rootx() + 25
        y += widget.winfo_rooty() + 25
        
        # Tooltip-Fenster erstellen
        tooltip = tk.Toplevel(widget)
        tooltip.wm_overrideredirect(True)
        tooltip.wm_geometry(f"+{x}+{y}")
        
        # Tooltip-Inhalt
        label = tk.Label(
            tooltip,
            text=text,
            background="#ffffe0",
            relief=tk.SOLID,
            borderwidth=1,
            padx=5,
            pady=2
        )
        label.pack()
        
        # Referenz speichern
        widget.tooltip = tooltip
    
    def leave(event):
        # Tooltip zerstören
        if hasattr(widget, "tooltip"):
            widget.tooltip.destroy()
            delattr(widget, "tooltip")
    
    # Event-Binding
    widget.bind("<Enter>", enter)
    widget.bind("<Leave>", leave)

# ================================================================================
# Datei: maehrdocs\gui\gui_cards.py
# ================================================================================

"""
Karten- und Container-Komponenten für MaehrDocs GUI
Enthält Funktionen zum Erstellen von Statuskarten und anderen Container-Elementen
"""

import tkinter as tk
from .gui_buttons import create_button

def create_status_card(app, parent, title, folder_suffix, icon):
    """
    Erstellt eine Statuskarte für einen Ordner
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        title: Titel der Karte
        folder_suffix: Ordnersuffix (für die Identifikation)
        icon: Icon-Text
        
    Returns:
        tk.Frame: Das erstellte Karten-Widget mit zusätzlichen Attributen
    """
    card = tk.Frame(parent, bg=app.colors["card_background"], padx=20, pady=15)
    
    header_frame = tk.Frame(card, bg=app.colors["card_background"])
    header_frame.pack(fill=tk.X, pady=(0, 10))
    
    icon_label = tk.Label(
        header_frame, 
        text=icon, 
        font=("Segoe UI", 18),
        bg=app.colors["card_background"],
        fg=app.colors["text_primary"]
    )
    icon_label.pack(side=tk.LEFT)
    
    title_label = tk.Label(
        header_frame, 
        text=title, 
        font=app.fonts["subheader"],
        bg=app.colors["card_background"],
        fg=app.colors["text_primary"]
    )
    title_label.pack(side=tk.LEFT, padx=5)
    
    # Dokumente Anzahl
    count_frame = tk.Frame(card, bg=app.colors["card_background"])
    count_frame.pack(fill=tk.X)
    
    count_label = tk.Label(
        count_frame, 
        text="Dokumente:", 
        font=app.fonts["normal"],
        bg=app.colors["card_background"],
        fg=app.colors["text_secondary"]
    )
    count_label.pack(side=tk.LEFT)
    
    count_value = tk.Label(
        count_frame, 
        text="Wird geladen...", 
        font=app.fonts["normal"],
        bg=app.colors["card_background"],
        fg=app.colors["primary"]
    )
    count_value.pack(side=tk.LEFT, padx=5)
    
    # Ordnerpfad
    path_frame = tk.Frame(card, bg=app.colors["card_background"], pady=5)
    path_frame.pack(fill=tk.X)
    
    path_label = tk.Label(
        path_frame, 
        text="Pfad:", 
        font=app.fonts["small"],
        bg=app.colors["card_background"],
        fg=app.colors["text_secondary"]
    )
    path_label.pack(side=tk.LEFT)
    
    path_value = tk.Label(
        path_frame, 
        text="...", 
        font=app.fonts["small"],
        bg=app.colors["card_background"],
        fg=app.colors["text_secondary"]
    )
    path_value.pack(side=tk.LEFT, padx=5)
    
    # Button zum Öffnen des Ordners
    open_btn = create_button(
        app,
        card, 
        "Ordner öffnen", 
        lambda f=folder_suffix: app.open_folder(f)
    )
    open_btn.pack(anchor=tk.W, pady=10)
    
    # Speichere Labels für späteren Zugriff
    card.count_value = count_value
    card.path_value = path_value
    card.folder_suffix = folder_suffix
    
    return card

def create_info_card(app, parent, title, content, icon=None, bg=None):
    """
    Erstellt eine Informationskarte
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        title: Titel der Karte
        content: Inhalt der Karte (Text)
        icon: Icon-Text (optional)
        bg: Hintergrundfarbe (optional)
        
    Returns:
        tk.Frame: Das erstellte Karten-Widget
    """
    if bg is None:
        bg = app.colors["card_background"]
    
    card = tk.Frame(parent, bg=bg, padx=15, pady=15)
    
    # Header mit Icon
    header_frame = tk.Frame(card, bg=bg)
    header_frame.pack(fill=tk.X, pady=(0, 10))
    
    if icon:
        icon_label = tk.Label(
            header_frame, 
            text=icon, 
            font=("Segoe UI", 18),
            bg=bg,
            fg=app.colors["text_primary"]
        )
        icon_label.pack(side=tk.LEFT, padx=(0, 5))
    
    title_label = tk.Label(
        header_frame, 
        text=title, 
        font=app.fonts["subheader"],
        bg=bg,
        fg=app.colors["text_primary"]
    )
    title_label.pack(side=tk.LEFT)
    
    # Inhalt
    content_label = tk.Label(
        card, 
        text=content, 
        font=app.fonts["normal"],
        bg=bg,
        fg=app.colors["text_primary"],
        justify=tk.LEFT,
        wraplength=400  # Textumbruch für längere Texte
    )
    content_label.pack(fill=tk.X, pady=5)
    
    return card

def create_activity_card(app, parent, title):
    """
    Erstellt eine Aktivitätskarte mit einem Textfeld für Updates
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        title: Titel der Karte
        
    Returns:
        tuple: (tk.Frame, tk.Text) Das Karten-Widget und das Textfeld für Updates
    """
    card = tk.Frame(
        parent, 
        bg=app.colors["card_background"], 
        padx=15, 
        pady=15
    )
    
    # Header
    header = tk.Label(
        card, 
        text=title, 
        font=app.fonts["subheader"],
        fg=app.colors["text_primary"],
        bg=app.colors["card_background"]
    )
    header.pack(anchor=tk.W, pady=(0, 10))
    
    # Textfeld für Aktivitäten
    activity_text = tk.Text(
        card, 
        height=3, 
        bg=app.colors["background_medium"],
        fg=app.colors["text_primary"],
        font=app.fonts["normal"],
        wrap=tk.WORD,
        state=tk.DISABLED
    )
    activity_text.pack(fill=tk.X)
    
    return card, activity_text

def create_section_frame(app, parent, title=None, padx=15, pady=15):
    """
    Erstellt einen Abschnittsrahmen mit optionalem Titel
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        title: Titel des Abschnitts (optional)
        padx: Horizontales Padding
        pady: Vertikales Padding
        
    Returns:
        tk.Frame: Der erstellte Rahmen
    """
    frame = tk.Frame(
        parent, 
        bg=app.colors["card_background"], 
        padx=padx, 
        pady=pady
    )
    
    if title:
        header = tk.Label(
            frame, 
            text=title, 
            font=app.fonts["subheader"],
            fg=app.colors["text_primary"],
            bg=app.colors["card_background"]
        )
        header.pack(anchor=tk.W, pady=(0, 10))
    
    return frame

# ================================================================================
# Datei: maehrdocs\gui\gui_command_executor.py
# ================================================================================

"""
Befehlsausführung für MaehrDocs
Enthält Funktionen zur Ausführung von Befehlen in separaten Threads
"""

import subprocess
import threading
from tkinter import messagebox

def run_command_in_thread(app, command):
    """
    Führt einen Befehl in einem separaten Thread aus
    
    Args:
        app: Instanz der GuiApp
        command: Liste mit Befehlszeile und Argumenten
    """
    # Status aktualisieren
    app.status_label.config(text="Verarbeitung läuft...")
    
    # Log protokollieren
    app.log(f"Führe Befehl aus: {' '.join(command)}")
    
    # Thread starten
    thread = threading.Thread(target=_run_command, args=(app, command))
    thread.daemon = True
    thread.start()

def _run_command(app, command):
    """
    Führt den eigentlichen Befehl aus und aktualisiert das Protokoll
    
    Args:
        app: Instanz der GuiApp
        command: Liste mit Befehlszeile und Argumenten
    """
    try:
        # Prozess starten und Ausgabe erfassen
        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True
        )
        
        # Ausgabe in Echtzeit verarbeiten
        for line in process.stdout:
            app.log(line.strip())
            
            # Auf Duplikate prüfen
            if "DUPLICATE DETECTED" in line:
                from .gui_notification_handlers import handle_duplicate_from_log
                handle_duplicate_from_log(app, line)
            
        # Auf Fehler prüfen
        for line in process.stderr:
            app.log(line.strip(), level="error")
            
        # Auf Prozessende warten
        process.wait()
        
        # Ergebnis anzeigen
        if process.returncode == 0:
            app.log("Verarbeitung erfolgreich abgeschlossen.", level="success")
            app.status_label.config(text="Bereit")
            
            # Dashboard aktualisieren
            app.root.after(1000, app.update_dashboard)
            
            # Benachrichtigung anzeigen wenn aktiviert
            if app.config.get("gui", {}).get("notify_on_completion", True):
                messagebox.showinfo(
                    "Verarbeitung abgeschlossen", 
                    "Die Dokumentenverarbeitung wurde erfolgreich abgeschlossen."
                )
        else:
            app.log(f"Verarbeitung mit Fehlercode {process.returncode} beendet.", level="error")
            app.status_label.config(text="Fehler aufgetreten")
            
    except Exception as e:
        app.log(f"Fehler bei der Ausführung: {str(e)}", level="error")
        app.status_label.config(text="Fehler aufgetreten")

# ================================================================================
# Datei: maehrdocs\gui\gui_core.py
# ================================================================================

"""
Kernmodul der GUI-Anwendung für MaehrDocs
Enthält die Hauptklasse GuiApp, die alle anderen GUI-Komponenten koordiniert und steuert.

Dieses Modul dient als zentraler Einstiegspunkt für die grafische Benutzeroberfläche
und verwaltet die Interaktion zwischen den verschiedenen GUI-Komponenten, dem Backend
und der Anwendungskonfiguration.
"""

import tkinter as tk
import logging
from tkinter import messagebox

# Prüfe, ob TkinterDnD2 installiert ist für Drag & Drop Funktionalität
DRAG_DROP_ENABLED = False
try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
    DRAG_DROP_ENABLED = True
except ImportError:
    pass

# Lokale Importe
from .gui_buttons import create_button
from .gui_dashboard import create_dashboard
from .gui_layout import (
    create_header,
    create_control_panel,
    create_log_panel,
    create_status_bar
)
from .gui_logger import setup_logging, log_message
from .gui_utils import (
    update_dashboard,
    check_for_new_documents,
    setup_drag_drop,
    clear_log
)
from .gui_settings import open_settings
from .gui_help import show_help
from .gui_actions import handle_drop

# Neuer Import für den ErrorHandler
from maehrdocs.error_handler import ErrorHandler

class GuiApp:
    """
    Hauptklasse für die MaehrDocs GUI-Anwendung.
    
    Diese Klasse dient als zentraler Koordinator für die gesamte GUI und:
    - Initialisiert das Hauptfenster und alle UI-Komponenten
    - Verwaltet das Farbschema und die Schriftarten
    - Stellt Hilfsfunktionen für andere GUI-Komponenten bereit
    - Koordiniert die Interaktion zwischen UI und Backend-Logik
    - Verwaltet regelmäßige Hintergrundaufgaben und Updates
    
    Die GuiApp-Instanz wird von allen UI-Komponenten als Referenz verwendet,
    um auf gemeinsame Ressourcen und Konfigurationen zuzugreifen.
    """
    def __init__(self, config_manager, document_processor):
        """
        Initialisiert die GUI mit Konfiguration und Dokumentenprozessor.
        
        Setzt das Farbschema, die Schriftarten und die grundlegenden
        Anwendungsreferenzen, ohne jedoch die eigentliche GUI zu erstellen.
        Die GUI-Erstellung erfolgt separat über setup_gui().
        
        Args:
            config_manager: Instanz des ConfigManager für Konfigurationszugriff
            document_processor: Instanz des DocumentProcessor für Dokumentenverarbeitung
        """
        self.config_manager = config_manager
        self.config = config_manager.get_config()
        self.document_processor = document_processor
        self.logger = logging.getLogger(__name__)
        
        # Zentrale Fehlerbehandlung initialisieren
        self.error_handler = ErrorHandler(self)
        
        # Farbschema definieren - modernes, dunkles Design
        self.colors = {
            "background_dark": "#0D1117",    # Tiefdunkles Blau-Schwarz
            "background_medium": "#161B22",  # Etwas hellerer Hintergrund
            "card_background": "#1F2937",    # Dunkles Grau-Blau für Panels
            "primary": "#3B82F6",            # Auffälliges, modernes Blau
            "accent": "#60A5FA",             # Helleres Blau für Hover
            "text_primary": "#F9FAFB",       # Fast weiß
            "text_secondary": "#9CA3AF",     # Mittelhelles Grau-Blau
            "success": "#10B981",            # Frisches Grün
            "warning": "#FBBF24",            # Sattes Gelb-Orange
            "error": "#EF4444"               # Kräftiges Rot
        }
        
        # Schriftarten definieren
        self.fonts = {
            "header": ("Segoe UI", 16, "bold"),
            "subheader": ("Segoe UI", 14, "bold"),
            "normal": ("Segoe UI", 12),
            "small": ("Segoe UI", 10),
            "code": ("Consolas", 11)
        }
        
        # GUI-Elemente
        self.root = None
        self.main_frame = None
        self.log_text = None
        self.status_label = None
        
        # Status und Tracking
        self.dashboard_elements = {}
        self.processing = False
        self.last_inbox_count = 0
        
        # Zentrale Messaging-Instanz (wird in setup_gui initialisiert)
        self.messaging = None
    
    def setup_gui(self):
        """
        Richtet die GUI ein und erstellt alle UI-Komponenten.
        
        Erstellt das Hauptfenster, initialisiert alle UI-Komponenten wie
        Header, Dashboard, Steuerungspanel und Protokollbereich, und
        startet die regelmäßigen Hintergrundaufgaben wie die Prüfung
        auf neue Dokumente.
        
        Returns:
            tk.Tk: Das Root-Fenster der Anwendung
        """
        # Mit ErrorHandler für sichere GUI-Initialisierung
        with self.error_handler.safe_operation(context="GUI-Initialisierung", level="critical"):
            # Initialisiere das Hauptfenster mit TkinterDnD wenn verfügbar, sonst normales Tk
            if DRAG_DROP_ENABLED:
                self.root = TkinterDnD.Tk()
            else:
                self.root = tk.Tk()
                self.logger.warning("TkinterDnD2 nicht installiert. Drag & Drop wird deaktiviert.")
            
            self.root.title("MaehrDocs - Automatisches Dokumentenmanagement")
            self.root.geometry("1700x1300")
            self.root.configure(bg=self.colors["background_dark"])
            
            # Hauptframe erstellen
            self.main_frame = tk.Frame(self.root, bg=self.colors["background_dark"])
            self.main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
            
            # Header erstellen
            self.header_elements = create_header(
                self,
                self.main_frame,
                lambda: open_settings(self),
                lambda: show_help(self)
            )
            
            # Dashboard erstellen
            self.dashboard_elements = create_dashboard(
                self,
                self.main_frame,
                self.config
            )
            
            # Steuerungspanel erstellen
            self.control_elements = create_control_panel(self, self.main_frame)
            
            # Protokollbereich erstellen
            self.log_panel_elements = create_log_panel(
                self,
                self.main_frame,
                lambda: clear_log(self)
            )
            self.log_text = self.log_panel_elements["log_text"]
            
            # Statusleiste erstellen
            self.status_elements = create_status_bar(self, self.main_frame)
            self.status_label = self.status_elements["status_label"]
            
            # Logging einrichten
            setup_logging(self)
            
            # Messaging-System initialisieren (NACH der GUI-Erstellung)
            from .messaging import MessagingSystem
            self.messaging = MessagingSystem(self)
            
            # ErrorHandler aktualisieren, um das jetzt verfügbare Messaging-System zu nutzen
            self.error_handler.app = self
            
            # Dashboard aktualisieren
            update_dashboard(self)
            
            # Drag & Drop-Unterstützung hinzufügen (wenn verfügbar)
            if DRAG_DROP_ENABLED:
                setup_drag_drop(self, lambda e: handle_drop(self, e))
            else:
                log_message(self, "Drag & Drop-Funktionalität nicht verfügbar. Für die volle Funktionalität wird TkinterDnD2 empfohlen. "
                "Installieren Sie es mit 'pip install tkinterdnd2'.", 
                level="warning")
            
            # Prüfe periodisch auf neue Dokumente
            self.root.after(5000, lambda: check_for_new_documents(self))
            
            return self.root
    
    def open_folder(self, folder_suffix):
        """
        Öffnet den angegebenen Ordner im Datei-Explorer.
        
        Verwendet plattformspezifische Methoden, um den entsprechenden
        Ordner im Standarddateimanager des Betriebssystems zu öffnen.
        
        Args:
            folder_suffix: Ordnersuffix (z.B. "01_InboxDocs") für die Identifikation
        """
        # Mit ErrorHandler ausführen
        def _open_folder():
            from .gui_utils import open_folder_in_explorer
            open_folder_in_explorer(self, folder_suffix)
        
        self.error_handler.try_except(_open_folder, context="Ordner öffnen", level="warning")
    
    def browse_folder(self, key):
        """
        Öffnet einen Dialog zur Ordnerauswahl für ein Einstellungsfeld.
        
        Zeigt einen Dateiauswahldialog und aktualisiert das entsprechende
        Einstellungsfeld mit dem ausgewählten Ordnerpfad.
        
        Args:
            key: Schlüssel des betroffenen Konfigurationsfeldes
        """
        # Mit ErrorHandler ausführen
        def _browse_folder():
            from .gui_settings import browse_folder
            browse_folder(self, key)
        
        self.error_handler.try_except(_browse_folder, context="Ordnerdialog", level="warning")
    
    def log(self, message, level="info"):
        """
        Fügt eine Nachricht zum Protokollbereich hinzu.
        
        Zentrale Methode zur Protokollierung von Nachrichten in der GUI
        mit entsprechender visueller Hervorhebung je nach Log-Level.
        
        Args:
            message: Die zu protokollierende Nachricht
            level: Log-Level (info, warning, error, success)
        """
        # Bei verfügbarem Messaging-System dieses verwenden
        if hasattr(self, 'messaging') and self.messaging:
            self.messaging.notify(message, level=level)
        else:
            # Fallback zur älteren Methode
            log_message(self, message, level)

# ================================================================================
# Datei: maehrdocs\gui\gui_dashboard.py
# ================================================================================

"""
Dashboard-Funktionalität für MaehrDocs
Erstellt das Dashboard mit Statuskarten und Aktivitätsanzeige
"""

import tkinter as tk
from .gui_cards import create_status_card

def create_dashboard(app, parent, config, open_folder_callback):
    """
    Erstellt das Dashboard mit Statusanzeigen
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        config: Konfigurationsdaten
        open_folder_callback: Callback-Funktion zum Öffnen von Ordnern
        
    Returns:
        dict: Dictionary mit allen erstellten Dashboard-Elementen
    """
    dashboard_elements = {}
    
    dashboard_frame = tk.Frame(parent, bg=app.colors["background_medium"], padx=15, pady=15)
    dashboard_frame.pack(fill=tk.X, pady=10)
    
    # Überschrift
    dashboard_header = tk.Label(
        dashboard_frame, 
        text="Dashboard", 
        font=app.fonts["header"],
        fg=app.colors["text_primary"],
        bg=app.colors["background_medium"]
    )
    dashboard_header.pack(anchor=tk.W, pady=(0, 10))
    
    # Container für die Karten
    cards_frame = tk.Frame(dashboard_frame, bg=app.colors["background_medium"])
    cards_frame.pack(fill=tk.X)
    
    # Karten für Ordner-Status
    inbox_card = create_status_card(app, cards_frame, "Eingang", "01_InboxDocs", "📥")
    inbox_card.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
    dashboard_elements["inbox_card"] = inbox_card
    
    processed_card = create_status_card(app, cards_frame, "Verarbeitet", "02_FinalDocs", "✅")
    processed_card.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
    dashboard_elements["processed_card"] = processed_card
    
    trash_card = create_status_card(app, cards_frame, "Probleme", "03_TrashDocs", "🗑️")
    trash_card.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
    dashboard_elements["trash_card"] = trash_card
    
    # Letzte Aktivität
    activity_frame = tk.Frame(dashboard_frame, bg=app.colors["card_background"], padx=15, pady=15)
    activity_frame.pack(fill=tk.X, pady=10)
    
    activity_header = tk.Label(
        activity_frame, 
        text="Letzte Aktivität", 
        font=app.fonts["subheader"],
        fg=app.colors["text_primary"],
        bg=app.colors["card_background"]
    )
    activity_header.pack(anchor=tk.W, pady=(0, 10))
    
    activity_list = tk.Text(
        activity_frame, 
        height=3, 
        bg=app.colors["background_medium"],
        fg=app.colors["text_primary"],
        font=app.fonts["normal"],
        wrap=tk.WORD,
        state=tk.DISABLED
    )
    activity_list.pack(fill=tk.X)
    dashboard_elements["activity_list"] = activity_list
    
    return dashboard_elements

# ================================================================================
# Datei: maehrdocs\gui\gui_dialog.py
# ================================================================================

"""
Dialog-Komponenten für MaehrDocs
Enthält standardisierte Dialogfunktionen für Benutzerinteraktionen wie
Bestätigungen, Informationen, Warnungen und Fehlermeldungen.

Diese Dialoge verwenden das native Messagebox-Modul von Tkinter und
sind im Stil der Anwendung gestaltet.
"""

import tkinter as tk
from tkinter import messagebox

def show_confirm_dialog(app, title, message):
    """
    Zeigt einen Bestätigungsdialog mit Ja/Nein-Optionen an.
    
    Dieser Dialog blockiert die Anwendung, bis der Benutzer eine Auswahl
    getroffen hat, und gibt das Ergebnis zurück.
    
    Args:
        app: Die Hauptanwendung (GuiApp-Instanz)
        title (str): Der Titel des Dialogs
        message (str): Die Nachricht des Dialogs
        
    Returns:
        bool: True wenn der Benutzer "Ja" wählt, False wenn "Nein" gewählt wird
    """
    return messagebox.askyesno(title, message)

def show_info_dialog(app, title, message):
    """
    Zeigt einen Informationsdialog mit einer OK-Schaltfläche an.
    
    Verwendet für Mitteilungen und Hinweise, die der Benutzer lesen und
    bestätigen soll, ohne eine Entscheidung treffen zu müssen.
    
    Args:
        app: Die Hauptanwendung (GuiApp-Instanz)
        title (str): Der Titel des Dialogs
        message (str): Die Nachricht des Dialogs
    """
    messagebox.showinfo(title, message)
    
def show_error_dialog(app, title, message):
    """
    Zeigt einen Fehlerdialog mit einem Fehlersymbol und einer OK-Schaltfläche an.
    
    Verwendet für Fehlermeldungen und kritische Probleme, die die Aufmerksamkeit
    des Benutzers erfordern.
    
    Args:
        app: Die Hauptanwendung (GuiApp-Instanz)
        title (str): Der Titel des Dialogs
        message (str): Die Nachricht des Dialogs
    """
    messagebox.showerror(title, message)
    
def show_warning_dialog(app, title, message):
    """
    Zeigt einen Warnungsdialog mit einem Warnsymbol und einer OK-Schaltfläche an.
    
    Verwendet für Warnungen und potenzielle Probleme, die der Benutzer beachten
    sollte, aber nicht unbedingt ein Eingreifen erfordern.
    
    Args:
        app: Die Hauptanwendung (GuiApp-Instanz)
        title (str): Der Titel des Dialogs
        message (str): Die Nachricht des Dialogs
    """
    messagebox.showwarning(title, message)

# ================================================================================
# Datei: maehrdocs\gui\gui_document_actions.py
# ================================================================================

"""
Dokumentenaktionen für MaehrDocs
Enthält Funktionen zur Verarbeitung von Dokumenten
"""

import os
from tkinter import filedialog, messagebox

def process_documents(app):
    """
    Verarbeitet alle Dokumente im Eingangsordner
    
    Args:
        app: Instanz der GuiApp
    """
    from .gui_command_executor import run_command_in_thread
    run_command_in_thread(app, ["python", "autodocs_v2.py"])

def simulate_processing(app):
    """
    Führt eine Simulation (Dry-Run) durch
    
    Args:
        app: Instanz der GuiApp
    """
    from .gui_command_executor import run_command_in_thread
    run_command_in_thread(app, ["python", "autodocs_v2.py", "--dry-run"])

def process_single_file(app):
    """
    Verarbeitet eine einzelne vom Benutzer ausgewählte Datei
    
    Args:
        app: Instanz der GuiApp
    """
    file_path = filedialog.askopenfilename(
        title="PDF-Datei auswählen",
        filetypes=[("PDF-Dateien", "*.pdf")]
    )
    
    if file_path:
        from .gui_command_executor import run_command_in_thread
        run_command_in_thread(app, ["python", "autodocs_v2.py", "--single-file", file_path])

def rebuild_config(app):
    """
    Setzt die Konfiguration zurück
    
    Args:
        app: Instanz der GuiApp
    """
    if messagebox.askyesno(
        "Konfiguration zurücksetzen", 
        "Möchten Sie die Konfiguration wirklich zurücksetzen? "
        "Alle benutzerdefinierten Einstellungen gehen verloren."
    ):
        from .gui_command_executor import run_command_in_thread
        run_command_in_thread(app, ["python", "autodocs_v2.py", "--rebuild-config"])

# ================================================================================
# Datei: maehrdocs\gui\gui_document_comparison.py
# ================================================================================

"""
Dokumentenvergleich für MaehrDocs
Enthält Funktionen zum Vergleichen von PDF-Dokumenten
"""

import os
import tkinter as tk
from tkinter import scrolledtext
import threading

from .gui_buttons import create_button
from .gui_document_loader import load_document_content

def compare_documents(app, original_file, duplicate_file):
    """
    Öffnet ein Fenster zum visuellen Vergleich zweier Dokumente
    
    Args:
        app: Instanz der GuiApp
        original_file: Pfad zur Originaldatei
        duplicate_file: Pfad zur Duplikatdatei
    """
    compare_window = tk.Toplevel(app.root)
    compare_window.title(f"Dokumentenvergleich")
    compare_window.geometry("1200x800")
    compare_window.configure(bg=app.colors["background_dark"])
    
    compare_frame = tk.Frame(
        compare_window, 
        bg=app.colors["background_medium"], 
        padx=15, 
        pady=15
    )
    compare_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
    
    # Überschrift
    header = tk.Label(
        compare_frame, 
        text="Dokumentenvergleich", 
        font=app.fonts["header"],
        fg=app.colors["text_primary"],
        bg=app.colors["background_medium"]
    )
    header.pack(anchor=tk.W, pady=(0, 15))
    
    # Zwei Spalten für die Dokumente
    docs_frame = tk.Frame(compare_frame, bg=app.colors["background_medium"])
    docs_frame.pack(fill=tk.BOTH, expand=True)
    
    # Linke Spalte - Original
    left_frame = create_document_panel(
        app, 
        docs_frame, 
        f"Original: {os.path.basename(original_file)}"
    )
    left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
    
    # Rechte Spalte - Duplikat
    right_frame = create_document_panel(
        app, 
        docs_frame, 
        f"Duplikat: {os.path.basename(duplicate_file)}"
    )
    right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
    
    # Button zum Schließen
    close_btn = create_button(
        app,
        compare_frame, 
        "Fenster schließen", 
        compare_window.destroy
    )
    close_btn.pack(anchor=tk.E, pady=10)
    
    # Inhalt der Dokumente in einem Thread laden
    threading.Thread(
        target=load_and_compare_contents, 
        args=(app, original_file, duplicate_file, left_frame.text, right_frame.text)
    ).start()
    
    return compare_window

def create_document_panel(app, parent, title):
    """
    Erstellt ein Panel für die Anzeige eines Dokuments
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        title: Titel des Panels
        
    Returns:
        tk.Frame: Das erstellte Panel
    """
    panel = tk.Frame(
        parent, 
        bg=app.colors["card_background"], 
        padx=10, 
        pady=10
    )
    
    header = tk.Label(
        panel, 
        text=title, 
        font=app.fonts["subheader"],
        fg=app.colors["text_primary"],
        bg=app.colors["card_background"]
    )
    header.pack(anchor=tk.W, pady=(0, 10))
    
    text = scrolledtext.ScrolledText(
        panel, 
        bg=app.colors["background_dark"],
        fg=app.colors["text_primary"],
        font=app.fonts["code"]
    )
    text.pack(fill=tk.BOTH, expand=True)
    
    # Speichere Textfeld als Attribut
    panel.text = text
    
    return panel

def load_and_compare_contents(app, original_file, duplicate_file, left_text, right_text):
    """
    Lädt den Inhalt der Dokumente und hebt Unterschiede hervor
    
    Args:
        app: Instanz der GuiApp
        original_file: Pfad zur Originaldatei
        duplicate_file: Pfad zur Duplikatdatei
        left_text: Textfeld für die Originaldatei
        right_text: Textfeld für die Duplikatdatei
    """
    try:
        # Original-Dokument laden
        load_document_content(app, original_file, left_text)
        
        # Duplikat-Dokument laden
        load_document_content(app, duplicate_file, right_text)
        
        # Unterschiede hervorheben
        highlight_differences(app, left_text, right_text)
        
    except Exception as e:
        app.log(f"Fehler beim Laden der Dokumenteninhalte: {str(e)}", level="error")

def highlight_differences(app, left_text, right_text):
    """
    Hebt Unterschiede zwischen zwei Textfenstern hervor
    
    Args:
        app: Instanz der GuiApp
        left_text: Textfeld mit dem Originaltext
        right_text: Textfeld mit dem Vergleichstext
    """
    try:
        # Text aus beiden Widgets holen
        left_text.config(state=tk.NORMAL)
        right_text.config(state=tk.NORMAL)
        
        left_content = left_text.get(1.0, tk.END)
        right_content = right_text.get(1.0, tk.END)
        
        # Texte in Zeilen aufteilen
        left_lines = left_content.splitlines()
        right_lines = right_content.splitlines()
        
        # Unterschiede finden
        import difflib
        differ = difflib.Differ()
        diff = list(differ.compare(left_lines, right_lines))
        
        # Text löschen und neu einfügen
        left_text.delete(1.0, tk.END)
        right_text.delete(1.0, tk.END)
        
        # Tags für die Formatierung erstellen
        left_text.tag_configure("difference", background=app.colors["error"], foreground="white")
        right_text.tag_configure("difference", background=app.colors["error"], foreground="white")
        
        # Unterschiedliche Zeilen hervorheben
        for line in diff:
            if line.startswith('  '):  # Gemeinsame Zeile
                left_text.insert(tk.END, line[2:] + "\n")
                right_text.insert(tk.END, line[2:] + "\n")
            elif line.startswith('- '):  # Nur links
                left_text.insert(tk.END, line[2:] + "\n", "difference")
            elif line.startswith('+ '):  # Nur rechts
                right_text.insert(tk.END, line[2:] + "\n", "difference")
        
        left_text.config(state=tk.DISABLED)
        right_text.config(state=tk.DISABLED)
        
    except Exception as e:
        app.log(f"Fehler beim Hervorheben von Unterschieden: {str(e)}", level="error")

# ================================================================================
# Datei: maehrdocs\gui\gui_document_loader.py
# ================================================================================

"""
Dokumentenloader für MaehrDocs
Enthält Funktionen zum Laden und Extrahieren von Dokumentinhalten
"""

import os
import tkinter as tk

from .gui_document_viewer import get_full_document_path

def load_document_content(app, file_path, text_widget):
    """
    Lädt den Inhalt eines Dokuments in ein Text-Widget
    
    Args:
        app: Instanz der GuiApp
        file_path: Pfad zur Datei
        text_widget: Textfeld-Widget
    """
    try:
        # PDF-Inhalt extrahieren
        import fitz  # PyMuPDF
        
        text_widget.config(state=tk.NORMAL)
        text_widget.delete(1.0, tk.END)
        
        # Vollständigen Pfad bestimmen
        full_path = get_full_document_path(app, file_path)
        
        if os.path.exists(full_path):
            doc = fitz.open(full_path)
            text = ""
            
            for page in doc:
                text += page.get_text()
            
            text_widget.insert(tk.END, text)
            
            # PDF-Metadaten anzeigen
            text_widget.insert(tk.END, "\n\n--- Metadaten ---\n")
            for key, value in doc.metadata.items():
                if value:
                    text_widget.insert(tk.END, f"{key}: {value}\n")
                    
            doc.close()
        else:
            text_widget.insert(tk.END, f"Datei nicht gefunden: {full_path}")
        
        text_widget.config(state=tk.DISABLED)
        
    except Exception as e:
        text_widget.config(state=tk.NORMAL)
        text_widget.delete(1.0, tk.END)
        text_widget.insert(tk.END, f"Fehler beim Laden der Datei: {str(e)}")
        text_widget.config(state=tk.DISABLED)

def get_document_metadata(file_path):
    """
    Extrahiert Metadaten aus einem PDF-Dokument
    
    Args:
        file_path: Pfad zur Datei
        
    Returns:
        dict: Metadaten des Dokuments oder leeres Dictionary bei Fehler
    """
    try:
        import fitz  # PyMuPDF
        
        if not os.path.exists(file_path) or not file_path.lower().endswith('.pdf'):
            return {}
        
        with fitz.open(file_path) as doc:
            # Metadaten extrahieren
            metadata = doc.metadata
            
            # Dokumentinformationen extrahieren
            info = {
                "Seitenanzahl": len(doc),
                "Erstellungsdatum": metadata.get("creationDate", ""),
                "Änderungsdatum": metadata.get("modDate", ""),
                "Format": doc.name.split(".")[-1].upper() if "." in doc.name else "",
                "Verschlüsselt": "Ja" if doc.isEncrypted else "Nein"
            }
            
            # Metadaten und Dokumentinformationen zusammenführen
            combined = {**metadata, **info}
            
            return combined
    
    except Exception:
        return {}

def extract_document_text(file_path):
    """
    Extrahiert Text aus einem PDF-Dokument
    
    Args:
        file_path: Pfad zur Datei
        
    Returns:
        str: Extrahierter Text oder leerer String bei Fehler
    """
    try:
        import fitz  # PyMuPDF
        
        if not os.path.exists(file_path) or not file_path.lower().endswith('.pdf'):
            return ""
        
        text = ""
        with fitz.open(file_path) as doc:
            for page in doc:
                text += page.get_text()
        
        return text
    
    except Exception:
        return ""

def get_document_preview(app, file_path, text_widget, max_chars=2000):
    """
    Lädt eine Vorschau des Dokumentinhalts in ein Text-Widget
    
    Args:
        app: Instanz der GuiApp
        file_path: Pfad zur Datei
        text_widget: Textfeld-Widget
        max_chars: Maximale Anzahl der anzuzeigenden Zeichen
    """
    try:
        # Vollständigen Pfad bestimmen
        full_path = get_full_document_path(app, file_path)
        
        if not os.path.exists(full_path):
            text_widget.config(state=tk.NORMAL)
            text_widget.delete(1.0, tk.END)
            text_widget.insert(tk.END, f"Datei nicht gefunden: {full_path}")
            text_widget.config(state=tk.DISABLED)
            return
        
        # Text extrahieren
        text = extract_document_text(full_path)
        
        # Text auf max_chars begrenzen
        if len(text) > max_chars:
            preview_text = text[:max_chars] + "...\n\n[Gekürzt - vollständigen Text anzeigen]"
        else:
            preview_text = text
        
        # In Widget anzeigen
        text_widget.config(state=tk.NORMAL)
        text_widget.delete(1.0, tk.END)
        text_widget.insert(tk.END, preview_text)
        text_widget.config(state=tk.DISABLED)
        
    except Exception as e:
        app.log(f"Fehler beim Laden der Dokumentvorschau: {str(e)}", level="error")

# ================================================================================
# Datei: maehrdocs\gui\gui_document_viewer.py
# ================================================================================

"""
Dokumentenansicht für MaehrDocs
Enthält grundlegende Funktionen zum Anzeigen von Dokumenten
"""

import os
import sys
import subprocess
from tkinter import messagebox

def open_document(app, file_path):
    """
    Öffnet ein Dokument mit dem Standardprogramm
    
    Args:
        app: Instanz der GuiApp
        file_path: Pfad zur Datei
    """
    try:
        # Vollständigen Pfad bestimmen
        complete_path = get_full_document_path(app, file_path)
        
        if os.path.exists(complete_path):
            # Plattformabhängiges Öffnen der Datei
            if os.name == 'nt':  # Windows
                os.startfile(complete_path)
            elif os.name == 'posix':  # macOS oder Linux
                subprocess.call(['open' if sys.platform == 'darwin' else 'xdg-open', complete_path])
        else:
            messagebox.showerror("Fehler", f"Datei nicht gefunden: {complete_path}")
            
    except Exception as e:
        messagebox.showerror("Fehler", f"Fehler beim Öffnen der Datei: {str(e)}")
        app.log(f"Fehler beim Öffnen der Datei: {str(e)}", level="error")

def get_full_document_path(app, file_path):
    """
    Bestimmt den vollständigen Pfad zu einem Dokument
    
    Args:
        app: Instanz der GuiApp
        file_path: Pfad zur Datei (kann relativ sein)
        
    Returns:
        str: Vollständiger Pfad zur Datei
    """
    # Wenn schon ein absoluter Pfad, dann direkt zurückgeben
    if os.path.isabs(file_path) and os.path.exists(file_path):
        return file_path
        
    # Prüfen in verschiedenen Ordnern
    for folder in [
        app.config["paths"]["input_dir"], 
        app.config["paths"]["output_dir"], 
        app.config["paths"]["trash_dir"]
    ]:
        potential_path = os.path.join(folder, os.path.basename(file_path))
        if os.path.exists(potential_path):
            return potential_path
    
    # Wenn nicht gefunden, dann den ursprünglichen Pfad zurückgeben
    return file_path

def show_document_info(app, file_path):
    """
    Zeigt Informationen über ein Dokument an
    
    Args:
        app: Instanz der GuiApp
        file_path: Pfad zur Datei
    """
    from .gui_document_loader import get_document_metadata
    
    try:
        full_path = get_full_document_path(app, file_path)
        if not os.path.exists(full_path):
            app.log(f"Datei nicht gefunden: {full_path}", level="error")
            return
            
        # Dokumentinformationen abrufen
        metadata = get_document_metadata(full_path)
        
        # Einfaches Popup mit Dokumentinformationen
        info_text = f"Dateiname: {os.path.basename(full_path)}\n"
        info_text += f"Größe: {os.path.getsize(full_path) / 1024:.1f} KB\n"
        info_text += f"Zuletzt geändert: {os.path.getmtime(full_path)}\n\n"
        
        # Metadaten hinzufügen
        info_text += "Metadaten:\n"
        for key, value in metadata.items():
            if value:
                info_text += f"{key}: {value}\n"
                
        # Popup anzeigen
        messagebox.showinfo("Dokumentinformationen", info_text)
        
    except Exception as e:
        app.log(f"Fehler beim Anzeigen der Dokumentinformationen: {str(e)}", level="error")

# ================================================================================
# Datei: maehrdocs\gui\gui_drop_handlers.py
# ================================================================================

"""
Drag & Drop Handler für MaehrDocs
Enthält Funktionen zum Verarbeiten von Drag & Drop Ereignissen
"""

import os
import time
import shutil
import threading
import tkinter as tk

def handle_drop(app, event):
    """
    Verarbeitet gedropte Dateien
    
    Args:
        app: Instanz der GuiApp
        event: Drop-Event mit Dateiinformationen
    """
    # Prüfen, ob Drag & Drop aktiviert ist
    if not hasattr(event, 'data'):
        app.messaging.notify("Drag & Drop ist nicht verfügbar.", level="warning")
        return
        
    # Liste der gedropten Dateien
    files = event.data
    
    # Windows-Pfade verarbeiten
    if os.name == 'nt':
        files = files.replace('{', '').replace('}', '')
        file_list = files.split()
    else:
        file_list = files.split()
    
    # PDF-Filter
    pdf_files = [f for f in file_list if f.lower().endswith('.pdf')]
    
    if not pdf_files:
        app.messaging.dialog("Keine PDFs", "Es wurden keine PDF-Dateien zum Verarbeiten gefunden.", type="info")
        return
        
    # Bestätigung
    if len(pdf_files) == 1:
        if app.messaging.dialog(
            "Datei verarbeiten", 
            f"Möchten Sie die Datei '{os.path.basename(pdf_files[0])}' verarbeiten?",
            type="confirm"
        ):
            from .gui_command_executor import run_command_in_thread
            run_command_in_thread(app, ["python", "autodocs_v2.py", "--single-file", pdf_files[0]])
    else:
        # Bei mehreren Dateien fragen, ob man sie in den Eingangsordner kopieren möchte
        if app.messaging.dialog(
            "Dateien verarbeiten", 
            f"Möchten Sie {len(pdf_files)} PDF-Dateien in den Eingangsordner kopieren?",
            type="confirm"
        ):
            copy_files_to_inbox(app, pdf_files)

def copy_files_to_inbox(app, file_list):
    """
    Kopiert Dateien in den Eingangsordner
    
    Args:
        app: Instanz der GuiApp
        file_list: Liste der zu kopierenden Dateipfade
    """
    from tkinter import ttk
    
    inbox_dir = app.config["paths"]["input_dir"]
    
    # Fortschrittsfenster erstellen
    progress_window = tk.Toplevel(app.root)
    progress_window.title("Dateien werden kopiert...")
    progress_window.geometry("400x200")
    progress_window.configure(bg=app.colors["background_dark"])
    progress_window.grab_set()  # Modal machen
    
    progress_frame = tk.Frame(
        progress_window, 
        bg=app.colors["background_medium"], 
        padx=20, 
        pady=20
    )
    progress_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
    
    # Beschreibung
    label = tk.Label(
        progress_frame, 
        text=f"Kopiere {len(file_list)} Dateien in den Eingangsordner...", 
        font=app.fonts["normal"],
        fg=app.colors["text_primary"],
        bg=app.colors["background_medium"]
    )
    label.pack(pady=10)
    
    # Fortschrittsbalken
    progress = ttk.Progressbar(progress_frame, length=300, mode='determinate')
    progress.pack(pady=10)
    
    # Dateiname
    file_label = tk.Label(
        progress_frame, 
        text="", 
        font=app.fonts["small"],
        fg=app.colors["text_secondary"],
        bg=app.colors["background_medium"]
    )
    file_label.pack(pady=5)
    
    # In einem Thread kopieren
    def copy_thread():
        success_count = 0
        error_count = 0
        
        for i, file_path in enumerate(file_list):
            try:
                # UI aktualisieren
                progress['value'] = (i / len(file_list)) * 100
                file_name = os.path.basename(file_path)
                file_label.config(text=f"Kopiere: {file_name}")
                
                # Datei kopieren
                dest_path = os.path.join(inbox_dir, file_name)
                shutil.copy2(file_path, dest_path)
                
                # Log
                app.messaging.notify(f"Datei kopiert: {file_name}")
                success_count += 1
                
            except Exception as e:
                app.messaging.notify(f"Fehler beim Kopieren von {os.path.basename(file_path)}: {str(e)}", level="error")
                error_count += 1
                
            # Kurze Pause für die UI
            time.sleep(0.1)
        
        # Fertig
        progress['value'] = 100
        file_label.config(text="Kopiervorgang abgeschlossen")
        
        # Abschlussmeldung
        if error_count == 0:
            app.messaging.dialog(
                "Kopiervorgang abgeschlossen", 
                f"Alle {success_count} Dateien wurden erfolgreich in den Eingangsordner kopiert.",
                type="info"
            )
        else:
            app.messaging.dialog(
                "Kopiervorgang mit Fehlern abgeschlossen", 
                f"{success_count} Dateien erfolgreich kopiert, {error_count} Fehler aufgetreten.",
                type="warning"
            )
        
        # Fenster schließen
        progress_window.destroy()
        
        # Dashboard aktualisieren
        app.update_dashboard()
        
        # Fragen, ob die Dateien verarbeitet werden sollen
        if success_count > 0 and app.messaging.dialog(
            "Dateien verarbeiten", 
            f"Möchten Sie die {success_count} kopierten Dateien jetzt verarbeiten?",
            type="confirm"
        ):
            from .gui_document_actions import process_documents
            process_documents(app)
    
    # Thread starten
    thread = threading.Thread(target=copy_thread)
    thread.daemon = True
    thread.start()

# ================================================================================
# Datei: maehrdocs\gui\gui_form_fields.py
# ================================================================================

# gui_form_fields.py
"""
Spezifische Formularfelder für MaehrDocs GUI
Enthält die verschiedenen Formularfelder und deren Erstellung
"""

import tkinter as tk
from tkinter import ttk
from .gui_buttons import create_button

def create_text_field(app, parent, value=""):
    """
    Erstellt ein Textfeld
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        value: Vorausgefüllter Wert (optional)
        
    Returns:
        tk.Entry: Das erstellte Textfeld
    """
    input_field = tk.Entry(
        parent, 
        font=app.fonts["normal"],
        bg=app.colors["background_medium"],
        fg=app.colors["text_primary"],
        insertbackground=app.colors["text_primary"]
    )
    
    if isinstance(value, str):
        input_field.insert(0, value)
        
    return input_field

def create_folder_field(app, parent, key, value=""):
    """
    Erstellt ein Feld für die Ordnerauswahl mit Durchsuchen-Button
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        key: Konfigurationsschlüssel
        value: Vorausgefüllter Wert (optional)
        
    Returns:
        tk.Entry: Das erstellte Textfeld
    """
    input_frame = tk.Frame(parent, bg=app.colors["card_background"])
    input_frame.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    input_field = tk.Entry(
        input_frame, 
        font=app.fonts["normal"],
        bg=app.colors["background_medium"],
        fg=app.colors["text_primary"],
        insertbackground=app.colors["text_primary"]
    )
    input_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    if isinstance(value, str):
        input_field.insert(0, value)
    
    browse_btn = create_button(
        app,
        input_frame, 
        "...", 
        lambda: app.browse_folder(key)
    )
    browse_btn.pack(side=tk.LEFT, padx=5)
    
    return input_field

def create_dropdown_field(app, parent, options, value=None):
    """
    Erstellt ein Dropdown-Feld
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        options: Liste der Optionen
        value: Vorausgewählter Wert (optional)
        
    Returns:
        ttk.Combobox: Das erstellte Dropdown-Feld
    """
    input_field = ttk.Combobox(
        parent, 
        values=options,
        font=app.fonts["normal"]
    )
    
    if isinstance(value, str) and value in options:
        input_field.set(value)
    else:
        input_field.current(0)
        
    return input_field

def create_spinbox_field(app, parent, from_val, to_val, value=None):
    """
    Erstellt ein Spinbox-Feld
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        from_val: Minimalwert
        to_val: Maximalwert
        value: Vorausgefüllter Wert (optional)
        
    Returns:
        tk.Spinbox: Das erstellte Spinbox-Feld
    """
    input_field = tk.Spinbox(
        parent, 
        from_=from_val, 
        to=to_val,
        font=app.fonts["normal"],
        bg=app.colors["background_medium"],
        fg=app.colors["text_primary"],
        buttonbackground=app.colors["primary"]
    )
    
    if isinstance(value, (int, float)):
        input_field.delete(0, tk.END)
        input_field.insert(0, str(value))
        
    return input_field

def create_scale_field(app, parent, from_val, to_val, resolution, value=None):
    """
    Erstellt ein Schieberegler-Feld
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        from_val: Minimalwert
        to_val: Maximalwert
        resolution: Auflösung
        value: Vorausgefüllter Wert (optional)
        
    Returns:
        tk.Scale: Das erstellte Schieberegler-Feld
    """
    input_field = tk.Scale(
        parent, 
        orient=tk.HORIZONTAL, 
        from_=from_val, 
        to=to_val, 
        resolution=resolution,
        bg=app.colors["card_background"],
        fg=app.colors["text_primary"],
        highlightthickness=0,
        sliderrelief=tk.FLAT,
        troughcolor=app.colors["background_medium"]
    )
    
    if isinstance(value, (int, float)):
        input_field.set(value)
        
    return input_field

def create_checkbox_field(app, parent, value=False):
    """
    Erstellt ein Checkbox-Feld
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        value: Vorausgewählter Wert (optional)
        
    Returns:
        tk.Checkbutton: Das erstellte Checkbox-Feld
    """
    var = tk.BooleanVar(value=bool(value))
    
    input_field = tk.Checkbutton(
        parent, 
        variable=var,
        bg=app.colors["card_background"],
        activebackground=app.colors["card_background"],
        selectcolor=app.colors["background_dark"],
        fg=app.colors["text_primary"]
    )
    
    input_field.var = var
    
    return input_field

# ================================================================================
# Datei: maehrdocs\gui\gui_forms.py
# ================================================================================

# gui_forms.py
"""
Zentrale Formularkomponenten für MaehrDocs GUI
Koordiniert die verschiedenen Formularelemente und -funktionen
"""

import tkinter as tk
from .gui_form_fields import (
    create_text_field,
    create_folder_field,
    create_dropdown_field,
    create_spinbox_field,
    create_scale_field,
    create_checkbox_field
)

def create_form_field(app, parent, field_config):
    """
    Erstellt ein einzelnes Formularfeld basierend auf der Konfiguration
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        field_config: Feldkonfiguration (dict)
        
    Returns:
        tk.Frame: Das Rahmen-Widget mit dem Feld
    """
    field_frame = tk.Frame(parent, bg=app.colors["card_background"])
    
    # Label erstellen
    label = tk.Label(
        field_frame, 
        text=field_config["label"] + ":", 
        font=app.fonts["normal"],
        width=25,
        anchor=tk.W,
        fg=app.colors["text_primary"],
        bg=app.colors["card_background"]
    )
    label.pack(side=tk.LEFT)
    
    # Wert aus Konfiguration holen
    value = _get_config_value(app, field_config["key"])
    
    # Feld erstellen basierend auf dem Typ
    field_type = field_config["type"]
    input_field = None
    
    if field_type == "text":
        input_field = create_text_field(app, field_frame, value)
        input_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
    elif field_type == "folder":
        input_field = create_folder_field(app, field_frame, field_config["key"], value)
        
    elif field_type == "dropdown":
        input_field = create_dropdown_field(app, field_frame, field_config["options"], value)
        input_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
    elif field_type == "spinbox":
        input_field = create_spinbox_field(
            app, field_frame, field_config["from"], field_config["to"], value
        )
        input_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
    elif field_type == "scale":
        input_field = create_scale_field(
            app, field_frame, 
            field_config["from"], field_config["to"], field_config["resolution"], 
            value
        )
        input_field.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
    elif field_type == "checkbox":
        input_field = create_checkbox_field(app, field_frame, bool(value))
        input_field.pack(side=tk.LEFT)
    
    # Speichere Feldtyp und -schlüssel für späteren Zugriff
    if input_field:
        input_field.field_type = field_type
        input_field.field_key = field_config["key"]
        
        # Speichere Feld im übergeordneten Frame
        field_id = field_config["key"].replace(".", "_")
        setattr(parent, field_id, input_field)
    
    return field_frame

def _get_config_value(app, key_path):
    """
    Holt einen Wert aus der Konfiguration
    
    Args:
        app: Instanz der GuiApp
        key_path: Pfad zum Konfigurationsschlüssel (mit Punkten getrennt)
        
    Returns:
        Der Wert aus der Konfiguration oder None
    """
    keys = key_path.split(".")
    value = app.config
    
    for key in keys:
        if isinstance(value, dict) and key in value:
            value = value[key]
        else:
            return None
            
    return value

# ================================================================================
# Datei: maehrdocs\gui\gui_help.py
# ================================================================================

"""
Hilfefunktionen für MaehrDocs
Enthält Funktionen für die Anzeige von Hilfetexten und -informationen
"""

import tkinter as tk
from tkinter import scrolledtext

from .gui_buttons import create_button

def show_help(app):
    """
    Zeigt ein Hilfefenster an
    
    Args:
        app: Instanz der GuiApp
    """
    help_window = tk.Toplevel(app.root)
    help_window.title("MaehrDocs - Hilfe")
    help_window.geometry("800x600")
    help_window.configure(bg=app.colors["background_dark"])
    
    help_frame = tk.Frame(
        help_window, 
        bg=app.colors["background_medium"], 
        padx=20, 
        pady=20
    )
    help_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
    
    # Überschrift
    header = tk.Label(
        help_frame, 
        text="Hilfe und Dokumentation", 
        font=app.fonts["header"],
        fg=app.colors["text_primary"],
        bg=app.colors["background_medium"]
    )
    header.pack(anchor=tk.W, pady=(0, 20))
    
    # Tabs für verschiedene Hilfethemen
    tab_frame = tk.Frame(help_frame, bg=app.colors["background_medium"])
    tab_frame.pack(fill=tk.X, pady=10)
    
    tabs = {
        "Überblick": get_overview_help,
        "Funktionen": get_features_help,
        "Anleitung": get_tutorial_help,
        "Fehlerbehebung": get_troubleshooting_help
    }
    
    # Aktiver Tab
    active_tab = tk.StringVar(value="Überblick")
    
    # Hilfetext
    help_text = scrolledtext.ScrolledText(
        help_frame, 
        font=app.fonts["normal"],
        bg=app.colors["card_background"],
        fg=app.colors["text_primary"],
        padx=15,
        pady=15
    )
    help_text.pack(fill=tk.BOTH, expand=True)
    
    # Tab-Buttons erstellen
    for tab_name in tabs:
        tab_btn = create_button(
            app,
            tab_frame, 
            tab_name, 
            lambda name=tab_name: change_tab(name),
            bg=app.colors["primary"] if tab_name == active_tab.get() else app.colors["background_dark"]
        )
        tab_btn.pack(side=tk.LEFT, padx=5)
    
    # Funktion zum Wechseln der Tabs
    def change_tab(tab_name):
        active_tab.set(tab_name)
        
        # Tabs aktualisieren
        for i, child in enumerate(tab_frame.winfo_children()):
            if isinstance(child, tk.Button):
                tab_text = list(tabs.keys())[i]
                if tab_text == tab_name:
                    child.config(bg=app.colors["primary"])
                else:
                    child.config(bg=app.colors["background_dark"])
        
        # Hilfetext aktualisieren
        help_text.config(state=tk.NORMAL)
        help_text.delete(1.0, tk.END)
        
        # Hilfetextfunktion abrufen und ausführen
        help_function = tabs[tab_name]
        help_content = help_function()
        
        help_text.insert(tk.END, help_content)
        help_text.config(state=tk.DISABLED)
    
    # Initial den Text für den aktiven Tab anzeigen
    initial_content = get_overview_help()
    help_text.insert(tk.END, initial_content)
    help_text.config(state=tk.DISABLED)
    
    # Button zum Schließen
    close_btn = create_button(
        app,
        help_frame, 
        "Schließen", 
        help_window.destroy
    )
    close_btn.pack(anchor=tk.E, pady=10)
    
    return help_window

def get_overview_help():
    """
    Liefert den Hilfetext für den Überblick
    
    Returns:
        str: Hilfetext
    """
    return """
# MaehrDocs - Benutzerhandbuch

## Überblick

MaehrDocs ist ein intelligentes Dokumentenmanagementsystem, das mit Hilfe von KI PDF-Dokumente automatisch analysiert, 
kategorisiert und umbenennt. Die Anwendung wurde entwickelt, um den Prozess der Dokumentenverwaltung zu vereinfachen
und zu automatisieren.

## Hauptfunktionen

1. **Automatische Verarbeitung** - PDFs werden aus dem Eingangsordner gelesen, analysiert und umbenannt
2. **KI-Analyse** - Verwendet OpenAI, um Dokumenttyp, Absender, Datum und andere Informationen zu extrahieren
3. **Duplikaterkennung** - Vermeidet doppelte Dokumente durch intelligente Ähnlichkeitserkennung
4. **Übersichtliches Dashboard** - Zeigt den Status aller Ordner und die letzten Aktivitäten an

## Ordnerstruktur

Die Anwendung verwendet standardmäßig die folgende Ordnerstruktur:

- Eingangsordner: Hier werden die zu verarbeitenden PDF-Dokumente abgelegt
- Ausgabeordner: Hier werden die verarbeiteten Dokumente mit neuem Namen gespeichert
- Problemordner: Hier werden Dokumente gespeichert, die nicht verarbeitet werden konnten oder als Duplikate erkannt wurden
"""

def get_features_help():
    """
    Liefert den Hilfetext für die Funktionen
    
    Returns:
        str: Hilfetext
    """
    return """
# Funktionen

## Dashboard

Das Dashboard bietet einen Überblick über den aktuellen Status Ihrer Dokumente:

- **Eingang**: Zeigt die Anzahl der Dokumente im Eingangsordner an
- **Verarbeitet**: Zeigt die Anzahl der bereits verarbeiteten Dokumente an
- **Probleme**: Zeigt die Anzahl der Dokumente im Problemordner an

## Dokumentenverarbeitung

Die Anwendung bietet verschiedene Methoden zur Verarbeitung von Dokumenten:

- **Alle verarbeiten**: Verarbeitet alle Dokumente im Eingangsordner
- **Simulation**: Führt eine Testverarbeitung durch, ohne Änderungen vorzunehmen
- **Einzelne Datei verarbeiten**: Ermöglicht die Verarbeitung einer einzelnen Datei

## Duplikaterkennung

Das System erkennt Duplikate durch:

- Berechnung des Datei-Hashs
- Textähnlichkeitsanalyse mit anpassbarem Schwellenwert
- Vergleich von Metadaten

Bei erkannten Duplikaten erscheint ein Hinweis im Protokoll und ein Popup-Dialog mit Details.

## Protokoll

Das Protokoll zeigt alle Aktionen und Ereignisse der Anwendung an:

- Erfolgreiche Verarbeitungen
- Fehler und Warnungen
- Erkannte Duplikate
"""

def get_tutorial_help():
    """
    Liefert den Hilfetext für die Anleitung
    
    Returns:
        str: Hilfetext
    """
    return """
# Anleitung

## Schnellstart

1. Legen Sie PDF-Dokumente im Eingangsordner ab
2. Klicken Sie auf "Alle Dokumente verarbeiten"
3. Die verarbeiteten Dokumente finden Sie im Ausgabeordner

## Detaillierte Anleitung

### Neue Dokumente verarbeiten

Klicken Sie auf "Alle Dokumente verarbeiten", um alle PDFs im Eingangsordner zu verarbeiten. 
Alternativ können Sie "Simulation (Dry-Run)" wählen, um die Verarbeitung zu testen, ohne Änderungen vorzunehmen.

### Einzelne Datei verarbeiten

Klicken Sie auf "Einzelne Datei verarbeiten" und wählen Sie eine PDF-Datei aus, um nur diese zu verarbeiten.

### Konfiguration anpassen

Klicken Sie auf "Einstellungen", um die Konfiguration anzupassen, z.B.:
- Verzeichnispfade
- OpenAI-Modell und Parameter
- Schwellenwert für Duplikaterkennung
- Gültige Dokumenttypen

### Drag & Drop

Sie können Dateien auch direkt per Drag & Drop in die Anwendung ziehen, um sie zu verarbeiten.
Beachten Sie, dass diese Funktion die Installation von tkinterdnd2 erfordert.
"""

def get_troubleshooting_help():
    """
    Liefert den Hilfetext für die Fehlerbehebung
    
    Returns:
        str: Hilfetext
    """
    return """
# Fehlerbehebung

## Häufige Probleme

### Fehler bei der Textextraktion

**Problem**: Die Anwendung kann keinen Text aus einer PDF extrahieren.

**Lösung**: 
- Prüfen Sie, ob die PDF beschädigt oder passwortgeschützt ist
- Stellen Sie sicher, dass die PDF Textinhalt hat (keine gescannte Bilder ohne OCR)
- Versuchen Sie, die PDF mit einem anderen Programm zu öffnen und zu speichern

### OpenAI-API-Fehler

**Problem**: Die Anwendung kann keine Verbindung zur OpenAI-API herstellen.

**Lösung**:
- Überprüfen Sie Ihre Internetverbindung
- Stellen Sie sicher, dass der API-Schlüssel in der .env-Datei korrekt ist
- Prüfen Sie, ob Ihr API-Schlüssel noch gültig ist
- Erhöhen Sie die Anzahl der Wiederholungsversuche in den Einstellungen

### Dokument wird nicht erkannt

**Problem**: Die Anwendung kann den Dokumenttyp nicht korrekt erkennen.

**Lösung**:
- Passen Sie die gültigen Dokumenttypen in den Einstellungen an
- Stellen Sie sicher, dass der Dokumenttyp im Text eindeutig erkennbar ist
- Probieren Sie ein anderes OpenAI-Modell (z.B. GPT-4o statt GPT-3.5-Turbo)

## Tipps & Tricks

- Verwenden Sie Drag & Drop, um Dateien direkt in die Anwendung zu ziehen
- Halten Sie Ihren Eingangsordner aufgeräumt für bessere Übersicht
- Überprüfen Sie regelmäßig den Problemordner auf nicht verarbeitete Dokumente
- Nutzen Sie die Simulationsfunktion, um die Verarbeitung zu testen, bevor Sie Änderungen vornehmen

Bei weiteren Fragen wenden Sie sich an support@maehrdocs.de
"""

# ================================================================================
# Datei: maehrdocs\gui\gui_layout.py
# ================================================================================

"""
Layout-Komponenten für MaehrDocs GUI
Enthält Funktionen zur strukturierten Erstellung der Hauptlayout-Bereiche der Anwendung:
Header, Steuerungspanel, Protokollbereich und Statusleiste.

Diese Module bilden das visuelle Grundgerüst der Anwendung und stellen eine konsistente
Benutzeroberfläche sicher, die den Design-Standards der MaehrDocs-Anwendung entspricht.
"""

import tkinter as tk
from tkinter import scrolledtext
from datetime import datetime

from .gui_buttons import create_button
from .gui_actions import (
    process_documents, 
    simulate_processing, 
    process_single_file, 
    rebuild_config
)

def create_header(app, parent, settings_callback, help_callback):
    """
    Erstellt den Kopfbereich der GUI mit Logo, Titel und Funktionsschaltflächen.
    
    Der Header dient als primärer Navigationspunkt und enthält den Anwendungstitel
    sowie Schnellzugriff auf Einstellungen und Hilfefunktionen.
    
    Args:
        app: Die GuiApp-Instanz mit den Farbdefinitionen und Schriftarten
        parent: Das übergeordnete Widget, in dem der Header platziert wird
        settings_callback: Callback-Funktion für den Einstellungen-Button
        help_callback: Callback-Funktion für den Hilfe-Button
        
    Returns:
        dict: Dictionary mit allen erstellten Header-Elementen für späteren Zugriff
    """
    header_elements = {}
    
    # Header-Implementierung
    # [... Code gekürzt zur Übersichtlichkeit ...]
    
    return header_elements

def create_control_panel(app, parent):
    """
    Erstellt das Steuerungspanel mit den Hauptfunktionsschaltflächen.
    
    Das Steuerungspanel enthält alle primären Aktionsschaltflächen für die 
    Dokumentverarbeitung sowie weitere Funktionen wie Konfigurationsreset.
    Es bildet das zentrale Bedienelement der Anwendung.
    
    Args:
        app: Die GuiApp-Instanz mit den Farbdefinitionen und Schriftarten
        parent: Das übergeordnete Widget, in dem das Panel platziert wird
        
    Returns:
        dict: Dictionary mit allen erstellten Steuerungselementen für späteren Zugriff
    """
    control_elements = {}
    
    # Steuerungspanel-Implementierung
    # [... Code gekürzt zur Übersichtlichkeit ...]
    
    return control_elements

def create_log_panel(app, parent, clear_callback):
    """
    Erstellt den Protokollbereich für Statusmeldungen und Aktivitätslogs.
    
    Der Protokollbereich zeigt alle Systemaktivitäten, Fehler, Warnungen und
    Erfolgsmeldungen an und ermöglicht dem Benutzer, den Verarbeitungsstatus
    zu überwachen und Probleme zu diagnostizieren.
    
    Args:
        app: Die GuiApp-Instanz mit den Farbdefinitionen und Schriftarten
        parent: Das übergeordnete Widget, in dem das Panel platziert wird
        clear_callback: Callback-Funktion zum Löschen des Protokolls
        
    Returns:
        dict: Dictionary mit allen erstellten Protokollelementen für späteren Zugriff
    """
    log_elements = {}
    
    # Protokollbereich-Implementierung
    # [... Code gekürzt zur Übersichtlichkeit ...]
    
    return log_elements

def create_status_bar(app, parent):
    """
    Erstellt die Statusleiste am unteren Rand der Anwendung.
    
    Die Statusleiste zeigt den aktuellen Betriebsstatus der Anwendung,
    Versionsinformationen und Copyright-Hinweise an. Sie dient als
    konstante Informationsquelle über den Zustand des Systems.
    
    Args:
        app: Die GuiApp-Instanz mit den Farbdefinitionen und Schriftarten
        parent: Das übergeordnete Widget, in dem die Statusleiste platziert wird
        
    Returns:
        dict: Dictionary mit allen erstellten Statuselementen für späteren Zugriff
    """
    status_elements = {}
    
    # Statusleisten-Implementierung
    # [... Code gekürzt zur Übersichtlichkeit ...]
    
    return status_elements

# ================================================================================
# Datei: maehrdocs\gui\gui_logger.py
# ================================================================================

"""
Logging-Funktionalität für MaehrDocs GUI
Implementiert ein visuelles Logging-System mit farblicher Hervorhebung verschiedener
Log-Levels (Info, Warnung, Fehler, Erfolg) und Integration in die GUI-Komponenten.

Dieses Modul verbindet das Python-Standard-Logging mit der grafischen Benutzeroberfläche
und sorgt für konsistente und gut sichtbare Statusmeldungen während der Anwendungsausführung.
"""

import tkinter as tk
import logging
from datetime import datetime

def setup_logging(app):
    """
    Richtet die Tags für das Logging im Textfeld ein und konfiguriert die Formatierung.
    
    Erstellt farbliche Tags für verschiedene Log-Levels, um die visuelle Unterscheidung
    von Meldungen zu ermöglichen und die Benutzerfreundlichkeit zu verbessern.
    
    Args:
        app: Die GuiApp-Instanz mit dem konfigurierten log_text-Widget
    """
    if not hasattr(app, 'log_text') or app.log_text is None:
        return
        
    # Tags für verschiedene Log-Level erstellen
    app.log_text.config(state=tk.NORMAL)
    
    # Nur erstellen, wenn noch nicht vorhanden
    if not hasattr(app.log_text, 'tags_created'):
        app.log_text.tag_configure("error", foreground=app.colors["error"])
        app.log_text.tag_configure("warning", foreground=app.colors["warning"])
        app.log_text.tag_configure("success", foreground=app.colors["success"])
        app.log_text.tag_configure("info", foreground=app.colors["text_primary"])
        app.log_text.tags_created = True
    
    app.log_text.config(state=tk.DISABLED)

def log_message(app, message, level="info"):
    """
    Fügt eine formatierte Nachricht zum Protokollbereich der GUI hinzu.
    
    Die Nachricht wird mit Zeitstempel, Präfix je nach Level und entsprechender
    Farbformatierung dargestellt. Zusätzlich wird die Nachricht an den Standard-Logger
    weitergeleitet und in der Aktivitätsanzeige des Dashboards aktualisiert.
    
    Args:
        app: Die GuiApp-Instanz mit dem konfigurierten log_text-Widget
        message (str): Die zu protokollierende Nachricht
        level (str): Log-Level ("info", "warning", "error", "success")
    """
    if not hasattr(app, 'log_text') or app.log_text is None:
        return
        
    # Aktuelle Zeit
    timestamp = datetime.now().strftime("%H:%M:%S")
    
    # Farbe und Präfix je nach Level
    tag = None
    if level == "error":
        tag = "error"
        prefix = "❌ FEHLER"
        log_level = logging.ERROR
    elif level == "warning":
        tag = "warning"
        prefix = "⚠️ WARNUNG"
        log_level = logging.WARNING
    elif level == "success":
        tag = "success"
        prefix = "✅ ERFOLG"
        log_level = logging.INFO
    else:
        tag = "info"
        prefix = "ℹ️ INFO"
        log_level = logging.INFO
    
    # Log an Logger-Objekt senden
    if hasattr(app, 'logger'):
        app.logger.log(log_level, message)
    
    # Log-Eintrag formatieren
    log_entry = f"[{timestamp}] {prefix}: {message}\n"
    
    # Text-Widget aktualisieren
    app.log_text.config(state=tk.NORMAL)
    
    # Tags erstellen, falls noch nicht vorhanden
    if not hasattr(app.log_text, 'tags_created'):
        setup_logging(app)
    
    # Text einfügen
    app.log_text.insert(tk.END, log_entry, tag)
    
    # Zum Ende scrollen
    app.log_text.see(tk.END)
    
    # Auf read-only setzen
    app.log_text.config(state=tk.DISABLED)
    
    # Letzte Aktivität aktualisieren
    update_activity_display(app, message)

def update_activity_display(app, message):
    """
    Aktualisiert die Aktivitätsanzeige im Dashboard mit der neuesten Nachricht.
    
    Zeigt die letzte Aktivität prominent im Dashboard an, um einen schnellen
    Überblick über den aktuellen Status der Anwendung zu bieten, ohne dass
    der Benutzer das vollständige Protokoll durchsuchen muss.
    
    Args:
        app: Die GuiApp-Instanz mit konfiguriertem Dashboard
        message (str): Die anzuzeigende Nachricht
    """
    if hasattr(app, 'dashboard_elements') and "activity_list" in app.dashboard_elements:
        activity_list = app.dashboard_elements["activity_list"]
        activity_list.config(state=tk.NORMAL)
        activity_list.delete(1.0, tk.END)
        activity_list.insert(tk.END, message)
        activity_list.config(state=tk.DISABLED)

def export_log(app, filepath=None):
    """
    Exportiert das aktuelle Protokoll in eine Textdatei.
    
    Ermöglicht es dem Benutzer, den kompletten Protokollinhalt für
    Dokumentations- oder Fehlerbehebungszwecke zu speichern.
    
    Args:
        app: Die GuiApp-Instanz mit dem konfigurierten log_text-Widget
        filepath (str, optional): Zieldatei-Pfad. Falls None, wird ein Dialog geöffnet.
        
    Returns:
        bool: True bei erfolgreicher Durchführung, False bei Fehler
    """
    if not hasattr(app, 'log_text') or app.log_text is None:
        return False
    
    try:
        # Wenn kein Pfad angegeben wurde, einen Dialog öffnen
        if filepath is None:
            from tkinter import filedialog
            filepath = filedialog.asksaveasfilename(
                defaultextension=".log",
                filetypes=[("Log-Dateien", "*.log"), ("Textdateien", "*.txt"), ("Alle Dateien", "*.*")]
            )
            
            if not filepath:  # Benutzer hat abgebrochen
                return False
        
        # Protokollinhalt holen
        app.log_text.config(state=tk.NORMAL)
        log_content = app.log_text.get(1.0, tk.END)
        app.log_text.config(state=tk.DISABLED)
        
        # In Datei schreiben
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(log_content)
        
        log_message(app, f"Protokoll exportiert nach: {filepath}", level="success")
        return True
        
    except Exception as e:
        log_message(app, f"Fehler beim Exportieren des Protokolls: {str(e)}", level="error")
        return False

# ================================================================================
# Datei: maehrdocs\gui\gui_notification_handlers.py
# ================================================================================

"""
Benachrichtigungshandler für MaehrDocs
Enthält Funktionen zur Verarbeitung von speziellen Benachrichtigungen
"""

def handle_duplicate_from_log(app, log_line):
    """
    Verarbeitet Duplikatbenachrichtigungen aus der Protokollausgabe
    
    Args:
        app: Instanz der GuiApp
        log_line: Log-Zeile mit Duplikatinformationen
    """
    try:
        # Aus dem Log-Text die relevanten Informationen extrahieren
        # Format könnte sein: "DUPLICATE DETECTED: [Original: file1.pdf] [Duplicate: file2.pdf] [Similarity: 0.92]"
        if "[Original:" in log_line and "[Duplicate:" in log_line and "[Similarity:" in log_line:
            # Original-Datei extrahieren
            original_start = log_line.find("[Original:") + 10
            original_end = log_line.find("]", original_start)
            original_file = log_line[original_start:original_end].strip()
            
            # Duplikat-Datei extrahieren
            duplicate_start = log_line.find("[Duplicate:") + 11
            duplicate_end = log_line.find("]", duplicate_start)
            duplicate_file = log_line[duplicate_start:duplicate_end].strip()
            
            # Ähnlichkeitswert extrahieren
            similarity_start = log_line.find("[Similarity:") + 12
            similarity_end = log_line.find("]", similarity_start)
            similarity_str = log_line[similarity_start:similarity_end].strip()
            similarity_score = float(similarity_str)
            
            # Popup anzeigen, wenn aktiviert
            if app.config.get("gui", {}).get("show_duplicate_popup", True):
                from .gui_document_viewer import show_duplicate_alert
                show_duplicate_alert(app, original_file, duplicate_file, similarity_score)
    except Exception as e:
        app.messaging.notify(
            f"Fehler bei der Verarbeitung der Duplikatbenachrichtigung: {str(e)}", 
            level="error"
        )

# ================================================================================
# Datei: maehrdocs\gui\gui_notifications.py
# ================================================================================

# gui_alerts.py
"""
Dieses Modul dient als zentrale Schnittstelle für alle Benachrichtigungen und Dialoge
in der MaehrDocs Anwendung. Es stellt verschiedene Funktionen zur Verfügung,
um Benachrichtigungen und Dialoge anzuzeigen.

Die eigentliche Implementierung dieser Funktionen wurde in separate Module ausgelagert:
- notifications.py: Benachrichtigungsfenster
- animations.py: Animationseffekte
- toast.py: Toast-Nachrichten
- dialog.py: Standard-Dialoge
"""

# Importe aus den spezialisierten Modulen
from .gui_notifications import show_notification
from .gui_animations import animate_window, fade_in, fade_out
from .gui_toast import show_toast
from .gui_dialog import (
    show_confirm_dialog,
    show_info_dialog, 
    show_error_dialog, 
    show_warning_dialog
)

# Benachrichtigungsfunktionen
def show_success(app, message, timeout=5000):
    """
    Zeigt eine Erfolgs-Benachrichtigung an
    
    Args:
        app: Die Hauptanwendung
        message: Die anzuzeigende Nachricht
        timeout: Zeit in ms, nach der die Benachrichtigung automatisch verschwindet
        
    Returns:
        Das erstellte Benachrichtigungsfenster
    """
    return show_notification(app, message, level="success", timeout=timeout)

def show_info(app, message, timeout=5000):
    """
    Zeigt eine Info-Benachrichtigung an
    
    Args:
        app: Die Hauptanwendung
        message: Die anzuzeigende Nachricht
        timeout: Zeit in ms, nach der die Benachrichtigung automatisch verschwindet
        
    Returns:
        Das erstellte Benachrichtigungsfenster
    """
    return show_notification(app, message, level="info", timeout=timeout)

def show_warning(app, message, timeout=5000):
    """
    Zeigt eine Warnungs-Benachrichtigung an
    
    Args:
        app: Die Hauptanwendung
        message: Die anzuzeigende Nachricht
        timeout: Zeit in ms, nach der die Benachrichtigung automatisch verschwindet
        
    Returns:
        Das erstellte Benachrichtigungsfenster
    """
    return show_notification(app, message, level="warning", timeout=timeout)

def show_error(app, message, timeout=5000):
    """
    Zeigt eine Fehler-Benachrichtigung an
    
    Args:
        app: Die Hauptanwendung
        message: Die anzuzeigende Nachricht
        timeout: Zeit in ms, nach der die Benachrichtigung automatisch verschwindet
        
    Returns:
        Das erstellte Benachrichtigungsfenster
    """
    return show_notification(app, message, level="error", timeout=timeout)

# Toast-Funktionen
def show_success_toast(app, message, duration=3000):
    """
    Zeigt einen Erfolgs-Toast an
    
    Args:
        app: Die Hauptanwendung
        message: Die anzuzeigende Nachricht
        duration: Dauer in ms, wie lange der Toast angezeigt wird
        
    Returns:
        Das erstellte Toast-Fenster
    """
    return show_toast(app, message, duration)

# Dialog-Wrapper-Funktionen
def confirm(app, title, message):
    """
    Zeigt einen Bestätigungsdialog an und gibt das Ergebnis zurück
    
    Args:
        app: Die Hauptanwendung
        title: Der Titel des Dialogs
        message: Die Nachricht des Dialogs
        
    Returns:
        bool: True wenn der Benutzer bestätigt hat, sonst False
    """
    return show_confirm_dialog(app, title, message)

def info(app, title, message):
    """
    Zeigt einen Informationsdialog an
    
    Args:
        app: Die Hauptanwendung
        title: Der Titel des Dialogs
        message: Die Nachricht des Dialogs
    """
    show_info_dialog(app, title, message)
    
def error(app, title, message):
    """
    Zeigt einen Fehlerdialog an
    
    Args:
        app: Die Hauptanwendung
        title: Der Titel des Dialogs
        message: Die Nachricht des Dialogs
    """
    show_error_dialog(app, title, message)
    
def warning(app, title, message):
    """
    Zeigt einen Warnungsdialog an
    
    Args:
        app: Die Hauptanwendung
        title: Der Titel des Dialogs
        message: Die Nachricht des Dialogs
    """
    show_warning_dialog(app, title, message)

# ================================================================================
# Datei: maehrdocs\gui\gui_settings.py
# ================================================================================

# gui_settings.py
"""
Einstellungsmodul für MaehrDocs (Kompatibilitätsschicht)
Dieses Modul importiert die Funktionen aus den neuen aufgeteilten Modulen
für die Abwärtskompatibilität.
"""

# Importiere Funktionen aus dem speziellen Komponententab
from .gui_settings_components import (
    create_settings_section,
    create_settings_tab,
    collect_settings_from_widget,
    search_and_update_field
)

# Importiere Funktionen aus dem Dialogmodul
from .gui_settings_dialog import (
    open_settings,
    create_general_tab,
    create_openai_tab,
    create_document_tab,
    create_notifications_tab,
    save_settings,
    browse_folder
)

# Re-Exportiere alle Funktionen für Abwärtskompatibilität
__all__ = [
    'create_settings_section',
    'create_settings_tab',
    'collect_settings_from_widget',
    'search_and_update_field',
    'open_settings',
    'create_general_tab',
    'create_openai_tab',
    'create_document_tab',
    'create_notifications_tab',
    'save_settings',
    'browse_folder'
]

# ================================================================================
# Datei: maehrdocs\gui\gui_settings_components.py
# ================================================================================

# gui_settings_components.py
"""
Einstellungskomponenten für MaehrDocs GUI
Enthält Funktionen zum Erstellen von Einstellungssektionen und -tabs
"""

import tkinter as tk
from tkinter import ttk
from .gui_forms import create_form_field

def create_settings_section(app, parent, title, fields):
    """
    Erstellt einen Abschnitt in den Einstellungen
    
    Args:
        app: Instanz der GuiApp
        parent: Parent-Widget
        title: Titel des Abschnitts
        fields: Liste der Felder
        
    Returns:
        tk.Frame: Der erstellte Abschnitt
    """
    section_frame = tk.Frame(
        parent, 
        bg=app.colors["card_background"], 
        padx=15, 
        pady=15
    )
    section_frame.pack(fill=tk.X, pady=10)
    
    section_header = tk.Label(
        section_frame, 
        text=title, 
        font=app.fonts["subheader"],
        fg=app.colors["text_primary"],
        bg=app.colors["card_background"]
    )
    section_header.pack(anchor=tk.W, pady=(0, 10))
    
    # Felder erstellen
    for field in fields:
        field_frame = create_form_field(app, section_frame, field)
        field_frame.pack(fill=tk.X, pady=5)
    
    return section_frame

def create_settings_tab(app, notebook, title, sections):
    """
    Erstellt einen Tab in den Einstellungen
    
    Args:
        app: Instanz der GuiApp
        notebook: ttk.Notebook-Widget
        title: Titel des Tabs
        sections: Liste der Abschnitte (dict mit title und fields)
        
    Returns:
        tk.Frame: Der erstellte Tab-Frame
    """
    tab_frame = tk.Frame(notebook, bg=app.colors["background_medium"])
    notebook.add(tab_frame, text=title)
    
    # Scrollable Bereich erstellen
    canvas = tk.Canvas(
        tab_frame, 
        bg=app.colors["background_medium"],
        highlightthickness=0
    )
    scrollbar = tk.Scrollbar(tab_frame, orient=tk.VERTICAL, command=canvas.yview)
    content_frame = tk.Frame(canvas, bg=app.colors["background_medium"])
    
    content_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )
    
    canvas.create_window((0, 0), window=content_frame, anchor=tk.NW)
    canvas.configure(yscrollcommand=scrollbar.set)
    
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    
    # Abschnitte erstellen
    for section in sections:
        create_settings_section(
            app, 
            content_frame, 
            section["title"], 
            section["fields"]
        )
    
    return tab_frame

def collect_settings_from_widget(app, widget):
    """
    Sammelt rekursiv alle Einstellungen aus Widgets
    
    Args:
        app: Instanz der GuiApp
        widget: Das zu durchsuchende Widget
    """
    # Prüfen, ob das Widget ein Feld mit einem Wert ist
    if hasattr(widget, 'field_key') and hasattr(widget, 'field_type'):
        # Wert entsprechend dem Feldtyp extrahieren
        value = None
        if widget.field_type == 'text' or widget.field_type == 'folder':
            value = widget.get()
        elif widget.field_type == 'dropdown':
            value = widget.get()
        elif widget.field_type == 'spinbox':
            try:
                value = int(widget.get())
            except ValueError:
                try:
                    value = float(widget.get())
                except ValueError:
                    value = widget.get()
        elif widget.field_type == 'scale':
            value = widget.get()
        elif widget.field_type == 'checkbox':
            value = widget.var.get()
            
        # Wert in der Konfiguration speichern
        keys = widget.field_key.split('.')
        current = app.config
        for i, key in enumerate(keys):
            if i == len(keys) - 1:
                current[key] = value
            else:
                if key not in current:
                    current[key] = {}
                current = current[key]
    
    # Rekursiv für alle Kind-Widgets aufrufen
    if hasattr(widget, 'winfo_children'):
        for child in widget.winfo_children():
            collect_settings_from_widget(app, child)

def search_and_update_field(widget, field_key, value):
    """
    Durchsucht ein Widget nach einem Feld und aktualisiert dessen Wert
    
    Args:
        widget: Das zu durchsuchende Widget
        field_key: Schlüssel des gesuchten Feldes
        value: Neuer Wert für das Feld
    """
    # Prüfen, ob das Widget das gesuchte Feld ist
    if hasattr(widget, 'field_key') and widget.field_key == field_key:
        widget.delete(0, tk.END)
        widget.insert(0, value)
        return True
    
    # Rekursiv für alle Kind-Widgets aufrufen
    if hasattr(widget, 'winfo_children'):
        for child in widget.winfo_children():
            if search_and_update_field(child, field_key, value):
                return True
    
    return False

# ================================================================================
# Datei: maehrdocs\gui\gui_settings_dialog.py
# ================================================================================

# gui_settings_dialog.py
"""
Einstellungsdialog für MaehrDocs
Erstellt ein Fenster zur Konfiguration der Anwendung
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import yaml
from .gui_buttons import create_button
from .gui_settings_components import create_settings_section, collect_settings_from_widget, search_and_update_field

def open_settings(app):
    """
    Öffnet das Einstellungsfenster
    
    Args:
        app: Instanz der GuiApp
    """
    settings_window = tk.Toplevel(app.root)
    settings_window.title("MaehrDocs - Einstellungen")
    settings_window.geometry("800x600")
    settings_window.configure(bg=app.colors["background_dark"])
    
    # Einstellungen aus der Konfigurationsdatei laden
    settings_frame = tk.Frame(settings_window, bg=app.colors["background_medium"], padx=20, pady=20)
    settings_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
    
    # Überschrift
    header = tk.Label(
        settings_frame, 
        text="Einstellungen", 
        font=app.fonts["header"],
        fg=app.colors["text_primary"],
        bg=app.colors["background_medium"]
    )
    header.pack(anchor=tk.W, pady=(0, 20))
    
    # Notebook für Einstellungskategorien
    notebook = ttk.Notebook(settings_frame)
    
    # Einstellungs-Tabs erstellen
    create_general_tab(app, notebook)
    create_openai_tab(app, notebook)
    create_document_tab(app, notebook)
    create_notifications_tab(app, notebook)
    
    notebook.pack(fill=tk.BOTH, expand=True)
    
    # Buttons
    buttons_frame = tk.Frame(settings_frame, bg=app.colors["background_medium"], pady=15)
    buttons_frame.pack(fill=tk.X)
    
    save_btn = create_button(
        app,
        buttons_frame, 
        "Speichern", 
        lambda: save_settings(app, settings_window)
    )
    save_btn.pack(side=tk.RIGHT, padx=5)
    
    cancel_btn = create_button(
        app,
        buttons_frame, 
        "Abbrechen", 
        settings_window.destroy
    )
    cancel_btn.pack(side=tk.RIGHT, padx=5)

def create_general_tab(app, notebook):
    """
    Erstellt den Tab für allgemeine Einstellungen
    
    Args:
        app: Instanz der GuiApp
        notebook: ttk.Notebook-Widget
    """
    general_frame = tk.Frame(notebook, bg=app.colors["background_medium"])
    notebook.add(general_frame, text="Allgemein")
    
    # Pfade
    paths_section = create_settings_section(app, general_frame, "Verzeichnisse", [
        {"label": "Eingangsordner", "key": "paths.input_dir", "type": "folder"},
        {"label": "Ausgabeordner", "key": "paths.output_dir", "type": "folder"},
        {"label": "Fehlerordner", "key": "paths.trash_dir", "type": "folder"}
    ])

def create_openai_tab(app, notebook):
    """
    Erstellt den Tab für OpenAI-Einstellungen
    
    Args:
        app: Instanz der GuiApp
        notebook: ttk.Notebook-Widget
    """
    openai_frame = tk.Frame(notebook, bg=app.colors["background_medium"])
    notebook.add(openai_frame, text="OpenAI")
    
    openai_section = create_settings_section(app, openai_frame, "API-Einstellungen", [
        {"label": "Modell", "key": "openai.model", "type": "dropdown", 
         "options": ["gpt-3.5-turbo", "gpt-4o", "gpt-4-1106-preview"]},
        {"label": "Temperatur", "key": "openai.temperature", "type": "scale", 
         "from": 0, "to": 1, "resolution": 0.1},
        {"label": "Max. Wiederholungsversuche", "key": "openai.max_retries", 
         "type": "spinbox", "from": 1, "to": 10}
    ])

def create_document_tab(app, notebook):
    """
    Erstellt den Tab für Dokumentverarbeitungseinstellungen
    
    Args:
        app: Instanz der GuiApp
        notebook: ttk.Notebook-Widget
    """
    docs_frame = tk.Frame(notebook, bg=app.colors["background_medium"])
    notebook.add(docs_frame, text="Dokumentverarbeitung")
    
    docs_section = create_settings_section(app, docs_frame, "Verarbeitungsoptionen", [
        {"label": "Max. Dateigröße (MB)", "key": "document_processing.max_file_size_mb", 
         "type": "spinbox", "from": 1, "to": 50},
        {"label": "Ähnlichkeitsschwelle für Duplikate", "key": "document_processing.similarity_threshold", 
         "type": "scale", "from": 0.5, "to": 1.0, "resolution": 0.05}
    ])
    
    # Dokumenttypen
    doctypes_frame = tk.Frame(docs_frame, bg=app.colors["card_background"], padx=15, pady=15)
    doctypes_frame.pack(fill=tk.X, pady=10)
    
    doctypes_header = tk.Label(
        doctypes_frame, 
        text="Gültige Dokumenttypen", 
        font=app.fonts["subheader"],
        fg=app.colors["text_primary"],
        bg=app.colors["card_background"]
    )
    doctypes_header.pack(anchor=tk.W, pady=(0, 10))
    
    # Textfeld für Dokumenttypen
    doctypes_text = tk.Text(
        doctypes_frame, 
        height=5, 
        bg=app.colors["background_medium"],
        fg=app.colors["text_primary"],
        font=app.fonts["normal"]
    )
    doctypes_text.pack(fill=tk.X)
    
    # Aktuelle Dokumenttypen laden
    try:
        doctypes = app.config.get("document_processing", {}).get("valid_doc_types", [])
        doctypes_text.insert(tk.END, "\n".join(doctypes))
    except:
        app.log("Fehler beim Laden der Dokumenttypen", level="error")
    
    # Speichern der Referenz auf Dokumenttypen
    app.doctypes_text = doctypes_text

def create_notifications_tab(app, notebook):
    """
    Erstellt den Tab für Benachrichtigungseinstellungen
    
    Args:
        app: Instanz der GuiApp
        notebook: ttk.Notebook-Widget
    """
    notifications_frame = tk.Frame(notebook, bg=app.colors["background_medium"])
    notebook.add(notifications_frame, text="Benachrichtigungen")
    
    notifications_section = create_settings_section(app, notifications_frame, "Benachrichtigungsoptionen", [
        {"label": "Popup bei Duplikaten anzeigen", "key": "gui.show_duplicate_popup", "type": "checkbox"},
        {"label": "Benachrichtigung bei Verarbeitungsabschluss", "key": "gui.notify_on_completion", "type": "checkbox"},
        {"label": "Soundeffekte aktivieren", "key": "gui.enable_sounds", "type": "checkbox"}
    ])

def save_settings(app, settings_window):
    """
    Speichert die Einstellungen aus dem Einstellungsfenster
    
    Args:
        app: Instanz der GuiApp
        settings_window: Das Einstellungsfenster
    """
    try:
        # Alle Eingabefelder im Fenster finden
        collect_settings_from_widget(app, settings_window)
        
        # Dokumenttypen speichern
        if hasattr(app, 'doctypes_text'):
            doctypes = app.doctypes_text.get(1.0, tk.END).strip().split('\n')
            if 'document_processing' not in app.config:
                app.config['document_processing'] = {}
            app.config['document_processing']['valid_doc_types'] = doctypes
        
        # Konfiguration speichern
        app.config_manager.save_config(app.config)
        
        # Dashboard aktualisieren
        app.update_dashboard()
        
        # Fenster schließen
        settings_window.destroy()
        
        # Bestätigung anzeigen
        messagebox.showinfo("Einstellungen", "Die Einstellungen wurden erfolgreich gespeichert.")
        
    except Exception as e:
        messagebox.showerror("Fehler", f"Fehler beim Speichern der Einstellungen: {str(e)}")
        app.log(f"Fehler beim Speichern der Einstellungen: {str(e)}", level="error")

def browse_folder(app, field_key):
    """
    Öffnet einen Dialog zur Ordnerauswahl für ein Einstellungsfeld
    
    Args:
        app: Instanz der GuiApp
        field_key: Schlüssel des betroffenen Feldes
    """
    folder = filedialog.askdirectory(title="Ordner auswählen")
    if folder:
        # Für alle Top-Level-Fenster durchsuchen
        for widget in app.root.winfo_children():
            if isinstance(widget, tk.Toplevel):
                # Für alle Widgets im Fenster
                for child in widget.winfo_children():
                    # Rekursiv nach dem Feld suchen
                    if hasattr(child, 'winfo_children'):
                        search_and_update_field(child, field_key, folder)

# ================================================================================
# Datei: maehrdocs\gui\gui_toast.py
# ================================================================================

"""
Toast-Benachrichtigungen für MaehrDocs
Implementiert temporäre, nicht-modale Benachrichtigungen, die am unteren
Bildschirmrand erscheinen und nach einer festgelegten Zeit automatisch verschwinden.

Diese Art von Benachrichtigungen werden häufig für subtile Hinweise und 
Rückmeldungen verwendet, ohne den Arbeitsfluss des Benutzers zu unterbrechen.
"""

import tkinter as tk
from maehrdocs.gui.gui_animations import fade_in, fade_out

class Toast:
    """
    Eine Toast-Benachrichtigung, die kurzzeitig am Bildschirmrand erscheint.
    
    Toast-Benachrichtigungen sind nicht-modale, temporäre Mitteilungen,
    die nicht mit Benutzereingaben interagieren und nach einer bestimmten
    Zeit automatisch verschwinden.
    """
    def __init__(self, app, message, duration=3000, position="bottom"):
        """
        Erstellt eine neue Toast-Benachrichtigung.
        
        Args:
            app: Die Hauptanwendung (GuiApp-Instanz)
            message (str): Die anzuzeigende Nachricht
            duration (int): Dauer in Millisekunden, wie lange der Toast angezeigt wird
            position (str): Position des Toasts: "bottom", "top" oder "center"
        """
        self.app = app
        self.message = message
        self.duration = duration
        self.position = position
        self.window = None
        
    def show(self):
        """
        Zeigt den Toast an.
        
        Erzeugt ein neues Fenster, positioniert es entsprechend der 
        Konfiguration, führt die Fade-In-Animation aus und startet einen
        Timer für das automatische Ausblenden.
        
        Returns:
            Das erzeugte Toast-Fenster-Objekt
        """
        # Fenster erstellen
        self.window = tk.Toplevel(self.app)
        self.window.overrideredirect(True)
        
        # Styling
        self.window.configure(bg=self.app.colors["card_background"])
        
        # Label für die Nachricht
        label = tk.Label(
            self.window,
            text=self.message,
            font=self.app.fonts["normal"],
            bg=self.app.colors["card_background"],
            fg=self.app.colors["text_primary"],
            padx=20,
            pady=10
        )
        label.pack()
        
        # Größe des Fensters an den Inhalt anpassen
        self.window.update_idletasks()
        width = label.winfo_width() + 40
        height = label.winfo_height() + 20
        
        # Position berechnen
        screen_width = self.app.winfo_screenwidth()
        screen_height = self.app.winfo_screenheight()
        
        if self.position == "bottom":
            x = (screen_width - width) // 2
            y = screen_height - height - 40
        elif self.position == "top":
            x = (screen_width - width) // 2
            y = 40
        else:  # center
            x = (screen_width - width) // 2
            y = (screen_height - height) // 2
            
        self.window.geometry(f"{width}x{height}+{x}+{y}")
        
        # Animation starten
        fade_in(self.window)
        
        # Timer zum Ausblenden
        self.window.after(self.duration, lambda: fade_out(self.window))
        
        return self.window

def show_toast(app, message, duration=3000, position="bottom"):
    """
    Hilfsfunktion zum einfachen Anzeigen eines Toasts.
    
    Erstellt und zeigt eine Toast-Benachrichtigung an, ohne dass 
    der Aufrufer ein Toast-Objekt erstellen muss.
    
    Args:
        app: Die Hauptanwendung (GuiApp-Instanz)
        message (str): Die anzuzeigende Nachricht
        duration (int): Dauer in Millisekunden, wie lange der Toast angezeigt wird
        position (str): Position des Toasts: "bottom", "top" oder "center"
        
    Returns:
        Das erzeugte Toast-Fenster-Objekt
    """
    toast = Toast(app, message, duration, position)
    return toast.show()

# ================================================================================
# Datei: maehrdocs\gui\gui_utils.py
# ================================================================================

# Datei: maehrdocs/gui/gui_utils.py

"""
Hilfsfunktionen für MaehrDocs GUI
Enthält verschiedene Hilfsfunktionen für die GUI mit verbesserter Fehlerbehandlung
"""

import os
import sys
import subprocess
import tkinter as tk
from tkinter import messagebox
from datetime import datetime

from .gui_actions import process_documents
from .gui_logger import log_message

def update_dashboard(app):
    """
    Aktualisiert die Anzeigen im Dashboard
    
    Args:
        app: Instanz der GuiApp
    """
    # Verwenden des ErrorHandlers für diese Operation
    with app.error_handler.safe_operation(context="Dashboard-Aktualisierung", level="warning"):
        # Inbox
        inbox_path = app.config["paths"]["input_dir"]
        inbox_count = len([f for f in os.listdir(inbox_path) if f.lower().endswith('.pdf')])
        app.dashboard_elements["inbox_card"].count_value.config(text=str(inbox_count))
        app.dashboard_elements["inbox_card"].path_value.config(text=inbox_path)
        
        # Processed
        processed_path = app.config["paths"]["output_dir"]
        processed_count = len([f for f in os.listdir(processed_path) if f.lower().endswith('.pdf')])
        app.dashboard_elements["processed_card"].count_value.config(text=str(processed_count))
        app.dashboard_elements["processed_card"].path_value.config(text=processed_path)
        
        # Trash
        trash_path = app.config["paths"]["trash_dir"]
        trash_count = len([f for f in os.listdir(trash_path) if f.lower().endswith('.pdf')])
        app.dashboard_elements["trash_card"].count_value.config(text=str(trash_count))
        app.dashboard_elements["trash_card"].path_value.config(text=trash_path)
        
        # Letzte Verarbeitungszeit aktualisieren
        app.messaging.update_status(f"Zuletzt aktualisiert: {datetime.now().strftime('%H:%M:%S')}")
        
        # Aktivitätsliste aktualisieren, wenn vorhanden
        if "activity_list" in app.dashboard_elements:
            app.dashboard_elements["activity_list"].config(state=tk.NORMAL)
            app.dashboard_elements["activity_list"].delete(1.0, tk.END)
            app.dashboard_elements["activity_list"].insert(tk.END, "Dashboard aktualisiert.")
            app.dashboard_elements["activity_list"].config(state=tk.DISABLED)

def open_folder_in_explorer(app, folder_suffix):
    """
    Öffnet den angegebenen Ordner im Datei-Explorer
    
    Args:
        app: Instanz der GuiApp
        folder_suffix: Ordnersuffix (für die Identifikation)
    """
    # Verwenden der try_except-Methode des ErrorHandlers
    def _open_folder():
        if folder_suffix == "01_InboxDocs":
            folder_path = app.config["paths"]["input_dir"]
        elif folder_suffix == "02_FinalDocs":
            folder_path = app.config["paths"]["output_dir"]
        elif folder_suffix == "03_TrashDocs":
            folder_path = app.config["paths"]["trash_dir"]
        else:
            return
            
        # Plattformabhängiges Öffnen des Ordners
        if os.name == 'nt':  # Windows
            os.startfile(folder_path)
        elif os.name == 'posix':  # macOS oder Linux
            subprocess.call(['open' if sys.platform == 'darwin' else 'xdg-open', folder_path])
    
    app.error_handler.try_except(
        _open_folder, 
        context="Öffnen des Ordners", 
        level="warning"
    )

def setup_drag_drop(app, drop_callback):
    """
    Richtet Drag & Drop-Funktionalität ein (erfordert tkinterdnd2)
    
    Args:
        app: Instanz der GuiApp
        drop_callback: Callback-Funktion für Drop-Events
    """
    # Prüfen, ob TkinterDnD2 importiert wurde
    if not hasattr(app.root, 'drop_target_register'):
        app.messaging.notify(
            "Drag & Drop nicht verfügbar. TkinterDnD2 ist nicht installiert.", 
            level="warning"
        )
        return
    
    # Register ist nur in tkinterdnd2 verfügbar
    def _setup_dnd():
        app.root.drop_target_register('DND_Files')
        app.root.dnd_bind('<<Drop>>', drop_callback)
    
    app.error_handler.try_except(
        _setup_dnd,
        context="Drag & Drop-Einrichtung",
        level="warning"
    )

def clear_log(app):
    """
    Löscht den Inhalt des Protokolls
    
    Args:
        app: Instanz der GuiApp
    """
    if not hasattr(app, 'log_text') or app.log_text is None:
        return
    
    def _clear_log():
        confirm = app.messaging.dialog(
            "Protokoll löschen", 
            "Möchten Sie das Protokoll wirklich löschen?", 
            type="confirm"
        )
        
        if confirm:
            app.log_text.config(state=tk.NORMAL)
            app.log_text.delete(1.0, tk.END)
            app.log_text.config(state=tk.DISABLED)
            app.messaging.notify("Protokoll gelöscht.")
    
    app.error_handler.try_except(
        _clear_log,
        context="Protokoll löschen",
        level="warning"
    )

def check_for_new_documents(app):
    """
    Prüft periodisch, ob neue Dokumente im Eingangsordner liegen
    
    Args:
        app: Instanz der GuiApp
    """
    # Mit ErrorHandler ausführen, aber keine visuelle Benachrichtigung bei Fehlern
    with app.error_handler.safe_operation(context="Prüfung auf neue Dokumente", level="warning"):
        # Eingangsordner prüfen
        inbox_dir = app.config["paths"]["input_dir"]
        
        if not os.path.exists(inbox_dir):
            # Ordner erstellen, falls er nicht existiert
            os.makedirs(inbox_dir)
            app.messaging.notify(f"Eingangsordner erstellt: {inbox_dir}", level="info")
            
        # Zähle PDF-Dateien
        pdf_count = len([f for f in os.listdir(inbox_dir) if f.lower().endswith('.pdf')])
        
        # Initialisieren, falls noch nicht geschehen
        if not hasattr(app, 'last_inbox_count'):
            app.last_inbox_count = pdf_count
        
        # Wenn neue Dokumente vorhanden sind, Nachricht anzeigen
        if pdf_count > app.last_inbox_count and pdf_count > 0:
            new_count = pdf_count - app.last_inbox_count
            app.messaging.notify(f"{new_count} neue Dokumente im Eingangsordner entdeckt.", level="info")
            
            # Benachrichtigung anzeigen wenn aktiviert
            if app.config.get("gui", {}).get("notify_on_new_documents", True):
                confirm = app.messaging.dialog(
                    "Neue Dokumente", 
                    f"{new_count} neue Dokumente im Eingangsordner entdeckt. Möchten Sie diese jetzt verarbeiten?",
                    type="confirm"
                )
                if confirm:
                    process_documents(app)
        
        # Zustand aktualisieren
        app.last_inbox_count = pdf_count
        
        # Dashboard aktualisieren, wenn sich etwas geändert hat
        if "inbox_card" in app.dashboard_elements:
            current_display = app.dashboard_elements["inbox_card"].count_value.cget("text")
            if pdf_count != int(current_display):
                update_dashboard(app)
    
    # In 5 Sekunden erneut prüfen
    app.root.after(5000, lambda: check_for_new_documents(app))

def create_directory_structure(app):
    """
    Erstellt die Verzeichnisstruktur für die Anwendung
    
    Args:
        app: Instanz der GuiApp
    """
    def _create_dirs():
        # Erstelle alle benötigten Verzeichnisse
        for key, path in app.config["paths"].items():
            if not os.path.exists(path):
                os.makedirs(path)
                app.messaging.notify(f"Verzeichnis erstellt: {path}", level="info")
    
    app.error_handler.try_except(
        _create_dirs,
        context="Verzeichnisstruktur erstellen",
        level="error"
    )

def get_file_count(directory, extension='.pdf'):
    """
    Zählt die Anzahl der Dateien mit der angegebenen Endung im Verzeichnis
    
    Args:
        directory: Verzeichnispfad
        extension: Dateiendung (Standardwert: '.pdf')
        
    Returns:
        int: Anzahl der Dateien
    """
    if not os.path.exists(directory):
        return 0
        
    return len([f for f in os.listdir(directory) if f.lower().endswith(extension.lower())])

def format_timestamp():
    """
    Erstellt einen formatierten Zeitstempel
    
    Returns:
        str: Formatierter Zeitstempel
    """
    return datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

def is_valid_path(path):
    """
    Prüft, ob der angegebene Pfad gültig ist
    
    Args:
        path: Zu prüfender Pfad
        
    Returns:
        bool: True, wenn der Pfad gültig ist
    """
    try:
        # Prüfe, ob der Pfad absolut ist
        if not os.path.isabs(path):
            return False
            
        # Prüfe, ob das Verzeichnis existiert
        if not os.path.exists(os.path.dirname(path)):
            return False
            
        # Prüfe, ob der Pfad ein Verzeichnis ist
        if os.path.isdir(path):
            # Prüfe, ob wir Schreibrechte haben
            return os.access(path, os.W_OK)
        
        # Wenn es eine Datei ist, prüfe, ob wir in das übergeordnete Verzeichnis schreiben können
        return os.access(os.path.dirname(path), os.W_OK)
    
    except Exception:
        return False

# ================================================================================
# Datei: maehrdocs\gui\messaging.py
# ================================================================================

"""
Zentrales Messaging-System für MaehrDocs
Bietet eine einheitliche Schnittstelle für alle Arten von Benachrichtigungen, 
Dialogen und Feedback-Mechanismen in der Anwendung.
"""

class MessagingSystem:
    """
    Zentrale Klasse für alle Benachrichtigungen und Dialoge.
    
    Vereinheitlicht die verschiedenen Benachrichtigungsmechanismen:
    - Protokolleinträge
    - Popup-Benachrichtigungen
    - Toast-Meldungen
    - Dialogfenster
    - Statusleistenaktualisierungen
    
    Bietet eine konsistente API, unabhängig von der zugrundeliegenden Implementierung.
    """
    
    def __init__(self, app):
        """
        Initialisiert das Messaging-System mit der GuiApp-Instanz.
        
        Args:
            app: Die GuiApp-Instanz
        """
        self.app = app
    
    def notify(self, message, level="info", visual=True, log=True, toast=False, timeout=5000):
        """
        Zeigt eine Benachrichtigung an und/oder protokolliert sie.
        
        Args:
            message (str): Die Nachricht
            level (str): Log-Level (info, warning, error, success)
            visual (bool): Ob eine visuelle Benachrichtigung angezeigt werden soll
            log (bool): Ob die Nachricht protokolliert werden soll
            toast (bool): Ob eine Toast-Benachrichtigung verwendet werden soll
            timeout (int): Timeout für visuelle Benachrichtigungen in ms
            
        Returns:
            Das erzeugte Benachrichtigungsfenster oder None
        """
        # Logging
        if log:
            from .gui_logger import log_message
            log_message(self.app, message, level)
        
        # Visuelle Benachrichtigung
        if visual:
            if toast:
                from .gui_toast import show_toast
                return show_toast(self.app, message, duration=timeout)
            else:
                from .gui_notifications import show_notification
                return show_notification(self.app, message, level=level, timeout=timeout)
        
        return None
    
    def dialog(self, title, message, type="info"):
        """
        Zeigt einen Dialogfenster an.
        
        Args:
            title (str): Titel des Dialogs
            message (str): Nachricht des Dialogs
            type (str): Typ des Dialogs (info, warning, error, confirm)
            
        Returns:
            Bei confirm: bool (Bestätigung)
            Bei anderen Typen: None
        """
        from .gui_dialog import (
            show_info_dialog, 
            show_warning_dialog, 
            show_error_dialog, 
            show_confirm_dialog
        )
        
        if type == "confirm":
            return show_confirm_dialog(self.app, title, message)
        elif type == "warning":
            show_warning_dialog(self.app, title, message)
        elif type == "error":
            show_error_dialog(self.app, title, message)
        else:  # info
            show_info_dialog(self.app, title, message)
        
        return None
    
    def update_status(self, message):
        """
        Aktualisiert die Statusleiste.
        
        Args:
            message (str): Statusnachricht
        """
        if hasattr(self.app, 'status_label') and self.app.status_label:
            self.app.status_label.config(text=message)

# ================================================================================
# Datei: maehrdocs\import_analyzer.py
# ================================================================================

"""
Import-Analysator für MaehrDocs

Hauptmodul des Import-Analysators, das die Analyse von Importabhängigkeiten 
und die Erkennung von zirkulären Imports koordiniert.
"""

import os
import sys
import logging
from pathlib import Path

from .import_analyzer_core import ImportAnalyzer
from .import_analyzer_parser import parse_imports
from .import_analyzer_graph import build_dependency_graph
from .import_analyzer_report import generate_report, suggest_solutions

logger = logging.getLogger(__name__)

def analyze_project(project_dir=None, output_file=None, visualize=False):
    """
    Analysiert ein Python-Projekt auf Importabhängigkeiten und zirkuläre Imports.
    
    Args:
        project_dir (str): Verzeichnis des zu analysierenden Projekts. 
                         Wenn None, wird das aktuelle Verzeichnis verwendet.
        output_file (str): Dateipfad für den Bericht. Wenn None, wird ein 
                          Standardname verwendet.
        visualize (bool): Gibt an, ob eine Visualisierung des Abhängigkeitsgraphen 
                        erstellt werden soll.
    
    Returns:
        tuple: (ImportAnalyzer-Instanz, Berichtspfad)
    """
    # Standard-Projektverzeichnis ist das aktuelle Verzeichnis
    if project_dir is None:
        project_dir = os.getcwd()
    
    # Standard-Ausgabedatei
    if output_file is None:
        output_file = os.path.join(project_dir, "import_analysis_report.md")
    
    logger.info(f"Analysiere Projekt in: {project_dir}")
    
    # Importanalyse durchführen
    analyzer = ImportAnalyzer(project_dir)
    analyzer.scan_project()
    
    # Abhängigkeitsgraph erstellen
    graph = build_dependency_graph(analyzer.modules, analyzer.imports)
    
    # Bericht generieren
    report_path = generate_report(analyzer, graph, output_file)
    
    # Lösungsvorschläge
    if analyzer.circular_imports:
        suggest_solutions(analyzer, graph, os.path.dirname(report_path))
    
    # Visualisierung erstellen, wenn gewünscht
    if visualize:
        try:
            from .import_analyzer_graph import visualize_graph
            visualize_graph(graph, os.path.join(os.path.dirname(report_path), "dependencies.png"))
        except ImportError:
            logger.warning("Visualisierungsabhängigkeiten fehlen. Installiere graphviz und pydot für Visualisierungen.")
    
    return analyzer, report_path

def main():
    """
    Hauptfunktion, wenn das Modul als Skript ausgeführt wird.
    """
    import argparse
    
    parser = argparse.ArgumentParser(description="MaehrDocs Import-Analysator")
    parser.add_argument("-d", "--directory", help="Zu analysierendes Verzeichnis")
    parser.add_argument("-o", "--output", help="Ausgabedatei für den Bericht")
    parser.add_argument("-v", "--visualize", action="store_true", help="Erstellt eine Visualisierung")
    parser.add_argument("--verbose", action="store_true", help="Ausführliche Ausgabe")
    
    args = parser.parse_args()
    
    # Logging konfigurieren
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(level=log_level, format='%(levelname)s: %(message)s')
    
    # Analyse durchführen
    analyzer, report_path = analyze_project(args.directory, args.output, args.visualize)
    
    print(f"\nAnalyse abgeschlossen.")
    print(f"Gefundene Module: {len(analyzer.modules)}")
    print(f"Gefundene Imports: {len(analyzer.imports)}")
    print(f"Zirkuläre Imports: {len(analyzer.circular_imports)}")
    print(f"Bericht erstellt: {report_path}")

if __name__ == "__main__":
    main()

# ================================================================================
# Datei: maehrdocs\import_analyzer_core.py
# ================================================================================

"""
Kernfunktionalität des Import-Analysators für MaehrDocs

Dieses Modul bildet das Herzstück des Import-Analysators und enthält die Hauptklasse 
ImportAnalyzer. Diese Klasse ist verantwortlich für das Scannen eines Python-Projekts, 
die Verarbeitung der einzelnen Python-Dateien, die Extraktion der Importabhängigkeiten 
und die Erkennung von zirkulären Importabhängigkeiten, die zu Laufzeitproblemen führen 
können.

Der Analyseprozess erfolgt in mehreren Stufen:
1. Rekursives Scannen des Projektverzeichnisses nach Python-Dateien
2. Extraktion der Modulnamen und Import-Anweisungen aus jeder Datei
3. Aufbau eines Abhängigkeitsnetzwerks zwischen den Modulen
4. Durchführung einer Tiefensuche zur Erkennung zirkulärer Abhängigkeiten
"""

import os
import logging
from pathlib import Path

from .import_analyzer_parser import parse_imports, extract_module_name

logger = logging.getLogger(__name__)

class ImportAnalyzer:
    """
    Hauptklasse für die Analyse von Importabhängigkeiten in Python-Projekten.
    
    Diese Klasse koordiniert den gesamten Analyseprozess, von der Erkennung 
    der Python-Dateien über die Extraktion der Imports bis zur Identifikation 
    von zirkulären Importabhängigkeiten.
    
    Attribute:
        project_dir (str): Absoluter Pfad zum Projektverzeichnis
        modules (dict): Zuordnung von Modulnamen zu ihren Dateipfaden {module_name: file_path}
        imports (dict): Zuordnung von Modulen zu ihren importierten Modulen {module_name: [imported_modules]}
        circular_imports (list): Liste identifizierter zirkulärer Importpfade
    """
    
    def __init__(self, project_dir):
        """
        Initialisiert den Import-Analyzer für ein spezifisches Projektverzeichnis.
        
        Args:
            project_dir (str): Verzeichnis des zu analysierenden Projekts (absoluter Pfad)
        """
        self.project_dir = os.path.abspath(project_dir)
        self.modules = {}  # {module_name: file_path}
        self.imports = {}  # {module_name: [imported_modules]}
        self.circular_imports = []  # Liste von zirkulären Importpfaden
    
    def scan_project(self):
        """
        Durchsucht das Projektverzeichnis nach Python-Dateien und analysiert deren Imports.
        
        Dieser Prozess umfasst:
        1. Rekursives Durchsuchen aller Verzeichnisse (außer __pycache__ und versteckten Ordnern)
        2. Verarbeiten jeder gefundenen Python-Datei (.py)
        3. Erkennung zirkulärer Importabhängigkeiten über eine Tiefensuche
        
        Die Ergebnisse werden in den Objektattributen modules, imports und circular_imports gespeichert.
        """
        logger.info(f"Scanne Projektverzeichnis: {self.project_dir}")
        
        # Python-Dateien im Projekt finden
        for root, dirs, files in os.walk(self.project_dir):
            # __pycache__ und andere versteckte Verzeichnisse überspringen
            dirs[:] = [d for d in dirs if not d.startswith('__') and not d.startswith('.')]
            
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    self._process_file(file_path)
        
        # Zirkuläre Imports erkennen
        self._detect_circular_imports()
        
        logger.info(f"Scan abgeschlossen. Gefunden: {len(self.modules)} Module, {len(self.circular_imports)} zirkuläre Imports.")
    
    def _process_file(self, file_path):
        """
        Verarbeitet eine einzelne Python-Datei und extrahiert Modulname und Imports.
        
        Diese Methode:
        1. Extrahiert den Modulnamen aus dem Dateipfad
        2. Liest und analysiert den Dateiinhalt, um alle Import-Anweisungen zu finden
        3. Speichert die Ergebnisse in den Objektattributen
        
        Args:
            file_path (str): Absoluter Pfad zur Python-Datei
        """
        rel_path = os.path.relpath(file_path, self.project_dir)
        logger.debug(f"Verarbeite Datei: {rel_path}")
        
        try:
            # Modulname aus Dateipfad extrahieren (z.B. 'package.module')
            module_name = extract_module_name(file_path, self.project_dir)
            
            # Datei parsen, um Imports zu extrahieren
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                import_statements = parse_imports(content)
            
            # Modulname und Imports speichern
            self.modules[module_name] = file_path
            self.imports[module_name] = import_statements
            
        except Exception as e:
            logger.error(f"Fehler beim Verarbeiten von {rel_path}: {str(e)}")
    
    def _detect_circular_imports(self):
        """
        Erkennt zirkuläre Importabhängigkeiten im Projekt.
        
        Diese Methode startet eine Tiefensuche (DFS) von jedem Modul aus,
        um zirkuläre Pfade im Abhängigkeitsgraphen zu finden. Jeder gefundene
        Zyklus wird in der circular_imports-Liste gespeichert.
        """
        logger.info("Suche nach zirkulären Imports...")
        
        # Für jedes Modul eine Tiefensuche starten
        for module_name in self.modules:
            # DFS starten, um zirkuläre Pfade zu finden
            visited = {}  # {module: path_to_module}
            self._dfs_for_cycles(module_name, visited, [])
    
    def _dfs_for_cycles(self, current, visited, path):
        """
        Führt eine Tiefensuche (DFS) durch, um zirkuläre Importpfade zu erkennen.
        
        Diese Methode implementiert einen angepassten DFS-Algorithmus zur Erkennung
        von Zyklen in einem gerichteten Graphen. Der Algorithmus funktioniert wie folgt:
        
        1. Wenn der aktuelle Knoten bereits im Pfad ist, wurde ein Zyklus gefunden
        2. Andernfalls wird der aktuelle Knoten zum Pfad hinzugefügt
        3. Für jeden Import des aktuellen Moduls wird die DFS rekursiv fortgesetzt
        4. Bei Rückkehr wird der aktuelle Knoten aus dem Pfad entfernt (Backtracking)
        
        Gefundene Zyklen werden nur einmal gespeichert, auch wenn sie mehrfach entdeckt werden.
        
        Args:
            current (str): Name des aktuellen Moduls
            visited (dict): Dictionary der bereits besuchten Module
            path (list): Aktueller Pfad in der DFS (Liste von Modulnamen)
        """
        # Wenn wir dieses Modul schon besucht haben, haben wir einen Kreis gefunden
        if current in visited:
            # Kreis extrahieren, beginnend vom ersten Vorkommen des aktuellen Moduls im Pfad
            cycle_path = path[path.index(current):]
            cycle_path.append(current)  # Kreis schließen, indem wir das aktuelle Modul anhängen
            
            # Generiere einen eindeutigen Schlüssel für diesen Zyklus
            cycle_key = '->'.join(cycle_path)
            
            # Nur eindeutige Kreise speichern
            if cycle_key not in [c['key'] for c in self.circular_imports]:
                self.circular_imports.append({
                    'key': cycle_key,  # Eindeutiger Identifikationsstring
                    'path': cycle_path.copy()  # Kopie des Pfads (Liste von Modulnamen)
                })
            return
        
        # Dieses Modul als besucht markieren
        visited[current] = True
        path.append(current)
        
        # Alle importierten Module durchgehen
        if current in self.imports:
            for imported_module in self.imports[current]:
                # Nur Module im Projekt verfolgen (externe Module ignorieren)
                if imported_module in self.modules:
                    # Wichtig: visited und path müssen kopiert werden, um Seiteneffekte zu vermeiden
                    self._dfs_for_cycles(imported_module, visited.copy(), path.copy())
        
        # Backtracking - Modul aus Pfad und besuchten Modulen entfernen
        path.pop()
        del visited[current]
    
    def get_module_details(self, module_name):
        """
        Gibt detaillierte Informationen zu einem bestimmten Modul zurück.
        
        Diese Methode sammelt umfassende Informationen über ein Modul:
        - Modulname und Dateipfad
        - Liste der von diesem Modul importierten Module
        - Liste der Module, die dieses Modul importieren (umgekehrte Abhängigkeiten)
        
        Args:
            module_name (str): Name des Moduls
            
        Returns:
            dict: Dictionary mit Moduldetails oder None, wenn das Modul nicht gefunden wurde
        """
        if module_name not in self.modules:
            return None
        
        # Module finden, die das angegebene Modul importieren
        imported_by = []
        for mod, imports in self.imports.items():
            if module_name in imports:
                imported_by.append(mod)
        
        return {
            'name': module_name,
            'file_path': self.modules[module_name],
            'imports': self.imports.get(module_name, []),
            'imported_by': imported_by
        }

# ================================================================================
# Datei: maehrdocs\import_analyzer_graph.py
# ================================================================================

"""
Graph-Funktionalität des Import-Analysators für MaehrDocs

Dieses Modul bietet eine Graph-basierte Darstellung von Modulabhängigkeiten
und Funktionen zur Analyse und Visualisierung dieser Abhängigkeitsstrukturen.
Es implementiert eine DependencyGraph-Klasse, die einen gerichteten Graphen
repräsentiert, sowie Hilfsfunktionen zum Aufbau und zur Visualisierung des Graphen.

Die Graph-Repräsentation ermöglicht:
- Einfache Navigation durch Abhängigkeitsbeziehungen
- Analyse der Modularchitektur
- Identifikation von stark vernetzten Komponenten
- Visualisierung des Abhängigkeitsnetzwerks
"""

import os
import logging
from collections import defaultdict

logger = logging.getLogger(__name__)

class DependencyGraph:
    """
    Repräsentiert einen gerichteten Graphen von Modulabhängigkeiten.
    
    Diese Klasse implementiert einen spezialisierten gerichteten Graphen für
    Modulabhängigkeiten. Sie speichert sowohl ausgehende als auch eingehende
    Kanten für jeden Knoten, um effiziente Abfragen in beide Richtungen zu ermöglichen.
    
    Attribute:
        nodes (set): Menge aller Modulnamen (Knoten im Graphen)
        edges (dict): Dictionary von ausgehenden Kanten {from_module: [to_modules]}
        reverse_edges (dict): Dictionary von eingehenden Kanten {to_module: [from_modules]}
    """
    def __init__(self):
        """
        Initialisiert einen leeren Abhängigkeitsgraphen.
        
        Erstellt leere Datenstrukturen für Knoten und Kanten in beide Richtungen.
        """
        self.nodes = set()  # Menge aller Modulnamen
        self.edges = {}  # Ausgehende Kanten {from_module: [to_modules]}
        self.reverse_edges = {}  # Eingehende Kanten {to_module: [from_modules]}
    
    def add_node(self, module_name):
        """
        Fügt einen Knoten (Modul) zum Graphen hinzu.
        
        Wenn der Knoten bereits existiert, wird er nicht dupliziert.
        Für jeden neuen Knoten werden leere Listen für ausgehende und 
        eingehende Kanten initialisiert.
        
        Args:
            module_name (str): Name des hinzuzufügenden Moduls
        """
        if module_name not in self.nodes:
            self.nodes.add(module_name)
            self.edges[module_name] = []  # Liste der ausgehenden Kanten (importierte Module)
            self.reverse_edges[module_name] = []  # Liste der eingehenden Kanten (importierende Module)
    
    def add_edge(self, from_module, to_module):
        """
        Fügt eine gerichtete Kante (Abhängigkeit) zwischen zwei Modulen hinzu.
        
        Die Kante repräsentiert, dass from_module das to_module importiert.
        Wenn eine der Knoten noch nicht existiert, werden sie automatisch hinzugefügt.
        Doppelte Kanten werden vermieden.
        
        Args:
            from_module (str): Name des importierenden Moduls (Quellknoten)
            to_module (str): Name des importierten Moduls (Zielknoten)
        """
        # Sicherstellen, dass beide Knoten existieren
        self.add_node(from_module)
        self.add_node(to_module)
        
        # Kante hinzufügen, wenn sie noch nicht existiert
        if to_module not in self.edges[from_module]:
            self.edges[from_module].append(to_module)  # Ausgehende Kante
            self.reverse_edges[to_module].append(from_module)  # Eingehende Kante
    
    def get_dependencies(self, module_name):
        """
        Gibt alle direkten Abhängigkeiten (Imports) eines Moduls zurück.
        
        Args:
            module_name (str): Name des Moduls
        
        Returns:
            list: Liste von Modulnamen, die vom angegebenen Modul importiert werden
                 (leere Liste, wenn das Modul keine bekannten Abhängigkeiten hat)
        """
        return self.edges.get(module_name, [])
    
    def get_dependents(self, module_name):
        """
        Gibt alle Module zurück, die das angegebene Modul importieren (abhängige Module).
        
        Dies sind die umgekehrten Abhängigkeiten oder "Einflussbereich" eines Moduls.
        
        Args:
            module_name (str): Name des Moduls
        
        Returns:
            list: Liste von Modulnamen, die das angegebene Modul importieren
                 (leere Liste, wenn keine Module von diesem Modul abhängig sind)
        """
        return self.reverse_edges.get(module_name, [])
    
    def find_cycles(self):
        """
        Findet alle Zyklen (zirkuläre Abhängigkeiten) im Abhängigkeitsgraphen.
        
        Diese Methode verwendet einen modifizierten Tiefensuchalgorithmus (DFS) zur
        Erkennung von Zyklen in gerichteten Graphen. Für jeden Knoten wird eine
        neue DFS gestartet, um alle möglichen Zyklen zu finden.
        
        Returns:
            list: Liste von Zyklen, wobei jeder Zyklus eine Liste von Modulnamen ist,
                  die einen geschlossenen Pfad im Graphen bilden
        """
        cycles = []
        visited = {}  # {node: in_current_path}
        
        def dfs(node, path):
            """
            Hilfsfunktion für die Tiefensuche.
            
            Args:
                node (str): Aktueller Knoten
                path (list): Aktueller Pfad in der DFS
            """
            if node in visited:
                if visited[node]:  # Wenn der Knoten auf dem aktuellen Pfad ist
                    # Zyklus gefunden
                    cycle_start = path.index(node)
                    cycle = path[cycle_start:] + [node]
                    cycles.append(cycle)
                return
            
            visited[node] = True  # Markiere als "auf aktuellem Pfad"
            path.append(node)
            
            for neighbor in self.edges.get(node, []):
                dfs(neighbor, path.copy())
            
            path.pop()
            visited[node] = False  # Markiere als "nicht mehr auf aktuellem Pfad"
        
        # Starte DFS von jedem Knoten aus
        for node in self.nodes:
            if node not in visited:
                dfs(node, [])
        
        return cycles

def build_dependency_graph(modules, imports):
    """
    Erstellt einen Abhängigkeitsgraphen aus Modulen und ihren Imports.
    
    Diese Funktion konvertiert die rohen Analysedaten (Module und ihre Imports)
    in eine strukturierte Graph-Repräsentation für weitergehende Analysen.
    
    Args:
        modules (dict): Zuordnung von Modulnamen zu Dateipfaden {module_name: file_path}
        imports (dict): Zuordnung von Modulen zu ihren Imports {module_name: [imported_modules]}
    
    Returns:
        DependencyGraph: Ein vollständig aufgebauter Abhängigkeitsgraph
    """
    graph = DependencyGraph()
    
    # Alle Module als Knoten hinzufügen
    for module_name in modules:
        graph.add_node(module_name)
    
    # Importabhängigkeiten als Kanten hinzufügen
    for module_name, imported_modules in imports.items():
        for imported_module in imported_modules:
            # Nur Kanten zu bekannten Modulen (im Projekt) hinzufügen
            # Externe Module (z.B. aus der Standardbibliothek) werden ignoriert
            if imported_module in modules:
                graph.add_edge(module_name, imported_module)
    
    return graph

def visualize_graph(graph, output_file):
    """
    Erstellt eine visuelle Darstellung des Abhängigkeitsgraphen.
    
    Diese Funktion erzeugt eine grafische Darstellung des Abhängigkeitsgraphen
    mithilfe der Bibliotheken pydot und graphviz. Die Visualisierung wird in der
    angegebenen Datei gespeichert (PNG, PDF, SVG, etc.).
    
    Visualisierungseigenschaften:
    - Module werden als Knoten dargestellt (Rechtecke, hellblau)
    - Abhängigkeiten werden als gerichtete Pfeile dargestellt
    - Das Layout ist von links nach rechts orientiert
    
    Args:
        graph (DependencyGraph): Der zu visualisierende Abhängigkeitsgraph
        output_file (str): Pfad zur Ausgabedatei (Format wird aus Dateiendung abgeleitet)
    
    Returns:
        bool: True bei Erfolg, False bei Fehler
    """
    try:
        import pydot
        
        # Neuen Graphen mit horizontalem Layout erstellen
        dot_graph = pydot.Dot(graph_type='digraph', rankdir='LR')
        
        # Knoten hinzufügen
        for node in graph.nodes:
            dot_node = pydot.Node(node, shape='box', style='filled', 
                                 fillcolor='lightblue')
            dot_graph.add_node(dot_node)
        
        # Kanten hinzufügen
        for from_node, to_nodes in graph.edges.items():
            for to_node in to_nodes:
                edge = pydot.Edge(from_node, to_node)
                dot_graph.add_edge(edge)
        
        # Graph in Datei schreiben (Format wird aus der Dateiendung abgeleitet)
        output_format = output_file.split('.')[-1]
        dot_graph.write(output_file, format=output_format)
        logger.info(f"Abhängigkeitsgraph gespeichert unter: {output_file}")
        
        return True
    except ImportError:
        logger.error("Visualisierung erfordert die Pakete 'pydot' und 'graphviz'.")
        logger.info("Installieren Sie diese mit: pip install pydot graphviz")
        return False
    except Exception as e:
        logger.error(f"Fehler bei der Graphvisualisierung: {str(e)}")
        return False

# ================================================================================
# Datei: maehrdocs\import_analyzer_parser.py
# ================================================================================

"""
Parser-Funktionalität des Import-Analysators für MaehrDocs

Dieses Modul ist verantwortlich für das Parsen von Python-Dateien und das Extrahieren 
von Import-Anweisungen. Es verwendet primär das AST-Modul (Abstract Syntax Tree) für 
präzise Codeanalyse und bietet Fallback-Mechanismen mit regulären Ausdrücken für Dateien 
mit Syntaxfehlern.

Hauptfunktionalitäten:
- Extrahieren aller Import-Anweisungen aus Python-Quellcode
- Behandlung verschiedener Import-Typen (import, from-import)
- Extraktion von Modulnamen aus Dateipfaden
- Erkennung relativer Imports
"""

import os
import re
import ast
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

def parse_imports(content):
    """
    Parst Python-Code und extrahiert alle Importanweisungen.
    
    Diese Funktion verwendet primär den Python-AST-Parser für eine präzise 
    syntaktische Analyse des Codes. Für Dateien mit Syntaxfehlern, die durch 
    den AST-Parser nicht verarbeitet werden können, wird ein Fallback mit 
    regulären Ausdrücken bereitgestellt.
    
    Unterstützte Import-Formate:
    - Einfache Imports: import module1, module2
    - Qualifizierte Imports: import module.submodule
    - From-Imports: from module import object
    - Absolute From-Imports: from module.submodule import object
    
    Args:
        content (str): Python-Quellcode als String
        
    Returns:
        list: Deduplizierte Liste von importierten Modulnamen
              (ohne die importierten Objekte, nur die Modulnamen)
    """
    imported_modules = []
    
    try:
        # Code mit dem AST-Parser analysieren
        tree = ast.parse(content)
        
        # Alle Import-Anweisungen im AST finden
        for node in ast.walk(tree):
            # Import-Anweisung (z.B. "import os", "import os, sys")
            if isinstance(node, ast.Import):
                for name in node.names:
                    imported_modules.append(name.name)
            
            # From-Import-Anweisung (z.B. "from os import path")
            elif isinstance(node, ast.ImportFrom):
                if node.level == 0:  # Absoluter Import (from module import x)
                    if node.module:
                        imported_modules.append(node.module)
                # Hinweis: Relative Imports (z.B. from .module import x) werden hier bewusst
                # ausgelassen, da sie keine externen Modulabhängigkeiten darstellen
                        
    except SyntaxError:
        # Fallback: Wenn der Code Syntaxfehler enthält, verwende reguläre Ausdrücke
        logger.warning("AST-Parsing fehlgeschlagen, verwende Regex-Fallback")
        imported_modules.extend(_parse_imports_with_regex(content))
        
    except Exception as e:
        logger.error(f"Fehler beim Parsen: {str(e)}")
    
    return list(set(imported_modules))  # Duplikate entfernen

def _parse_imports_with_regex(content):
    """
    Fallback-Methode zum Extrahieren von Imports mit regulären Ausdrücken.
    
    Diese Methode wird verwendet, wenn die AST-Analyse aufgrund von Syntaxfehlern 
    im Code fehlschlägt. Sie ist weniger genau als die AST-basierte Analyse, 
    kann aber auch bei fehlerhaftem Code grundlegende Import-Informationen extrahieren.
    
    Die Methode verwendet zwei Hauptmuster:
    1. Für direkte Imports: 'import modulname[, modulname2, ...]'
    2. Für from-Imports: 'from modulname import ...'
    
    Einschränkungen:
    - Erkennt keine Kommentare oder Strings, die Import-Schlüsselwörter enthalten
    - Kann bei komplexeren Import-Strukturen ungenau sein
    - Identifiziert keine bedingten Imports (z.B. in if-Blöcken)
    
    Args:
        content (str): Python-Quellcode
        
    Returns:
        list: Liste von importierten Modulnamen (möglicherweise mit Duplikaten)
    """
    imported_modules = []
    
    # Reguläre Ausdrücke für Import-Anweisungen
    # Import-Muster: 'import module' oder 'import module1, module2'
    import_pattern = r'^\s*import\s+([\w\.]+)(?:\s*,\s*([\w\.]+))*'
    # From-Import-Muster: 'from module import ...'
    from_pattern = r'^\s*from\s+([\w\.]+)\s+import'
    
    # Alle Zeilen durchgehen
    for line in content.split('\n'):
        # Import-Anweisungen finden
        import_match = re.match(import_pattern, line)
        if import_match:
            for group in import_match.groups():
                if group:  # Ignoriere None-Werte
                    imported_modules.append(group)
        
        # From-Import-Anweisungen finden
        from_match = re.match(from_pattern, line)
        if from_match and from_match.group(1):
            imported_modules.append(from_match.group(1))
    
    return imported_modules

def extract_module_name(file_path, project_dir):
    """
    Extrahiert den vollqualifizierten Modulnamen aus einem Dateipfad.
    
    Konvertiert einen Dateipfad in einen Python-Modulnamen entsprechend 
    der Python-Importkonventionen. Berücksichtigt dabei:
    - Relativen Pfad vom Projektverzeichnis
    - OS-spezifische Pfadtrennzeichen → Python-Punktnotation
    - Spezialbehandlung von __init__.py-Dateien als Verzeichnismodule
    
    Beispiele:
    - project_dir/module/file.py → module.file
    - project_dir/package/module/file.py → package.module.file
    - project_dir/package/__init__.py → package
    
    Args:
        file_path (str): Absoluter Pfad zur Python-Datei
        project_dir (str): Absoluter Pfad zum Basisverzeichnis des Projekts
        
    Returns:
        str: Der ermittelte Python-Modulname
    """
    # Relativen Pfad vom Projektverzeichnis aus erstellen
    rel_path = os.path.relpath(file_path, project_dir)
    
    # Dateiendung entfernen
    module_path = os.path.splitext(rel_path)[0]
    
    # Pfadtrenner durch Punkte ersetzen (OS-unabhängig)
    module_name = module_path.replace(os.path.sep, '.')
    
    # __init__.py-Dateien werden als Verzeichnismodul behandelt
    if module_name.endswith('.__init__'):
        module_name = module_name[:-9]  # .__init__ entfernen
        
    return module_name

def is_relative_import(import_statement):
    """
    Überprüft, ob ein Import-Statement ein relativer Import ist.
    
    Relative Imports beginnen mit einem oder mehreren Punkten und beziehen sich
    auf Module relativ zum aktuellen Modul, z.B.:
    - from . import module (Import aus demselben Paket)
    - from .. import module (Import aus dem übergeordneten Paket)
    - from .module import object (Import aus einem Modul im selben Paket)
    
    Args:
        import_statement (str): Die zu prüfende Import-Anweisung als String
        
    Returns:
        bool: True, wenn es sich um einen relativen Import handelt (beginnt mit '.'),
              False für absolute Imports
    """
    return import_statement.startswith('.')

# ================================================================================
# Datei: maehrdocs\import_analyzer_report.py
# ================================================================================

"""
Berichterstellung und Lösungsvorschläge für den Import-Analysator

Dieses Modul ist verantwortlich für die Aufbereitung und Präsentation der
Analyseergebnisse in lesbaren Berichten und die Generierung von konkreten
Lösungsvorschlägen für identifizierte Probleme. Es stellt zwei Hauptfunktionen bereit:

1. generate_report - Erstellt einen umfassenden Analysebericht im Markdown-Format
   mit Übersichten, Statistiken und detaillierten Modulinformationen
   
2. suggest_solutions - Generiert maßgeschneiderte Lösungsvorschläge für erkannte
   zirkuläre Abhängigkeiten mit Codebeispielen und Best Practices

Die Berichte und Lösungsvorschläge werden als separate Markdown-Dateien gespeichert
und enthalten strukturierte, leicht verständliche Informationen für Entwickler.
"""

import os
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

def generate_report(analyzer, graph, output_file):
    """
    Erstellt einen detaillierten Bericht über die Importabhängigkeiten eines Projekts.
    
    Diese Funktion verarbeitet die Ergebnisse der Importanalyse und erstellt einen
    strukturierten Markdown-Bericht mit folgenden Hauptabschnitten:
    
    1. Übersicht - Zusammenfassung der Analyseergebnisse (Anzahl Module, Imports, Probleme)
    2. Zirkuläre Abhängigkeiten - Detaillierte Auflistung aller erkannten Zyklen
    3. Moduldetails - Informationen zu jedem Modul (Pfad, Imports, eingehende Abhängigkeiten)
    4. Statistiken - Quantitative Auswertungen (Top-Module nach Imports, häufig importierte Module)
    
    Die Berichte sind so gestaltet, dass sie sowohl für Menschen lesbar als auch
    für weitere automatisierte Verarbeitung geeignet sind (Markdown-Format).
    
    Args:
        analyzer (ImportAnalyzer): Die ImportAnalyzer-Instanz mit den Analyseergebnissen
        graph (DependencyGraph): Der Abhängigkeitsgraph zur Analyse von Beziehungen
        output_file (str): Pfad zur Ausgabedatei für den Bericht (Markdown)
    
    Returns:
        str: Absoluter Pfad zum erstellten Bericht
    """
    logger.info(f"Erstelle Bericht: {output_file}")
    
    # Sicherstellen, dass das Ausgabeverzeichnis existiert
    os.makedirs(os.path.dirname(os.path.abspath(output_file)), exist_ok=True)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        # Berichtkopf mit Metadaten
        f.write(f"# Import-Analyse Bericht - MaehrDocs\n\n")
        f.write(f"Erstellt am: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Analysiertes Verzeichnis: `{analyzer.project_dir}`\n\n")
        
        # Zusammenfassung der Ergebnisse
        f.write("## Zusammenfassung\n\n")
        f.write(f"- Anzahl Module: {len(analyzer.modules)}\n")
        f.write(f"- Anzahl Imports: {sum(len(imports) for imports in analyzer.imports.values())}\n")
        f.write(f"- Zirkuläre Importabhängigkeiten: {len(analyzer.circular_imports)}\n\n")
        
        # Zirkuläre Imports detailliert darstellen
        if analyzer.circular_imports:
            f.write("## Zirkuläre Importabhängigkeiten\n\n")
            f.write("Die folgenden zirkulären Abhängigkeiten wurden erkannt und sollten behoben werden:\n\n")
            
            for i, cycle in enumerate(analyzer.circular_imports, 1):
                path = cycle['path']
                f.write(f"### Zyklus {i}: {' -> '.join(path)}\n\n")
                
                # Detaillierte Informationen zu jedem Modul im Zyklus
                for module in path:
                    if module in analyzer.modules:
                        file_path = analyzer.modules[module]
                        rel_path = os.path.relpath(file_path, analyzer.project_dir)
                        f.write(f"- **{module}** (`{rel_path}`)\n")
                        
                        # Imports anzeigen, die Teil des Zyklus sind
                        if module in analyzer.imports:
                            cycle_imports = [imp for imp in analyzer.imports[module] if imp in path]
                            if cycle_imports:
                                f.write("  - Importiert: " + ", ".join(f"`{imp}`" for imp in cycle_imports) + "\n")
                
                f.write("\n")
        
        # Detaillierte Modulinformationen
        f.write("## Moduldetails\n\n")
        
        for module_name in sorted(analyzer.modules.keys()):
            f.write(f"### {module_name}\n\n")
            
            # Dateipfad
            file_path = analyzer.modules[module_name]
            rel_path = os.path.relpath(file_path, analyzer.project_dir)
            f.write(f"- **Datei:** `{rel_path}`\n")
            
            # Imports - unterscheiden zwischen internen (Projekt) und externen Imports
            if module_name in analyzer.imports and analyzer.imports[module_name]:
                f.write("- **Importiert:**\n")
                # Sortiere Imports für bessere Lesbarkeit
                for imp in sorted(analyzer.imports[module_name]):
                    # Markiere, wenn der Import zu einem anderen Modul im Projekt gehört
                    if imp in analyzer.modules:
                        f.write(f"  - `{imp}` (intern)\n")
                    else:
                        f.write(f"  - `{imp}` (extern)\n")
            else:
                f.write("- **Importiert:** Keine\n")
            
            # Module, die dieses Modul importieren (umgekehrte Abhängigkeiten)
            dependents = graph.get_dependents(module_name)
            if dependents:
                f.write("- **Importiert von:**\n")
                for dep in sorted(dependents):
                    f.write(f"  - `{dep}`\n")
            else:
                f.write("- **Importiert von:** Keinem\n")
            
            # Ist das Modul Teil von zirkulären Imports?
            in_cycles = [c for c in analyzer.circular_imports if module_name in c['path']]
            if in_cycles:
                f.write("- **In zirkulären Abhängigkeiten:**\n")
                for i, cycle in enumerate(in_cycles, 1):
                    cycle_str = ' -> '.join(cycle['path'])
                    f.write(f"  - Zyklus {i}: `{cycle_str}`\n")
                    
            f.write("\n")
        
        # Statistiken und Kennzahlen
        f.write("## Statistiken\n\n")
        
        # Module mit den meisten Imports (komplexeste Module)
        f.write("### Module mit den meisten Imports\n\n")
        modules_by_imports = sorted(
            [(m, len(imps)) for m, imps in analyzer.imports.items()],
            key=lambda x: x[1],
            reverse=True
        )
        
        f.write("| Modul | Anzahl Imports |\n")
        f.write("|-------|---------------|\n")
        for module, count in modules_by_imports[:10]:  # Top 10
            f.write(f"| `{module}` | {count} |\n")
        
        f.write("\n")
        
        # Am häufigsten importierte Module (zentrale Module)
        f.write("### Am häufigsten importierte Module\n\n")
        import_counts = {}
        for imports in analyzer.imports.values():
            for imp in imports:
                if imp in analyzer.modules:  # Nur interne Module
                    import_counts[imp] = import_counts.get(imp, 0) + 1
        
        most_imported = sorted(
            [(m, c) for m, c in import_counts.items()],
            key=lambda x: x[1],
            reverse=True
        )
        
        f.write("| Modul | Importiert von |\n")
        f.write("|-------|---------------|\n")
        for module, count in most_imported[:10]:  # Top 10
            f.write(f"| `{module}` | {count} |\n")
    
    logger.info(f"Bericht erstellt: {output_file}")
    return output_file

def suggest_solutions(analyzer, graph, output_dir):
    """
    Generiert maßgeschneiderte Lösungsvorschläge für zirkuläre Importabhängigkeiten.
    
    Diese Funktion analysiert die identifizierten zirkulären Abhängigkeiten und erstellt
    einen Bericht mit konkreten, aktionablen Lösungsvorschlägen. Für jeden Zyklus werden
    mehrere Lösungsstrategien vorgeschlagen, darunter:
    
    1. Extrahieren gemeinsamer Funktionalität in separate Module
    2. Verwenden von "Lazy Imports" (Verschieben von Imports in Funktionen)
    3. Implementierung von Dependency Injection
    4. Verwendung von TYPE_CHECKING für Typ-Annotationen
    5. Umstrukturierung der Modulhierarchie
    
    Jeder Lösungsvorschlag wird mit konkreten Codebeispielen und Erläuterungen versehen,
    um die Implementierung zu erleichtern.
    
    Args:
        analyzer (ImportAnalyzer): Die ImportAnalyzer-Instanz mit den Analyseergebnissen
        graph (DependencyGraph): Der Abhängigkeitsgraph zur Analyse von Beziehungen
        output_dir (str): Verzeichnis für die Ausgabedatei
    
    Returns:
        str: Pfad zum erstellten Lösungsvorschlagsbericht
    """
    output_file = os.path.join(output_dir, "import_solutions.md")
    logger.info(f"Erstelle Lösungsvorschläge: {output_file}")
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Lösungsvorschläge für Importprobleme\n\n")
        f.write(f"Erstellt am: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        
        # Wenn keine Probleme gefunden wurden
        if not analyzer.circular_imports:
            f.write("## Keine zirkulären Importabhängigkeiten gefunden\n\n")
            f.write("Die Analyse hat keine zirkulären Importabhängigkeiten im Projekt identifiziert. ")
            f.write("Die aktuelle Modulstruktur ist in dieser Hinsicht optimal.\n\n")
            f.write("### Präventive Maßnahmen\n\n")
            f.write("Um auch in Zukunft zirkuläre Abhängigkeiten zu vermeiden, empfiehlt sich:\n\n")
            f.write("1. Regelmäßige Importanalysen durchführen\n")
            f.write("2. Klare Modulhierarchie definieren und dokumentieren\n")
            f.write("3. Gemeinsame Basismodule für häufig benötigte Funktionalität einrichten\n")
            
            return output_file
        
        # Einführung bei gefundenen Problemen
        f.write("## Zirkuläre Importabhängigkeiten\n\n")
        f.write("Die folgenden zirkulären Abhängigkeiten wurden identifiziert und benötigen Aufmerksamkeit. ")
        f.write("Diese Zyklen könnten bei bestimmten Import-Konstellationen zu Problemen führen, ")
        f.write("beispielsweise zu ImportError-Ausnahmen oder unerwarteten Verhaltensweisen.\n\n")
        
        # Für jeden Zyklus individuelle Lösungen vorschlagen
        for i, cycle in enumerate(analyzer.circular_imports, 1):
            path = cycle['path']
            f.write(f"### Zyklus {i}: {' -> '.join(path)}\n\n")
            
            # Analyse des spezifischen Zyklus
            f.write("#### Analyse\n\n")
            
            # Moduldetails anzeigen
            for module in path:
                if module in analyzer.modules:
                    file_path = analyzer.modules[module]
                    rel_path = os.path.relpath(file_path, analyzer.project_dir)
                    f.write(f"- **{module}** (`{rel_path}`)\n")
                    
                    # Imports anzeigen, die an diesem Zyklus beteiligt sind
                    if module in analyzer.imports:
                        cycle_imports = [imp for imp in analyzer.imports[module] if imp in path]
                        if cycle_imports:
                            f.write("  - Importiert aus diesem Zyklus: " + 
                                  ", ".join(f"`{imp}`" for imp in cycle_imports) + "\n")
            
            # Detaillierte Lösungsvorschläge
            f.write("\n#### Lösungsvorschläge\n\n")
            
            # Strategie 1: Gemeinsames Modul extrahieren
            f.write("**1. Gemeinsames Modul extrahieren:**\n")
            f.write("Identifizieren Sie gemeinsam genutzte Funktionalität zwischen diesen Modulen und extrahieren ")
            f.write("Sie diese in ein separates, neues Modul, das von beiden abhängigen Modulen importiert wird. ")
            f.write("Dies ist besonders effektiv, wenn die zirkuläre Abhängigkeit durch gegenseitige ")
            f.write("Nutzung ähnlicher Funktionen entsteht.\n\n")
            
            # Beispielcode mit dynamisch generiertem Modulnamen
            module_base = path[0].split('.')[-1] if '.' in path[0] else path[0]
            common_module = f"{'.'.join(path[0].split('.')[:-1])}.common_{module_base}" if '.' in path[0] else f"common_{module_base}"
            
            f.write("```python\n")
            f.write(f"# Neues Modul: {common_module}.py\n")
            f.write("# Gemeinsame Funktionalität hier implementieren\n")
            f.write("def shared_function():\n")
            f.write("    # Implementierung\n")
            f.write("    pass\n\n")
            f.write("class SharedClass:\n")
            f.write("    # Implementierung\n")
            f.write("    pass\n\n")
            f.write("# In den ursprünglichen Modulen:\n")
            f.write(f"from {common_module} import SharedClass, shared_function\n")
            f.write("```\n\n")
            
            # Strategie 2: Lazy Imports
            f.write("**2. Lazy Imports verwenden:**\n")
            f.write("Verschieben Sie die Imports in die Funktionen oder Methoden, die sie tatsächlich benötigen, ")
            f.write("anstatt sie auf Modulebene zu importieren. Dies vermeidet Probleme bei der Initialisierung ")
            f.write("und löst viele zirkuläre Abhängigkeiten elegante Weise.\n\n")
            
            f.write("```python\n")
            f.write("# Anstatt: from other_module import SomeClass\n\n")
            f.write("def some_function():\n")
            f.write("    # Lazy Import - wird erst bei Funktionsaufruf geladen\n")
            f.write("    from other_module import SomeClass\n")
            f.write("    \n")
            f.write("    # Rest der Funktion\n")
            f.write("    instance = SomeClass()\n")
            f.write("    return instance.process()\n")
            f.write("```\n\n")
            
            # Strategie 3: Dependency Injection
            f.write("**3. Dependency Injection:**\n")
            f.write("Übergeben Sie die benötigten Objekte als Parameter, anstatt die Module direkt zu importieren. ")
            f.write("Dies entkoppelt die Module und ermöglicht eine flexiblere Struktur. Dependency Injection ist ")
            f.write("besonders wertvoll bei komplexeren Anwendungen und vereinfacht auch das Testen.\n\n")
            
            f.write("```python\n")
            f.write("# Anstatt:\n")
            f.write("from other_module import SomeClass\n")
            f.write("def process_data():\n")
            f.write("    obj = SomeClass()\n")
            f.write("    return obj.process()\n\n")
            f.write("# Besser (mit Dependency Injection):\n")
            f.write("def process_data(processor):\n")
            f.write("    return processor.process()\n\n")
            f.write("# Aufruf:\n")
            f.write("from other_module import SomeClass\n")
            f.write("result = process_data(SomeClass())\n")
            f.write("```\n\n")
            
            # Strategie 4: Typ-Annotationen verschieben
            f.write("**4. Typ-Annotationen mit 'TYPE_CHECKING':**\n")
            f.write("Wenn die zirkulären Imports nur für Typ-Annotationen verwendet werden, ")
            f.write("nutzen Sie den `typing.TYPE_CHECKING`-Mechanismus. Dies ermöglicht die statische ")
            f.write("Typprüfung während der Entwicklung, ohne zirkuläre Abhängigkeiten zur Laufzeit.\n\n")
            
            f.write("```python\n")
            f.write("from typing import TYPE_CHECKING, Optional\n\n")
            f.write("if TYPE_CHECKING:\n")
            f.write("    from other_module import SomeClass  # Import nur für Typchecking\n\n")
            f.write("def function() -> 'SomeClass':  # String-Annotation verwenden\n")
            f.write("    # Zur Laufzeit importieren\n")
            f.write("    from other_module import SomeClass\n")
            f.write("    return SomeClass()\n\n")
            f.write("# Alternative mit Union und Optional:\n")
            f.write("def another_function() -> Optional['SomeClass']:\n")
            f.write("    # Implementierung\n")
            f.write("    pass\n")
            f.write("```\n\n")
            
            # Strategie 5: Modulstruktur überdenken
            f.write("**5. Modulstruktur überdenken:**\n")
            f.write("Möglicherweise deutet der Zyklus auf ein grundlegenderes Designproblem hin. ")
            f.write("Erwägen Sie eine Umstrukturierung der Modulhierarchie, um klare Abhängigkeitsrichtungen zu schaffen. ")
            f.write("Dies kann bedeuten, Module zusammenzuführen oder Funktionalität neu zu organisieren nach dem ")
            f.write("Prinzip der Verantwortungstrennung (Separation of Concerns).\n\n")
            
            f.write("Fragen zur Überprüfung:\n")
            f.write("- Sollten diese Module tatsächlich separate Einheiten sein?\n")
            f.write("- Gibt es eine natürliche Hierarchie zwischen ihnen?\n")
            f.write("- Könnten einige Funktionen besser in einem gemeinsamen übergeordneten Modul platziert werden?\n\n")
        
        # Allgemeine Best Practices
        f.write("## Allgemeine Empfehlungen\n\n")
        
        f.write("### 1. Konsistente Importkonventionen\n\n")
        f.write("Verwenden Sie einheitliche Import-Muster im gesamten Projekt:\n")
        f.write("- Absolute Imports für externe Module und projektweite Importe\n")
        f.write("- Relative Imports für Module innerhalb desselben Pakets\n")
        f.write("- Sortieren Sie Imports nach Konvention (z.B. Standardbibliothek → Drittanbieterbibliotheken → Projektmodule)\n\n")
        
        f.write("### 2. Klare Modulhierarchie\n\n")
        f.write("Etablieren Sie eine klare Hierarchie von Abhängigkeiten:\n")
        f.write("- Basismodule sollten keine höheren Module importieren\n")
        f.write("- Gemeinsame Funktionalität in eigenen Modulen organisieren\n")
        f.write("- Eindeutige Richtung des Datenflusses definieren\n\n")
        
        f.write("### 3. Modulgrößen optimieren\n\n")
        f.write("Finden Sie die richtige Balance für die Modulgranularität:\n")
        f.write("- Zu viele kleine Module können zu unnötiger Komplexität führen\n")
        f.write("- Zu große Module werden unübersichtlich und schwer zu warten\n")
        f.write("- Zusammengehörige Funktionalität sollte im gleichen Modul bleiben\n\n")
        
        f.write("### 4. Regelmäßige Überprüfung\n\n")
        f.write("Integrieren Sie die Importanalyse in Ihren Entwicklungsprozess:\n")
        f.write("- Führen Sie regelmäßig und nach größeren Refactorings Analysen durch\n")
        f.write("- Verwenden Sie CI/CD-Pipelines zur Erkennung neuer zirkulärer Abhängigkeiten\n")
        f.write("- Dokumentieren Sie die beabsichtigte Architektur und Modulstruktur\n")
    
    logger.info(f"Lösungsvorschläge erstellt: {output_file}")
    return output_file

# ================================================================================
# Datei: maehrdocs\main.py
# ================================================================================

#!/usr/bin/env python
"""
Haupteinstiegspunkt für MaehrDocs
Enthält die Kommandozeilenargumente und die CLI-Logik
"""

import argparse
import logging
import os
import sys
import time

# Füge das übergeordnete Verzeichnis zum Pythonpfad hinzu, um maehrdocs als Paket zu importieren
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

# Logging einrichten
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('maehrdocs.log', encoding='utf-8')
    ]
)

# Importiere notwendige Module
try:
    # Jetzt sollte der Import funktionieren
    from maehrdocs import ConfigManager, DocumentProcessor
except ImportError as e:
    logging.error(f"Fehler beim Importieren der Module: {str(e)}")
    print(f"Fehler: {str(e)}")
    print("Stellen Sie sicher, dass Sie sich im richtigen Verzeichnis befinden und alle Abhängigkeiten installiert sind.")
    sys.exit(1)

def parse_arguments():
    """
    Parst die Kommandozeilenargumente
    
    Returns:
        argparse.Namespace: Die geparsten Argumente
    """
    parser = argparse.ArgumentParser(description='MaehrDocs - Automatisches Dokumentenmanagementsystem')
    
    # Optionale Argumente
    parser.add_argument('--dry-run', action='store_true', 
                      help='Simulation ohne tatsächliche Änderungen')
    parser.add_argument('--single-file', type=str, metavar='FILE',
                      help='Verarbeitet eine einzelne PDF-Datei statt des Eingangsordners')
    parser.add_argument('--rebuild-config', action='store_true',
                      help='Erstellt die Konfigurationsdatei neu mit Standardwerten')
    parser.add_argument('--force', action='store_true',
                      help='Überschreibt vorhandene Dateien ohne Rückfrage')
    parser.add_argument('-v', '--verbose', action='count', default=0,
                      help='Erhöht die Ausführlichkeit der Ausgabe (verwende -vv für noch mehr Details)')
    
    return parser.parse_args()

def setup_logging(verbose_level):
    """
    Richtet das Logging basierend auf der Ausführlichkeitsstufe ein
    
    Args:
        verbose_level: Ausführlichkeitsstufe (0=normal, 1=verbose, 2=debug)
    """
    # Logging-Level basierend auf der Ausführlichkeitsstufe festlegen
    if verbose_level >= 2:
        logging.getLogger().setLevel(logging.DEBUG)
    elif verbose_level >= 1:
        logging.getLogger().setLevel(logging.INFO)
    else:
        logging.getLogger().setLevel(logging.WARNING)
    
    logging.info(f"Logging-Level gesetzt auf: {logging.getLogger().getEffectiveLevel()}")

def main():
    """
    Hauptfunktion des Programms
    """
    try:
        # Argumente parsen
        args = parse_arguments()
        
        # Logging einrichten
        setup_logging(args.verbose)
        
        # Konfiguration laden oder neu erstellen
        config_manager = ConfigManager()
        
        # Wenn die Konfiguration neu erstellt werden soll
        if args.rebuild_config:
            logging.info("Erstelle Konfigurationsdatei neu...")
            config = config_manager.create_default_config()
            config_manager.save_config(config)
            logging.info("Konfigurationsdatei wurde neu erstellt.")
            return
        
        # Konfiguration laden
        config = config_manager.get_config()
        
        # Dokumentenprozessor erstellen
        document_processor = DocumentProcessor(config)
        
        # Verbosity-Level setzen
        document_processor.verbose = args.verbose
        
        # Force-Option setzen
        document_processor.force = args.force
        
        # Einzelne Datei verarbeiten
        if args.single_file:
            file_path = args.single_file
            if not os.path.exists(file_path):
                logging.error(f"Datei nicht gefunden: {file_path}")
                return
                
            logging.info(f"Verarbeite einzelne Datei: {file_path}")
            result = document_processor.process_document(file_path, dry_run=args.dry_run)
            
            if result:
                logging.info(f"Dokument verarbeitet: {result['new_filename']}")
                if result.get('is_duplicate', False):
                    logging.warning(f"Duplikat erkannt: Ähnlich zu {result['duplicate_path']}")
            else:
                logging.error(f"Fehler bei der Verarbeitung von {file_path}")
        
        # Alle Dokumente im Eingangsordner verarbeiten
        else:
            mode = "Simulation" if args.dry_run else "Verarbeitung"
            logging.info(f"{mode} aller Dokumente im Eingangsordner gestartet...")
            
            start_time = time.time()
            results = document_processor.process_all_documents(dry_run=args.dry_run)
            end_time = time.time()
            
            if results:
                logging.info(f"{len(results)} Dokumente verarbeitet in {end_time - start_time:.2f} Sekunden.")
            else:
                logging.warning("Keine Dokumente verarbeitet oder Fehler aufgetreten.")
        
    except KeyboardInterrupt:
        logging.info("Programm durch Benutzer abgebrochen.")
    except Exception as e:
        logging.error(f"Fehler: {str(e)}", exc_info=True)
        print(f"Fehler: {str(e)}")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())

# ================================================================================
# Datei: maehrdocs\openai_integration.py
# ================================================================================

"""
OpenAI-Integration für MaehrDocs
Implementiert die Integration mit der OpenAI API für die Analyse von Dokumenteninhalten.

Dieses Modul kapselt alle Interaktionen mit der OpenAI API und bietet robuste
Fehlerbehandlung, Wiederholungslogik und strukturierte Antwortverarbeitung.
Es ist ein zentraler Bestandteil der KI-gestützten Dokumentenverarbeitung.
"""

import os
import json
import logging
import openai
from dotenv import load_dotenv

class OpenAIIntegration:
    """
    Klasse zur Interaktion mit der OpenAI API.
    
    Diese Klasse ist verantwortlich für:
    - Konfiguration und Initialisierung der OpenAI API-Verbindung
    - Formulierung von Prompts zur Dokumentenanalyse
    - Verarbeitung von API-Antworten und Konvertierung in strukturierte Daten
    - Fehlerbehandlung und automatische Wiederholungsversuche
    
    Die Integration verwendet primär das ChatCompletion-Feature der API,
    um intelligente Dokumentenanalyse durchzuführen.
    """
    
    def __init__(self, config):
        """
        Initialisiert die OpenAI-Integration mit Konfiguration und API-Schlüssel.
        
        Lädt den API-Schlüssel aus der .env-Datei und konfiguriert die
        OpenAI-Client-Bibliothek mit den übergebenen Einstellungen.
        
        Args:
            config (dict): Konfigurationsdaten mit OpenAI-Einstellungen (Modell, Temperatur, etc.)
        """
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # OpenAI API-Key aus .env-Datei laden
        load_dotenv()
        openai.api_key = os.getenv("OPENAI_API_KEY")
        
        # Prüfen, ob der API-Key gesetzt ist
        if not openai.api_key:
            self.logger.warning("OpenAI API-Key nicht gefunden. Bitte .env-Datei mit OPENAI_API_KEY erstellen.")
    
    def analyze_document(self, text, valid_doc_types):
        """
        Analysiert einen Dokumenttext mit der OpenAI API.
        
        Sendet einen Teil des Dokumenttextes an die OpenAI API mit einem
        strukturierten Prompt zur Extraktion von Dokumentmetadaten wie
        Absender, Datum, Dokumenttyp und Betreff.
        
        Args:
            text (str): Zu analysierender Dokumenttext
            valid_doc_types (list): Liste gültiger Dokumenttypen zur Kategorisierung
            
        Returns:
            dict: Extrahierte Dokumentinformationen oder None bei Fehler
        """
        # Begrenze die Textlänge für die API-Anfrage
        truncated_text = text[:3000] if text else ""
        
        if not truncated_text:
            self.logger.error("Kein Text zur Analyse vorhanden")
            return None
            
        prompt = self._create_analysis_prompt(truncated_text, valid_doc_types)
        max_retries = self.config['openai'].get('max_retries', 3)
        
        for attempt in range(max_retries):
            try:
                response = self._call_openai_api(prompt)
                
                if response:
                    # Versuche, das Ergebnis als JSON zu parsen
                    doc_info = self._parse_json_response(response)
                    
                    if doc_info:
                        return doc_info
                    else:
                        self.logger.warning(f"Konnte die API-Antwort nicht als JSON parsen. Versuch {attempt+1}/{max_retries}")
                        
            except Exception as e:
                self.logger.warning(f"OpenAI API-Fehler: {str(e)}. Versuch {attempt+1}/{max_retries}")
                
                if attempt == max_retries - 1:
                    self.logger.error("Maximale Anzahl an Versuchen erreicht.")
        
        return None
    
    def _create_analysis_prompt(self, text, valid_doc_types):
        """
        Erstellt den Prompt für die Dokumentenanalyse.
        
        Formuliert einen strukturierten Prompt für die OpenAI API, der
        spezifische Anweisungen zur Extraktion von Dokumentinformationen
        und das Format der gewünschten Antwort enthält.
        
        Args:
            text (str): Zu analysierender Dokumenttext
            valid_doc_types (list): Liste gültiger Dokumenttypen
            
        Returns:
            str: Formatierter Prompt für die API-Anfrage
        """
        return f"""Analysiere folgendes Dokument und extrahiere:
1. Absender (Firma/Person, die das Dokument erstellt hat)
2. Datum (im Format YYYY-MM-DD)
3. Dokumenttyp (einer der folgenden: {', '.join(valid_doc_types)})
4. Betreff/Titel (kurz und prägnant)
5. Wichtige Kennzahlen (z.B. Rechnungsbetrag, Vertragsnummer)

Gib deine Antwort als JSON-Objekt mit den Schlüsseln 'absender', 'datum', 'dokumenttyp', 'betreff' und 'kennzahlen' zurück.

Dokumenttext:
{text}"""
    
    def _call_openai_api(self, prompt):
        """
        Ruft die OpenAI API mit dem gegebenen Prompt auf.
        
        Konfiguriert die API-Anfrage basierend auf den Anwendungseinstellungen
        (Modell, Temperatur) und sendet den Prompt an die OpenAI API.
        
        Args:
            prompt (str): Der vollständige Prompt für die API
            
        Returns:
            str: API-Antworttext oder None bei Fehler
        """
        try:
            model = self.config['openai'].get('model', 'gpt-3.5-turbo')
            temperature = self.config['openai'].get('temperature', 0.3)
            
            response = openai.ChatCompletion.create(
                model=model,
                temperature=temperature,
                messages=[
                    {"role": "system", "content": "Du bist ein Experte für Dokumentenanalyse."},
                    {"role": "user", "content": prompt}
                ]
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            self.logger.error(f"Fehler beim Aufruf der OpenAI API: {str(e)}")
            return None
    
    def _parse_json_response(self, response_text):
        """
        Parst die JSON-Antwort der API in ein Python-Dictionary.
        
        Extrahiert den JSON-Teil aus der API-Antwort und wandelt ihn in eine
        strukturierte Python-Datenstruktur um. Berücksichtigt verschiedene
        Formate, in denen die API das JSON zurückliefern kann.
        
        Args:
            response_text (str): Antworttext der API
            
        Returns:
            dict: Geparste JSON-Daten oder None bei Fehler
        """
        try:
            # Versuche, das JSON zu extrahieren, falls es in Markdown-Code-Blöcken steht
            if "```json" in response_text and "```" in response_text:
                # Extrahiere den JSON-Teil
                json_start = response_text.find("```json") + 7
                json_end = response_text.find("```", json_start)
                response_text = response_text[json_start:json_end].strip()
            elif "```" in response_text and "```" in response_text:
                # Extrahiere den Code-Block
                json_start = response_text.find("```") + 3
                json_end = response_text.find("```", json_start)
                response_text = response_text[json_start:json_end].strip()
            
            return json.loads(response_text)
            
        except json.JSONDecodeError as e:
            self.logger.error(f"JSON-Parsing-Fehler: {str(e)}")
            self.logger.debug(f"Antworttext: {response_text}")
            return None

# ================================================================================
# Datei: maehrdocs\start_maehrdocs.py
# ================================================================================

#!/usr/bin/env python
"""
Starter-Skript für MaehrDocs
Startet die GUI der Anwendung
"""

import tkinter as tk
import logging
import os
import sys

# Füge das übergeordnete Verzeichnis zum Pythonpfad hinzu
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.insert(0, parent_dir)

# Logging einrichten
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('maehrdocs.log', encoding='utf-8')
    ]
)

# Importiere notwendige Module
try:
    from maehrdocs import ConfigManager, DocumentProcessor
    from maehrdocs.gui import GuiApp
except ImportError as e:
    logging.error(f"Fehler beim Importieren der Module: {str(e)}")
    print(f"Fehler: {str(e)}")
    print("Stellen Sie sicher, dass Sie sich im richtigen Verzeichnis befinden und alle Abhängigkeiten installiert sind.")
    sys.exit(1)

def main():
    """
    Hauptfunktion zum Starten der GUI
    """
    try:
        # Erstelle eine Instanz des ConfigManager
        config_manager = ConfigManager()
        
        # Lade oder erstelle die Konfiguration
        config = config_manager.get_config()
        
        # Erstelle eine Instanz des DocumentProcessor
        document_processor = DocumentProcessor(config)
        
        # Erstelle die GUI-Anwendung
        app = GuiApp(config_manager, document_processor)
        
        # Starte die GUI
        root = app.setup_gui()
        
        # Starte den Event-Loop
        root.mainloop()
        
    except Exception as e:
        logging.error(f"Fehler beim Starten der Anwendung: {str(e)}")
        print(f"Fehler: {str(e)}")
        input("Drücken Sie Enter, um zu beenden.")
        sys.exit(1)

if __name__ == "__main__":
    main()

# ================================================================================
# Datei: maehrdocs\text_extractor.py
# ================================================================================

"""
Textextraktion aus PDF-Dokumenten für MaehrDocs
Enthält die TextExtractor-Klasse zum sicheren Extrahieren von Text und Metadaten
aus PDF-Dokumenten unter Berücksichtigung verschiedener Fehlerszenarien.

Dieses Modul ist ein zentraler Bestandteil der Dokumentenverarbeitung und
stellt sicher, dass Textinhalte zuverlässig aus PDFs extrahiert werden können,
bevor sie zur weiteren Analyse an die KI-Komponenten übergeben werden.
"""

import os
import logging
import fitz  # PyMuPDF

class TextExtractor:
    """
    Klasse zur Extraktion von Text aus PDF-Dokumenten.
    
    Diese Klasse bietet robuste Methoden zum:
    - Extrahieren von Volltext aus PDF-Dokumenten
    - Abrufen von PDF-Metadaten
    - Validieren von PDF-Dateien (Existenz, Format, Größe)
    
    Die Implementierung verwendet die PyMuPDF-Bibliothek (Wrapper für MuPDF)
    für performante und zuverlässige Textextraktion.
    """
    
    def __init__(self):
        """
        Initialisiert den TextExtractor mit einem Logger.
        """
        self.logger = logging.getLogger(__name__)
    
    def extract_text_from_pdf(self, file_path):
        """
        Extrahiert Text aus einer PDF-Datei.
        
        Öffnet die PDF-Datei, extrahiert den Text aus allen Seiten und
        kombiniert ihn zu einem Gesamttext. Bei Problemen werden detaillierte
        Fehlerprotokolle erstellt.
        
        Args:
            file_path (str): Pfad zur PDF-Datei
            
        Returns:
            str: Extrahierter Text oder None bei Fehler
        """
        try:
            if not os.path.exists(file_path):
                self.logger.error(f"Datei existiert nicht: {file_path}")
                return None
                
            if not file_path.lower().endswith('.pdf'):
                self.logger.error(f"Datei ist keine PDF: {file_path}")
                return None
                
            text = ""
            with fitz.open(file_path) as doc:
                # Metadaten für Debugging
                self.logger.debug(f"PDF-Metadaten: {doc.metadata}")
                
                # Dokumentinformationen
                self.logger.debug(f"Seitenanzahl: {len(doc)}")
                
                # Text aus jeder Seite extrahieren
                for page_num, page in enumerate(doc):
                    page_text = page.get_text()
                    self.logger.debug(f"Seite {page_num+1}: {len(page_text)} Zeichen extrahiert")
                    text += page_text
                    
            if not text.strip():
                self.logger.warning(f"Extrahierter Text ist leer: {file_path}")
                
            return text
            
        except Exception as e:
            self.logger.error(f"Fehler beim Extrahieren des Textes aus {file_path}: {str(e)}")
            return None
    
    def get_pdf_metadata(self, file_path):
        """
        Extrahiert Metadaten aus einer PDF-Datei.
        
        Liest die Standardmetadaten wie Autor, Erstellungsdatum, Titel, usw.
        aus dem PDF-Dokument aus.
        
        Args:
            file_path (str): Pfad zur PDF-Datei
            
        Returns:
            dict: Dictionary mit Metadaten oder leeres Dictionary bei Fehler
        """
        try:
            if not os.path.exists(file_path) or not file_path.lower().endswith('.pdf'):
                return {}
                
            with fitz.open(file_path) as doc:
                return doc.metadata
                
        except Exception as e:
            self.logger.error(f"Fehler beim Extrahieren der Metadaten aus {file_path}: {str(e)}")
            return {}
    
    def is_valid_pdf(self, file_path, max_size_mb=20):
        """
        Prüft, ob eine Datei eine gültige PDF ist und die Größenbeschränkung einhält.
        
        Führt mehrere Validierungsschritte durch:
        1. Prüft, ob die Datei existiert
        2. Prüft, ob die Datei eine .pdf-Erweiterung hat
        3. Prüft, ob die Dateigröße unter dem Grenzwert liegt
        4. Prüft, ob die Datei als gültiges PDF geöffnet werden kann
        5. Prüft, ob das PDF mindestens eine Seite enthält
        
        Args:
            file_path (str): Pfad zur zu prüfenden Datei
            max_size_mb (int): Maximale zulässige Dateigröße in MB
            
        Returns:
            bool: True, wenn die Datei eine gültige PDF ist und die Größenbeschränkung einhält
        """
        try:
            # Existenz prüfen
            if not os.path.exists(file_path):
                self.logger.error(f"Datei existiert nicht: {file_path}")
                return False
                
            # Endung prüfen
            if not file_path.lower().endswith('.pdf'):
                self.logger.error(f"Datei ist keine PDF: {file_path}")
                return False
                
            # Größe prüfen
            file_size_mb = os.path.getsize(file_path) / (1024 * 1024)
            if file_size_mb > max_size_mb:
                self.logger.warning(f"Datei zu groß ({file_size_mb:.2f} MB): {file_path}")
                return False
                
            # Versuche, die Datei als PDF zu öffnen
            with fitz.open(file_path) as doc:
                # Prüfe, ob mindestens eine Seite vorhanden ist
                if len(doc) == 0:
                    self.logger.warning(f"PDF enthält keine Seiten: {file_path}")
                    return False
                    
            return True
            
        except Exception as e:
            self.logger.error(f"Fehler bei der PDF-Validierung von {file_path}: {str(e)}")
            return False